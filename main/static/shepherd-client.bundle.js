(function(e, a) { for(var i in a) e[i] = a[i]; }(window, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./index.js":
/*!******************!*\
  !*** ./index.js ***!
  \******************/
/*! exports provided: InitBrowserDefault */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InitBrowserDefault", function() { return InitBrowserDefault; });
/* harmony import */ var _src_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./src/browser */ "./src/browser.js");


function InitBrowserDefault(reqid, opts) {
  document.addEventListener("readystatechange", function() {
    if (document.readyState != "complete") {
      return;
    }

    opts = opts || {};

    // if in iframe, notify parent of reqid
    if (window != window.parent && !opts.noNotifyParent) {
      window.parent.postMessage({"type": "reqid", "reqid": reqid}, "*");
    }

    if (!opts.on_countdown) {
      opts.on_countdown = function(seconds, countdown_text) {
        var text = document.getElementById("countdown");
        if (text) {
          text.innerText = countdown_text;
        }
      }
    }

    if (!opts.on_event) {
      opts.on_event = function(type, data) {
        if (type == "fail" || type == "expire") {
          window.location.reload();
        }
      }
    }

    if (opts.proxy_ws === undefined) {
      if (!window.location.port) {
        opts.proxy_ws = true;
      }
    }

    if (opts.audio === undefined) {
      opts.audio = true;
    }

    if (opts.fill_window === undefined) {
      opts.fill_window = true;
    }

    if (opts.inactiveSecs === undefined) {
      opts.inactiveSecs = 10;
    }

    var id = opts.id || "#browser";

    return new _src_browser__WEBPACK_IMPORTED_MODULE_0__["default"](reqid, id, opts);
  });
}





/***/ }),

/***/ "./node_modules/@novnc/novnc/core/base64.js":
/*!**************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/base64.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _util_logging_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/logging.js */ "./node_modules/@novnc/novnc/core/util/logging.js");
/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

// From: http://hg.mozilla.org/mozilla-central/raw-file/ec10630b1a54/js/src/devtools/jint/sunspider/string-base64.js



/* harmony default export */ __webpack_exports__["default"] = ({
    /* Convert data (an array of integers) to a Base64 string. */
    toBase64Table: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='.split(''),
    base64Pad: '=',

    encode(data) {
        "use strict";
        let result = '';
        const length = data.length;
        const lengthpad = (length % 3);
        // Convert every three bytes to 4 ascii characters.

        for (let i = 0; i < (length - 2); i += 3) {
            result += this.toBase64Table[data[i] >> 2];
            result += this.toBase64Table[((data[i] & 0x03) << 4) + (data[i + 1] >> 4)];
            result += this.toBase64Table[((data[i + 1] & 0x0f) << 2) + (data[i + 2] >> 6)];
            result += this.toBase64Table[data[i + 2] & 0x3f];
        }

        // Convert the remaining 1 or 2 bytes, pad out to 4 characters.
        const j = length - lengthpad;
        if (lengthpad === 2) {
            result += this.toBase64Table[data[j] >> 2];
            result += this.toBase64Table[((data[j] & 0x03) << 4) + (data[j + 1] >> 4)];
            result += this.toBase64Table[(data[j + 1] & 0x0f) << 2];
            result += this.toBase64Table[64];
        } else if (lengthpad === 1) {
            result += this.toBase64Table[data[j] >> 2];
            result += this.toBase64Table[(data[j] & 0x03) << 4];
            result += this.toBase64Table[64];
            result += this.toBase64Table[64];
        }

        return result;
    },

    /* Convert Base64 data to a string */
    /* eslint-disable comma-spacing */
    toBinaryTable: [
        -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
        -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,-1,
        -1,-1,-1,-1, -1,-1,-1,-1, -1,-1,-1,62, -1,-1,-1,63,
        52,53,54,55, 56,57,58,59, 60,61,-1,-1, -1, 0,-1,-1,
        -1, 0, 1, 2,  3, 4, 5, 6,  7, 8, 9,10, 11,12,13,14,
        15,16,17,18, 19,20,21,22, 23,24,25,-1, -1,-1,-1,-1,
        -1,26,27,28, 29,30,31,32, 33,34,35,36, 37,38,39,40,
        41,42,43,44, 45,46,47,48, 49,50,51,-1, -1,-1,-1,-1
    ],
    /* eslint-enable comma-spacing */

    decode(data, offset = 0) {
        let data_length = data.indexOf('=') - offset;
        if (data_length < 0) { data_length = data.length - offset; }

        /* Every four characters is 3 resulting numbers */
        const result_length = (data_length >> 2) * 3 + Math.floor((data_length % 4) / 1.5);
        const result = new Array(result_length);

        // Convert one by one.

        let leftbits = 0; // number of bits decoded, but yet to be appended
        let leftdata = 0; // bits decoded, but yet to be appended
        for (let idx = 0, i = offset; i < data.length; i++) {
            const c = this.toBinaryTable[data.charCodeAt(i) & 0x7f];
            const padding = (data.charAt(i) === this.base64Pad);
            // Skip illegal characters and whitespace
            if (c === -1) {
                _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Error"]("Illegal character code " + data.charCodeAt(i) + " at position " + i);
                continue;
            }

            // Collect data into leftdata, update bitcount
            leftdata = (leftdata << 6) | c;
            leftbits += 6;

            // If we have 8 or more bits, append 8 bits to the result
            if (leftbits >= 8) {
                leftbits -= 8;
                // Append if not padding.
                if (!padding) {
                    result[idx++] = (leftdata >> leftbits) & 0xff;
                }
                leftdata &= (1 << leftbits) - 1;
            }
        }

        // If there are any bits left, the base64 string was corrupted
        if (leftbits) {
            const err = new Error('Corrupted base64 string');
            err.name = 'Base64-Error';
            throw err;
        }

        return result;
    }
}); /* End of Base64 namespace */


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/decoders/copyrect.js":
/*!*************************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/decoders/copyrect.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CopyRectDecoder; });
/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2012 Joel Martin
 * Copyright (C) 2018 Samuel Mannehed for Cendio AB
 * Copyright (C) 2018 Pierre Ossman for Cendio AB
 * Licensed under MPL 2.0 (see LICENSE.txt)
 *
 * See README.md for usage and integration instructions.
 *
 */

class CopyRectDecoder {
    decodeRect(x, y, width, height, sock, display, depth) {
        if (sock.rQwait("COPYRECT", 4)) {
            return false;
        }

        let deltaX = sock.rQshift16();
        let deltaY = sock.rQshift16();
        display.copyImage(deltaX, deltaY, x, y, width, height);

        return true;
    }
}


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/decoders/hextile.js":
/*!************************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/decoders/hextile.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HextileDecoder; });
/* harmony import */ var _util_logging_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logging.js */ "./node_modules/@novnc/novnc/core/util/logging.js");
/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2012 Joel Martin
 * Copyright (C) 2018 Samuel Mannehed for Cendio AB
 * Copyright (C) 2018 Pierre Ossman for Cendio AB
 * Licensed under MPL 2.0 (see LICENSE.txt)
 *
 * See README.md for usage and integration instructions.
 *
 */



class HextileDecoder {
    constructor() {
        this._tiles = 0;
        this._lastsubencoding = 0;
    }

    decodeRect(x, y, width, height, sock, display, depth) {
        if (this._tiles === 0) {
            this._tiles_x = Math.ceil(width / 16);
            this._tiles_y = Math.ceil(height / 16);
            this._total_tiles = this._tiles_x * this._tiles_y;
            this._tiles = this._total_tiles;
        }

        while (this._tiles > 0) {
            let bytes = 1;

            if (sock.rQwait("HEXTILE", bytes)) {
                return false;
            }

            let rQ = sock.rQ;
            let rQi = sock.rQi;

            let subencoding = rQ[rQi];  // Peek
            if (subencoding > 30) {  // Raw
                throw new Error("Illegal hextile subencoding (subencoding: " +
                            subencoding + ")");
            }

            const curr_tile = this._total_tiles - this._tiles;
            const tile_x = curr_tile % this._tiles_x;
            const tile_y = Math.floor(curr_tile / this._tiles_x);
            const tx = x + tile_x * 16;
            const ty = y + tile_y * 16;
            const tw = Math.min(16, (x + width) - tx);
            const th = Math.min(16, (y + height) - ty);

            // Figure out how much we are expecting
            if (subencoding & 0x01) {  // Raw
                bytes += tw * th * 4;
            } else {
                if (subencoding & 0x02) {  // Background
                    bytes += 4;
                }
                if (subencoding & 0x04) {  // Foreground
                    bytes += 4;
                }
                if (subencoding & 0x08) {  // AnySubrects
                    bytes++;  // Since we aren't shifting it off

                    if (sock.rQwait("HEXTILE", bytes)) {
                        return false;
                    }

                    let subrects = rQ[rQi + bytes - 1];  // Peek
                    if (subencoding & 0x10) {  // SubrectsColoured
                        bytes += subrects * (4 + 2);
                    } else {
                        bytes += subrects * 2;
                    }
                }
            }

            if (sock.rQwait("HEXTILE", bytes)) {
                return false;
            }

            // We know the encoding and have a whole tile
            rQi++;
            if (subencoding === 0) {
                if (this._lastsubencoding & 0x01) {
                    // Weird: ignore blanks are RAW
                    _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("     Ignoring blank after RAW");
                } else {
                    display.fillRect(tx, ty, tw, th, this._background);
                }
            } else if (subencoding & 0x01) {  // Raw
                display.blitImage(tx, ty, tw, th, rQ, rQi);
                rQi += bytes - 1;
            } else {
                if (subencoding & 0x02) {  // Background
                    this._background = [rQ[rQi], rQ[rQi + 1], rQ[rQi + 2], rQ[rQi + 3]];
                    rQi += 4;
                }
                if (subencoding & 0x04) {  // Foreground
                    this._foreground = [rQ[rQi], rQ[rQi + 1], rQ[rQi + 2], rQ[rQi + 3]];
                    rQi += 4;
                }

                display.startTile(tx, ty, tw, th, this._background);
                if (subencoding & 0x08) {  // AnySubrects
                    let subrects = rQ[rQi];
                    rQi++;

                    for (let s = 0; s < subrects; s++) {
                        let color;
                        if (subencoding & 0x10) {  // SubrectsColoured
                            color = [rQ[rQi], rQ[rQi + 1], rQ[rQi + 2], rQ[rQi + 3]];
                            rQi += 4;
                        } else {
                            color = this._foreground;
                        }
                        const xy = rQ[rQi];
                        rQi++;
                        const sx = (xy >> 4);
                        const sy = (xy & 0x0f);

                        const wh = rQ[rQi];
                        rQi++;
                        const sw = (wh >> 4) + 1;
                        const sh = (wh & 0x0f) + 1;

                        display.subTile(sx, sy, sw, sh, color);
                    }
                }
                display.finishTile();
            }
            sock.rQi = rQi;
            this._lastsubencoding = subencoding;
            this._tiles--;
        }

        return true;
    }
}


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/decoders/raw.js":
/*!********************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/decoders/raw.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RawDecoder; });
/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2012 Joel Martin
 * Copyright (C) 2018 Samuel Mannehed for Cendio AB
 * Copyright (C) 2018 Pierre Ossman for Cendio AB
 * Licensed under MPL 2.0 (see LICENSE.txt)
 *
 * See README.md for usage and integration instructions.
 *
 */

class RawDecoder {
    constructor() {
        this._lines = 0;
    }

    decodeRect(x, y, width, height, sock, display, depth) {
        if (this._lines === 0) {
            this._lines = height;
        }

        const pixelSize = depth == 8 ? 1 : 4;
        const bytesPerLine = width * pixelSize;

        if (sock.rQwait("RAW", bytesPerLine)) {
            return false;
        }

        const cur_y = y + (height - this._lines);
        const curr_height = Math.min(this._lines,
                                     Math.floor(sock.rQlen / bytesPerLine));
        let data = sock.rQ;
        let index = sock.rQi;

        // Convert data if needed
        if (depth == 8) {
            const pixels = width * curr_height;
            const newdata = new Uint8Array(pixels * 4);
            for (let i = 0; i < pixels; i++) {
                newdata[i * 4 + 0] = ((data[index + i] >> 0) & 0x3) * 255 / 3;
                newdata[i * 4 + 1] = ((data[index + i] >> 2) & 0x3) * 255 / 3;
                newdata[i * 4 + 2] = ((data[index + i] >> 4) & 0x3) * 255 / 3;
                newdata[i * 4 + 4] = 0;
            }
            data = newdata;
            index = 0;
        }

        display.blitImage(x, cur_y, width, curr_height, data, index);
        sock.rQskipBytes(curr_height * bytesPerLine);
        this._lines -= curr_height;
        if (this._lines > 0) {
            return false;
        }

        return true;
    }
}


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/decoders/rre.js":
/*!********************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/decoders/rre.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RREDecoder; });
/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2012 Joel Martin
 * Copyright (C) 2018 Samuel Mannehed for Cendio AB
 * Copyright (C) 2018 Pierre Ossman for Cendio AB
 * Licensed under MPL 2.0 (see LICENSE.txt)
 *
 * See README.md for usage and integration instructions.
 *
 */

class RREDecoder {
    constructor() {
        this._subrects = 0;
    }

    decodeRect(x, y, width, height, sock, display, depth) {
        if (this._subrects === 0) {
            if (sock.rQwait("RRE", 4 + 4)) {
                return false;
            }

            this._subrects = sock.rQshift32();

            let color = sock.rQshiftBytes(4);  // Background
            display.fillRect(x, y, width, height, color);
        }

        while (this._subrects > 0) {
            if (sock.rQwait("RRE", 4 + 8)) {
                return false;
            }

            let color = sock.rQshiftBytes(4);
            let sx = sock.rQshift16();
            let sy = sock.rQshift16();
            let swidth = sock.rQshift16();
            let sheight = sock.rQshift16();
            display.fillRect(x + sx, y + sy, swidth, sheight, color);

            this._subrects--;
        }

        return true;
    }
}


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/decoders/tight.js":
/*!**********************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/decoders/tight.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TightDecoder; });
/* harmony import */ var _util_logging_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logging.js */ "./node_modules/@novnc/novnc/core/util/logging.js");
/* harmony import */ var _inflator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../inflator.js */ "./node_modules/@novnc/novnc/core/inflator.js");
/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2012 Joel Martin
 * (c) 2012 Michael Tinglof, Joe Balaz, Les Piech (Mercuri.ca)
 * Copyright (C) 2018 Samuel Mannehed for Cendio AB
 * Copyright (C) 2018 Pierre Ossman for Cendio AB
 * Licensed under MPL 2.0 (see LICENSE.txt)
 *
 * See README.md for usage and integration instructions.
 *
 */




class TightDecoder {
    constructor() {
        this._ctl = null;
        this._filter = null;
        this._numColors = 0;
        this._palette = new Uint8Array(1024);  // 256 * 4 (max palette size * max bytes-per-pixel)
        this._len = 0;

        this._zlibs = [];
        for (let i = 0; i < 4; i++) {
            this._zlibs[i] = new _inflator_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
        }
    }

    decodeRect(x, y, width, height, sock, display, depth) {
        if (this._ctl === null) {
            if (sock.rQwait("TIGHT compression-control", 1)) {
                return false;
            }

            this._ctl = sock.rQshift8();

            // Reset streams if the server requests it
            for (let i = 0; i < 4; i++) {
                if ((this._ctl >> i) & 1) {
                    this._zlibs[i].reset();
                    _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Info"]("Reset zlib stream " + i);
                }
            }

            // Figure out filter
            this._ctl = this._ctl >> 4;
        }

        let ret;

        if (this._ctl === 0x08) {
            ret = this._fillRect(x, y, width, height,
                                 sock, display, depth);
        } else if (this._ctl === 0x09) {
            ret = this._jpegRect(x, y, width, height,
                                 sock, display, depth);
        } else if (this._ctl === 0x0A) {
            ret = this._pngRect(x, y, width, height,
                                sock, display, depth);
        } else if ((this._ctl & 0x80) == 0) {
            ret = this._basicRect(this._ctl, x, y, width, height,
                                  sock, display, depth);
        } else {
            throw new Error("Illegal tight compression received (ctl: " +
                                   this._ctl + ")");
        }

        if (ret) {
            this._ctl = null;
        }

        return ret;
    }

    _fillRect(x, y, width, height, sock, display, depth) {
        if (sock.rQwait("TIGHT", 3)) {
            return false;
        }

        const rQi = sock.rQi;
        const rQ = sock.rQ;

        display.fillRect(x, y, width, height,
                         [rQ[rQi + 2], rQ[rQi + 1], rQ[rQi]], false);
        sock.rQskipBytes(3);

        return true;
    }

    _jpegRect(x, y, width, height, sock, display, depth) {
        let data = this._readData(sock);
        if (data === null) {
            return false;
        }

        display.imageRect(x, y, "image/jpeg", data);

        return true;
    }

    _pngRect(x, y, width, height, sock, display, depth) {
        throw new Error("PNG received in standard Tight rect");
    }

    _basicRect(ctl, x, y, width, height, sock, display, depth) {
        if (this._filter === null) {
            if (ctl & 0x4) {
                if (sock.rQwait("TIGHT", 1)) {
                    return false;
                }

                this._filter = sock.rQshift8();
            } else {
                // Implicit CopyFilter
                this._filter = 0;
            }
        }

        let streamId = ctl & 0x3;

        let ret;

        switch (this._filter) {
            case 0: // CopyFilter
                ret = this._copyFilter(streamId, x, y, width, height,
                                       sock, display, depth);
                break;
            case 1: // PaletteFilter
                ret = this._paletteFilter(streamId, x, y, width, height,
                                          sock, display, depth);
                break;
            case 2: // GradientFilter
                ret = this._gradientFilter(streamId, x, y, width, height,
                                           sock, display, depth);
                break;
            default:
                throw new Error("Illegal tight filter received (ctl: " +
                                       this._filter + ")");
        }

        if (ret) {
            this._filter = null;
        }

        return ret;
    }

    _copyFilter(streamId, x, y, width, height, sock, display, depth) {
        const uncompressedSize = width * height * 3;
        let data;

        if (uncompressedSize < 12) {
            if (sock.rQwait("TIGHT", uncompressedSize)) {
                return false;
            }

            data = sock.rQshiftBytes(uncompressedSize);
        } else {
            data = this._readData(sock);
            if (data === null) {
                return false;
            }

            data = this._zlibs[streamId].inflate(data, true, uncompressedSize);
            if (data.length != uncompressedSize) {
                throw new Error("Incomplete zlib block");
            }
        }

        display.blitRgbImage(x, y, width, height, data, 0, false);

        return true;
    }

    _paletteFilter(streamId, x, y, width, height, sock, display, depth) {
        if (this._numColors === 0) {
            if (sock.rQwait("TIGHT palette", 1)) {
                return false;
            }

            const numColors = sock.rQpeek8() + 1;
            const paletteSize = numColors * 3;

            if (sock.rQwait("TIGHT palette", 1 + paletteSize)) {
                return false;
            }

            this._numColors = numColors;
            sock.rQskipBytes(1);

            sock.rQshiftTo(this._palette, paletteSize);
        }

        const bpp = (this._numColors <= 2) ? 1 : 8;
        const rowSize = Math.floor((width * bpp + 7) / 8);
        const uncompressedSize = rowSize * height;

        let data;

        if (uncompressedSize < 12) {
            if (sock.rQwait("TIGHT", uncompressedSize)) {
                return false;
            }

            data = sock.rQshiftBytes(uncompressedSize);
        } else {
            data = this._readData(sock);
            if (data === null) {
                return false;
            }

            data = this._zlibs[streamId].inflate(data, true, uncompressedSize);
            if (data.length != uncompressedSize) {
                throw new Error("Incomplete zlib block");
            }
        }

        // Convert indexed (palette based) image data to RGB
        if (this._numColors == 2) {
            this._monoRect(x, y, width, height, data, this._palette, display);
        } else {
            this._paletteRect(x, y, width, height, data, this._palette, display);
        }

        this._numColors = 0;

        return true;
    }

    _monoRect(x, y, width, height, data, palette, display) {
        // Convert indexed (palette based) image data to RGB
        // TODO: reduce number of calculations inside loop
        const dest = this._getScratchBuffer(width * height * 4);
        const w = Math.floor((width + 7) / 8);
        const w1 = Math.floor(width / 8);

        for (let y = 0; y < height; y++) {
            let dp, sp, x;
            for (x = 0; x < w1; x++) {
                for (let b = 7; b >= 0; b--) {
                    dp = (y * width + x * 8 + 7 - b) * 4;
                    sp = (data[y * w + x] >> b & 1) * 3;
                    dest[dp] = palette[sp];
                    dest[dp + 1] = palette[sp + 1];
                    dest[dp + 2] = palette[sp + 2];
                    dest[dp + 3] = 255;
                }
            }

            for (let b = 7; b >= 8 - width % 8; b--) {
                dp = (y * width + x * 8 + 7 - b) * 4;
                sp = (data[y * w + x] >> b & 1) * 3;
                dest[dp] = palette[sp];
                dest[dp + 1] = palette[sp + 1];
                dest[dp + 2] = palette[sp + 2];
                dest[dp + 3] = 255;
            }
        }

        display.blitRgbxImage(x, y, width, height, dest, 0, false);
    }

    _paletteRect(x, y, width, height, data, palette, display) {
        // Convert indexed (palette based) image data to RGB
        const dest = this._getScratchBuffer(width * height * 4);
        const total = width * height * 4;
        for (let i = 0, j = 0; i < total; i += 4, j++) {
            const sp = data[j] * 3;
            dest[i] = palette[sp];
            dest[i + 1] = palette[sp + 1];
            dest[i + 2] = palette[sp + 2];
            dest[i + 3] = 255;
        }

        display.blitRgbxImage(x, y, width, height, dest, 0, false);
    }

    _gradientFilter(streamId, x, y, width, height, sock, display, depth) {
        throw new Error("Gradient filter not implemented");
    }

    _readData(sock) {
        if (this._len === 0) {
            if (sock.rQwait("TIGHT", 3)) {
                return null;
            }

            let byte;

            byte = sock.rQshift8();
            this._len = byte & 0x7f;
            if (byte & 0x80) {
                byte = sock.rQshift8();
                this._len |= (byte & 0x7f) << 7;
                if (byte & 0x80) {
                    byte = sock.rQshift8();
                    this._len |= byte << 14;
                }
            }
        }

        if (sock.rQwait("TIGHT", this._len)) {
            return null;
        }

        let data = sock.rQshiftBytes(this._len);
        this._len = 0;

        return data;
    }

    _getScratchBuffer(size) {
        if (!this._scratchBuffer || (this._scratchBuffer.length < size)) {
            this._scratchBuffer = new Uint8Array(size);
        }
        return this._scratchBuffer;
    }
}


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/decoders/tightpng.js":
/*!*************************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/decoders/tightpng.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TightPNGDecoder; });
/* harmony import */ var _tight_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./tight.js */ "./node_modules/@novnc/novnc/core/decoders/tight.js");
/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2012 Joel Martin
 * Copyright (C) 2018 Samuel Mannehed for Cendio AB
 * Copyright (C) 2018 Pierre Ossman for Cendio AB
 * Licensed under MPL 2.0 (see LICENSE.txt)
 *
 * See README.md for usage and integration instructions.
 *
 */



class TightPNGDecoder extends _tight_js__WEBPACK_IMPORTED_MODULE_0__["default"] {
    _pngRect(x, y, width, height, sock, display, depth) {
        let data = this._readData(sock);
        if (data === null) {
            return false;
        }

        display.imageRect(x, y, "image/png", data);

        return true;
    }

    _basicRect(ctl, x, y, width, height, sock, display, depth) {
        throw new Error("BasicCompression received in TightPNG rect");
    }
}


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/des.js":
/*!***********************************************!*\
  !*** ./node_modules/@novnc/novnc/core/des.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return DES; });
/*
 * Ported from Flashlight VNC ActionScript implementation:
 *     http://www.wizhelp.com/flashlight-vnc/
 *
 * Full attribution follows:
 *
 * -------------------------------------------------------------------------
 *
 * This DES class has been extracted from package Acme.Crypto for use in VNC.
 * The unnecessary odd parity code has been removed.
 *
 * These changes are:
 *  Copyright (C) 1999 AT&T Laboratories Cambridge.  All Rights Reserved.
 *
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 *

 * DesCipher - the DES encryption method
 *
 * The meat of this code is by Dave Zimmerman <dzimm@widget.com>, and is:
 *
 * Copyright (c) 1996 Widget Workshop, Inc. All Rights Reserved.
 *
 * Permission to use, copy, modify, and distribute this software
 * and its documentation for NON-COMMERCIAL or COMMERCIAL purposes and
 * without fee is hereby granted, provided that this copyright notice is kept
 * intact.
 *
 * WIDGET WORKSHOP MAKES NO REPRESENTATIONS OR WARRANTIES ABOUT THE SUITABILITY
 * OF THE SOFTWARE, EITHER EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED
 * TO THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
 * PARTICULAR PURPOSE, OR NON-INFRINGEMENT. WIDGET WORKSHOP SHALL NOT BE LIABLE
 * FOR ANY DAMAGES SUFFERED BY LICENSEE AS A RESULT OF USING, MODIFYING OR
 * DISTRIBUTING THIS SOFTWARE OR ITS DERIVATIVES.
 *
 * THIS SOFTWARE IS NOT DESIGNED OR INTENDED FOR USE OR RESALE AS ON-LINE
 * CONTROL EQUIPMENT IN HAZARDOUS ENVIRONMENTS REQUIRING FAIL-SAFE
 * PERFORMANCE, SUCH AS IN THE OPERATION OF NUCLEAR FACILITIES, AIRCRAFT
 * NAVIGATION OR COMMUNICATION SYSTEMS, AIR TRAFFIC CONTROL, DIRECT LIFE
 * SUPPORT MACHINES, OR WEAPONS SYSTEMS, IN WHICH THE FAILURE OF THE
 * SOFTWARE COULD LEAD DIRECTLY TO DEATH, PERSONAL INJURY, OR SEVERE
 * PHYSICAL OR ENVIRONMENTAL DAMAGE ("HIGH RISK ACTIVITIES").  WIDGET WORKSHOP
 * SPECIFICALLY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY OF FITNESS FOR
 * HIGH RISK ACTIVITIES.
 *
 *
 * The rest is:
 *
 * Copyright (C) 1996 by Jef Poskanzer <jef@acme.com>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * Visit the ACME Labs Java page for up-to-date versions of this and other
 * fine Java utilities: http://www.acme.com/java/
 */

/* eslint-disable comma-spacing */

// Tables, permutations, S-boxes, etc.
const PC2 = [13,16,10,23, 0, 4, 2,27,14, 5,20, 9,22,18,11, 3,
             25, 7,15, 6,26,19,12, 1,40,51,30,36,46,54,29,39,
             50,44,32,47,43,48,38,55,33,52,45,41,49,35,28,31 ],
    totrot = [ 1, 2, 4, 6, 8,10,12,14,15,17,19,21,23,25,27,28];

const z = 0x0;
let a,b,c,d,e,f;
a=1<<16; b=1<<24; c=a|b; d=1<<2; e=1<<10; f=d|e;
const SP1 = [c|e,z|z,a|z,c|f,c|d,a|f,z|d,a|z,z|e,c|e,c|f,z|e,b|f,c|d,b|z,z|d,
             z|f,b|e,b|e,a|e,a|e,c|z,c|z,b|f,a|d,b|d,b|d,a|d,z|z,z|f,a|f,b|z,
             a|z,c|f,z|d,c|z,c|e,b|z,b|z,z|e,c|d,a|z,a|e,b|d,z|e,z|d,b|f,a|f,
             c|f,a|d,c|z,b|f,b|d,z|f,a|f,c|e,z|f,b|e,b|e,z|z,a|d,a|e,z|z,c|d];
a=1<<20; b=1<<31; c=a|b; d=1<<5; e=1<<15; f=d|e;
const SP2 = [c|f,b|e,z|e,a|f,a|z,z|d,c|d,b|f,b|d,c|f,c|e,b|z,b|e,a|z,z|d,c|d,
             a|e,a|d,b|f,z|z,b|z,z|e,a|f,c|z,a|d,b|d,z|z,a|e,z|f,c|e,c|z,z|f,
             z|z,a|f,c|d,a|z,b|f,c|z,c|e,z|e,c|z,b|e,z|d,c|f,a|f,z|d,z|e,b|z,
             z|f,c|e,a|z,b|d,a|d,b|f,b|d,a|d,a|e,z|z,b|e,z|f,b|z,c|d,c|f,a|e];
a=1<<17; b=1<<27; c=a|b; d=1<<3; e=1<<9; f=d|e;
const SP3 = [z|f,c|e,z|z,c|d,b|e,z|z,a|f,b|e,a|d,b|d,b|d,a|z,c|f,a|d,c|z,z|f,
             b|z,z|d,c|e,z|e,a|e,c|z,c|d,a|f,b|f,a|e,a|z,b|f,z|d,c|f,z|e,b|z,
             c|e,b|z,a|d,z|f,a|z,c|e,b|e,z|z,z|e,a|d,c|f,b|e,b|d,z|e,z|z,c|d,
             b|f,a|z,b|z,c|f,z|d,a|f,a|e,b|d,c|z,b|f,z|f,c|z,a|f,z|d,c|d,a|e];
a=1<<13; b=1<<23; c=a|b; d=1<<0; e=1<<7; f=d|e;
const SP4 = [c|d,a|f,a|f,z|e,c|e,b|f,b|d,a|d,z|z,c|z,c|z,c|f,z|f,z|z,b|e,b|d,
             z|d,a|z,b|z,c|d,z|e,b|z,a|d,a|e,b|f,z|d,a|e,b|e,a|z,c|e,c|f,z|f,
             b|e,b|d,c|z,c|f,z|f,z|z,z|z,c|z,a|e,b|e,b|f,z|d,c|d,a|f,a|f,z|e,
             c|f,z|f,z|d,a|z,b|d,a|d,c|e,b|f,a|d,a|e,b|z,c|d,z|e,b|z,a|z,c|e];
a=1<<25; b=1<<30; c=a|b; d=1<<8; e=1<<19; f=d|e;
const SP5 = [z|d,a|f,a|e,c|d,z|e,z|d,b|z,a|e,b|f,z|e,a|d,b|f,c|d,c|e,z|f,b|z,
             a|z,b|e,b|e,z|z,b|d,c|f,c|f,a|d,c|e,b|d,z|z,c|z,a|f,a|z,c|z,z|f,
             z|e,c|d,z|d,a|z,b|z,a|e,c|d,b|f,a|d,b|z,c|e,a|f,b|f,z|d,a|z,c|e,
             c|f,z|f,c|z,c|f,a|e,z|z,b|e,c|z,z|f,a|d,b|d,z|e,z|z,b|e,a|f,b|d];
a=1<<22; b=1<<29; c=a|b; d=1<<4; e=1<<14; f=d|e;
const SP6 = [b|d,c|z,z|e,c|f,c|z,z|d,c|f,a|z,b|e,a|f,a|z,b|d,a|d,b|e,b|z,z|f,
             z|z,a|d,b|f,z|e,a|e,b|f,z|d,c|d,c|d,z|z,a|f,c|e,z|f,a|e,c|e,b|z,
             b|e,z|d,c|d,a|e,c|f,a|z,z|f,b|d,a|z,b|e,b|z,z|f,b|d,c|f,a|e,c|z,
             a|f,c|e,z|z,c|d,z|d,z|e,c|z,a|f,z|e,a|d,b|f,z|z,c|e,b|z,a|d,b|f];
a=1<<21; b=1<<26; c=a|b; d=1<<1; e=1<<11; f=d|e;
const SP7 = [a|z,c|d,b|f,z|z,z|e,b|f,a|f,c|e,c|f,a|z,z|z,b|d,z|d,b|z,c|d,z|f,
             b|e,a|f,a|d,b|e,b|d,c|z,c|e,a|d,c|z,z|e,z|f,c|f,a|e,z|d,b|z,a|e,
             b|z,a|e,a|z,b|f,b|f,c|d,c|d,z|d,a|d,b|z,b|e,a|z,c|e,z|f,a|f,c|e,
             z|f,b|d,c|f,c|z,a|e,z|z,z|d,c|f,z|z,a|f,c|z,z|e,b|d,b|e,z|e,a|d];
a=1<<18; b=1<<28; c=a|b; d=1<<6; e=1<<12; f=d|e;
const SP8 = [b|f,z|e,a|z,c|f,b|z,b|f,z|d,b|z,a|d,c|z,c|f,a|e,c|e,a|f,z|e,z|d,
             c|z,b|d,b|e,z|f,a|e,a|d,c|d,c|e,z|f,z|z,z|z,c|d,b|d,b|e,a|f,a|z,
             a|f,a|z,c|e,z|e,z|d,c|d,z|e,a|f,b|e,z|d,b|d,c|z,c|d,b|z,a|z,b|f,
             z|z,c|f,a|d,b|d,c|z,b|e,b|f,z|z,c|f,a|e,a|e,z|f,z|f,a|d,b|z,c|e];

/* eslint-enable comma-spacing */

class DES {
    constructor(password) {
        this.keys = [];

        // Set the key.
        const pc1m = [], pcr = [], kn = [];

        for (let j = 0, l = 56; j < 56; ++j, l -= 8) {
            l += l < -5 ? 65 : l < -3 ? 31 : l < -1 ? 63 : l === 27 ? 35 : 0; // PC1
            const m = l & 0x7;
            pc1m[j] = ((password[l >>> 3] & (1<<m)) !== 0) ? 1: 0;
        }

        for (let i = 0; i < 16; ++i) {
            const m = i << 1;
            const n = m + 1;
            kn[m] = kn[n] = 0;
            for (let o = 28; o < 59; o += 28) {
                for (let j = o - 28; j < o; ++j) {
                    const l = j + totrot[i];
                    pcr[j] = l < o ? pc1m[l] : pc1m[l - 28];
                }
            }
            for (let j = 0; j < 24; ++j) {
                if (pcr[PC2[j]] !== 0) {
                    kn[m] |= 1 << (23 - j);
                }
                if (pcr[PC2[j + 24]] !== 0) {
                    kn[n] |= 1 << (23 - j);
                }
            }
        }

        // cookey
        for (let i = 0, rawi = 0, KnLi = 0; i < 16; ++i) {
            const raw0 = kn[rawi++];
            const raw1 = kn[rawi++];
            this.keys[KnLi] = (raw0 & 0x00fc0000) << 6;
            this.keys[KnLi] |= (raw0 & 0x00000fc0) << 10;
            this.keys[KnLi] |= (raw1 & 0x00fc0000) >>> 10;
            this.keys[KnLi] |= (raw1 & 0x00000fc0) >>> 6;
            ++KnLi;
            this.keys[KnLi] = (raw0 & 0x0003f000) << 12;
            this.keys[KnLi] |= (raw0 & 0x0000003f) << 16;
            this.keys[KnLi] |= (raw1 & 0x0003f000) >>> 4;
            this.keys[KnLi] |= (raw1 & 0x0000003f);
            ++KnLi;
        }
    }

    // Encrypt 8 bytes of text
    enc8(text) {
        const b = text.slice();
        let i = 0, l, r, x; // left, right, accumulator

        // Squash 8 bytes to 2 ints
        l = b[i++]<<24 | b[i++]<<16 | b[i++]<<8 | b[i++];
        r = b[i++]<<24 | b[i++]<<16 | b[i++]<<8 | b[i++];

        x = ((l >>> 4) ^ r) & 0x0f0f0f0f;
        r ^= x;
        l ^= (x << 4);
        x = ((l >>> 16) ^ r) & 0x0000ffff;
        r ^= x;
        l ^= (x << 16);
        x = ((r >>> 2) ^ l) & 0x33333333;
        l ^= x;
        r ^= (x << 2);
        x = ((r >>> 8) ^ l) & 0x00ff00ff;
        l ^= x;
        r ^= (x << 8);
        r = (r << 1) | ((r >>> 31) & 1);
        x = (l ^ r) & 0xaaaaaaaa;
        l ^= x;
        r ^= x;
        l = (l << 1) | ((l >>> 31) & 1);

        for (let i = 0, keysi = 0; i < 8; ++i) {
            x = (r << 28) | (r >>> 4);
            x ^= this.keys[keysi++];
            let fval =  SP7[x & 0x3f];
            fval |= SP5[(x >>> 8) & 0x3f];
            fval |= SP3[(x >>> 16) & 0x3f];
            fval |= SP1[(x >>> 24) & 0x3f];
            x = r ^ this.keys[keysi++];
            fval |= SP8[x & 0x3f];
            fval |= SP6[(x >>> 8) & 0x3f];
            fval |= SP4[(x >>> 16) & 0x3f];
            fval |= SP2[(x >>> 24) & 0x3f];
            l ^= fval;
            x = (l << 28) | (l >>> 4);
            x ^= this.keys[keysi++];
            fval =  SP7[x & 0x3f];
            fval |= SP5[(x >>> 8) & 0x3f];
            fval |= SP3[(x >>> 16) & 0x3f];
            fval |= SP1[(x >>> 24) & 0x3f];
            x = l ^ this.keys[keysi++];
            fval |= SP8[x & 0x0000003f];
            fval |= SP6[(x >>> 8) & 0x3f];
            fval |= SP4[(x >>> 16) & 0x3f];
            fval |= SP2[(x >>> 24) & 0x3f];
            r ^= fval;
        }

        r = (r << 31) | (r >>> 1);
        x = (l ^ r) & 0xaaaaaaaa;
        l ^= x;
        r ^= x;
        l = (l << 31) | (l >>> 1);
        x = ((l >>> 8) ^ r) & 0x00ff00ff;
        r ^= x;
        l ^= (x << 8);
        x = ((l >>> 2) ^ r) & 0x33333333;
        r ^= x;
        l ^= (x << 2);
        x = ((r >>> 16) ^ l) & 0x0000ffff;
        l ^= x;
        r ^= (x << 16);
        x = ((r >>> 4) ^ l) & 0x0f0f0f0f;
        l ^= x;
        r ^= (x << 4);

        // Spread ints to bytes
        x = [r, l];
        for (i = 0; i < 8; i++) {
            b[i] = (x[i>>>2] >>> (8 * (3 - (i % 4)))) % 256;
            if (b[i] < 0) { b[i] += 256; } // unsigned
        }
        return b;
    }

    // Encrypt 16 bytes of text using passwd as key
    encrypt(t) {
        return this.enc8(t.slice(0, 8)).concat(this.enc8(t.slice(8, 16)));
    }
}


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/display.js":
/*!***************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/display.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Display; });
/* harmony import */ var _util_logging_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/logging.js */ "./node_modules/@novnc/novnc/core/util/logging.js");
/* harmony import */ var _base64_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./base64.js */ "./node_modules/@novnc/novnc/core/base64.js");
/* harmony import */ var _util_browser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/browser.js */ "./node_modules/@novnc/novnc/core/util/browser.js");
/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2018 The noVNC Authors
 * Licensed under MPL 2.0 (see LICENSE.txt)
 *
 * See README.md for usage and integration instructions.
 */





class Display {
    constructor(target) {
        this._drawCtx = null;
        this._c_forceCanvas = false;

        this._renderQ = [];  // queue drawing actions for in-oder rendering
        this._flushing = false;

        // the full frame buffer (logical canvas) size
        this._fb_width = 0;
        this._fb_height = 0;

        this._prevDrawStyle = "";
        this._tile = null;
        this._tile16x16 = null;
        this._tile_x = 0;
        this._tile_y = 0;

        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"](">> Display.constructor");

        // The visible canvas
        this._target = target;

        if (!this._target) {
            throw new Error("Target must be set");
        }

        if (typeof this._target === 'string') {
            throw new Error('target must be a DOM element');
        }

        if (!this._target.getContext) {
            throw new Error("no getContext method");
        }

        this._targetCtx = this._target.getContext('2d');

        // the visible canvas viewport (i.e. what actually gets seen)
        this._viewportLoc = { 'x': 0, 'y': 0, 'w': this._target.width, 'h': this._target.height };

        // The hidden canvas, where we do the actual rendering
        this._backbuffer = document.createElement('canvas');
        this._drawCtx = this._backbuffer.getContext('2d');

        this._damageBounds = { left: 0, top: 0,
                               right: this._backbuffer.width,
                               bottom: this._backbuffer.height };

        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("User Agent: " + navigator.userAgent);

        this.clear();

        // Check canvas features
        if (!('createImageData' in this._drawCtx)) {
            throw new Error("Canvas does not support createImageData");
        }

        this._tile16x16 = this._drawCtx.createImageData(16, 16);
        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("<< Display.constructor");

        // ===== PROPERTIES =====

        this._scale = 1.0;
        this._clipViewport = false;
        this.logo = null;

        // ===== EVENT HANDLERS =====

        this.onflush = () => {}; // A flush request has finished
    }

    // ===== PROPERTIES =====

    get scale() { return this._scale; }
    set scale(scale) {
        this._rescale(scale);
    }

    get clipViewport() { return this._clipViewport; }
    set clipViewport(viewport) {
        this._clipViewport = viewport;
        // May need to readjust the viewport dimensions
        const vp = this._viewportLoc;
        this.viewportChangeSize(vp.w, vp.h);
        this.viewportChangePos(0, 0);
    }

    get width() {
        return this._fb_width;
    }

    get height() {
        return this._fb_height;
    }

    // ===== PUBLIC METHODS =====

    viewportChangePos(deltaX, deltaY) {
        const vp = this._viewportLoc;
        deltaX = Math.floor(deltaX);
        deltaY = Math.floor(deltaY);

        if (!this._clipViewport) {
            deltaX = -vp.w;  // clamped later of out of bounds
            deltaY = -vp.h;
        }

        const vx2 = vp.x + vp.w - 1;
        const vy2 = vp.y + vp.h - 1;

        // Position change

        if (deltaX < 0 && vp.x + deltaX < 0) {
            deltaX = -vp.x;
        }
        if (vx2 + deltaX >= this._fb_width) {
            deltaX -= vx2 + deltaX - this._fb_width + 1;
        }

        if (vp.y + deltaY < 0) {
            deltaY = -vp.y;
        }
        if (vy2 + deltaY >= this._fb_height) {
            deltaY -= (vy2 + deltaY - this._fb_height + 1);
        }

        if (deltaX === 0 && deltaY === 0) {
            return;
        }
        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("viewportChange deltaX: " + deltaX + ", deltaY: " + deltaY);

        vp.x += deltaX;
        vp.y += deltaY;

        this._damage(vp.x, vp.y, vp.w, vp.h);

        this.flip();
    }

    viewportChangeSize(width, height) {

        if (!this._clipViewport ||
            typeof(width) === "undefined" ||
            typeof(height) === "undefined") {

            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("Setting viewport to full display region");
            width = this._fb_width;
            height = this._fb_height;
        }

        width = Math.floor(width);
        height = Math.floor(height);

        if (width > this._fb_width) {
            width = this._fb_width;
        }
        if (height > this._fb_height) {
            height = this._fb_height;
        }

        const vp = this._viewportLoc;
        if (vp.w !== width || vp.h !== height) {
            vp.w = width;
            vp.h = height;

            const canvas = this._target;
            canvas.width = width;
            canvas.height = height;

            // The position might need to be updated if we've grown
            this.viewportChangePos(0, 0);

            this._damage(vp.x, vp.y, vp.w, vp.h);
            this.flip();

            // Update the visible size of the target canvas
            this._rescale(this._scale);
        }
    }

    absX(x) {
        if (this._scale === 0) {
            return 0;
        }
        return x / this._scale + this._viewportLoc.x;
    }

    absY(y) {
        if (this._scale === 0) {
            return 0;
        }
        return y / this._scale + this._viewportLoc.y;
    }

    resize(width, height) {
        this._prevDrawStyle = "";

        this._fb_width = width;
        this._fb_height = height;

        const canvas = this._backbuffer;
        if (canvas.width !== width || canvas.height !== height) {

            // We have to save the canvas data since changing the size will clear it
            let saveImg = null;
            if (canvas.width > 0 && canvas.height > 0) {
                saveImg = this._drawCtx.getImageData(0, 0, canvas.width, canvas.height);
            }

            if (canvas.width !== width) {
                canvas.width = width;
            }
            if (canvas.height !== height) {
                canvas.height = height;
            }

            if (saveImg) {
                this._drawCtx.putImageData(saveImg, 0, 0);
            }
        }

        // Readjust the viewport as it may be incorrectly sized
        // and positioned
        const vp = this._viewportLoc;
        this.viewportChangeSize(vp.w, vp.h);
        this.viewportChangePos(0, 0);
    }

    // Track what parts of the visible canvas that need updating
    _damage(x, y, w, h) {
        if (x < this._damageBounds.left) {
            this._damageBounds.left = x;
        }
        if (y < this._damageBounds.top) {
            this._damageBounds.top = y;
        }
        if ((x + w) > this._damageBounds.right) {
            this._damageBounds.right = x + w;
        }
        if ((y + h) > this._damageBounds.bottom) {
            this._damageBounds.bottom = y + h;
        }
    }

    // Update the visible canvas with the contents of the
    // rendering canvas
    flip(from_queue) {
        if (this._renderQ.length !== 0 && !from_queue) {
            this._renderQ_push({
                'type': 'flip'
            });
        } else {
            let x = this._damageBounds.left;
            let y = this._damageBounds.top;
            let w = this._damageBounds.right - x;
            let h = this._damageBounds.bottom - y;

            let vx = x - this._viewportLoc.x;
            let vy = y - this._viewportLoc.y;

            if (vx < 0) {
                w += vx;
                x -= vx;
                vx = 0;
            }
            if (vy < 0) {
                h += vy;
                y -= vy;
                vy = 0;
            }

            if ((vx + w) > this._viewportLoc.w) {
                w = this._viewportLoc.w - vx;
            }
            if ((vy + h) > this._viewportLoc.h) {
                h = this._viewportLoc.h - vy;
            }

            if ((w > 0) && (h > 0)) {
                // FIXME: We may need to disable image smoothing here
                //        as well (see copyImage()), but we haven't
                //        noticed any problem yet.
                this._targetCtx.drawImage(this._backbuffer,
                                          x, y, w, h,
                                          vx, vy, w, h);
            }

            this._damageBounds.left = this._damageBounds.top = 65535;
            this._damageBounds.right = this._damageBounds.bottom = 0;
        }
    }

    clear() {
        if (this._logo) {
            this.resize(this._logo.width, this._logo.height);
            this.imageRect(0, 0, this._logo.type, this._logo.data);
        } else {
            this.resize(240, 20);
            this._drawCtx.clearRect(0, 0, this._fb_width, this._fb_height);
        }
        this.flip();
    }

    pending() {
        return this._renderQ.length > 0;
    }

    flush() {
        if (this._renderQ.length === 0) {
            this.onflush();
        } else {
            this._flushing = true;
        }
    }

    fillRect(x, y, width, height, color, from_queue) {
        if (this._renderQ.length !== 0 && !from_queue) {
            this._renderQ_push({
                'type': 'fill',
                'x': x,
                'y': y,
                'width': width,
                'height': height,
                'color': color
            });
        } else {
            this._setFillColor(color);
            this._drawCtx.fillRect(x, y, width, height);
            this._damage(x, y, width, height);
        }
    }

    copyImage(old_x, old_y, new_x, new_y, w, h, from_queue) {
        if (this._renderQ.length !== 0 && !from_queue) {
            this._renderQ_push({
                'type': 'copy',
                'old_x': old_x,
                'old_y': old_y,
                'x': new_x,
                'y': new_y,
                'width': w,
                'height': h,
            });
        } else {
            // Due to this bug among others [1] we need to disable the image-smoothing to
            // avoid getting a blur effect when copying data.
            //
            // 1. https://bugzilla.mozilla.org/show_bug.cgi?id=1194719
            //
            // We need to set these every time since all properties are reset
            // when the the size is changed
            this._drawCtx.mozImageSmoothingEnabled = false;
            this._drawCtx.webkitImageSmoothingEnabled = false;
            this._drawCtx.msImageSmoothingEnabled = false;
            this._drawCtx.imageSmoothingEnabled = false;

            this._drawCtx.drawImage(this._backbuffer,
                                    old_x, old_y, w, h,
                                    new_x, new_y, w, h);
            this._damage(new_x, new_y, w, h);
        }
    }

    imageRect(x, y, mime, arr) {
        const img = new Image();
        img.src = "data: " + mime + ";base64," + _base64_js__WEBPACK_IMPORTED_MODULE_1__["default"].encode(arr);
        this._renderQ_push({
            'type': 'img',
            'img': img,
            'x': x,
            'y': y
        });
    }

    // start updating a tile
    startTile(x, y, width, height, color) {
        this._tile_x = x;
        this._tile_y = y;
        if (width === 16 && height === 16) {
            this._tile = this._tile16x16;
        } else {
            this._tile = this._drawCtx.createImageData(width, height);
        }

        const red = color[2];
        const green = color[1];
        const blue = color[0];

        const data = this._tile.data;
        for (let i = 0; i < width * height * 4; i += 4) {
            data[i] = red;
            data[i + 1] = green;
            data[i + 2] = blue;
            data[i + 3] = 255;
        }
    }

    // update sub-rectangle of the current tile
    subTile(x, y, w, h, color) {
        const red = color[2];
        const green = color[1];
        const blue = color[0];
        const xend = x + w;
        const yend = y + h;

        const data = this._tile.data;
        const width = this._tile.width;
        for (let j = y; j < yend; j++) {
            for (let i = x; i < xend; i++) {
                const p = (i + (j * width)) * 4;
                data[p] = red;
                data[p + 1] = green;
                data[p + 2] = blue;
                data[p + 3] = 255;
            }
        }
    }

    // draw the current tile to the screen
    finishTile() {
        this._drawCtx.putImageData(this._tile, this._tile_x, this._tile_y);
        this._damage(this._tile_x, this._tile_y,
                     this._tile.width, this._tile.height);
    }

    blitImage(x, y, width, height, arr, offset, from_queue) {
        if (this._renderQ.length !== 0 && !from_queue) {
            // NB(directxman12): it's technically more performant here to use preallocated arrays,
            // but it's a lot of extra work for not a lot of payoff -- if we're using the render queue,
            // this probably isn't getting called *nearly* as much
            const new_arr = new Uint8Array(width * height * 4);
            new_arr.set(new Uint8Array(arr.buffer, 0, new_arr.length));
            this._renderQ_push({
                'type': 'blit',
                'data': new_arr,
                'x': x,
                'y': y,
                'width': width,
                'height': height,
            });
        } else {
            this._bgrxImageData(x, y, width, height, arr, offset);
        }
    }

    blitRgbImage(x, y, width, height, arr, offset, from_queue) {
        if (this._renderQ.length !== 0 && !from_queue) {
            // NB(directxman12): it's technically more performant here to use preallocated arrays,
            // but it's a lot of extra work for not a lot of payoff -- if we're using the render queue,
            // this probably isn't getting called *nearly* as much
            const new_arr = new Uint8Array(width * height * 3);
            new_arr.set(new Uint8Array(arr.buffer, 0, new_arr.length));
            this._renderQ_push({
                'type': 'blitRgb',
                'data': new_arr,
                'x': x,
                'y': y,
                'width': width,
                'height': height,
            });
        } else {
            this._rgbImageData(x, y, width, height, arr, offset);
        }
    }

    blitRgbxImage(x, y, width, height, arr, offset, from_queue) {
        if (this._renderQ.length !== 0 && !from_queue) {
            // NB(directxman12): it's technically more performant here to use preallocated arrays,
            // but it's a lot of extra work for not a lot of payoff -- if we're using the render queue,
            // this probably isn't getting called *nearly* as much
            const new_arr = new Uint8Array(width * height * 4);
            new_arr.set(new Uint8Array(arr.buffer, 0, new_arr.length));
            this._renderQ_push({
                'type': 'blitRgbx',
                'data': new_arr,
                'x': x,
                'y': y,
                'width': width,
                'height': height,
            });
        } else {
            this._rgbxImageData(x, y, width, height, arr, offset);
        }
    }

    drawImage(img, x, y) {
        this._drawCtx.drawImage(img, x, y);
        this._damage(x, y, img.width, img.height);
    }

    autoscale(containerWidth, containerHeight) {
        let scaleRatio;

        if (containerWidth === 0 || containerHeight === 0) {
            scaleRatio = 0;

        } else {

            const vp = this._viewportLoc;
            const targetAspectRatio = containerWidth / containerHeight;
            const fbAspectRatio = vp.w / vp.h;

            if (fbAspectRatio >= targetAspectRatio) {
                scaleRatio = containerWidth / vp.w;
            } else {
                scaleRatio = containerHeight / vp.h;
            }
        }

        this._rescale(scaleRatio);
    }

    // ===== PRIVATE METHODS =====

    _rescale(factor) {
        this._scale = factor;
        const vp = this._viewportLoc;

        // NB(directxman12): If you set the width directly, or set the
        //                   style width to a number, the canvas is cleared.
        //                   However, if you set the style width to a string
        //                   ('NNNpx'), the canvas is scaled without clearing.
        const width = factor * vp.w + 'px';
        const height = factor * vp.h + 'px';

        if ((this._target.style.width !== width) ||
            (this._target.style.height !== height)) {
            this._target.style.width = width;
            this._target.style.height = height;
        }
    }

    _setFillColor(color) {
        const newStyle = 'rgb(' + color[2] + ',' + color[1] + ',' + color[0] + ')';
        if (newStyle !== this._prevDrawStyle) {
            this._drawCtx.fillStyle = newStyle;
            this._prevDrawStyle = newStyle;
        }
    }

    _rgbImageData(x, y, width, height, arr, offset) {
        const img = this._drawCtx.createImageData(width, height);
        const data = img.data;
        for (let i = 0, j = offset; i < width * height * 4; i += 4, j += 3) {
            data[i]     = arr[j];
            data[i + 1] = arr[j + 1];
            data[i + 2] = arr[j + 2];
            data[i + 3] = 255;  // Alpha
        }
        this._drawCtx.putImageData(img, x, y);
        this._damage(x, y, img.width, img.height);
    }

    _bgrxImageData(x, y, width, height, arr, offset) {
        const img = this._drawCtx.createImageData(width, height);
        const data = img.data;
        for (let i = 0, j = offset; i < width * height * 4; i += 4, j += 4) {
            data[i]     = arr[j + 2];
            data[i + 1] = arr[j + 1];
            data[i + 2] = arr[j];
            data[i + 3] = 255;  // Alpha
        }
        this._drawCtx.putImageData(img, x, y);
        this._damage(x, y, img.width, img.height);
    }

    _rgbxImageData(x, y, width, height, arr, offset) {
        // NB(directxman12): arr must be an Type Array view
        let img;
        if (_util_browser_js__WEBPACK_IMPORTED_MODULE_2__["supportsImageMetadata"]) {
            img = new ImageData(new Uint8ClampedArray(arr.buffer, arr.byteOffset, width * height * 4), width, height);
        } else {
            img = this._drawCtx.createImageData(width, height);
            img.data.set(new Uint8ClampedArray(arr.buffer, arr.byteOffset, width * height * 4));
        }
        this._drawCtx.putImageData(img, x, y);
        this._damage(x, y, img.width, img.height);
    }

    _renderQ_push(action) {
        this._renderQ.push(action);
        if (this._renderQ.length === 1) {
            // If this can be rendered immediately it will be, otherwise
            // the scanner will wait for the relevant event
            this._scan_renderQ();
        }
    }

    _resume_renderQ() {
        // "this" is the object that is ready, not the
        // display object
        this.removeEventListener('load', this._noVNC_display._resume_renderQ);
        this._noVNC_display._scan_renderQ();
    }

    _scan_renderQ() {
        let ready = true;
        while (ready && this._renderQ.length > 0) {
            const a = this._renderQ[0];
            switch (a.type) {
                case 'flip':
                    this.flip(true);
                    break;
                case 'copy':
                    this.copyImage(a.old_x, a.old_y, a.x, a.y, a.width, a.height, true);
                    break;
                case 'fill':
                    this.fillRect(a.x, a.y, a.width, a.height, a.color, true);
                    break;
                case 'blit':
                    this.blitImage(a.x, a.y, a.width, a.height, a.data, 0, true);
                    break;
                case 'blitRgb':
                    this.blitRgbImage(a.x, a.y, a.width, a.height, a.data, 0, true);
                    break;
                case 'blitRgbx':
                    this.blitRgbxImage(a.x, a.y, a.width, a.height, a.data, 0, true);
                    break;
                case 'img':
                    if (a.img.complete) {
                        this.drawImage(a.img, a.x, a.y);
                    } else {
                        a.img._noVNC_display = this;
                        a.img.addEventListener('load', this._resume_renderQ);
                        // We need to wait for this image to 'load'
                        // to keep things in-order
                        ready = false;
                    }
                    break;
            }

            if (ready) {
                this._renderQ.shift();
            }
        }

        if (this._renderQ.length === 0 && this._flushing) {
            this._flushing = false;
            this.onflush();
        }
    }
}


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/encodings.js":
/*!*****************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/encodings.js ***!
  \*****************************************************/
/*! exports provided: encodings, encodingName */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodings", function() { return encodings; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encodingName", function() { return encodingName; });
/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2018 The noVNC Authors
 * Licensed under MPL 2.0 (see LICENSE.txt)
 *
 * See README.md for usage and integration instructions.
 */

const encodings = {
    encodingRaw: 0,
    encodingCopyRect: 1,
    encodingRRE: 2,
    encodingHextile: 5,
    encodingTight: 7,
    encodingTightPNG: -260,

    pseudoEncodingQualityLevel9: -23,
    pseudoEncodingQualityLevel0: -32,
    pseudoEncodingDesktopSize: -223,
    pseudoEncodingLastRect: -224,
    pseudoEncodingCursor: -239,
    pseudoEncodingQEMUExtendedKeyEvent: -258,
    pseudoEncodingExtendedDesktopSize: -308,
    pseudoEncodingXvp: -309,
    pseudoEncodingFence: -312,
    pseudoEncodingContinuousUpdates: -313,
    pseudoEncodingCompressLevel9: -247,
    pseudoEncodingCompressLevel0: -256,
};

function encodingName(num) {
    switch (num) {
        case encodings.encodingRaw:      return "Raw";
        case encodings.encodingCopyRect: return "CopyRect";
        case encodings.encodingRRE:      return "RRE";
        case encodings.encodingHextile:  return "Hextile";
        case encodings.encodingTight:    return "Tight";
        case encodings.encodingTightPNG: return "TightPNG";
        default:                         return "[unknown encoding " + num + "]";
    }
}


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/inflator.js":
/*!****************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/inflator.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Inflate; });
/* harmony import */ var _vendor_pako_lib_zlib_inflate_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../vendor/pako/lib/zlib/inflate.js */ "./node_modules/@novnc/novnc/vendor/pako/lib/zlib/inflate.js");
/* harmony import */ var _vendor_pako_lib_zlib_zstream_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../vendor/pako/lib/zlib/zstream.js */ "./node_modules/@novnc/novnc/vendor/pako/lib/zlib/zstream.js");



class Inflate {
    constructor() {
        this.strm = new _vendor_pako_lib_zlib_zstream_js__WEBPACK_IMPORTED_MODULE_1__["default"]();
        this.chunkSize = 1024 * 10 * 10;
        this.strm.output = new Uint8Array(this.chunkSize);
        this.windowBits = 5;

        Object(_vendor_pako_lib_zlib_inflate_js__WEBPACK_IMPORTED_MODULE_0__["inflateInit"])(this.strm, this.windowBits);
    }

    inflate(data, flush, expected) {
        this.strm.input = data;
        this.strm.avail_in = this.strm.input.length;
        this.strm.next_in = 0;
        this.strm.next_out = 0;

        // resize our output buffer if it's too small
        // (we could just use multiple chunks, but that would cause an extra
        // allocation each time to flatten the chunks)
        if (expected > this.chunkSize) {
            this.chunkSize = expected;
            this.strm.output = new Uint8Array(this.chunkSize);
        }

        this.strm.avail_out = this.chunkSize;

        Object(_vendor_pako_lib_zlib_inflate_js__WEBPACK_IMPORTED_MODULE_0__["inflate"])(this.strm, flush);

        return new Uint8Array(this.strm.output.buffer, 0, this.strm.next_out);
    }

    reset() {
        Object(_vendor_pako_lib_zlib_inflate_js__WEBPACK_IMPORTED_MODULE_0__["inflateReset"])(this.strm);
    }
}


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/input/domkeytable.js":
/*!*************************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/input/domkeytable.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _keysym_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keysym.js */ "./node_modules/@novnc/novnc/core/input/keysym.js");
/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2018 The noVNC Authors
 * Licensed under MPL 2.0 or any later version (see LICENSE.txt)
 */



/*
 * Mapping between HTML key values and VNC/X11 keysyms for "special"
 * keys that cannot be handled via their Unicode codepoint.
 *
 * See https://www.w3.org/TR/uievents-key/ for possible values.
 */

const DOMKeyTable = {};

function addStandard(key, standard) {
    if (standard === undefined) throw new Error("Undefined keysym for key \"" + key + "\"");
    if (key in DOMKeyTable) throw new Error("Duplicate entry for key \"" + key + "\"");
    DOMKeyTable[key] = [standard, standard, standard, standard];
}

function addLeftRight(key, left, right) {
    if (left === undefined) throw new Error("Undefined keysym for key \"" + key + "\"");
    if (right === undefined) throw new Error("Undefined keysym for key \"" + key + "\"");
    if (key in DOMKeyTable) throw new Error("Duplicate entry for key \"" + key + "\"");
    DOMKeyTable[key] = [left, left, right, left];
}

function addNumpad(key, standard, numpad) {
    if (standard === undefined) throw new Error("Undefined keysym for key \"" + key + "\"");
    if (numpad === undefined) throw new Error("Undefined keysym for key \"" + key + "\"");
    if (key in DOMKeyTable) throw new Error("Duplicate entry for key \"" + key + "\"");
    DOMKeyTable[key] = [standard, standard, standard, numpad];
}

// 2.2. Modifier Keys

addLeftRight("Alt", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Alt_L, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Alt_R);
addStandard("AltGraph", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_ISO_Level3_Shift);
addStandard("CapsLock", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Caps_Lock);
addLeftRight("Control", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Control_L, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Control_R);
// - Fn
// - FnLock
addLeftRight("Hyper", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Super_L, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Super_R);
addLeftRight("Meta", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Super_L, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Super_R);
addStandard("NumLock", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Num_Lock);
addStandard("ScrollLock", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Scroll_Lock);
addLeftRight("Shift", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Shift_L, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Shift_R);
addLeftRight("Super", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Super_L, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Super_R);
// - Symbol
// - SymbolLock

// 2.3. Whitespace Keys

addNumpad("Enter", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Return, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_Enter);
addStandard("Tab", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Tab);
addNumpad(" ", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_space, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_Space);

// 2.4. Navigation Keys

addNumpad("ArrowDown", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Down, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_Down);
addNumpad("ArrowUp", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Up, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_Up);
addNumpad("ArrowLeft", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Left, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_Left);
addNumpad("ArrowRight", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Right, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_Right);
addNumpad("End", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_End, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_End);
addNumpad("Home", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Home, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_Home);
addNumpad("PageDown", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Next, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_Next);
addNumpad("PageUp", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Prior, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_Prior);

// 2.5. Editing Keys

addStandard("Backspace", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_BackSpace);
addNumpad("Clear", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Clear, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_Begin);
addStandard("Copy", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Copy);
// - CrSel
addStandard("Cut", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Cut);
addNumpad("Delete", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Delete, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_Delete);
// - EraseEof
// - ExSel
addNumpad("Insert", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Insert, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_Insert);
addStandard("Paste", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Paste);
addStandard("Redo", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Redo);
addStandard("Undo", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Undo);

// 2.6. UI Keys

// - Accept
// - Again (could just be XK_Redo)
// - Attn
addStandard("Cancel", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Cancel);
addStandard("ContextMenu", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Menu);
addStandard("Escape", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Escape);
addStandard("Execute", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Execute);
addStandard("Find", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Find);
addStandard("Help", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Help);
addStandard("Pause", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Pause);
// - Play
// - Props
addStandard("Select", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Select);
addStandard("ZoomIn", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_ZoomIn);
addStandard("ZoomOut", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_ZoomOut);

// 2.7. Device Keys

addStandard("BrightnessDown", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_MonBrightnessDown);
addStandard("BrightnessUp", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_MonBrightnessUp);
addStandard("Eject", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Eject);
addStandard("LogOff", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_LogOff);
addStandard("Power", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_PowerOff);
addStandard("PowerOff", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_PowerDown);
addStandard("PrintScreen", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Print);
addStandard("Hibernate", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Hibernate);
addStandard("Standby", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Standby);
addStandard("WakeUp", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_WakeUp);

// 2.8. IME and Composition Keys

addStandard("AllCandidates", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_MultipleCandidate);
addStandard("Alphanumeric", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Eisu_Shift); // could also be _Eisu_Toggle
addStandard("CodeInput", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Codeinput);
addStandard("Compose", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Multi_key);
addStandard("Convert", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Henkan);
// - Dead
// - FinalMode
addStandard("GroupFirst", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_ISO_First_Group);
addStandard("GroupLast", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_ISO_Last_Group);
addStandard("GroupNext", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_ISO_Next_Group);
addStandard("GroupPrevious", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_ISO_Prev_Group);
// - ModeChange (XK_Mode_switch is often used for AltGr)
// - NextCandidate
addStandard("NonConvert", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Muhenkan);
addStandard("PreviousCandidate", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_PreviousCandidate);
// - Process
addStandard("SingleCandidate", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_SingleCandidate);
addStandard("HangulMode", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Hangul);
addStandard("HanjaMode", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Hangul_Hanja);
addStandard("JunjuaMode", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Hangul_Jeonja);
addStandard("Eisu", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Eisu_toggle);
addStandard("Hankaku", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Hankaku);
addStandard("Hiragana", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Hiragana);
addStandard("HiraganaKatakana", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Hiragana_Katakana);
addStandard("KanaMode", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Kana_Shift); // could also be _Kana_Lock
addStandard("KanjiMode", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Kanji);
addStandard("Katakana", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Katakana);
addStandard("Romaji", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Romaji);
addStandard("Zenkaku", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Zenkaku);
addStandard("ZenkakuHanaku", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Zenkaku_Hankaku);

// 2.9. General-Purpose Function Keys

addStandard("F1", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F1);
addStandard("F2", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F2);
addStandard("F3", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F3);
addStandard("F4", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F4);
addStandard("F5", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F5);
addStandard("F6", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F6);
addStandard("F7", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F7);
addStandard("F8", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F8);
addStandard("F9", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F9);
addStandard("F10", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F10);
addStandard("F11", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F11);
addStandard("F12", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F12);
addStandard("F13", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F13);
addStandard("F14", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F14);
addStandard("F15", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F15);
addStandard("F16", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F16);
addStandard("F17", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F17);
addStandard("F18", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F18);
addStandard("F19", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F19);
addStandard("F20", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F20);
addStandard("F21", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F21);
addStandard("F22", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F22);
addStandard("F23", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F23);
addStandard("F24", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F24);
addStandard("F25", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F25);
addStandard("F26", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F26);
addStandard("F27", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F27);
addStandard("F28", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F28);
addStandard("F29", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F29);
addStandard("F30", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F30);
addStandard("F31", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F31);
addStandard("F32", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F32);
addStandard("F33", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F33);
addStandard("F34", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F34);
addStandard("F35", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_F35);
// - Soft1...

// 2.10. Multimedia Keys

// - ChannelDown
// - ChannelUp
addStandard("Close", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Close);
addStandard("MailForward", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_MailForward);
addStandard("MailReply", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Reply);
addStandard("MainSend", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Send);
addStandard("MediaFastForward", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_AudioForward);
addStandard("MediaPause", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_AudioPause);
addStandard("MediaPlay", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_AudioPlay);
addStandard("MediaRecord", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_AudioRecord);
addStandard("MediaRewind", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_AudioRewind);
addStandard("MediaStop", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_AudioStop);
addStandard("MediaTrackNext", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_AudioNext);
addStandard("MediaTrackPrevious", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_AudioPrev);
addStandard("New", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_New);
addStandard("Open", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Open);
addStandard("Print", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_Print);
addStandard("Save", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Save);
addStandard("SpellCheck", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Spell);

// 2.11. Multimedia Numpad Keys

// - Key11
// - Key12

// 2.12. Audio Keys

// - AudioBalanceLeft
// - AudioBalanceRight
// - AudioBassDown
// - AudioBassBoostDown
// - AudioBassBoostToggle
// - AudioBassBoostUp
// - AudioBassUp
// - AudioFaderFront
// - AudioFaderRear
// - AudioSurroundModeNext
// - AudioTrebleDown
// - AudioTrebleUp
addStandard("AudioVolumeDown", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_AudioLowerVolume);
addStandard("AudioVolumeUp", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_AudioRaiseVolume);
addStandard("AudioVolumeMute", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_AudioMute);
// - MicrophoneToggle
// - MicrophoneVolumeDown
// - MicrophoneVolumeUp
addStandard("MicrophoneVolumeMute", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_AudioMicMute);

// 2.13. Speech Keys

// - SpeechCorrectionList
// - SpeechInputToggle

// 2.14. Application Keys

addStandard("LaunchCalculator", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Calculator);
addStandard("LaunchCalendar", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Calendar);
addStandard("LaunchMail", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Mail);
addStandard("LaunchMediaPlayer", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_AudioMedia);
addStandard("LaunchMusicPlayer", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Music);
addStandard("LaunchMyComputer", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_MyComputer);
addStandard("LaunchPhone", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Phone);
addStandard("LaunchScreenSaver", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_ScreenSaver);
addStandard("LaunchSpreadsheet", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Excel);
addStandard("LaunchWebBrowser", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_WWW);
addStandard("LaunchWebCam", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_WebCam);
addStandard("LaunchWordProcessor", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Word);

// 2.15. Browser Keys

addStandard("BrowserBack", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Back);
addStandard("BrowserFavorites", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Favorites);
addStandard("BrowserForward", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Forward);
addStandard("BrowserHome", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_HomePage);
addStandard("BrowserRefresh", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Refresh);
addStandard("BrowserSearch", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Search);
addStandard("BrowserStop", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Stop);

// 2.16. Mobile Phone Keys

// - A whole bunch...

// 2.17. TV Keys

// - A whole bunch...

// 2.18. Media Controller Keys

// - A whole bunch...
addStandard("Dimmer", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_BrightnessAdjust);
addStandard("MediaAudioTrack", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_AudioCycleTrack);
addStandard("RandomToggle", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_AudioRandomPlay);
addStandard("SplitScreenToggle", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_SplitScreen);
addStandard("Subtitle", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Subtitle);
addStandard("VideoModeNext", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XF86XK_Next_VMode);

// Extra: Numpad

addNumpad("=", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_equal, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_Equal);
addNumpad("+", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_plus, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_Add);
addNumpad("-", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_minus, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_Subtract);
addNumpad("*", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_asterisk, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_Multiply);
addNumpad("/", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_slash, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_Divide);
addNumpad(".", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_period, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_Decimal);
addNumpad(",", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_comma, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_Separator);
addNumpad("0", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_0, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_0);
addNumpad("1", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_1, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_1);
addNumpad("2", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_2, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_2);
addNumpad("3", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_3, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_3);
addNumpad("4", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_4, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_4);
addNumpad("5", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_5, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_5);
addNumpad("6", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_6, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_6);
addNumpad("7", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_7, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_7);
addNumpad("8", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_8, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_8);
addNumpad("9", _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_9, _keysym_js__WEBPACK_IMPORTED_MODULE_0__["default"].XK_KP_9);

/* harmony default export */ __webpack_exports__["default"] = (DOMKeyTable);


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/input/fixedkeys.js":
/*!***********************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/input/fixedkeys.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2018 The noVNC Authors
 * Licensed under MPL 2.0 or any later version (see LICENSE.txt)
 */

/*
 * Fallback mapping between HTML key codes (physical keys) and
 * HTML key values. This only works for keys that don't vary
 * between layouts. We also omit those who manage fine by mapping the
 * Unicode representation.
 *
 * See https://www.w3.org/TR/uievents-code/ for possible codes.
 * See https://www.w3.org/TR/uievents-key/ for possible values.
 */

/* eslint-disable key-spacing */

/* harmony default export */ __webpack_exports__["default"] = ({

// 3.1.1.1. Writing System Keys

    'Backspace':        'Backspace',

// 3.1.1.2. Functional Keys

    'AltLeft':          'Alt',
    'AltRight':         'Alt', // This could also be 'AltGraph'
    'CapsLock':         'CapsLock',
    'ContextMenu':      'ContextMenu',
    'ControlLeft':      'Control',
    'ControlRight':     'Control',
    'Enter':            'Enter',
    'MetaLeft':         'Meta',
    'MetaRight':        'Meta',
    'ShiftLeft':        'Shift',
    'ShiftRight':       'Shift',
    'Tab':              'Tab',
    // FIXME: Japanese/Korean keys

// 3.1.2. Control Pad Section

    'Delete':           'Delete',
    'End':              'End',
    'Help':             'Help',
    'Home':             'Home',
    'Insert':           'Insert',
    'PageDown':         'PageDown',
    'PageUp':           'PageUp',

// 3.1.3. Arrow Pad Section

    'ArrowDown':        'ArrowDown',
    'ArrowLeft':        'ArrowLeft',
    'ArrowRight':       'ArrowRight',
    'ArrowUp':          'ArrowUp',

// 3.1.4. Numpad Section

    'NumLock':          'NumLock',
    'NumpadBackspace':  'Backspace',
    'NumpadClear':      'Clear',

// 3.1.5. Function Section

    'Escape':           'Escape',
    'F1':               'F1',
    'F2':               'F2',
    'F3':               'F3',
    'F4':               'F4',
    'F5':               'F5',
    'F6':               'F6',
    'F7':               'F7',
    'F8':               'F8',
    'F9':               'F9',
    'F10':              'F10',
    'F11':              'F11',
    'F12':              'F12',
    'F13':              'F13',
    'F14':              'F14',
    'F15':              'F15',
    'F16':              'F16',
    'F17':              'F17',
    'F18':              'F18',
    'F19':              'F19',
    'F20':              'F20',
    'F21':              'F21',
    'F22':              'F22',
    'F23':              'F23',
    'F24':              'F24',
    'F25':              'F25',
    'F26':              'F26',
    'F27':              'F27',
    'F28':              'F28',
    'F29':              'F29',
    'F30':              'F30',
    'F31':              'F31',
    'F32':              'F32',
    'F33':              'F33',
    'F34':              'F34',
    'F35':              'F35',
    'PrintScreen':      'PrintScreen',
    'ScrollLock':       'ScrollLock',
    'Pause':            'Pause',

// 3.1.6. Media Keys

    'BrowserBack':      'BrowserBack',
    'BrowserFavorites': 'BrowserFavorites',
    'BrowserForward':   'BrowserForward',
    'BrowserHome':      'BrowserHome',
    'BrowserRefresh':   'BrowserRefresh',
    'BrowserSearch':    'BrowserSearch',
    'BrowserStop':      'BrowserStop',
    'Eject':            'Eject',
    'LaunchApp1':       'LaunchMyComputer',
    'LaunchApp2':       'LaunchCalendar',
    'LaunchMail':       'LaunchMail',
    'MediaPlayPause':   'MediaPlay',
    'MediaStop':        'MediaStop',
    'MediaTrackNext':   'MediaTrackNext',
    'MediaTrackPrevious': 'MediaTrackPrevious',
    'Power':            'Power',
    'Sleep':            'Sleep',
    'AudioVolumeDown':  'AudioVolumeDown',
    'AudioVolumeMute':  'AudioVolumeMute',
    'AudioVolumeUp':    'AudioVolumeUp',
    'WakeUp':           'WakeUp',
});


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/input/keyboard.js":
/*!**********************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/input/keyboard.js ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Keyboard; });
/* harmony import */ var _util_logging_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logging.js */ "./node_modules/@novnc/novnc/core/util/logging.js");
/* harmony import */ var _util_events_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/events.js */ "./node_modules/@novnc/novnc/core/util/events.js");
/* harmony import */ var _util_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util.js */ "./node_modules/@novnc/novnc/core/input/util.js");
/* harmony import */ var _keysym_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./keysym.js */ "./node_modules/@novnc/novnc/core/input/keysym.js");
/* harmony import */ var _util_browser_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/browser.js */ "./node_modules/@novnc/novnc/core/util/browser.js");
/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2018 The noVNC Authors
 * Licensed under MPL 2.0 or any later version (see LICENSE.txt)
 */







//
// Keyboard event handler
//

class Keyboard {
    constructor(target) {
        this._target = target || null;

        this._keyDownList = {};         // List of depressed keys
                                        // (even if they are happy)
        this._pendingKey = null;        // Key waiting for keypress
        this._altGrArmed = false;       // Windows AltGr detection

        // keep these here so we can refer to them later
        this._eventHandlers = {
            'keyup': this._handleKeyUp.bind(this),
            'keydown': this._handleKeyDown.bind(this),
            'keypress': this._handleKeyPress.bind(this),
            'blur': this._allKeysUp.bind(this),
            'checkalt': this._checkAlt.bind(this),
        };

        // ===== EVENT HANDLERS =====

        this.onkeyevent = () => {}; // Handler for key press/release
    }

    // ===== PRIVATE METHODS =====

    _sendKeyEvent(keysym, code, down) {
        if (down) {
            this._keyDownList[code] = keysym;
        } else {
            // Do we really think this key is down?
            if (!(code in this._keyDownList)) {
                return;
            }
            delete this._keyDownList[code];
        }

        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("onkeyevent " + (down ? "down" : "up") +
                  ", keysym: " + keysym, ", code: " + code);
        this.onkeyevent(keysym, code, down);
    }

    _getKeyCode(e) {
        const code = _util_js__WEBPACK_IMPORTED_MODULE_2__["getKeycode"](e);
        if (code !== 'Unidentified') {
            return code;
        }

        // Unstable, but we don't have anything else to go on
        // (don't use it for 'keypress' events thought since
        // WebKit sets it to the same as charCode)
        if (e.keyCode && (e.type !== 'keypress')) {
            // 229 is used for composition events
            if (e.keyCode !== 229) {
                return 'Platform' + e.keyCode;
            }
        }

        // A precursor to the final DOM3 standard. Unfortunately it
        // is not layout independent, so it is as bad as using keyCode
        if (e.keyIdentifier) {
            // Non-character key?
            if (e.keyIdentifier.substr(0, 2) !== 'U+') {
                return e.keyIdentifier;
            }

            const codepoint = parseInt(e.keyIdentifier.substr(2), 16);
            const char = String.fromCharCode(codepoint).toUpperCase();

            return 'Platform' + char.charCodeAt();
        }

        return 'Unidentified';
    }

    _handleKeyDown(e) {
        const code = this._getKeyCode(e);
        let keysym = _util_js__WEBPACK_IMPORTED_MODULE_2__["getKeysym"](e);

        // Windows doesn't have a proper AltGr, but handles it using
        // fake Ctrl+Alt. However the remote end might not be Windows,
        // so we need to merge those in to a single AltGr event. We
        // detect this case by seeing the two key events directly after
        // each other with a very short time between them (<50ms).
        if (this._altGrArmed) {
            this._altGrArmed = false;
            clearTimeout(this._altGrTimeout);

            if ((code === "AltRight") &&
                ((e.timeStamp - this._altGrCtrlTime) < 50)) {
                // FIXME: We fail to detect this if either Ctrl key is
                //        first manually pressed as Windows then no
                //        longer sends the fake Ctrl down event. It
                //        does however happily send real Ctrl events
                //        even when AltGr is already down. Some
                //        browsers detect this for us though and set the
                //        key to "AltGraph".
                keysym = _keysym_js__WEBPACK_IMPORTED_MODULE_3__["default"].XK_ISO_Level3_Shift;
            } else {
                this._sendKeyEvent(_keysym_js__WEBPACK_IMPORTED_MODULE_3__["default"].XK_Control_L, "ControlLeft", true);
            }
        }

        // We cannot handle keys we cannot track, but we also need
        // to deal with virtual keyboards which omit key info
        // (iOS omits tracking info on keyup events, which forces us to
        // special treat that platform here)
        if ((code === 'Unidentified') || _util_browser_js__WEBPACK_IMPORTED_MODULE_4__["isIOS"]()) {
            if (keysym) {
                // If it's a virtual keyboard then it should be
                // sufficient to just send press and release right
                // after each other
                this._sendKeyEvent(keysym, code, true);
                this._sendKeyEvent(keysym, code, false);
            }

            Object(_util_events_js__WEBPACK_IMPORTED_MODULE_1__["stopEvent"])(e);
            return;
        }

        // Alt behaves more like AltGraph on macOS, so shuffle the
        // keys around a bit to make things more sane for the remote
        // server. This method is used by RealVNC and TigerVNC (and
        // possibly others).
        if (_util_browser_js__WEBPACK_IMPORTED_MODULE_4__["isMac"]()) {
            switch (keysym) {
                case _keysym_js__WEBPACK_IMPORTED_MODULE_3__["default"].XK_Super_L:
                    keysym = _keysym_js__WEBPACK_IMPORTED_MODULE_3__["default"].XK_Alt_L;
                    break;
                case _keysym_js__WEBPACK_IMPORTED_MODULE_3__["default"].XK_Super_R:
                    keysym = _keysym_js__WEBPACK_IMPORTED_MODULE_3__["default"].XK_Super_L;
                    break;
                case _keysym_js__WEBPACK_IMPORTED_MODULE_3__["default"].XK_Alt_L:
                    keysym = _keysym_js__WEBPACK_IMPORTED_MODULE_3__["default"].XK_Mode_switch;
                    break;
                case _keysym_js__WEBPACK_IMPORTED_MODULE_3__["default"].XK_Alt_R:
                    keysym = _keysym_js__WEBPACK_IMPORTED_MODULE_3__["default"].XK_ISO_Level3_Shift;
                    break;
            }
        }

        // Is this key already pressed? If so, then we must use the
        // same keysym or we'll confuse the server
        if (code in this._keyDownList) {
            keysym = this._keyDownList[code];
        }

        // macOS doesn't send proper key events for modifiers, only
        // state change events. That gets extra confusing for CapsLock
        // which toggles on each press, but not on release. So pretend
        // it was a quick press and release of the button.
        if (_util_browser_js__WEBPACK_IMPORTED_MODULE_4__["isMac"]() && (code === 'CapsLock')) {
            this._sendKeyEvent(_keysym_js__WEBPACK_IMPORTED_MODULE_3__["default"].XK_Caps_Lock, 'CapsLock', true);
            this._sendKeyEvent(_keysym_js__WEBPACK_IMPORTED_MODULE_3__["default"].XK_Caps_Lock, 'CapsLock', false);
            Object(_util_events_js__WEBPACK_IMPORTED_MODULE_1__["stopEvent"])(e);
            return;
        }

        // If this is a legacy browser then we'll need to wait for
        // a keypress event as well
        // (IE and Edge has a broken KeyboardEvent.key, so we can't
        // just check for the presence of that field)
        if (!keysym && (!e.key || _util_browser_js__WEBPACK_IMPORTED_MODULE_4__["isIE"]() || _util_browser_js__WEBPACK_IMPORTED_MODULE_4__["isEdge"]())) {
            this._pendingKey = code;
            // However we might not get a keypress event if the key
            // is non-printable, which needs some special fallback
            // handling
            setTimeout(this._handleKeyPressTimeout.bind(this), 10, e);
            return;
        }

        this._pendingKey = null;
        Object(_util_events_js__WEBPACK_IMPORTED_MODULE_1__["stopEvent"])(e);

        // Possible start of AltGr sequence? (see above)
        if ((code === "ControlLeft") && _util_browser_js__WEBPACK_IMPORTED_MODULE_4__["isWindows"]() &&
            !("ControlLeft" in this._keyDownList)) {
            this._altGrArmed = true;
            this._altGrTimeout = setTimeout(this._handleAltGrTimeout.bind(this), 100);
            this._altGrCtrlTime = e.timeStamp;
            return;
        }

        this._sendKeyEvent(keysym, code, true);
    }

    // Legacy event for browsers without code/key
    _handleKeyPress(e) {
        Object(_util_events_js__WEBPACK_IMPORTED_MODULE_1__["stopEvent"])(e);

        // Are we expecting a keypress?
        if (this._pendingKey === null) {
            return;
        }

        let code = this._getKeyCode(e);
        const keysym = _util_js__WEBPACK_IMPORTED_MODULE_2__["getKeysym"](e);

        // The key we were waiting for?
        if ((code !== 'Unidentified') && (code != this._pendingKey)) {
            return;
        }

        code = this._pendingKey;
        this._pendingKey = null;

        if (!keysym) {
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Info"]('keypress with no keysym:', e);
            return;
        }

        this._sendKeyEvent(keysym, code, true);
    }

    _handleKeyPressTimeout(e) {
        // Did someone manage to sort out the key already?
        if (this._pendingKey === null) {
            return;
        }

        let keysym;

        const code = this._pendingKey;
        this._pendingKey = null;

        // We have no way of knowing the proper keysym with the
        // information given, but the following are true for most
        // layouts
        if ((e.keyCode >= 0x30) && (e.keyCode <= 0x39)) {
            // Digit
            keysym = e.keyCode;
        } else if ((e.keyCode >= 0x41) && (e.keyCode <= 0x5a)) {
            // Character (A-Z)
            let char = String.fromCharCode(e.keyCode);
            // A feeble attempt at the correct case
            if (e.shiftKey) {
                char = char.toUpperCase();
            } else {
                char = char.toLowerCase();
            }
            keysym = char.charCodeAt();
        } else {
            // Unknown, give up
            keysym = 0;
        }

        this._sendKeyEvent(keysym, code, true);
    }

    _handleKeyUp(e) {
        Object(_util_events_js__WEBPACK_IMPORTED_MODULE_1__["stopEvent"])(e);

        const code = this._getKeyCode(e);

        // We can't get a release in the middle of an AltGr sequence, so
        // abort that detection
        if (this._altGrArmed) {
            this._altGrArmed = false;
            clearTimeout(this._altGrTimeout);
            this._sendKeyEvent(_keysym_js__WEBPACK_IMPORTED_MODULE_3__["default"].XK_Control_L, "ControlLeft", true);
        }

        // See comment in _handleKeyDown()
        if (_util_browser_js__WEBPACK_IMPORTED_MODULE_4__["isMac"]() && (code === 'CapsLock')) {
            this._sendKeyEvent(_keysym_js__WEBPACK_IMPORTED_MODULE_3__["default"].XK_Caps_Lock, 'CapsLock', true);
            this._sendKeyEvent(_keysym_js__WEBPACK_IMPORTED_MODULE_3__["default"].XK_Caps_Lock, 'CapsLock', false);
            return;
        }

        this._sendKeyEvent(this._keyDownList[code], code, false);
    }

    _handleAltGrTimeout() {
        this._altGrArmed = false;
        clearTimeout(this._altGrTimeout);
        this._sendKeyEvent(_keysym_js__WEBPACK_IMPORTED_MODULE_3__["default"].XK_Control_L, "ControlLeft", true);
    }

    _allKeysUp() {
        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"](">> Keyboard.allKeysUp");
        for (let code in this._keyDownList) {
            this._sendKeyEvent(this._keyDownList[code], code, false);
        }
        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("<< Keyboard.allKeysUp");
    }

    // Firefox Alt workaround, see below
    _checkAlt(e) {
        if (e.altKey) {
            return;
        }

        const target = this._target;
        const downList = this._keyDownList;
        ['AltLeft', 'AltRight'].forEach((code) => {
            if (!(code in downList)) {
                return;
            }

            const event = new KeyboardEvent('keyup',
                                            { key: downList[code],
                                              code: code });
            target.dispatchEvent(event);
        });
    }

    // ===== PUBLIC METHODS =====

    grab() {
        //Log.Debug(">> Keyboard.grab");

        this._target.addEventListener('keydown', this._eventHandlers.keydown);
        this._target.addEventListener('keyup', this._eventHandlers.keyup);
        this._target.addEventListener('keypress', this._eventHandlers.keypress);

        // Release (key up) if window loses focus
        window.addEventListener('blur', this._eventHandlers.blur);

        // Firefox has broken handling of Alt, so we need to poll as
        // best we can for releases (still doesn't prevent the menu
        // from popping up though as we can't call preventDefault())
        if (_util_browser_js__WEBPACK_IMPORTED_MODULE_4__["isWindows"]() && _util_browser_js__WEBPACK_IMPORTED_MODULE_4__["isFirefox"]()) {
            const handler = this._eventHandlers.checkalt;
            ['mousedown', 'mouseup', 'mousemove', 'wheel',
             'touchstart', 'touchend', 'touchmove',
             'keydown', 'keyup'].forEach(type =>
                document.addEventListener(type, handler,
                                          { capture: true,
                                            passive: true }));
        }

        //Log.Debug("<< Keyboard.grab");
    }

    ungrab() {
        //Log.Debug(">> Keyboard.ungrab");

        if (_util_browser_js__WEBPACK_IMPORTED_MODULE_4__["isWindows"]() && _util_browser_js__WEBPACK_IMPORTED_MODULE_4__["isFirefox"]()) {
            const handler = this._eventHandlers.checkalt;
            ['mousedown', 'mouseup', 'mousemove', 'wheel',
             'touchstart', 'touchend', 'touchmove',
             'keydown', 'keyup'].forEach(type => document.removeEventListener(type, handler));
        }

        this._target.removeEventListener('keydown', this._eventHandlers.keydown);
        this._target.removeEventListener('keyup', this._eventHandlers.keyup);
        this._target.removeEventListener('keypress', this._eventHandlers.keypress);
        window.removeEventListener('blur', this._eventHandlers.blur);

        // Release (key up) all keys that are in a down state
        this._allKeysUp();

        //Log.Debug(">> Keyboard.ungrab");
    }
}


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/input/keysym.js":
/*!********************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/input/keysym.js ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* eslint-disable key-spacing */

/* harmony default export */ __webpack_exports__["default"] = ({
    XK_VoidSymbol:                  0xffffff, /* Void symbol */

    XK_BackSpace:                   0xff08, /* Back space, back char */
    XK_Tab:                         0xff09,
    XK_Linefeed:                    0xff0a, /* Linefeed, LF */
    XK_Clear:                       0xff0b,
    XK_Return:                      0xff0d, /* Return, enter */
    XK_Pause:                       0xff13, /* Pause, hold */
    XK_Scroll_Lock:                 0xff14,
    XK_Sys_Req:                     0xff15,
    XK_Escape:                      0xff1b,
    XK_Delete:                      0xffff, /* Delete, rubout */

    /* International & multi-key character composition */

    XK_Multi_key:                   0xff20, /* Multi-key character compose */
    XK_Codeinput:                   0xff37,
    XK_SingleCandidate:             0xff3c,
    XK_MultipleCandidate:           0xff3d,
    XK_PreviousCandidate:           0xff3e,

    /* Japanese keyboard support */

    XK_Kanji:                       0xff21, /* Kanji, Kanji convert */
    XK_Muhenkan:                    0xff22, /* Cancel Conversion */
    XK_Henkan_Mode:                 0xff23, /* Start/Stop Conversion */
    XK_Henkan:                      0xff23, /* Alias for Henkan_Mode */
    XK_Romaji:                      0xff24, /* to Romaji */
    XK_Hiragana:                    0xff25, /* to Hiragana */
    XK_Katakana:                    0xff26, /* to Katakana */
    XK_Hiragana_Katakana:           0xff27, /* Hiragana/Katakana toggle */
    XK_Zenkaku:                     0xff28, /* to Zenkaku */
    XK_Hankaku:                     0xff29, /* to Hankaku */
    XK_Zenkaku_Hankaku:             0xff2a, /* Zenkaku/Hankaku toggle */
    XK_Touroku:                     0xff2b, /* Add to Dictionary */
    XK_Massyo:                      0xff2c, /* Delete from Dictionary */
    XK_Kana_Lock:                   0xff2d, /* Kana Lock */
    XK_Kana_Shift:                  0xff2e, /* Kana Shift */
    XK_Eisu_Shift:                  0xff2f, /* Alphanumeric Shift */
    XK_Eisu_toggle:                 0xff30, /* Alphanumeric toggle */
    XK_Kanji_Bangou:                0xff37, /* Codeinput */
    XK_Zen_Koho:                    0xff3d, /* Multiple/All Candidate(s) */
    XK_Mae_Koho:                    0xff3e, /* Previous Candidate */

    /* Cursor control & motion */

    XK_Home:                        0xff50,
    XK_Left:                        0xff51, /* Move left, left arrow */
    XK_Up:                          0xff52, /* Move up, up arrow */
    XK_Right:                       0xff53, /* Move right, right arrow */
    XK_Down:                        0xff54, /* Move down, down arrow */
    XK_Prior:                       0xff55, /* Prior, previous */
    XK_Page_Up:                     0xff55,
    XK_Next:                        0xff56, /* Next */
    XK_Page_Down:                   0xff56,
    XK_End:                         0xff57, /* EOL */
    XK_Begin:                       0xff58, /* BOL */


    /* Misc functions */

    XK_Select:                      0xff60, /* Select, mark */
    XK_Print:                       0xff61,
    XK_Execute:                     0xff62, /* Execute, run, do */
    XK_Insert:                      0xff63, /* Insert, insert here */
    XK_Undo:                        0xff65,
    XK_Redo:                        0xff66, /* Redo, again */
    XK_Menu:                        0xff67,
    XK_Find:                        0xff68, /* Find, search */
    XK_Cancel:                      0xff69, /* Cancel, stop, abort, exit */
    XK_Help:                        0xff6a, /* Help */
    XK_Break:                       0xff6b,
    XK_Mode_switch:                 0xff7e, /* Character set switch */
    XK_script_switch:               0xff7e, /* Alias for mode_switch */
    XK_Num_Lock:                    0xff7f,

    /* Keypad functions, keypad numbers cleverly chosen to map to ASCII */

    XK_KP_Space:                    0xff80, /* Space */
    XK_KP_Tab:                      0xff89,
    XK_KP_Enter:                    0xff8d, /* Enter */
    XK_KP_F1:                       0xff91, /* PF1, KP_A, ... */
    XK_KP_F2:                       0xff92,
    XK_KP_F3:                       0xff93,
    XK_KP_F4:                       0xff94,
    XK_KP_Home:                     0xff95,
    XK_KP_Left:                     0xff96,
    XK_KP_Up:                       0xff97,
    XK_KP_Right:                    0xff98,
    XK_KP_Down:                     0xff99,
    XK_KP_Prior:                    0xff9a,
    XK_KP_Page_Up:                  0xff9a,
    XK_KP_Next:                     0xff9b,
    XK_KP_Page_Down:                0xff9b,
    XK_KP_End:                      0xff9c,
    XK_KP_Begin:                    0xff9d,
    XK_KP_Insert:                   0xff9e,
    XK_KP_Delete:                   0xff9f,
    XK_KP_Equal:                    0xffbd, /* Equals */
    XK_KP_Multiply:                 0xffaa,
    XK_KP_Add:                      0xffab,
    XK_KP_Separator:                0xffac, /* Separator, often comma */
    XK_KP_Subtract:                 0xffad,
    XK_KP_Decimal:                  0xffae,
    XK_KP_Divide:                   0xffaf,

    XK_KP_0:                        0xffb0,
    XK_KP_1:                        0xffb1,
    XK_KP_2:                        0xffb2,
    XK_KP_3:                        0xffb3,
    XK_KP_4:                        0xffb4,
    XK_KP_5:                        0xffb5,
    XK_KP_6:                        0xffb6,
    XK_KP_7:                        0xffb7,
    XK_KP_8:                        0xffb8,
    XK_KP_9:                        0xffb9,

    /*
     * Auxiliary functions; note the duplicate definitions for left and right
     * function keys;  Sun keyboards and a few other manufacturers have such
     * function key groups on the left and/or right sides of the keyboard.
     * We've not found a keyboard with more than 35 function keys total.
     */

    XK_F1:                          0xffbe,
    XK_F2:                          0xffbf,
    XK_F3:                          0xffc0,
    XK_F4:                          0xffc1,
    XK_F5:                          0xffc2,
    XK_F6:                          0xffc3,
    XK_F7:                          0xffc4,
    XK_F8:                          0xffc5,
    XK_F9:                          0xffc6,
    XK_F10:                         0xffc7,
    XK_F11:                         0xffc8,
    XK_L1:                          0xffc8,
    XK_F12:                         0xffc9,
    XK_L2:                          0xffc9,
    XK_F13:                         0xffca,
    XK_L3:                          0xffca,
    XK_F14:                         0xffcb,
    XK_L4:                          0xffcb,
    XK_F15:                         0xffcc,
    XK_L5:                          0xffcc,
    XK_F16:                         0xffcd,
    XK_L6:                          0xffcd,
    XK_F17:                         0xffce,
    XK_L7:                          0xffce,
    XK_F18:                         0xffcf,
    XK_L8:                          0xffcf,
    XK_F19:                         0xffd0,
    XK_L9:                          0xffd0,
    XK_F20:                         0xffd1,
    XK_L10:                         0xffd1,
    XK_F21:                         0xffd2,
    XK_R1:                          0xffd2,
    XK_F22:                         0xffd3,
    XK_R2:                          0xffd3,
    XK_F23:                         0xffd4,
    XK_R3:                          0xffd4,
    XK_F24:                         0xffd5,
    XK_R4:                          0xffd5,
    XK_F25:                         0xffd6,
    XK_R5:                          0xffd6,
    XK_F26:                         0xffd7,
    XK_R6:                          0xffd7,
    XK_F27:                         0xffd8,
    XK_R7:                          0xffd8,
    XK_F28:                         0xffd9,
    XK_R8:                          0xffd9,
    XK_F29:                         0xffda,
    XK_R9:                          0xffda,
    XK_F30:                         0xffdb,
    XK_R10:                         0xffdb,
    XK_F31:                         0xffdc,
    XK_R11:                         0xffdc,
    XK_F32:                         0xffdd,
    XK_R12:                         0xffdd,
    XK_F33:                         0xffde,
    XK_R13:                         0xffde,
    XK_F34:                         0xffdf,
    XK_R14:                         0xffdf,
    XK_F35:                         0xffe0,
    XK_R15:                         0xffe0,

    /* Modifiers */

    XK_Shift_L:                     0xffe1, /* Left shift */
    XK_Shift_R:                     0xffe2, /* Right shift */
    XK_Control_L:                   0xffe3, /* Left control */
    XK_Control_R:                   0xffe4, /* Right control */
    XK_Caps_Lock:                   0xffe5, /* Caps lock */
    XK_Shift_Lock:                  0xffe6, /* Shift lock */

    XK_Meta_L:                      0xffe7, /* Left meta */
    XK_Meta_R:                      0xffe8, /* Right meta */
    XK_Alt_L:                       0xffe9, /* Left alt */
    XK_Alt_R:                       0xffea, /* Right alt */
    XK_Super_L:                     0xffeb, /* Left super */
    XK_Super_R:                     0xffec, /* Right super */
    XK_Hyper_L:                     0xffed, /* Left hyper */
    XK_Hyper_R:                     0xffee, /* Right hyper */

    /*
     * Keyboard (XKB) Extension function and modifier keys
     * (from Appendix C of "The X Keyboard Extension: Protocol Specification")
     * Byte 3 = 0xfe
     */

    XK_ISO_Level3_Shift:            0xfe03, /* AltGr */
    XK_ISO_Next_Group:              0xfe08,
    XK_ISO_Prev_Group:              0xfe0a,
    XK_ISO_First_Group:             0xfe0c,
    XK_ISO_Last_Group:              0xfe0e,

    /*
     * Latin 1
     * (ISO/IEC 8859-1: Unicode U+0020..U+00FF)
     * Byte 3: 0
     */

    XK_space:                       0x0020, /* U+0020 SPACE */
    XK_exclam:                      0x0021, /* U+0021 EXCLAMATION MARK */
    XK_quotedbl:                    0x0022, /* U+0022 QUOTATION MARK */
    XK_numbersign:                  0x0023, /* U+0023 NUMBER SIGN */
    XK_dollar:                      0x0024, /* U+0024 DOLLAR SIGN */
    XK_percent:                     0x0025, /* U+0025 PERCENT SIGN */
    XK_ampersand:                   0x0026, /* U+0026 AMPERSAND */
    XK_apostrophe:                  0x0027, /* U+0027 APOSTROPHE */
    XK_quoteright:                  0x0027, /* deprecated */
    XK_parenleft:                   0x0028, /* U+0028 LEFT PARENTHESIS */
    XK_parenright:                  0x0029, /* U+0029 RIGHT PARENTHESIS */
    XK_asterisk:                    0x002a, /* U+002A ASTERISK */
    XK_plus:                        0x002b, /* U+002B PLUS SIGN */
    XK_comma:                       0x002c, /* U+002C COMMA */
    XK_minus:                       0x002d, /* U+002D HYPHEN-MINUS */
    XK_period:                      0x002e, /* U+002E FULL STOP */
    XK_slash:                       0x002f, /* U+002F SOLIDUS */
    XK_0:                           0x0030, /* U+0030 DIGIT ZERO */
    XK_1:                           0x0031, /* U+0031 DIGIT ONE */
    XK_2:                           0x0032, /* U+0032 DIGIT TWO */
    XK_3:                           0x0033, /* U+0033 DIGIT THREE */
    XK_4:                           0x0034, /* U+0034 DIGIT FOUR */
    XK_5:                           0x0035, /* U+0035 DIGIT FIVE */
    XK_6:                           0x0036, /* U+0036 DIGIT SIX */
    XK_7:                           0x0037, /* U+0037 DIGIT SEVEN */
    XK_8:                           0x0038, /* U+0038 DIGIT EIGHT */
    XK_9:                           0x0039, /* U+0039 DIGIT NINE */
    XK_colon:                       0x003a, /* U+003A COLON */
    XK_semicolon:                   0x003b, /* U+003B SEMICOLON */
    XK_less:                        0x003c, /* U+003C LESS-THAN SIGN */
    XK_equal:                       0x003d, /* U+003D EQUALS SIGN */
    XK_greater:                     0x003e, /* U+003E GREATER-THAN SIGN */
    XK_question:                    0x003f, /* U+003F QUESTION MARK */
    XK_at:                          0x0040, /* U+0040 COMMERCIAL AT */
    XK_A:                           0x0041, /* U+0041 LATIN CAPITAL LETTER A */
    XK_B:                           0x0042, /* U+0042 LATIN CAPITAL LETTER B */
    XK_C:                           0x0043, /* U+0043 LATIN CAPITAL LETTER C */
    XK_D:                           0x0044, /* U+0044 LATIN CAPITAL LETTER D */
    XK_E:                           0x0045, /* U+0045 LATIN CAPITAL LETTER E */
    XK_F:                           0x0046, /* U+0046 LATIN CAPITAL LETTER F */
    XK_G:                           0x0047, /* U+0047 LATIN CAPITAL LETTER G */
    XK_H:                           0x0048, /* U+0048 LATIN CAPITAL LETTER H */
    XK_I:                           0x0049, /* U+0049 LATIN CAPITAL LETTER I */
    XK_J:                           0x004a, /* U+004A LATIN CAPITAL LETTER J */
    XK_K:                           0x004b, /* U+004B LATIN CAPITAL LETTER K */
    XK_L:                           0x004c, /* U+004C LATIN CAPITAL LETTER L */
    XK_M:                           0x004d, /* U+004D LATIN CAPITAL LETTER M */
    XK_N:                           0x004e, /* U+004E LATIN CAPITAL LETTER N */
    XK_O:                           0x004f, /* U+004F LATIN CAPITAL LETTER O */
    XK_P:                           0x0050, /* U+0050 LATIN CAPITAL LETTER P */
    XK_Q:                           0x0051, /* U+0051 LATIN CAPITAL LETTER Q */
    XK_R:                           0x0052, /* U+0052 LATIN CAPITAL LETTER R */
    XK_S:                           0x0053, /* U+0053 LATIN CAPITAL LETTER S */
    XK_T:                           0x0054, /* U+0054 LATIN CAPITAL LETTER T */
    XK_U:                           0x0055, /* U+0055 LATIN CAPITAL LETTER U */
    XK_V:                           0x0056, /* U+0056 LATIN CAPITAL LETTER V */
    XK_W:                           0x0057, /* U+0057 LATIN CAPITAL LETTER W */
    XK_X:                           0x0058, /* U+0058 LATIN CAPITAL LETTER X */
    XK_Y:                           0x0059, /* U+0059 LATIN CAPITAL LETTER Y */
    XK_Z:                           0x005a, /* U+005A LATIN CAPITAL LETTER Z */
    XK_bracketleft:                 0x005b, /* U+005B LEFT SQUARE BRACKET */
    XK_backslash:                   0x005c, /* U+005C REVERSE SOLIDUS */
    XK_bracketright:                0x005d, /* U+005D RIGHT SQUARE BRACKET */
    XK_asciicircum:                 0x005e, /* U+005E CIRCUMFLEX ACCENT */
    XK_underscore:                  0x005f, /* U+005F LOW LINE */
    XK_grave:                       0x0060, /* U+0060 GRAVE ACCENT */
    XK_quoteleft:                   0x0060, /* deprecated */
    XK_a:                           0x0061, /* U+0061 LATIN SMALL LETTER A */
    XK_b:                           0x0062, /* U+0062 LATIN SMALL LETTER B */
    XK_c:                           0x0063, /* U+0063 LATIN SMALL LETTER C */
    XK_d:                           0x0064, /* U+0064 LATIN SMALL LETTER D */
    XK_e:                           0x0065, /* U+0065 LATIN SMALL LETTER E */
    XK_f:                           0x0066, /* U+0066 LATIN SMALL LETTER F */
    XK_g:                           0x0067, /* U+0067 LATIN SMALL LETTER G */
    XK_h:                           0x0068, /* U+0068 LATIN SMALL LETTER H */
    XK_i:                           0x0069, /* U+0069 LATIN SMALL LETTER I */
    XK_j:                           0x006a, /* U+006A LATIN SMALL LETTER J */
    XK_k:                           0x006b, /* U+006B LATIN SMALL LETTER K */
    XK_l:                           0x006c, /* U+006C LATIN SMALL LETTER L */
    XK_m:                           0x006d, /* U+006D LATIN SMALL LETTER M */
    XK_n:                           0x006e, /* U+006E LATIN SMALL LETTER N */
    XK_o:                           0x006f, /* U+006F LATIN SMALL LETTER O */
    XK_p:                           0x0070, /* U+0070 LATIN SMALL LETTER P */
    XK_q:                           0x0071, /* U+0071 LATIN SMALL LETTER Q */
    XK_r:                           0x0072, /* U+0072 LATIN SMALL LETTER R */
    XK_s:                           0x0073, /* U+0073 LATIN SMALL LETTER S */
    XK_t:                           0x0074, /* U+0074 LATIN SMALL LETTER T */
    XK_u:                           0x0075, /* U+0075 LATIN SMALL LETTER U */
    XK_v:                           0x0076, /* U+0076 LATIN SMALL LETTER V */
    XK_w:                           0x0077, /* U+0077 LATIN SMALL LETTER W */
    XK_x:                           0x0078, /* U+0078 LATIN SMALL LETTER X */
    XK_y:                           0x0079, /* U+0079 LATIN SMALL LETTER Y */
    XK_z:                           0x007a, /* U+007A LATIN SMALL LETTER Z */
    XK_braceleft:                   0x007b, /* U+007B LEFT CURLY BRACKET */
    XK_bar:                         0x007c, /* U+007C VERTICAL LINE */
    XK_braceright:                  0x007d, /* U+007D RIGHT CURLY BRACKET */
    XK_asciitilde:                  0x007e, /* U+007E TILDE */

    XK_nobreakspace:                0x00a0, /* U+00A0 NO-BREAK SPACE */
    XK_exclamdown:                  0x00a1, /* U+00A1 INVERTED EXCLAMATION MARK */
    XK_cent:                        0x00a2, /* U+00A2 CENT SIGN */
    XK_sterling:                    0x00a3, /* U+00A3 POUND SIGN */
    XK_currency:                    0x00a4, /* U+00A4 CURRENCY SIGN */
    XK_yen:                         0x00a5, /* U+00A5 YEN SIGN */
    XK_brokenbar:                   0x00a6, /* U+00A6 BROKEN BAR */
    XK_section:                     0x00a7, /* U+00A7 SECTION SIGN */
    XK_diaeresis:                   0x00a8, /* U+00A8 DIAERESIS */
    XK_copyright:                   0x00a9, /* U+00A9 COPYRIGHT SIGN */
    XK_ordfeminine:                 0x00aa, /* U+00AA FEMININE ORDINAL INDICATOR */
    XK_guillemotleft:               0x00ab, /* U+00AB LEFT-POINTING DOUBLE ANGLE QUOTATION MARK */
    XK_notsign:                     0x00ac, /* U+00AC NOT SIGN */
    XK_hyphen:                      0x00ad, /* U+00AD SOFT HYPHEN */
    XK_registered:                  0x00ae, /* U+00AE REGISTERED SIGN */
    XK_macron:                      0x00af, /* U+00AF MACRON */
    XK_degree:                      0x00b0, /* U+00B0 DEGREE SIGN */
    XK_plusminus:                   0x00b1, /* U+00B1 PLUS-MINUS SIGN */
    XK_twosuperior:                 0x00b2, /* U+00B2 SUPERSCRIPT TWO */
    XK_threesuperior:               0x00b3, /* U+00B3 SUPERSCRIPT THREE */
    XK_acute:                       0x00b4, /* U+00B4 ACUTE ACCENT */
    XK_mu:                          0x00b5, /* U+00B5 MICRO SIGN */
    XK_paragraph:                   0x00b6, /* U+00B6 PILCROW SIGN */
    XK_periodcentered:              0x00b7, /* U+00B7 MIDDLE DOT */
    XK_cedilla:                     0x00b8, /* U+00B8 CEDILLA */
    XK_onesuperior:                 0x00b9, /* U+00B9 SUPERSCRIPT ONE */
    XK_masculine:                   0x00ba, /* U+00BA MASCULINE ORDINAL INDICATOR */
    XK_guillemotright:              0x00bb, /* U+00BB RIGHT-POINTING DOUBLE ANGLE QUOTATION MARK */
    XK_onequarter:                  0x00bc, /* U+00BC VULGAR FRACTION ONE QUARTER */
    XK_onehalf:                     0x00bd, /* U+00BD VULGAR FRACTION ONE HALF */
    XK_threequarters:               0x00be, /* U+00BE VULGAR FRACTION THREE QUARTERS */
    XK_questiondown:                0x00bf, /* U+00BF INVERTED QUESTION MARK */
    XK_Agrave:                      0x00c0, /* U+00C0 LATIN CAPITAL LETTER A WITH GRAVE */
    XK_Aacute:                      0x00c1, /* U+00C1 LATIN CAPITAL LETTER A WITH ACUTE */
    XK_Acircumflex:                 0x00c2, /* U+00C2 LATIN CAPITAL LETTER A WITH CIRCUMFLEX */
    XK_Atilde:                      0x00c3, /* U+00C3 LATIN CAPITAL LETTER A WITH TILDE */
    XK_Adiaeresis:                  0x00c4, /* U+00C4 LATIN CAPITAL LETTER A WITH DIAERESIS */
    XK_Aring:                       0x00c5, /* U+00C5 LATIN CAPITAL LETTER A WITH RING ABOVE */
    XK_AE:                          0x00c6, /* U+00C6 LATIN CAPITAL LETTER AE */
    XK_Ccedilla:                    0x00c7, /* U+00C7 LATIN CAPITAL LETTER C WITH CEDILLA */
    XK_Egrave:                      0x00c8, /* U+00C8 LATIN CAPITAL LETTER E WITH GRAVE */
    XK_Eacute:                      0x00c9, /* U+00C9 LATIN CAPITAL LETTER E WITH ACUTE */
    XK_Ecircumflex:                 0x00ca, /* U+00CA LATIN CAPITAL LETTER E WITH CIRCUMFLEX */
    XK_Ediaeresis:                  0x00cb, /* U+00CB LATIN CAPITAL LETTER E WITH DIAERESIS */
    XK_Igrave:                      0x00cc, /* U+00CC LATIN CAPITAL LETTER I WITH GRAVE */
    XK_Iacute:                      0x00cd, /* U+00CD LATIN CAPITAL LETTER I WITH ACUTE */
    XK_Icircumflex:                 0x00ce, /* U+00CE LATIN CAPITAL LETTER I WITH CIRCUMFLEX */
    XK_Idiaeresis:                  0x00cf, /* U+00CF LATIN CAPITAL LETTER I WITH DIAERESIS */
    XK_ETH:                         0x00d0, /* U+00D0 LATIN CAPITAL LETTER ETH */
    XK_Eth:                         0x00d0, /* deprecated */
    XK_Ntilde:                      0x00d1, /* U+00D1 LATIN CAPITAL LETTER N WITH TILDE */
    XK_Ograve:                      0x00d2, /* U+00D2 LATIN CAPITAL LETTER O WITH GRAVE */
    XK_Oacute:                      0x00d3, /* U+00D3 LATIN CAPITAL LETTER O WITH ACUTE */
    XK_Ocircumflex:                 0x00d4, /* U+00D4 LATIN CAPITAL LETTER O WITH CIRCUMFLEX */
    XK_Otilde:                      0x00d5, /* U+00D5 LATIN CAPITAL LETTER O WITH TILDE */
    XK_Odiaeresis:                  0x00d6, /* U+00D6 LATIN CAPITAL LETTER O WITH DIAERESIS */
    XK_multiply:                    0x00d7, /* U+00D7 MULTIPLICATION SIGN */
    XK_Oslash:                      0x00d8, /* U+00D8 LATIN CAPITAL LETTER O WITH STROKE */
    XK_Ooblique:                    0x00d8, /* U+00D8 LATIN CAPITAL LETTER O WITH STROKE */
    XK_Ugrave:                      0x00d9, /* U+00D9 LATIN CAPITAL LETTER U WITH GRAVE */
    XK_Uacute:                      0x00da, /* U+00DA LATIN CAPITAL LETTER U WITH ACUTE */
    XK_Ucircumflex:                 0x00db, /* U+00DB LATIN CAPITAL LETTER U WITH CIRCUMFLEX */
    XK_Udiaeresis:                  0x00dc, /* U+00DC LATIN CAPITAL LETTER U WITH DIAERESIS */
    XK_Yacute:                      0x00dd, /* U+00DD LATIN CAPITAL LETTER Y WITH ACUTE */
    XK_THORN:                       0x00de, /* U+00DE LATIN CAPITAL LETTER THORN */
    XK_Thorn:                       0x00de, /* deprecated */
    XK_ssharp:                      0x00df, /* U+00DF LATIN SMALL LETTER SHARP S */
    XK_agrave:                      0x00e0, /* U+00E0 LATIN SMALL LETTER A WITH GRAVE */
    XK_aacute:                      0x00e1, /* U+00E1 LATIN SMALL LETTER A WITH ACUTE */
    XK_acircumflex:                 0x00e2, /* U+00E2 LATIN SMALL LETTER A WITH CIRCUMFLEX */
    XK_atilde:                      0x00e3, /* U+00E3 LATIN SMALL LETTER A WITH TILDE */
    XK_adiaeresis:                  0x00e4, /* U+00E4 LATIN SMALL LETTER A WITH DIAERESIS */
    XK_aring:                       0x00e5, /* U+00E5 LATIN SMALL LETTER A WITH RING ABOVE */
    XK_ae:                          0x00e6, /* U+00E6 LATIN SMALL LETTER AE */
    XK_ccedilla:                    0x00e7, /* U+00E7 LATIN SMALL LETTER C WITH CEDILLA */
    XK_egrave:                      0x00e8, /* U+00E8 LATIN SMALL LETTER E WITH GRAVE */
    XK_eacute:                      0x00e9, /* U+00E9 LATIN SMALL LETTER E WITH ACUTE */
    XK_ecircumflex:                 0x00ea, /* U+00EA LATIN SMALL LETTER E WITH CIRCUMFLEX */
    XK_ediaeresis:                  0x00eb, /* U+00EB LATIN SMALL LETTER E WITH DIAERESIS */
    XK_igrave:                      0x00ec, /* U+00EC LATIN SMALL LETTER I WITH GRAVE */
    XK_iacute:                      0x00ed, /* U+00ED LATIN SMALL LETTER I WITH ACUTE */
    XK_icircumflex:                 0x00ee, /* U+00EE LATIN SMALL LETTER I WITH CIRCUMFLEX */
    XK_idiaeresis:                  0x00ef, /* U+00EF LATIN SMALL LETTER I WITH DIAERESIS */
    XK_eth:                         0x00f0, /* U+00F0 LATIN SMALL LETTER ETH */
    XK_ntilde:                      0x00f1, /* U+00F1 LATIN SMALL LETTER N WITH TILDE */
    XK_ograve:                      0x00f2, /* U+00F2 LATIN SMALL LETTER O WITH GRAVE */
    XK_oacute:                      0x00f3, /* U+00F3 LATIN SMALL LETTER O WITH ACUTE */
    XK_ocircumflex:                 0x00f4, /* U+00F4 LATIN SMALL LETTER O WITH CIRCUMFLEX */
    XK_otilde:                      0x00f5, /* U+00F5 LATIN SMALL LETTER O WITH TILDE */
    XK_odiaeresis:                  0x00f6, /* U+00F6 LATIN SMALL LETTER O WITH DIAERESIS */
    XK_division:                    0x00f7, /* U+00F7 DIVISION SIGN */
    XK_oslash:                      0x00f8, /* U+00F8 LATIN SMALL LETTER O WITH STROKE */
    XK_ooblique:                    0x00f8, /* U+00F8 LATIN SMALL LETTER O WITH STROKE */
    XK_ugrave:                      0x00f9, /* U+00F9 LATIN SMALL LETTER U WITH GRAVE */
    XK_uacute:                      0x00fa, /* U+00FA LATIN SMALL LETTER U WITH ACUTE */
    XK_ucircumflex:                 0x00fb, /* U+00FB LATIN SMALL LETTER U WITH CIRCUMFLEX */
    XK_udiaeresis:                  0x00fc, /* U+00FC LATIN SMALL LETTER U WITH DIAERESIS */
    XK_yacute:                      0x00fd, /* U+00FD LATIN SMALL LETTER Y WITH ACUTE */
    XK_thorn:                       0x00fe, /* U+00FE LATIN SMALL LETTER THORN */
    XK_ydiaeresis:                  0x00ff, /* U+00FF LATIN SMALL LETTER Y WITH DIAERESIS */

    /*
     * Korean
     * Byte 3 = 0x0e
     */

    XK_Hangul:                      0xff31, /* Hangul start/stop(toggle) */
    XK_Hangul_Hanja:                0xff34, /* Start Hangul->Hanja Conversion */
    XK_Hangul_Jeonja:               0xff38, /* Jeonja mode */

    /*
     * XFree86 vendor specific keysyms.
     *
     * The XFree86 keysym range is 0x10080001 - 0x1008FFFF.
     */

    XF86XK_ModeLock:                0x1008FF01,
    XF86XK_MonBrightnessUp:         0x1008FF02,
    XF86XK_MonBrightnessDown:       0x1008FF03,
    XF86XK_KbdLightOnOff:           0x1008FF04,
    XF86XK_KbdBrightnessUp:         0x1008FF05,
    XF86XK_KbdBrightnessDown:       0x1008FF06,
    XF86XK_Standby:                 0x1008FF10,
    XF86XK_AudioLowerVolume:        0x1008FF11,
    XF86XK_AudioMute:               0x1008FF12,
    XF86XK_AudioRaiseVolume:        0x1008FF13,
    XF86XK_AudioPlay:               0x1008FF14,
    XF86XK_AudioStop:               0x1008FF15,
    XF86XK_AudioPrev:               0x1008FF16,
    XF86XK_AudioNext:               0x1008FF17,
    XF86XK_HomePage:                0x1008FF18,
    XF86XK_Mail:                    0x1008FF19,
    XF86XK_Start:                   0x1008FF1A,
    XF86XK_Search:                  0x1008FF1B,
    XF86XK_AudioRecord:             0x1008FF1C,
    XF86XK_Calculator:              0x1008FF1D,
    XF86XK_Memo:                    0x1008FF1E,
    XF86XK_ToDoList:                0x1008FF1F,
    XF86XK_Calendar:                0x1008FF20,
    XF86XK_PowerDown:               0x1008FF21,
    XF86XK_ContrastAdjust:          0x1008FF22,
    XF86XK_RockerUp:                0x1008FF23,
    XF86XK_RockerDown:              0x1008FF24,
    XF86XK_RockerEnter:             0x1008FF25,
    XF86XK_Back:                    0x1008FF26,
    XF86XK_Forward:                 0x1008FF27,
    XF86XK_Stop:                    0x1008FF28,
    XF86XK_Refresh:                 0x1008FF29,
    XF86XK_PowerOff:                0x1008FF2A,
    XF86XK_WakeUp:                  0x1008FF2B,
    XF86XK_Eject:                   0x1008FF2C,
    XF86XK_ScreenSaver:             0x1008FF2D,
    XF86XK_WWW:                     0x1008FF2E,
    XF86XK_Sleep:                   0x1008FF2F,
    XF86XK_Favorites:               0x1008FF30,
    XF86XK_AudioPause:              0x1008FF31,
    XF86XK_AudioMedia:              0x1008FF32,
    XF86XK_MyComputer:              0x1008FF33,
    XF86XK_VendorHome:              0x1008FF34,
    XF86XK_LightBulb:               0x1008FF35,
    XF86XK_Shop:                    0x1008FF36,
    XF86XK_History:                 0x1008FF37,
    XF86XK_OpenURL:                 0x1008FF38,
    XF86XK_AddFavorite:             0x1008FF39,
    XF86XK_HotLinks:                0x1008FF3A,
    XF86XK_BrightnessAdjust:        0x1008FF3B,
    XF86XK_Finance:                 0x1008FF3C,
    XF86XK_Community:               0x1008FF3D,
    XF86XK_AudioRewind:             0x1008FF3E,
    XF86XK_BackForward:             0x1008FF3F,
    XF86XK_Launch0:                 0x1008FF40,
    XF86XK_Launch1:                 0x1008FF41,
    XF86XK_Launch2:                 0x1008FF42,
    XF86XK_Launch3:                 0x1008FF43,
    XF86XK_Launch4:                 0x1008FF44,
    XF86XK_Launch5:                 0x1008FF45,
    XF86XK_Launch6:                 0x1008FF46,
    XF86XK_Launch7:                 0x1008FF47,
    XF86XK_Launch8:                 0x1008FF48,
    XF86XK_Launch9:                 0x1008FF49,
    XF86XK_LaunchA:                 0x1008FF4A,
    XF86XK_LaunchB:                 0x1008FF4B,
    XF86XK_LaunchC:                 0x1008FF4C,
    XF86XK_LaunchD:                 0x1008FF4D,
    XF86XK_LaunchE:                 0x1008FF4E,
    XF86XK_LaunchF:                 0x1008FF4F,
    XF86XK_ApplicationLeft:         0x1008FF50,
    XF86XK_ApplicationRight:        0x1008FF51,
    XF86XK_Book:                    0x1008FF52,
    XF86XK_CD:                      0x1008FF53,
    XF86XK_Calculater:              0x1008FF54,
    XF86XK_Clear:                   0x1008FF55,
    XF86XK_Close:                   0x1008FF56,
    XF86XK_Copy:                    0x1008FF57,
    XF86XK_Cut:                     0x1008FF58,
    XF86XK_Display:                 0x1008FF59,
    XF86XK_DOS:                     0x1008FF5A,
    XF86XK_Documents:               0x1008FF5B,
    XF86XK_Excel:                   0x1008FF5C,
    XF86XK_Explorer:                0x1008FF5D,
    XF86XK_Game:                    0x1008FF5E,
    XF86XK_Go:                      0x1008FF5F,
    XF86XK_iTouch:                  0x1008FF60,
    XF86XK_LogOff:                  0x1008FF61,
    XF86XK_Market:                  0x1008FF62,
    XF86XK_Meeting:                 0x1008FF63,
    XF86XK_MenuKB:                  0x1008FF65,
    XF86XK_MenuPB:                  0x1008FF66,
    XF86XK_MySites:                 0x1008FF67,
    XF86XK_New:                     0x1008FF68,
    XF86XK_News:                    0x1008FF69,
    XF86XK_OfficeHome:              0x1008FF6A,
    XF86XK_Open:                    0x1008FF6B,
    XF86XK_Option:                  0x1008FF6C,
    XF86XK_Paste:                   0x1008FF6D,
    XF86XK_Phone:                   0x1008FF6E,
    XF86XK_Q:                       0x1008FF70,
    XF86XK_Reply:                   0x1008FF72,
    XF86XK_Reload:                  0x1008FF73,
    XF86XK_RotateWindows:           0x1008FF74,
    XF86XK_RotationPB:              0x1008FF75,
    XF86XK_RotationKB:              0x1008FF76,
    XF86XK_Save:                    0x1008FF77,
    XF86XK_ScrollUp:                0x1008FF78,
    XF86XK_ScrollDown:              0x1008FF79,
    XF86XK_ScrollClick:             0x1008FF7A,
    XF86XK_Send:                    0x1008FF7B,
    XF86XK_Spell:                   0x1008FF7C,
    XF86XK_SplitScreen:             0x1008FF7D,
    XF86XK_Support:                 0x1008FF7E,
    XF86XK_TaskPane:                0x1008FF7F,
    XF86XK_Terminal:                0x1008FF80,
    XF86XK_Tools:                   0x1008FF81,
    XF86XK_Travel:                  0x1008FF82,
    XF86XK_UserPB:                  0x1008FF84,
    XF86XK_User1KB:                 0x1008FF85,
    XF86XK_User2KB:                 0x1008FF86,
    XF86XK_Video:                   0x1008FF87,
    XF86XK_WheelButton:             0x1008FF88,
    XF86XK_Word:                    0x1008FF89,
    XF86XK_Xfer:                    0x1008FF8A,
    XF86XK_ZoomIn:                  0x1008FF8B,
    XF86XK_ZoomOut:                 0x1008FF8C,
    XF86XK_Away:                    0x1008FF8D,
    XF86XK_Messenger:               0x1008FF8E,
    XF86XK_WebCam:                  0x1008FF8F,
    XF86XK_MailForward:             0x1008FF90,
    XF86XK_Pictures:                0x1008FF91,
    XF86XK_Music:                   0x1008FF92,
    XF86XK_Battery:                 0x1008FF93,
    XF86XK_Bluetooth:               0x1008FF94,
    XF86XK_WLAN:                    0x1008FF95,
    XF86XK_UWB:                     0x1008FF96,
    XF86XK_AudioForward:            0x1008FF97,
    XF86XK_AudioRepeat:             0x1008FF98,
    XF86XK_AudioRandomPlay:         0x1008FF99,
    XF86XK_Subtitle:                0x1008FF9A,
    XF86XK_AudioCycleTrack:         0x1008FF9B,
    XF86XK_CycleAngle:              0x1008FF9C,
    XF86XK_FrameBack:               0x1008FF9D,
    XF86XK_FrameForward:            0x1008FF9E,
    XF86XK_Time:                    0x1008FF9F,
    XF86XK_Select:                  0x1008FFA0,
    XF86XK_View:                    0x1008FFA1,
    XF86XK_TopMenu:                 0x1008FFA2,
    XF86XK_Red:                     0x1008FFA3,
    XF86XK_Green:                   0x1008FFA4,
    XF86XK_Yellow:                  0x1008FFA5,
    XF86XK_Blue:                    0x1008FFA6,
    XF86XK_Suspend:                 0x1008FFA7,
    XF86XK_Hibernate:               0x1008FFA8,
    XF86XK_TouchpadToggle:          0x1008FFA9,
    XF86XK_TouchpadOn:              0x1008FFB0,
    XF86XK_TouchpadOff:             0x1008FFB1,
    XF86XK_AudioMicMute:            0x1008FFB2,
    XF86XK_Switch_VT_1:             0x1008FE01,
    XF86XK_Switch_VT_2:             0x1008FE02,
    XF86XK_Switch_VT_3:             0x1008FE03,
    XF86XK_Switch_VT_4:             0x1008FE04,
    XF86XK_Switch_VT_5:             0x1008FE05,
    XF86XK_Switch_VT_6:             0x1008FE06,
    XF86XK_Switch_VT_7:             0x1008FE07,
    XF86XK_Switch_VT_8:             0x1008FE08,
    XF86XK_Switch_VT_9:             0x1008FE09,
    XF86XK_Switch_VT_10:            0x1008FE0A,
    XF86XK_Switch_VT_11:            0x1008FE0B,
    XF86XK_Switch_VT_12:            0x1008FE0C,
    XF86XK_Ungrab:                  0x1008FE20,
    XF86XK_ClearGrab:               0x1008FE21,
    XF86XK_Next_VMode:              0x1008FE22,
    XF86XK_Prev_VMode:              0x1008FE23,
    XF86XK_LogWindowTree:           0x1008FE24,
    XF86XK_LogGrabInfo:             0x1008FE25,
});


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/input/keysymdef.js":
/*!***********************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/input/keysymdef.js ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*
 * Mapping from Unicode codepoints to X11/RFB keysyms
 *
 * This file was automatically generated from keysymdef.h
 * DO NOT EDIT!
 */

/* Functions at the bottom */

const codepoints = {
    0x0100: 0x03c0, // XK_Amacron
    0x0101: 0x03e0, // XK_amacron
    0x0102: 0x01c3, // XK_Abreve
    0x0103: 0x01e3, // XK_abreve
    0x0104: 0x01a1, // XK_Aogonek
    0x0105: 0x01b1, // XK_aogonek
    0x0106: 0x01c6, // XK_Cacute
    0x0107: 0x01e6, // XK_cacute
    0x0108: 0x02c6, // XK_Ccircumflex
    0x0109: 0x02e6, // XK_ccircumflex
    0x010a: 0x02c5, // XK_Cabovedot
    0x010b: 0x02e5, // XK_cabovedot
    0x010c: 0x01c8, // XK_Ccaron
    0x010d: 0x01e8, // XK_ccaron
    0x010e: 0x01cf, // XK_Dcaron
    0x010f: 0x01ef, // XK_dcaron
    0x0110: 0x01d0, // XK_Dstroke
    0x0111: 0x01f0, // XK_dstroke
    0x0112: 0x03aa, // XK_Emacron
    0x0113: 0x03ba, // XK_emacron
    0x0116: 0x03cc, // XK_Eabovedot
    0x0117: 0x03ec, // XK_eabovedot
    0x0118: 0x01ca, // XK_Eogonek
    0x0119: 0x01ea, // XK_eogonek
    0x011a: 0x01cc, // XK_Ecaron
    0x011b: 0x01ec, // XK_ecaron
    0x011c: 0x02d8, // XK_Gcircumflex
    0x011d: 0x02f8, // XK_gcircumflex
    0x011e: 0x02ab, // XK_Gbreve
    0x011f: 0x02bb, // XK_gbreve
    0x0120: 0x02d5, // XK_Gabovedot
    0x0121: 0x02f5, // XK_gabovedot
    0x0122: 0x03ab, // XK_Gcedilla
    0x0123: 0x03bb, // XK_gcedilla
    0x0124: 0x02a6, // XK_Hcircumflex
    0x0125: 0x02b6, // XK_hcircumflex
    0x0126: 0x02a1, // XK_Hstroke
    0x0127: 0x02b1, // XK_hstroke
    0x0128: 0x03a5, // XK_Itilde
    0x0129: 0x03b5, // XK_itilde
    0x012a: 0x03cf, // XK_Imacron
    0x012b: 0x03ef, // XK_imacron
    0x012e: 0x03c7, // XK_Iogonek
    0x012f: 0x03e7, // XK_iogonek
    0x0130: 0x02a9, // XK_Iabovedot
    0x0131: 0x02b9, // XK_idotless
    0x0134: 0x02ac, // XK_Jcircumflex
    0x0135: 0x02bc, // XK_jcircumflex
    0x0136: 0x03d3, // XK_Kcedilla
    0x0137: 0x03f3, // XK_kcedilla
    0x0138: 0x03a2, // XK_kra
    0x0139: 0x01c5, // XK_Lacute
    0x013a: 0x01e5, // XK_lacute
    0x013b: 0x03a6, // XK_Lcedilla
    0x013c: 0x03b6, // XK_lcedilla
    0x013d: 0x01a5, // XK_Lcaron
    0x013e: 0x01b5, // XK_lcaron
    0x0141: 0x01a3, // XK_Lstroke
    0x0142: 0x01b3, // XK_lstroke
    0x0143: 0x01d1, // XK_Nacute
    0x0144: 0x01f1, // XK_nacute
    0x0145: 0x03d1, // XK_Ncedilla
    0x0146: 0x03f1, // XK_ncedilla
    0x0147: 0x01d2, // XK_Ncaron
    0x0148: 0x01f2, // XK_ncaron
    0x014a: 0x03bd, // XK_ENG
    0x014b: 0x03bf, // XK_eng
    0x014c: 0x03d2, // XK_Omacron
    0x014d: 0x03f2, // XK_omacron
    0x0150: 0x01d5, // XK_Odoubleacute
    0x0151: 0x01f5, // XK_odoubleacute
    0x0152: 0x13bc, // XK_OE
    0x0153: 0x13bd, // XK_oe
    0x0154: 0x01c0, // XK_Racute
    0x0155: 0x01e0, // XK_racute
    0x0156: 0x03a3, // XK_Rcedilla
    0x0157: 0x03b3, // XK_rcedilla
    0x0158: 0x01d8, // XK_Rcaron
    0x0159: 0x01f8, // XK_rcaron
    0x015a: 0x01a6, // XK_Sacute
    0x015b: 0x01b6, // XK_sacute
    0x015c: 0x02de, // XK_Scircumflex
    0x015d: 0x02fe, // XK_scircumflex
    0x015e: 0x01aa, // XK_Scedilla
    0x015f: 0x01ba, // XK_scedilla
    0x0160: 0x01a9, // XK_Scaron
    0x0161: 0x01b9, // XK_scaron
    0x0162: 0x01de, // XK_Tcedilla
    0x0163: 0x01fe, // XK_tcedilla
    0x0164: 0x01ab, // XK_Tcaron
    0x0165: 0x01bb, // XK_tcaron
    0x0166: 0x03ac, // XK_Tslash
    0x0167: 0x03bc, // XK_tslash
    0x0168: 0x03dd, // XK_Utilde
    0x0169: 0x03fd, // XK_utilde
    0x016a: 0x03de, // XK_Umacron
    0x016b: 0x03fe, // XK_umacron
    0x016c: 0x02dd, // XK_Ubreve
    0x016d: 0x02fd, // XK_ubreve
    0x016e: 0x01d9, // XK_Uring
    0x016f: 0x01f9, // XK_uring
    0x0170: 0x01db, // XK_Udoubleacute
    0x0171: 0x01fb, // XK_udoubleacute
    0x0172: 0x03d9, // XK_Uogonek
    0x0173: 0x03f9, // XK_uogonek
    0x0178: 0x13be, // XK_Ydiaeresis
    0x0179: 0x01ac, // XK_Zacute
    0x017a: 0x01bc, // XK_zacute
    0x017b: 0x01af, // XK_Zabovedot
    0x017c: 0x01bf, // XK_zabovedot
    0x017d: 0x01ae, // XK_Zcaron
    0x017e: 0x01be, // XK_zcaron
    0x0192: 0x08f6, // XK_function
    0x01d2: 0x10001d1, // XK_Ocaron
    0x02c7: 0x01b7, // XK_caron
    0x02d8: 0x01a2, // XK_breve
    0x02d9: 0x01ff, // XK_abovedot
    0x02db: 0x01b2, // XK_ogonek
    0x02dd: 0x01bd, // XK_doubleacute
    0x0385: 0x07ae, // XK_Greek_accentdieresis
    0x0386: 0x07a1, // XK_Greek_ALPHAaccent
    0x0388: 0x07a2, // XK_Greek_EPSILONaccent
    0x0389: 0x07a3, // XK_Greek_ETAaccent
    0x038a: 0x07a4, // XK_Greek_IOTAaccent
    0x038c: 0x07a7, // XK_Greek_OMICRONaccent
    0x038e: 0x07a8, // XK_Greek_UPSILONaccent
    0x038f: 0x07ab, // XK_Greek_OMEGAaccent
    0x0390: 0x07b6, // XK_Greek_iotaaccentdieresis
    0x0391: 0x07c1, // XK_Greek_ALPHA
    0x0392: 0x07c2, // XK_Greek_BETA
    0x0393: 0x07c3, // XK_Greek_GAMMA
    0x0394: 0x07c4, // XK_Greek_DELTA
    0x0395: 0x07c5, // XK_Greek_EPSILON
    0x0396: 0x07c6, // XK_Greek_ZETA
    0x0397: 0x07c7, // XK_Greek_ETA
    0x0398: 0x07c8, // XK_Greek_THETA
    0x0399: 0x07c9, // XK_Greek_IOTA
    0x039a: 0x07ca, // XK_Greek_KAPPA
    0x039b: 0x07cb, // XK_Greek_LAMDA
    0x039c: 0x07cc, // XK_Greek_MU
    0x039d: 0x07cd, // XK_Greek_NU
    0x039e: 0x07ce, // XK_Greek_XI
    0x039f: 0x07cf, // XK_Greek_OMICRON
    0x03a0: 0x07d0, // XK_Greek_PI
    0x03a1: 0x07d1, // XK_Greek_RHO
    0x03a3: 0x07d2, // XK_Greek_SIGMA
    0x03a4: 0x07d4, // XK_Greek_TAU
    0x03a5: 0x07d5, // XK_Greek_UPSILON
    0x03a6: 0x07d6, // XK_Greek_PHI
    0x03a7: 0x07d7, // XK_Greek_CHI
    0x03a8: 0x07d8, // XK_Greek_PSI
    0x03a9: 0x07d9, // XK_Greek_OMEGA
    0x03aa: 0x07a5, // XK_Greek_IOTAdieresis
    0x03ab: 0x07a9, // XK_Greek_UPSILONdieresis
    0x03ac: 0x07b1, // XK_Greek_alphaaccent
    0x03ad: 0x07b2, // XK_Greek_epsilonaccent
    0x03ae: 0x07b3, // XK_Greek_etaaccent
    0x03af: 0x07b4, // XK_Greek_iotaaccent
    0x03b0: 0x07ba, // XK_Greek_upsilonaccentdieresis
    0x03b1: 0x07e1, // XK_Greek_alpha
    0x03b2: 0x07e2, // XK_Greek_beta
    0x03b3: 0x07e3, // XK_Greek_gamma
    0x03b4: 0x07e4, // XK_Greek_delta
    0x03b5: 0x07e5, // XK_Greek_epsilon
    0x03b6: 0x07e6, // XK_Greek_zeta
    0x03b7: 0x07e7, // XK_Greek_eta
    0x03b8: 0x07e8, // XK_Greek_theta
    0x03b9: 0x07e9, // XK_Greek_iota
    0x03ba: 0x07ea, // XK_Greek_kappa
    0x03bb: 0x07eb, // XK_Greek_lamda
    0x03bc: 0x07ec, // XK_Greek_mu
    0x03bd: 0x07ed, // XK_Greek_nu
    0x03be: 0x07ee, // XK_Greek_xi
    0x03bf: 0x07ef, // XK_Greek_omicron
    0x03c0: 0x07f0, // XK_Greek_pi
    0x03c1: 0x07f1, // XK_Greek_rho
    0x03c2: 0x07f3, // XK_Greek_finalsmallsigma
    0x03c3: 0x07f2, // XK_Greek_sigma
    0x03c4: 0x07f4, // XK_Greek_tau
    0x03c5: 0x07f5, // XK_Greek_upsilon
    0x03c6: 0x07f6, // XK_Greek_phi
    0x03c7: 0x07f7, // XK_Greek_chi
    0x03c8: 0x07f8, // XK_Greek_psi
    0x03c9: 0x07f9, // XK_Greek_omega
    0x03ca: 0x07b5, // XK_Greek_iotadieresis
    0x03cb: 0x07b9, // XK_Greek_upsilondieresis
    0x03cc: 0x07b7, // XK_Greek_omicronaccent
    0x03cd: 0x07b8, // XK_Greek_upsilonaccent
    0x03ce: 0x07bb, // XK_Greek_omegaaccent
    0x0401: 0x06b3, // XK_Cyrillic_IO
    0x0402: 0x06b1, // XK_Serbian_DJE
    0x0403: 0x06b2, // XK_Macedonia_GJE
    0x0404: 0x06b4, // XK_Ukrainian_IE
    0x0405: 0x06b5, // XK_Macedonia_DSE
    0x0406: 0x06b6, // XK_Ukrainian_I
    0x0407: 0x06b7, // XK_Ukrainian_YI
    0x0408: 0x06b8, // XK_Cyrillic_JE
    0x0409: 0x06b9, // XK_Cyrillic_LJE
    0x040a: 0x06ba, // XK_Cyrillic_NJE
    0x040b: 0x06bb, // XK_Serbian_TSHE
    0x040c: 0x06bc, // XK_Macedonia_KJE
    0x040e: 0x06be, // XK_Byelorussian_SHORTU
    0x040f: 0x06bf, // XK_Cyrillic_DZHE
    0x0410: 0x06e1, // XK_Cyrillic_A
    0x0411: 0x06e2, // XK_Cyrillic_BE
    0x0412: 0x06f7, // XK_Cyrillic_VE
    0x0413: 0x06e7, // XK_Cyrillic_GHE
    0x0414: 0x06e4, // XK_Cyrillic_DE
    0x0415: 0x06e5, // XK_Cyrillic_IE
    0x0416: 0x06f6, // XK_Cyrillic_ZHE
    0x0417: 0x06fa, // XK_Cyrillic_ZE
    0x0418: 0x06e9, // XK_Cyrillic_I
    0x0419: 0x06ea, // XK_Cyrillic_SHORTI
    0x041a: 0x06eb, // XK_Cyrillic_KA
    0x041b: 0x06ec, // XK_Cyrillic_EL
    0x041c: 0x06ed, // XK_Cyrillic_EM
    0x041d: 0x06ee, // XK_Cyrillic_EN
    0x041e: 0x06ef, // XK_Cyrillic_O
    0x041f: 0x06f0, // XK_Cyrillic_PE
    0x0420: 0x06f2, // XK_Cyrillic_ER
    0x0421: 0x06f3, // XK_Cyrillic_ES
    0x0422: 0x06f4, // XK_Cyrillic_TE
    0x0423: 0x06f5, // XK_Cyrillic_U
    0x0424: 0x06e6, // XK_Cyrillic_EF
    0x0425: 0x06e8, // XK_Cyrillic_HA
    0x0426: 0x06e3, // XK_Cyrillic_TSE
    0x0427: 0x06fe, // XK_Cyrillic_CHE
    0x0428: 0x06fb, // XK_Cyrillic_SHA
    0x0429: 0x06fd, // XK_Cyrillic_SHCHA
    0x042a: 0x06ff, // XK_Cyrillic_HARDSIGN
    0x042b: 0x06f9, // XK_Cyrillic_YERU
    0x042c: 0x06f8, // XK_Cyrillic_SOFTSIGN
    0x042d: 0x06fc, // XK_Cyrillic_E
    0x042e: 0x06e0, // XK_Cyrillic_YU
    0x042f: 0x06f1, // XK_Cyrillic_YA
    0x0430: 0x06c1, // XK_Cyrillic_a
    0x0431: 0x06c2, // XK_Cyrillic_be
    0x0432: 0x06d7, // XK_Cyrillic_ve
    0x0433: 0x06c7, // XK_Cyrillic_ghe
    0x0434: 0x06c4, // XK_Cyrillic_de
    0x0435: 0x06c5, // XK_Cyrillic_ie
    0x0436: 0x06d6, // XK_Cyrillic_zhe
    0x0437: 0x06da, // XK_Cyrillic_ze
    0x0438: 0x06c9, // XK_Cyrillic_i
    0x0439: 0x06ca, // XK_Cyrillic_shorti
    0x043a: 0x06cb, // XK_Cyrillic_ka
    0x043b: 0x06cc, // XK_Cyrillic_el
    0x043c: 0x06cd, // XK_Cyrillic_em
    0x043d: 0x06ce, // XK_Cyrillic_en
    0x043e: 0x06cf, // XK_Cyrillic_o
    0x043f: 0x06d0, // XK_Cyrillic_pe
    0x0440: 0x06d2, // XK_Cyrillic_er
    0x0441: 0x06d3, // XK_Cyrillic_es
    0x0442: 0x06d4, // XK_Cyrillic_te
    0x0443: 0x06d5, // XK_Cyrillic_u
    0x0444: 0x06c6, // XK_Cyrillic_ef
    0x0445: 0x06c8, // XK_Cyrillic_ha
    0x0446: 0x06c3, // XK_Cyrillic_tse
    0x0447: 0x06de, // XK_Cyrillic_che
    0x0448: 0x06db, // XK_Cyrillic_sha
    0x0449: 0x06dd, // XK_Cyrillic_shcha
    0x044a: 0x06df, // XK_Cyrillic_hardsign
    0x044b: 0x06d9, // XK_Cyrillic_yeru
    0x044c: 0x06d8, // XK_Cyrillic_softsign
    0x044d: 0x06dc, // XK_Cyrillic_e
    0x044e: 0x06c0, // XK_Cyrillic_yu
    0x044f: 0x06d1, // XK_Cyrillic_ya
    0x0451: 0x06a3, // XK_Cyrillic_io
    0x0452: 0x06a1, // XK_Serbian_dje
    0x0453: 0x06a2, // XK_Macedonia_gje
    0x0454: 0x06a4, // XK_Ukrainian_ie
    0x0455: 0x06a5, // XK_Macedonia_dse
    0x0456: 0x06a6, // XK_Ukrainian_i
    0x0457: 0x06a7, // XK_Ukrainian_yi
    0x0458: 0x06a8, // XK_Cyrillic_je
    0x0459: 0x06a9, // XK_Cyrillic_lje
    0x045a: 0x06aa, // XK_Cyrillic_nje
    0x045b: 0x06ab, // XK_Serbian_tshe
    0x045c: 0x06ac, // XK_Macedonia_kje
    0x045e: 0x06ae, // XK_Byelorussian_shortu
    0x045f: 0x06af, // XK_Cyrillic_dzhe
    0x0490: 0x06bd, // XK_Ukrainian_GHE_WITH_UPTURN
    0x0491: 0x06ad, // XK_Ukrainian_ghe_with_upturn
    0x05d0: 0x0ce0, // XK_hebrew_aleph
    0x05d1: 0x0ce1, // XK_hebrew_bet
    0x05d2: 0x0ce2, // XK_hebrew_gimel
    0x05d3: 0x0ce3, // XK_hebrew_dalet
    0x05d4: 0x0ce4, // XK_hebrew_he
    0x05d5: 0x0ce5, // XK_hebrew_waw
    0x05d6: 0x0ce6, // XK_hebrew_zain
    0x05d7: 0x0ce7, // XK_hebrew_chet
    0x05d8: 0x0ce8, // XK_hebrew_tet
    0x05d9: 0x0ce9, // XK_hebrew_yod
    0x05da: 0x0cea, // XK_hebrew_finalkaph
    0x05db: 0x0ceb, // XK_hebrew_kaph
    0x05dc: 0x0cec, // XK_hebrew_lamed
    0x05dd: 0x0ced, // XK_hebrew_finalmem
    0x05de: 0x0cee, // XK_hebrew_mem
    0x05df: 0x0cef, // XK_hebrew_finalnun
    0x05e0: 0x0cf0, // XK_hebrew_nun
    0x05e1: 0x0cf1, // XK_hebrew_samech
    0x05e2: 0x0cf2, // XK_hebrew_ayin
    0x05e3: 0x0cf3, // XK_hebrew_finalpe
    0x05e4: 0x0cf4, // XK_hebrew_pe
    0x05e5: 0x0cf5, // XK_hebrew_finalzade
    0x05e6: 0x0cf6, // XK_hebrew_zade
    0x05e7: 0x0cf7, // XK_hebrew_qoph
    0x05e8: 0x0cf8, // XK_hebrew_resh
    0x05e9: 0x0cf9, // XK_hebrew_shin
    0x05ea: 0x0cfa, // XK_hebrew_taw
    0x060c: 0x05ac, // XK_Arabic_comma
    0x061b: 0x05bb, // XK_Arabic_semicolon
    0x061f: 0x05bf, // XK_Arabic_question_mark
    0x0621: 0x05c1, // XK_Arabic_hamza
    0x0622: 0x05c2, // XK_Arabic_maddaonalef
    0x0623: 0x05c3, // XK_Arabic_hamzaonalef
    0x0624: 0x05c4, // XK_Arabic_hamzaonwaw
    0x0625: 0x05c5, // XK_Arabic_hamzaunderalef
    0x0626: 0x05c6, // XK_Arabic_hamzaonyeh
    0x0627: 0x05c7, // XK_Arabic_alef
    0x0628: 0x05c8, // XK_Arabic_beh
    0x0629: 0x05c9, // XK_Arabic_tehmarbuta
    0x062a: 0x05ca, // XK_Arabic_teh
    0x062b: 0x05cb, // XK_Arabic_theh
    0x062c: 0x05cc, // XK_Arabic_jeem
    0x062d: 0x05cd, // XK_Arabic_hah
    0x062e: 0x05ce, // XK_Arabic_khah
    0x062f: 0x05cf, // XK_Arabic_dal
    0x0630: 0x05d0, // XK_Arabic_thal
    0x0631: 0x05d1, // XK_Arabic_ra
    0x0632: 0x05d2, // XK_Arabic_zain
    0x0633: 0x05d3, // XK_Arabic_seen
    0x0634: 0x05d4, // XK_Arabic_sheen
    0x0635: 0x05d5, // XK_Arabic_sad
    0x0636: 0x05d6, // XK_Arabic_dad
    0x0637: 0x05d7, // XK_Arabic_tah
    0x0638: 0x05d8, // XK_Arabic_zah
    0x0639: 0x05d9, // XK_Arabic_ain
    0x063a: 0x05da, // XK_Arabic_ghain
    0x0640: 0x05e0, // XK_Arabic_tatweel
    0x0641: 0x05e1, // XK_Arabic_feh
    0x0642: 0x05e2, // XK_Arabic_qaf
    0x0643: 0x05e3, // XK_Arabic_kaf
    0x0644: 0x05e4, // XK_Arabic_lam
    0x0645: 0x05e5, // XK_Arabic_meem
    0x0646: 0x05e6, // XK_Arabic_noon
    0x0647: 0x05e7, // XK_Arabic_ha
    0x0648: 0x05e8, // XK_Arabic_waw
    0x0649: 0x05e9, // XK_Arabic_alefmaksura
    0x064a: 0x05ea, // XK_Arabic_yeh
    0x064b: 0x05eb, // XK_Arabic_fathatan
    0x064c: 0x05ec, // XK_Arabic_dammatan
    0x064d: 0x05ed, // XK_Arabic_kasratan
    0x064e: 0x05ee, // XK_Arabic_fatha
    0x064f: 0x05ef, // XK_Arabic_damma
    0x0650: 0x05f0, // XK_Arabic_kasra
    0x0651: 0x05f1, // XK_Arabic_shadda
    0x0652: 0x05f2, // XK_Arabic_sukun
    0x0e01: 0x0da1, // XK_Thai_kokai
    0x0e02: 0x0da2, // XK_Thai_khokhai
    0x0e03: 0x0da3, // XK_Thai_khokhuat
    0x0e04: 0x0da4, // XK_Thai_khokhwai
    0x0e05: 0x0da5, // XK_Thai_khokhon
    0x0e06: 0x0da6, // XK_Thai_khorakhang
    0x0e07: 0x0da7, // XK_Thai_ngongu
    0x0e08: 0x0da8, // XK_Thai_chochan
    0x0e09: 0x0da9, // XK_Thai_choching
    0x0e0a: 0x0daa, // XK_Thai_chochang
    0x0e0b: 0x0dab, // XK_Thai_soso
    0x0e0c: 0x0dac, // XK_Thai_chochoe
    0x0e0d: 0x0dad, // XK_Thai_yoying
    0x0e0e: 0x0dae, // XK_Thai_dochada
    0x0e0f: 0x0daf, // XK_Thai_topatak
    0x0e10: 0x0db0, // XK_Thai_thothan
    0x0e11: 0x0db1, // XK_Thai_thonangmontho
    0x0e12: 0x0db2, // XK_Thai_thophuthao
    0x0e13: 0x0db3, // XK_Thai_nonen
    0x0e14: 0x0db4, // XK_Thai_dodek
    0x0e15: 0x0db5, // XK_Thai_totao
    0x0e16: 0x0db6, // XK_Thai_thothung
    0x0e17: 0x0db7, // XK_Thai_thothahan
    0x0e18: 0x0db8, // XK_Thai_thothong
    0x0e19: 0x0db9, // XK_Thai_nonu
    0x0e1a: 0x0dba, // XK_Thai_bobaimai
    0x0e1b: 0x0dbb, // XK_Thai_popla
    0x0e1c: 0x0dbc, // XK_Thai_phophung
    0x0e1d: 0x0dbd, // XK_Thai_fofa
    0x0e1e: 0x0dbe, // XK_Thai_phophan
    0x0e1f: 0x0dbf, // XK_Thai_fofan
    0x0e20: 0x0dc0, // XK_Thai_phosamphao
    0x0e21: 0x0dc1, // XK_Thai_moma
    0x0e22: 0x0dc2, // XK_Thai_yoyak
    0x0e23: 0x0dc3, // XK_Thai_rorua
    0x0e24: 0x0dc4, // XK_Thai_ru
    0x0e25: 0x0dc5, // XK_Thai_loling
    0x0e26: 0x0dc6, // XK_Thai_lu
    0x0e27: 0x0dc7, // XK_Thai_wowaen
    0x0e28: 0x0dc8, // XK_Thai_sosala
    0x0e29: 0x0dc9, // XK_Thai_sorusi
    0x0e2a: 0x0dca, // XK_Thai_sosua
    0x0e2b: 0x0dcb, // XK_Thai_hohip
    0x0e2c: 0x0dcc, // XK_Thai_lochula
    0x0e2d: 0x0dcd, // XK_Thai_oang
    0x0e2e: 0x0dce, // XK_Thai_honokhuk
    0x0e2f: 0x0dcf, // XK_Thai_paiyannoi
    0x0e30: 0x0dd0, // XK_Thai_saraa
    0x0e31: 0x0dd1, // XK_Thai_maihanakat
    0x0e32: 0x0dd2, // XK_Thai_saraaa
    0x0e33: 0x0dd3, // XK_Thai_saraam
    0x0e34: 0x0dd4, // XK_Thai_sarai
    0x0e35: 0x0dd5, // XK_Thai_saraii
    0x0e36: 0x0dd6, // XK_Thai_saraue
    0x0e37: 0x0dd7, // XK_Thai_sarauee
    0x0e38: 0x0dd8, // XK_Thai_sarau
    0x0e39: 0x0dd9, // XK_Thai_sarauu
    0x0e3a: 0x0dda, // XK_Thai_phinthu
    0x0e3f: 0x0ddf, // XK_Thai_baht
    0x0e40: 0x0de0, // XK_Thai_sarae
    0x0e41: 0x0de1, // XK_Thai_saraae
    0x0e42: 0x0de2, // XK_Thai_sarao
    0x0e43: 0x0de3, // XK_Thai_saraaimaimuan
    0x0e44: 0x0de4, // XK_Thai_saraaimaimalai
    0x0e45: 0x0de5, // XK_Thai_lakkhangyao
    0x0e46: 0x0de6, // XK_Thai_maiyamok
    0x0e47: 0x0de7, // XK_Thai_maitaikhu
    0x0e48: 0x0de8, // XK_Thai_maiek
    0x0e49: 0x0de9, // XK_Thai_maitho
    0x0e4a: 0x0dea, // XK_Thai_maitri
    0x0e4b: 0x0deb, // XK_Thai_maichattawa
    0x0e4c: 0x0dec, // XK_Thai_thanthakhat
    0x0e4d: 0x0ded, // XK_Thai_nikhahit
    0x0e50: 0x0df0, // XK_Thai_leksun
    0x0e51: 0x0df1, // XK_Thai_leknung
    0x0e52: 0x0df2, // XK_Thai_leksong
    0x0e53: 0x0df3, // XK_Thai_leksam
    0x0e54: 0x0df4, // XK_Thai_leksi
    0x0e55: 0x0df5, // XK_Thai_lekha
    0x0e56: 0x0df6, // XK_Thai_lekhok
    0x0e57: 0x0df7, // XK_Thai_lekchet
    0x0e58: 0x0df8, // XK_Thai_lekpaet
    0x0e59: 0x0df9, // XK_Thai_lekkao
    0x2002: 0x0aa2, // XK_enspace
    0x2003: 0x0aa1, // XK_emspace
    0x2004: 0x0aa3, // XK_em3space
    0x2005: 0x0aa4, // XK_em4space
    0x2007: 0x0aa5, // XK_digitspace
    0x2008: 0x0aa6, // XK_punctspace
    0x2009: 0x0aa7, // XK_thinspace
    0x200a: 0x0aa8, // XK_hairspace
    0x2012: 0x0abb, // XK_figdash
    0x2013: 0x0aaa, // XK_endash
    0x2014: 0x0aa9, // XK_emdash
    0x2015: 0x07af, // XK_Greek_horizbar
    0x2017: 0x0cdf, // XK_hebrew_doublelowline
    0x2018: 0x0ad0, // XK_leftsinglequotemark
    0x2019: 0x0ad1, // XK_rightsinglequotemark
    0x201a: 0x0afd, // XK_singlelowquotemark
    0x201c: 0x0ad2, // XK_leftdoublequotemark
    0x201d: 0x0ad3, // XK_rightdoublequotemark
    0x201e: 0x0afe, // XK_doublelowquotemark
    0x2020: 0x0af1, // XK_dagger
    0x2021: 0x0af2, // XK_doubledagger
    0x2022: 0x0ae6, // XK_enfilledcircbullet
    0x2025: 0x0aaf, // XK_doubbaselinedot
    0x2026: 0x0aae, // XK_ellipsis
    0x2030: 0x0ad5, // XK_permille
    0x2032: 0x0ad6, // XK_minutes
    0x2033: 0x0ad7, // XK_seconds
    0x2038: 0x0afc, // XK_caret
    0x203e: 0x047e, // XK_overline
    0x20a9: 0x0eff, // XK_Korean_Won
    0x20ac: 0x20ac, // XK_EuroSign
    0x2105: 0x0ab8, // XK_careof
    0x2116: 0x06b0, // XK_numerosign
    0x2117: 0x0afb, // XK_phonographcopyright
    0x211e: 0x0ad4, // XK_prescription
    0x2122: 0x0ac9, // XK_trademark
    0x2153: 0x0ab0, // XK_onethird
    0x2154: 0x0ab1, // XK_twothirds
    0x2155: 0x0ab2, // XK_onefifth
    0x2156: 0x0ab3, // XK_twofifths
    0x2157: 0x0ab4, // XK_threefifths
    0x2158: 0x0ab5, // XK_fourfifths
    0x2159: 0x0ab6, // XK_onesixth
    0x215a: 0x0ab7, // XK_fivesixths
    0x215b: 0x0ac3, // XK_oneeighth
    0x215c: 0x0ac4, // XK_threeeighths
    0x215d: 0x0ac5, // XK_fiveeighths
    0x215e: 0x0ac6, // XK_seveneighths
    0x2190: 0x08fb, // XK_leftarrow
    0x2191: 0x08fc, // XK_uparrow
    0x2192: 0x08fd, // XK_rightarrow
    0x2193: 0x08fe, // XK_downarrow
    0x21d2: 0x08ce, // XK_implies
    0x21d4: 0x08cd, // XK_ifonlyif
    0x2202: 0x08ef, // XK_partialderivative
    0x2207: 0x08c5, // XK_nabla
    0x2218: 0x0bca, // XK_jot
    0x221a: 0x08d6, // XK_radical
    0x221d: 0x08c1, // XK_variation
    0x221e: 0x08c2, // XK_infinity
    0x2227: 0x08de, // XK_logicaland
    0x2228: 0x08df, // XK_logicalor
    0x2229: 0x08dc, // XK_intersection
    0x222a: 0x08dd, // XK_union
    0x222b: 0x08bf, // XK_integral
    0x2234: 0x08c0, // XK_therefore
    0x223c: 0x08c8, // XK_approximate
    0x2243: 0x08c9, // XK_similarequal
    0x2245: 0x1002248, // XK_approxeq
    0x2260: 0x08bd, // XK_notequal
    0x2261: 0x08cf, // XK_identical
    0x2264: 0x08bc, // XK_lessthanequal
    0x2265: 0x08be, // XK_greaterthanequal
    0x2282: 0x08da, // XK_includedin
    0x2283: 0x08db, // XK_includes
    0x22a2: 0x0bfc, // XK_righttack
    0x22a3: 0x0bdc, // XK_lefttack
    0x22a4: 0x0bc2, // XK_downtack
    0x22a5: 0x0bce, // XK_uptack
    0x2308: 0x0bd3, // XK_upstile
    0x230a: 0x0bc4, // XK_downstile
    0x2315: 0x0afa, // XK_telephonerecorder
    0x2320: 0x08a4, // XK_topintegral
    0x2321: 0x08a5, // XK_botintegral
    0x2395: 0x0bcc, // XK_quad
    0x239b: 0x08ab, // XK_topleftparens
    0x239d: 0x08ac, // XK_botleftparens
    0x239e: 0x08ad, // XK_toprightparens
    0x23a0: 0x08ae, // XK_botrightparens
    0x23a1: 0x08a7, // XK_topleftsqbracket
    0x23a3: 0x08a8, // XK_botleftsqbracket
    0x23a4: 0x08a9, // XK_toprightsqbracket
    0x23a6: 0x08aa, // XK_botrightsqbracket
    0x23a8: 0x08af, // XK_leftmiddlecurlybrace
    0x23ac: 0x08b0, // XK_rightmiddlecurlybrace
    0x23b7: 0x08a1, // XK_leftradical
    0x23ba: 0x09ef, // XK_horizlinescan1
    0x23bb: 0x09f0, // XK_horizlinescan3
    0x23bc: 0x09f2, // XK_horizlinescan7
    0x23bd: 0x09f3, // XK_horizlinescan9
    0x2409: 0x09e2, // XK_ht
    0x240a: 0x09e5, // XK_lf
    0x240b: 0x09e9, // XK_vt
    0x240c: 0x09e3, // XK_ff
    0x240d: 0x09e4, // XK_cr
    0x2423: 0x0aac, // XK_signifblank
    0x2424: 0x09e8, // XK_nl
    0x2500: 0x08a3, // XK_horizconnector
    0x2502: 0x08a6, // XK_vertconnector
    0x250c: 0x08a2, // XK_topleftradical
    0x2510: 0x09eb, // XK_uprightcorner
    0x2514: 0x09ed, // XK_lowleftcorner
    0x2518: 0x09ea, // XK_lowrightcorner
    0x251c: 0x09f4, // XK_leftt
    0x2524: 0x09f5, // XK_rightt
    0x252c: 0x09f7, // XK_topt
    0x2534: 0x09f6, // XK_bott
    0x253c: 0x09ee, // XK_crossinglines
    0x2592: 0x09e1, // XK_checkerboard
    0x25aa: 0x0ae7, // XK_enfilledsqbullet
    0x25ab: 0x0ae1, // XK_enopensquarebullet
    0x25ac: 0x0adb, // XK_filledrectbullet
    0x25ad: 0x0ae2, // XK_openrectbullet
    0x25ae: 0x0adf, // XK_emfilledrect
    0x25af: 0x0acf, // XK_emopenrectangle
    0x25b2: 0x0ae8, // XK_filledtribulletup
    0x25b3: 0x0ae3, // XK_opentribulletup
    0x25b6: 0x0add, // XK_filledrighttribullet
    0x25b7: 0x0acd, // XK_rightopentriangle
    0x25bc: 0x0ae9, // XK_filledtribulletdown
    0x25bd: 0x0ae4, // XK_opentribulletdown
    0x25c0: 0x0adc, // XK_filledlefttribullet
    0x25c1: 0x0acc, // XK_leftopentriangle
    0x25c6: 0x09e0, // XK_soliddiamond
    0x25cb: 0x0ace, // XK_emopencircle
    0x25cf: 0x0ade, // XK_emfilledcircle
    0x25e6: 0x0ae0, // XK_enopencircbullet
    0x2606: 0x0ae5, // XK_openstar
    0x260e: 0x0af9, // XK_telephone
    0x2613: 0x0aca, // XK_signaturemark
    0x261c: 0x0aea, // XK_leftpointer
    0x261e: 0x0aeb, // XK_rightpointer
    0x2640: 0x0af8, // XK_femalesymbol
    0x2642: 0x0af7, // XK_malesymbol
    0x2663: 0x0aec, // XK_club
    0x2665: 0x0aee, // XK_heart
    0x2666: 0x0aed, // XK_diamond
    0x266d: 0x0af6, // XK_musicalflat
    0x266f: 0x0af5, // XK_musicalsharp
    0x2713: 0x0af3, // XK_checkmark
    0x2717: 0x0af4, // XK_ballotcross
    0x271d: 0x0ad9, // XK_latincross
    0x2720: 0x0af0, // XK_maltesecross
    0x27e8: 0x0abc, // XK_leftanglebracket
    0x27e9: 0x0abe, // XK_rightanglebracket
    0x3001: 0x04a4, // XK_kana_comma
    0x3002: 0x04a1, // XK_kana_fullstop
    0x300c: 0x04a2, // XK_kana_openingbracket
    0x300d: 0x04a3, // XK_kana_closingbracket
    0x309b: 0x04de, // XK_voicedsound
    0x309c: 0x04df, // XK_semivoicedsound
    0x30a1: 0x04a7, // XK_kana_a
    0x30a2: 0x04b1, // XK_kana_A
    0x30a3: 0x04a8, // XK_kana_i
    0x30a4: 0x04b2, // XK_kana_I
    0x30a5: 0x04a9, // XK_kana_u
    0x30a6: 0x04b3, // XK_kana_U
    0x30a7: 0x04aa, // XK_kana_e
    0x30a8: 0x04b4, // XK_kana_E
    0x30a9: 0x04ab, // XK_kana_o
    0x30aa: 0x04b5, // XK_kana_O
    0x30ab: 0x04b6, // XK_kana_KA
    0x30ad: 0x04b7, // XK_kana_KI
    0x30af: 0x04b8, // XK_kana_KU
    0x30b1: 0x04b9, // XK_kana_KE
    0x30b3: 0x04ba, // XK_kana_KO
    0x30b5: 0x04bb, // XK_kana_SA
    0x30b7: 0x04bc, // XK_kana_SHI
    0x30b9: 0x04bd, // XK_kana_SU
    0x30bb: 0x04be, // XK_kana_SE
    0x30bd: 0x04bf, // XK_kana_SO
    0x30bf: 0x04c0, // XK_kana_TA
    0x30c1: 0x04c1, // XK_kana_CHI
    0x30c3: 0x04af, // XK_kana_tsu
    0x30c4: 0x04c2, // XK_kana_TSU
    0x30c6: 0x04c3, // XK_kana_TE
    0x30c8: 0x04c4, // XK_kana_TO
    0x30ca: 0x04c5, // XK_kana_NA
    0x30cb: 0x04c6, // XK_kana_NI
    0x30cc: 0x04c7, // XK_kana_NU
    0x30cd: 0x04c8, // XK_kana_NE
    0x30ce: 0x04c9, // XK_kana_NO
    0x30cf: 0x04ca, // XK_kana_HA
    0x30d2: 0x04cb, // XK_kana_HI
    0x30d5: 0x04cc, // XK_kana_FU
    0x30d8: 0x04cd, // XK_kana_HE
    0x30db: 0x04ce, // XK_kana_HO
    0x30de: 0x04cf, // XK_kana_MA
    0x30df: 0x04d0, // XK_kana_MI
    0x30e0: 0x04d1, // XK_kana_MU
    0x30e1: 0x04d2, // XK_kana_ME
    0x30e2: 0x04d3, // XK_kana_MO
    0x30e3: 0x04ac, // XK_kana_ya
    0x30e4: 0x04d4, // XK_kana_YA
    0x30e5: 0x04ad, // XK_kana_yu
    0x30e6: 0x04d5, // XK_kana_YU
    0x30e7: 0x04ae, // XK_kana_yo
    0x30e8: 0x04d6, // XK_kana_YO
    0x30e9: 0x04d7, // XK_kana_RA
    0x30ea: 0x04d8, // XK_kana_RI
    0x30eb: 0x04d9, // XK_kana_RU
    0x30ec: 0x04da, // XK_kana_RE
    0x30ed: 0x04db, // XK_kana_RO
    0x30ef: 0x04dc, // XK_kana_WA
    0x30f2: 0x04a6, // XK_kana_WO
    0x30f3: 0x04dd, // XK_kana_N
    0x30fb: 0x04a5, // XK_kana_conjunctive
    0x30fc: 0x04b0, // XK_prolongedsound
};

/* harmony default export */ __webpack_exports__["default"] = ({
    lookup(u) {
        // Latin-1 is one-to-one mapping
        if ((u >= 0x20) && (u <= 0xff)) {
            return u;
        }

        // Lookup table (fairly random)
        const keysym = codepoints[u];
        if (keysym !== undefined) {
            return keysym;
        }

        // General mapping as final fallback
        return 0x01000000 | u;
    },
});


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/input/mouse.js":
/*!*******************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/input/mouse.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Mouse; });
/* harmony import */ var _util_logging_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../util/logging.js */ "./node_modules/@novnc/novnc/core/util/logging.js");
/* harmony import */ var _util_browser_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../util/browser.js */ "./node_modules/@novnc/novnc/core/util/browser.js");
/* harmony import */ var _util_events_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../util/events.js */ "./node_modules/@novnc/novnc/core/util/events.js");
/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2018 The noVNC Authors
 * Licensed under MPL 2.0 or any later version (see LICENSE.txt)
 */





const WHEEL_STEP = 10; // Delta threshold for a mouse wheel step
const WHEEL_STEP_TIMEOUT = 50; // ms
const WHEEL_LINE_HEIGHT = 19;

class Mouse {
    constructor(target) {
        this._target = target || document;

        this._doubleClickTimer = null;
        this._lastTouchPos = null;

        this._pos = null;
        this._wheelStepXTimer = null;
        this._wheelStepYTimer = null;
        this._accumulatedWheelDeltaX = 0;
        this._accumulatedWheelDeltaY = 0;

        this._eventHandlers = {
            'mousedown': this._handleMouseDown.bind(this),
            'mouseup': this._handleMouseUp.bind(this),
            'mousemove': this._handleMouseMove.bind(this),
            'mousewheel': this._handleMouseWheel.bind(this),
            'mousedisable': this._handleMouseDisable.bind(this)
        };

        // ===== PROPERTIES =====

        this.touchButton = 1;                 // Button mask (1, 2, 4) for touch devices (0 means ignore clicks)

        // ===== EVENT HANDLERS =====

        this.onmousebutton = () => {}; // Handler for mouse button click/release
        this.onmousemove = () => {}; // Handler for mouse movement
    }

    // ===== PRIVATE METHODS =====

    _resetDoubleClickTimer() {
        this._doubleClickTimer = null;
    }

    _handleMouseButton(e, down) {
        this._updateMousePosition(e);
        let pos = this._pos;

        let bmask;
        if (e.touches || e.changedTouches) {
            // Touch device

            // When two touches occur within 500 ms of each other and are
            // close enough together a double click is triggered.
            if (down == 1) {
                if (this._doubleClickTimer === null) {
                    this._lastTouchPos = pos;
                } else {
                    clearTimeout(this._doubleClickTimer);

                    // When the distance between the two touches is small enough
                    // force the position of the latter touch to the position of
                    // the first.

                    const xs = this._lastTouchPos.x - pos.x;
                    const ys = this._lastTouchPos.y - pos.y;
                    const d = Math.sqrt((xs * xs) + (ys * ys));

                    // The goal is to trigger on a certain physical width, the
                    // devicePixelRatio brings us a bit closer but is not optimal.
                    const threshold = 20 * (window.devicePixelRatio || 1);
                    if (d < threshold) {
                        pos = this._lastTouchPos;
                    }
                }
                this._doubleClickTimer = setTimeout(this._resetDoubleClickTimer.bind(this), 500);
            }
            bmask = this.touchButton;
            // If bmask is set
        } else if (e.which) {
            /* everything except IE */
            bmask = 1 << e.button;
        } else {
            /* IE including 9 */
            bmask = (e.button & 0x1) +      // Left
                    (e.button & 0x2) * 2 +  // Right
                    (e.button & 0x4) / 2;   // Middle
        }

        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("onmousebutton " + (down ? "down" : "up") +
                  ", x: " + pos.x + ", y: " + pos.y + ", bmask: " + bmask);
        this.onmousebutton(pos.x, pos.y, down, bmask);

        Object(_util_events_js__WEBPACK_IMPORTED_MODULE_2__["stopEvent"])(e);
    }

    _handleMouseDown(e) {
        // Touch events have implicit capture
        if (e.type === "mousedown") {
            Object(_util_events_js__WEBPACK_IMPORTED_MODULE_2__["setCapture"])(this._target);
        }

        this._handleMouseButton(e, 1);
    }

    _handleMouseUp(e) {
        this._handleMouseButton(e, 0);
    }

    // Mouse wheel events are sent in steps over VNC. This means that the VNC
    // protocol can't handle a wheel event with specific distance or speed.
    // Therefor, if we get a lot of small mouse wheel events we combine them.
    _generateWheelStepX() {

        if (this._accumulatedWheelDeltaX < 0) {
            this.onmousebutton(this._pos.x, this._pos.y, 1, 1 << 5);
            this.onmousebutton(this._pos.x, this._pos.y, 0, 1 << 5);
        } else if (this._accumulatedWheelDeltaX > 0) {
            this.onmousebutton(this._pos.x, this._pos.y, 1, 1 << 6);
            this.onmousebutton(this._pos.x, this._pos.y, 0, 1 << 6);
        }

        this._accumulatedWheelDeltaX = 0;
    }

    _generateWheelStepY() {

        if (this._accumulatedWheelDeltaY < 0) {
            this.onmousebutton(this._pos.x, this._pos.y, 1, 1 << 3);
            this.onmousebutton(this._pos.x, this._pos.y, 0, 1 << 3);
        } else if (this._accumulatedWheelDeltaY > 0) {
            this.onmousebutton(this._pos.x, this._pos.y, 1, 1 << 4);
            this.onmousebutton(this._pos.x, this._pos.y, 0, 1 << 4);
        }

        this._accumulatedWheelDeltaY = 0;
    }

    _resetWheelStepTimers() {
        window.clearTimeout(this._wheelStepXTimer);
        window.clearTimeout(this._wheelStepYTimer);
        this._wheelStepXTimer = null;
        this._wheelStepYTimer = null;
    }

    _handleMouseWheel(e) {
        this._resetWheelStepTimers();

        this._updateMousePosition(e);

        let dX = e.deltaX;
        let dY = e.deltaY;

        // Pixel units unless it's non-zero.
        // Note that if deltamode is line or page won't matter since we aren't
        // sending the mouse wheel delta to the server anyway.
        // The difference between pixel and line can be important however since
        // we have a threshold that can be smaller than the line height.
        if (e.deltaMode !== 0) {
            dX *= WHEEL_LINE_HEIGHT;
            dY *= WHEEL_LINE_HEIGHT;
        }

        this._accumulatedWheelDeltaX += dX;
        this._accumulatedWheelDeltaY += dY;

        // Generate a mouse wheel step event when the accumulated delta
        // for one of the axes is large enough.
        // Small delta events that do not pass the threshold get sent
        // after a timeout.
        if (Math.abs(this._accumulatedWheelDeltaX) > WHEEL_STEP) {
            this._generateWheelStepX();
        } else {
            this._wheelStepXTimer =
                window.setTimeout(this._generateWheelStepX.bind(this),
                                  WHEEL_STEP_TIMEOUT);
        }
        if (Math.abs(this._accumulatedWheelDeltaY) > WHEEL_STEP) {
            this._generateWheelStepY();
        } else {
            this._wheelStepYTimer =
                window.setTimeout(this._generateWheelStepY.bind(this),
                                  WHEEL_STEP_TIMEOUT);
        }

        Object(_util_events_js__WEBPACK_IMPORTED_MODULE_2__["stopEvent"])(e);
    }

    _handleMouseMove(e) {
        this._updateMousePosition(e);
        this.onmousemove(this._pos.x, this._pos.y);
        Object(_util_events_js__WEBPACK_IMPORTED_MODULE_2__["stopEvent"])(e);
    }

    _handleMouseDisable(e) {
        /*
         * Stop propagation if inside canvas area
         * Note: This is only needed for the 'click' event as it fails
         *       to fire properly for the target element so we have
         *       to listen on the document element instead.
         */
        if (e.target == this._target) {
            Object(_util_events_js__WEBPACK_IMPORTED_MODULE_2__["stopEvent"])(e);
        }
    }

    // Update coordinates relative to target
    _updateMousePosition(e) {
        e = Object(_util_events_js__WEBPACK_IMPORTED_MODULE_2__["getPointerEvent"])(e);
        const bounds = this._target.getBoundingClientRect();
        let x;
        let y;
        // Clip to target bounds
        if (e.clientX < bounds.left) {
            x = 0;
        } else if (e.clientX >= bounds.right) {
            x = bounds.width - 1;
        } else {
            x = e.clientX - bounds.left;
        }
        if (e.clientY < bounds.top) {
            y = 0;
        } else if (e.clientY >= bounds.bottom) {
            y = bounds.height - 1;
        } else {
            y = e.clientY - bounds.top;
        }
        this._pos = {x: x, y: y};
    }

    // ===== PUBLIC METHODS =====

    grab() {
        if (_util_browser_js__WEBPACK_IMPORTED_MODULE_1__["isTouchDevice"]) {
            this._target.addEventListener('touchstart', this._eventHandlers.mousedown);
            this._target.addEventListener('touchend', this._eventHandlers.mouseup);
            this._target.addEventListener('touchmove', this._eventHandlers.mousemove);
        }
        this._target.addEventListener('mousedown', this._eventHandlers.mousedown);
        this._target.addEventListener('mouseup', this._eventHandlers.mouseup);
        this._target.addEventListener('mousemove', this._eventHandlers.mousemove);
        this._target.addEventListener('wheel', this._eventHandlers.mousewheel);

        /* Prevent middle-click pasting (see above for why we bind to document) */
        document.addEventListener('click', this._eventHandlers.mousedisable);

        /* preventDefault() on mousedown doesn't stop this event for some
           reason so we have to explicitly block it */
        this._target.addEventListener('contextmenu', this._eventHandlers.mousedisable);
    }

    ungrab() {
        this._resetWheelStepTimers();

        if (_util_browser_js__WEBPACK_IMPORTED_MODULE_1__["isTouchDevice"]) {
            this._target.removeEventListener('touchstart', this._eventHandlers.mousedown);
            this._target.removeEventListener('touchend', this._eventHandlers.mouseup);
            this._target.removeEventListener('touchmove', this._eventHandlers.mousemove);
        }
        this._target.removeEventListener('mousedown', this._eventHandlers.mousedown);
        this._target.removeEventListener('mouseup', this._eventHandlers.mouseup);
        this._target.removeEventListener('mousemove', this._eventHandlers.mousemove);
        this._target.removeEventListener('wheel', this._eventHandlers.mousewheel);

        document.removeEventListener('click', this._eventHandlers.mousedisable);

        this._target.removeEventListener('contextmenu', this._eventHandlers.mousedisable);
    }
}


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/input/util.js":
/*!******************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/input/util.js ***!
  \******************************************************/
/*! exports provided: getKeycode, getKey, getKeysym */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKeycode", function() { return getKeycode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKey", function() { return getKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getKeysym", function() { return getKeysym; });
/* harmony import */ var _keysymdef_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./keysymdef.js */ "./node_modules/@novnc/novnc/core/input/keysymdef.js");
/* harmony import */ var _vkeys_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./vkeys.js */ "./node_modules/@novnc/novnc/core/input/vkeys.js");
/* harmony import */ var _fixedkeys_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./fixedkeys.js */ "./node_modules/@novnc/novnc/core/input/fixedkeys.js");
/* harmony import */ var _domkeytable_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./domkeytable.js */ "./node_modules/@novnc/novnc/core/input/domkeytable.js");
/* harmony import */ var _util_browser_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../util/browser.js */ "./node_modules/@novnc/novnc/core/util/browser.js");






// Get 'KeyboardEvent.code', handling legacy browsers
function getKeycode(evt) {
    // Are we getting proper key identifiers?
    // (unfortunately Firefox and Chrome are crappy here and gives
    // us an empty string on some platforms, rather than leaving it
    // undefined)
    if (evt.code) {
        // Mozilla isn't fully in sync with the spec yet
        switch (evt.code) {
            case 'OSLeft': return 'MetaLeft';
            case 'OSRight': return 'MetaRight';
        }

        return evt.code;
    }

    // The de-facto standard is to use Windows Virtual-Key codes
    // in the 'keyCode' field for non-printable characters. However
    // Webkit sets it to the same as charCode in 'keypress' events.
    if ((evt.type !== 'keypress') && (evt.keyCode in _vkeys_js__WEBPACK_IMPORTED_MODULE_1__["default"])) {
        let code = _vkeys_js__WEBPACK_IMPORTED_MODULE_1__["default"][evt.keyCode];

        // macOS has messed up this code for some reason
        if (_util_browser_js__WEBPACK_IMPORTED_MODULE_4__["isMac"]() && (code === 'ContextMenu')) {
            code = 'MetaRight';
        }

        // The keyCode doesn't distinguish between left and right
        // for the standard modifiers
        if (evt.location === 2) {
            switch (code) {
                case 'ShiftLeft': return 'ShiftRight';
                case 'ControlLeft': return 'ControlRight';
                case 'AltLeft': return 'AltRight';
            }
        }

        // Nor a bunch of the numpad keys
        if (evt.location === 3) {
            switch (code) {
                case 'Delete': return 'NumpadDecimal';
                case 'Insert': return 'Numpad0';
                case 'End': return 'Numpad1';
                case 'ArrowDown': return 'Numpad2';
                case 'PageDown': return 'Numpad3';
                case 'ArrowLeft': return 'Numpad4';
                case 'ArrowRight': return 'Numpad6';
                case 'Home': return 'Numpad7';
                case 'ArrowUp': return 'Numpad8';
                case 'PageUp': return 'Numpad9';
                case 'Enter': return 'NumpadEnter';
            }
        }

        return code;
    }

    return 'Unidentified';
}

// Get 'KeyboardEvent.key', handling legacy browsers
function getKey(evt) {
    // Are we getting a proper key value?
    if (evt.key !== undefined) {
        // IE and Edge use some ancient version of the spec
        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8860571/
        switch (evt.key) {
            case 'Spacebar': return ' ';
            case 'Esc': return 'Escape';
            case 'Scroll': return 'ScrollLock';
            case 'Win': return 'Meta';
            case 'Apps': return 'ContextMenu';
            case 'Up': return 'ArrowUp';
            case 'Left': return 'ArrowLeft';
            case 'Right': return 'ArrowRight';
            case 'Down': return 'ArrowDown';
            case 'Del': return 'Delete';
            case 'Divide': return '/';
            case 'Multiply': return '*';
            case 'Subtract': return '-';
            case 'Add': return '+';
            case 'Decimal': return evt.char;
        }

        // Mozilla isn't fully in sync with the spec yet
        switch (evt.key) {
            case 'OS': return 'Meta';
        }

        // iOS leaks some OS names
        switch (evt.key) {
            case 'UIKeyInputUpArrow': return 'ArrowUp';
            case 'UIKeyInputDownArrow': return 'ArrowDown';
            case 'UIKeyInputLeftArrow': return 'ArrowLeft';
            case 'UIKeyInputRightArrow': return 'ArrowRight';
            case 'UIKeyInputEscape': return 'Escape';
        }

        // IE and Edge have broken handling of AltGraph so we cannot
        // trust them for printable characters
        if ((evt.key.length !== 1) || (!_util_browser_js__WEBPACK_IMPORTED_MODULE_4__["isIE"]() && !_util_browser_js__WEBPACK_IMPORTED_MODULE_4__["isEdge"]())) {
            return evt.key;
        }
    }

    // Try to deduce it based on the physical key
    const code = getKeycode(evt);
    if (code in _fixedkeys_js__WEBPACK_IMPORTED_MODULE_2__["default"]) {
        return _fixedkeys_js__WEBPACK_IMPORTED_MODULE_2__["default"][code];
    }

    // If that failed, then see if we have a printable character
    if (evt.charCode) {
        return String.fromCharCode(evt.charCode);
    }

    // At this point we have nothing left to go on
    return 'Unidentified';
}

// Get the most reliable keysym value we can get from a key event
function getKeysym(evt) {
    const key = getKey(evt);

    if (key === 'Unidentified') {
        return null;
    }

    // First look up special keys
    if (key in _domkeytable_js__WEBPACK_IMPORTED_MODULE_3__["default"]) {
        let location = evt.location;

        // Safari screws up location for the right cmd key
        if ((key === 'Meta') && (location === 0)) {
            location = 2;
        }

        if ((location === undefined) || (location > 3)) {
            location = 0;
        }

        return _domkeytable_js__WEBPACK_IMPORTED_MODULE_3__["default"][key][location];
    }

    // Now we need to look at the Unicode symbol instead

    // Special key? (FIXME: Should have been caught earlier)
    if (key.length !== 1) {
        return null;
    }

    const codepoint = key.charCodeAt();
    if (codepoint) {
        return _keysymdef_js__WEBPACK_IMPORTED_MODULE_0__["default"].lookup(codepoint);
    }

    return null;
}


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/input/vkeys.js":
/*!*******************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/input/vkeys.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2018 The noVNC Authors
 * Licensed under MPL 2.0 or any later version (see LICENSE.txt)
 */

/*
 * Mapping between Microsoft® Windows® Virtual-Key codes and
 * HTML key codes.
 */

/* harmony default export */ __webpack_exports__["default"] = ({
    0x08: 'Backspace',
    0x09: 'Tab',
    0x0a: 'NumpadClear',
    0x0c: 'Numpad5', // IE11 sends evt.keyCode: 12 when numlock is off
    0x0d: 'Enter',
    0x10: 'ShiftLeft',
    0x11: 'ControlLeft',
    0x12: 'AltLeft',
    0x13: 'Pause',
    0x14: 'CapsLock',
    0x15: 'Lang1',
    0x19: 'Lang2',
    0x1b: 'Escape',
    0x1c: 'Convert',
    0x1d: 'NonConvert',
    0x20: 'Space',
    0x21: 'PageUp',
    0x22: 'PageDown',
    0x23: 'End',
    0x24: 'Home',
    0x25: 'ArrowLeft',
    0x26: 'ArrowUp',
    0x27: 'ArrowRight',
    0x28: 'ArrowDown',
    0x29: 'Select',
    0x2c: 'PrintScreen',
    0x2d: 'Insert',
    0x2e: 'Delete',
    0x2f: 'Help',
    0x30: 'Digit0',
    0x31: 'Digit1',
    0x32: 'Digit2',
    0x33: 'Digit3',
    0x34: 'Digit4',
    0x35: 'Digit5',
    0x36: 'Digit6',
    0x37: 'Digit7',
    0x38: 'Digit8',
    0x39: 'Digit9',
    0x5b: 'MetaLeft',
    0x5c: 'MetaRight',
    0x5d: 'ContextMenu',
    0x5f: 'Sleep',
    0x60: 'Numpad0',
    0x61: 'Numpad1',
    0x62: 'Numpad2',
    0x63: 'Numpad3',
    0x64: 'Numpad4',
    0x65: 'Numpad5',
    0x66: 'Numpad6',
    0x67: 'Numpad7',
    0x68: 'Numpad8',
    0x69: 'Numpad9',
    0x6a: 'NumpadMultiply',
    0x6b: 'NumpadAdd',
    0x6c: 'NumpadDecimal',
    0x6d: 'NumpadSubtract',
    0x6e: 'NumpadDecimal', // Duplicate, because buggy on Windows
    0x6f: 'NumpadDivide',
    0x70: 'F1',
    0x71: 'F2',
    0x72: 'F3',
    0x73: 'F4',
    0x74: 'F5',
    0x75: 'F6',
    0x76: 'F7',
    0x77: 'F8',
    0x78: 'F9',
    0x79: 'F10',
    0x7a: 'F11',
    0x7b: 'F12',
    0x7c: 'F13',
    0x7d: 'F14',
    0x7e: 'F15',
    0x7f: 'F16',
    0x80: 'F17',
    0x81: 'F18',
    0x82: 'F19',
    0x83: 'F20',
    0x84: 'F21',
    0x85: 'F22',
    0x86: 'F23',
    0x87: 'F24',
    0x90: 'NumLock',
    0x91: 'ScrollLock',
    0xa6: 'BrowserBack',
    0xa7: 'BrowserForward',
    0xa8: 'BrowserRefresh',
    0xa9: 'BrowserStop',
    0xaa: 'BrowserSearch',
    0xab: 'BrowserFavorites',
    0xac: 'BrowserHome',
    0xad: 'AudioVolumeMute',
    0xae: 'AudioVolumeDown',
    0xaf: 'AudioVolumeUp',
    0xb0: 'MediaTrackNext',
    0xb1: 'MediaTrackPrevious',
    0xb2: 'MediaStop',
    0xb3: 'MediaPlayPause',
    0xb4: 'LaunchMail',
    0xb5: 'MediaSelect',
    0xb6: 'LaunchApp1',
    0xb7: 'LaunchApp2',
    0xe1: 'AltRight', // Only when it is AltGraph
});


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/input/xtscancodes.js":
/*!*************************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/input/xtscancodes.js ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/*
 * This file is auto-generated from keymaps.csv on 2017-05-31 16:20
 * Database checksum sha256(92fd165507f2a3b8c5b3fa56e425d45788dbcb98cf067a307527d91ce22cab94)
 * To re-generate, run:
 *   keymap-gen --lang=js code-map keymaps.csv html atset1
*/
/* harmony default export */ __webpack_exports__["default"] = ({
  "Again": 0xe005, /* html:Again (Again) -> linux:129 (KEY_AGAIN) -> atset1:57349 */
  "AltLeft": 0x38, /* html:AltLeft (AltLeft) -> linux:56 (KEY_LEFTALT) -> atset1:56 */
  "AltRight": 0xe038, /* html:AltRight (AltRight) -> linux:100 (KEY_RIGHTALT) -> atset1:57400 */
  "ArrowDown": 0xe050, /* html:ArrowDown (ArrowDown) -> linux:108 (KEY_DOWN) -> atset1:57424 */
  "ArrowLeft": 0xe04b, /* html:ArrowLeft (ArrowLeft) -> linux:105 (KEY_LEFT) -> atset1:57419 */
  "ArrowRight": 0xe04d, /* html:ArrowRight (ArrowRight) -> linux:106 (KEY_RIGHT) -> atset1:57421 */
  "ArrowUp": 0xe048, /* html:ArrowUp (ArrowUp) -> linux:103 (KEY_UP) -> atset1:57416 */
  "AudioVolumeDown": 0xe02e, /* html:AudioVolumeDown (AudioVolumeDown) -> linux:114 (KEY_VOLUMEDOWN) -> atset1:57390 */
  "AudioVolumeMute": 0xe020, /* html:AudioVolumeMute (AudioVolumeMute) -> linux:113 (KEY_MUTE) -> atset1:57376 */
  "AudioVolumeUp": 0xe030, /* html:AudioVolumeUp (AudioVolumeUp) -> linux:115 (KEY_VOLUMEUP) -> atset1:57392 */
  "Backquote": 0x29, /* html:Backquote (Backquote) -> linux:41 (KEY_GRAVE) -> atset1:41 */
  "Backslash": 0x2b, /* html:Backslash (Backslash) -> linux:43 (KEY_BACKSLASH) -> atset1:43 */
  "Backspace": 0xe, /* html:Backspace (Backspace) -> linux:14 (KEY_BACKSPACE) -> atset1:14 */
  "BracketLeft": 0x1a, /* html:BracketLeft (BracketLeft) -> linux:26 (KEY_LEFTBRACE) -> atset1:26 */
  "BracketRight": 0x1b, /* html:BracketRight (BracketRight) -> linux:27 (KEY_RIGHTBRACE) -> atset1:27 */
  "BrowserBack": 0xe06a, /* html:BrowserBack (BrowserBack) -> linux:158 (KEY_BACK) -> atset1:57450 */
  "BrowserFavorites": 0xe066, /* html:BrowserFavorites (BrowserFavorites) -> linux:156 (KEY_BOOKMARKS) -> atset1:57446 */
  "BrowserForward": 0xe069, /* html:BrowserForward (BrowserForward) -> linux:159 (KEY_FORWARD) -> atset1:57449 */
  "BrowserHome": 0xe032, /* html:BrowserHome (BrowserHome) -> linux:172 (KEY_HOMEPAGE) -> atset1:57394 */
  "BrowserRefresh": 0xe067, /* html:BrowserRefresh (BrowserRefresh) -> linux:173 (KEY_REFRESH) -> atset1:57447 */
  "BrowserSearch": 0xe065, /* html:BrowserSearch (BrowserSearch) -> linux:217 (KEY_SEARCH) -> atset1:57445 */
  "BrowserStop": 0xe068, /* html:BrowserStop (BrowserStop) -> linux:128 (KEY_STOP) -> atset1:57448 */
  "CapsLock": 0x3a, /* html:CapsLock (CapsLock) -> linux:58 (KEY_CAPSLOCK) -> atset1:58 */
  "Comma": 0x33, /* html:Comma (Comma) -> linux:51 (KEY_COMMA) -> atset1:51 */
  "ContextMenu": 0xe05d, /* html:ContextMenu (ContextMenu) -> linux:127 (KEY_COMPOSE) -> atset1:57437 */
  "ControlLeft": 0x1d, /* html:ControlLeft (ControlLeft) -> linux:29 (KEY_LEFTCTRL) -> atset1:29 */
  "ControlRight": 0xe01d, /* html:ControlRight (ControlRight) -> linux:97 (KEY_RIGHTCTRL) -> atset1:57373 */
  "Convert": 0x79, /* html:Convert (Convert) -> linux:92 (KEY_HENKAN) -> atset1:121 */
  "Copy": 0xe078, /* html:Copy (Copy) -> linux:133 (KEY_COPY) -> atset1:57464 */
  "Cut": 0xe03c, /* html:Cut (Cut) -> linux:137 (KEY_CUT) -> atset1:57404 */
  "Delete": 0xe053, /* html:Delete (Delete) -> linux:111 (KEY_DELETE) -> atset1:57427 */
  "Digit0": 0xb, /* html:Digit0 (Digit0) -> linux:11 (KEY_0) -> atset1:11 */
  "Digit1": 0x2, /* html:Digit1 (Digit1) -> linux:2 (KEY_1) -> atset1:2 */
  "Digit2": 0x3, /* html:Digit2 (Digit2) -> linux:3 (KEY_2) -> atset1:3 */
  "Digit3": 0x4, /* html:Digit3 (Digit3) -> linux:4 (KEY_3) -> atset1:4 */
  "Digit4": 0x5, /* html:Digit4 (Digit4) -> linux:5 (KEY_4) -> atset1:5 */
  "Digit5": 0x6, /* html:Digit5 (Digit5) -> linux:6 (KEY_5) -> atset1:6 */
  "Digit6": 0x7, /* html:Digit6 (Digit6) -> linux:7 (KEY_6) -> atset1:7 */
  "Digit7": 0x8, /* html:Digit7 (Digit7) -> linux:8 (KEY_7) -> atset1:8 */
  "Digit8": 0x9, /* html:Digit8 (Digit8) -> linux:9 (KEY_8) -> atset1:9 */
  "Digit9": 0xa, /* html:Digit9 (Digit9) -> linux:10 (KEY_9) -> atset1:10 */
  "Eject": 0xe07d, /* html:Eject (Eject) -> linux:162 (KEY_EJECTCLOSECD) -> atset1:57469 */
  "End": 0xe04f, /* html:End (End) -> linux:107 (KEY_END) -> atset1:57423 */
  "Enter": 0x1c, /* html:Enter (Enter) -> linux:28 (KEY_ENTER) -> atset1:28 */
  "Equal": 0xd, /* html:Equal (Equal) -> linux:13 (KEY_EQUAL) -> atset1:13 */
  "Escape": 0x1, /* html:Escape (Escape) -> linux:1 (KEY_ESC) -> atset1:1 */
  "F1": 0x3b, /* html:F1 (F1) -> linux:59 (KEY_F1) -> atset1:59 */
  "F10": 0x44, /* html:F10 (F10) -> linux:68 (KEY_F10) -> atset1:68 */
  "F11": 0x57, /* html:F11 (F11) -> linux:87 (KEY_F11) -> atset1:87 */
  "F12": 0x58, /* html:F12 (F12) -> linux:88 (KEY_F12) -> atset1:88 */
  "F13": 0x5d, /* html:F13 (F13) -> linux:183 (KEY_F13) -> atset1:93 */
  "F14": 0x5e, /* html:F14 (F14) -> linux:184 (KEY_F14) -> atset1:94 */
  "F15": 0x5f, /* html:F15 (F15) -> linux:185 (KEY_F15) -> atset1:95 */
  "F16": 0x55, /* html:F16 (F16) -> linux:186 (KEY_F16) -> atset1:85 */
  "F17": 0xe003, /* html:F17 (F17) -> linux:187 (KEY_F17) -> atset1:57347 */
  "F18": 0xe077, /* html:F18 (F18) -> linux:188 (KEY_F18) -> atset1:57463 */
  "F19": 0xe004, /* html:F19 (F19) -> linux:189 (KEY_F19) -> atset1:57348 */
  "F2": 0x3c, /* html:F2 (F2) -> linux:60 (KEY_F2) -> atset1:60 */
  "F20": 0x5a, /* html:F20 (F20) -> linux:190 (KEY_F20) -> atset1:90 */
  "F21": 0x74, /* html:F21 (F21) -> linux:191 (KEY_F21) -> atset1:116 */
  "F22": 0xe079, /* html:F22 (F22) -> linux:192 (KEY_F22) -> atset1:57465 */
  "F23": 0x6d, /* html:F23 (F23) -> linux:193 (KEY_F23) -> atset1:109 */
  "F24": 0x6f, /* html:F24 (F24) -> linux:194 (KEY_F24) -> atset1:111 */
  "F3": 0x3d, /* html:F3 (F3) -> linux:61 (KEY_F3) -> atset1:61 */
  "F4": 0x3e, /* html:F4 (F4) -> linux:62 (KEY_F4) -> atset1:62 */
  "F5": 0x3f, /* html:F5 (F5) -> linux:63 (KEY_F5) -> atset1:63 */
  "F6": 0x40, /* html:F6 (F6) -> linux:64 (KEY_F6) -> atset1:64 */
  "F7": 0x41, /* html:F7 (F7) -> linux:65 (KEY_F7) -> atset1:65 */
  "F8": 0x42, /* html:F8 (F8) -> linux:66 (KEY_F8) -> atset1:66 */
  "F9": 0x43, /* html:F9 (F9) -> linux:67 (KEY_F9) -> atset1:67 */
  "Find": 0xe041, /* html:Find (Find) -> linux:136 (KEY_FIND) -> atset1:57409 */
  "Help": 0xe075, /* html:Help (Help) -> linux:138 (KEY_HELP) -> atset1:57461 */
  "Hiragana": 0x77, /* html:Hiragana (Lang4) -> linux:91 (KEY_HIRAGANA) -> atset1:119 */
  "Home": 0xe047, /* html:Home (Home) -> linux:102 (KEY_HOME) -> atset1:57415 */
  "Insert": 0xe052, /* html:Insert (Insert) -> linux:110 (KEY_INSERT) -> atset1:57426 */
  "IntlBackslash": 0x56, /* html:IntlBackslash (IntlBackslash) -> linux:86 (KEY_102ND) -> atset1:86 */
  "IntlRo": 0x73, /* html:IntlRo (IntlRo) -> linux:89 (KEY_RO) -> atset1:115 */
  "IntlYen": 0x7d, /* html:IntlYen (IntlYen) -> linux:124 (KEY_YEN) -> atset1:125 */
  "KanaMode": 0x70, /* html:KanaMode (KanaMode) -> linux:93 (KEY_KATAKANAHIRAGANA) -> atset1:112 */
  "Katakana": 0x78, /* html:Katakana (Lang3) -> linux:90 (KEY_KATAKANA) -> atset1:120 */
  "KeyA": 0x1e, /* html:KeyA (KeyA) -> linux:30 (KEY_A) -> atset1:30 */
  "KeyB": 0x30, /* html:KeyB (KeyB) -> linux:48 (KEY_B) -> atset1:48 */
  "KeyC": 0x2e, /* html:KeyC (KeyC) -> linux:46 (KEY_C) -> atset1:46 */
  "KeyD": 0x20, /* html:KeyD (KeyD) -> linux:32 (KEY_D) -> atset1:32 */
  "KeyE": 0x12, /* html:KeyE (KeyE) -> linux:18 (KEY_E) -> atset1:18 */
  "KeyF": 0x21, /* html:KeyF (KeyF) -> linux:33 (KEY_F) -> atset1:33 */
  "KeyG": 0x22, /* html:KeyG (KeyG) -> linux:34 (KEY_G) -> atset1:34 */
  "KeyH": 0x23, /* html:KeyH (KeyH) -> linux:35 (KEY_H) -> atset1:35 */
  "KeyI": 0x17, /* html:KeyI (KeyI) -> linux:23 (KEY_I) -> atset1:23 */
  "KeyJ": 0x24, /* html:KeyJ (KeyJ) -> linux:36 (KEY_J) -> atset1:36 */
  "KeyK": 0x25, /* html:KeyK (KeyK) -> linux:37 (KEY_K) -> atset1:37 */
  "KeyL": 0x26, /* html:KeyL (KeyL) -> linux:38 (KEY_L) -> atset1:38 */
  "KeyM": 0x32, /* html:KeyM (KeyM) -> linux:50 (KEY_M) -> atset1:50 */
  "KeyN": 0x31, /* html:KeyN (KeyN) -> linux:49 (KEY_N) -> atset1:49 */
  "KeyO": 0x18, /* html:KeyO (KeyO) -> linux:24 (KEY_O) -> atset1:24 */
  "KeyP": 0x19, /* html:KeyP (KeyP) -> linux:25 (KEY_P) -> atset1:25 */
  "KeyQ": 0x10, /* html:KeyQ (KeyQ) -> linux:16 (KEY_Q) -> atset1:16 */
  "KeyR": 0x13, /* html:KeyR (KeyR) -> linux:19 (KEY_R) -> atset1:19 */
  "KeyS": 0x1f, /* html:KeyS (KeyS) -> linux:31 (KEY_S) -> atset1:31 */
  "KeyT": 0x14, /* html:KeyT (KeyT) -> linux:20 (KEY_T) -> atset1:20 */
  "KeyU": 0x16, /* html:KeyU (KeyU) -> linux:22 (KEY_U) -> atset1:22 */
  "KeyV": 0x2f, /* html:KeyV (KeyV) -> linux:47 (KEY_V) -> atset1:47 */
  "KeyW": 0x11, /* html:KeyW (KeyW) -> linux:17 (KEY_W) -> atset1:17 */
  "KeyX": 0x2d, /* html:KeyX (KeyX) -> linux:45 (KEY_X) -> atset1:45 */
  "KeyY": 0x15, /* html:KeyY (KeyY) -> linux:21 (KEY_Y) -> atset1:21 */
  "KeyZ": 0x2c, /* html:KeyZ (KeyZ) -> linux:44 (KEY_Z) -> atset1:44 */
  "Lang3": 0x78, /* html:Lang3 (Lang3) -> linux:90 (KEY_KATAKANA) -> atset1:120 */
  "Lang4": 0x77, /* html:Lang4 (Lang4) -> linux:91 (KEY_HIRAGANA) -> atset1:119 */
  "Lang5": 0x76, /* html:Lang5 (Lang5) -> linux:85 (KEY_ZENKAKUHANKAKU) -> atset1:118 */
  "LaunchApp1": 0xe06b, /* html:LaunchApp1 (LaunchApp1) -> linux:157 (KEY_COMPUTER) -> atset1:57451 */
  "LaunchApp2": 0xe021, /* html:LaunchApp2 (LaunchApp2) -> linux:140 (KEY_CALC) -> atset1:57377 */
  "LaunchMail": 0xe06c, /* html:LaunchMail (LaunchMail) -> linux:155 (KEY_MAIL) -> atset1:57452 */
  "MediaPlayPause": 0xe022, /* html:MediaPlayPause (MediaPlayPause) -> linux:164 (KEY_PLAYPAUSE) -> atset1:57378 */
  "MediaSelect": 0xe06d, /* html:MediaSelect (MediaSelect) -> linux:226 (KEY_MEDIA) -> atset1:57453 */
  "MediaStop": 0xe024, /* html:MediaStop (MediaStop) -> linux:166 (KEY_STOPCD) -> atset1:57380 */
  "MediaTrackNext": 0xe019, /* html:MediaTrackNext (MediaTrackNext) -> linux:163 (KEY_NEXTSONG) -> atset1:57369 */
  "MediaTrackPrevious": 0xe010, /* html:MediaTrackPrevious (MediaTrackPrevious) -> linux:165 (KEY_PREVIOUSSONG) -> atset1:57360 */
  "MetaLeft": 0xe05b, /* html:MetaLeft (MetaLeft) -> linux:125 (KEY_LEFTMETA) -> atset1:57435 */
  "MetaRight": 0xe05c, /* html:MetaRight (MetaRight) -> linux:126 (KEY_RIGHTMETA) -> atset1:57436 */
  "Minus": 0xc, /* html:Minus (Minus) -> linux:12 (KEY_MINUS) -> atset1:12 */
  "NonConvert": 0x7b, /* html:NonConvert (NonConvert) -> linux:94 (KEY_MUHENKAN) -> atset1:123 */
  "NumLock": 0x45, /* html:NumLock (NumLock) -> linux:69 (KEY_NUMLOCK) -> atset1:69 */
  "Numpad0": 0x52, /* html:Numpad0 (Numpad0) -> linux:82 (KEY_KP0) -> atset1:82 */
  "Numpad1": 0x4f, /* html:Numpad1 (Numpad1) -> linux:79 (KEY_KP1) -> atset1:79 */
  "Numpad2": 0x50, /* html:Numpad2 (Numpad2) -> linux:80 (KEY_KP2) -> atset1:80 */
  "Numpad3": 0x51, /* html:Numpad3 (Numpad3) -> linux:81 (KEY_KP3) -> atset1:81 */
  "Numpad4": 0x4b, /* html:Numpad4 (Numpad4) -> linux:75 (KEY_KP4) -> atset1:75 */
  "Numpad5": 0x4c, /* html:Numpad5 (Numpad5) -> linux:76 (KEY_KP5) -> atset1:76 */
  "Numpad6": 0x4d, /* html:Numpad6 (Numpad6) -> linux:77 (KEY_KP6) -> atset1:77 */
  "Numpad7": 0x47, /* html:Numpad7 (Numpad7) -> linux:71 (KEY_KP7) -> atset1:71 */
  "Numpad8": 0x48, /* html:Numpad8 (Numpad8) -> linux:72 (KEY_KP8) -> atset1:72 */
  "Numpad9": 0x49, /* html:Numpad9 (Numpad9) -> linux:73 (KEY_KP9) -> atset1:73 */
  "NumpadAdd": 0x4e, /* html:NumpadAdd (NumpadAdd) -> linux:78 (KEY_KPPLUS) -> atset1:78 */
  "NumpadComma": 0x7e, /* html:NumpadComma (NumpadComma) -> linux:121 (KEY_KPCOMMA) -> atset1:126 */
  "NumpadDecimal": 0x53, /* html:NumpadDecimal (NumpadDecimal) -> linux:83 (KEY_KPDOT) -> atset1:83 */
  "NumpadDivide": 0xe035, /* html:NumpadDivide (NumpadDivide) -> linux:98 (KEY_KPSLASH) -> atset1:57397 */
  "NumpadEnter": 0xe01c, /* html:NumpadEnter (NumpadEnter) -> linux:96 (KEY_KPENTER) -> atset1:57372 */
  "NumpadEqual": 0x59, /* html:NumpadEqual (NumpadEqual) -> linux:117 (KEY_KPEQUAL) -> atset1:89 */
  "NumpadMultiply": 0x37, /* html:NumpadMultiply (NumpadMultiply) -> linux:55 (KEY_KPASTERISK) -> atset1:55 */
  "NumpadParenLeft": 0xe076, /* html:NumpadParenLeft (NumpadParenLeft) -> linux:179 (KEY_KPLEFTPAREN) -> atset1:57462 */
  "NumpadParenRight": 0xe07b, /* html:NumpadParenRight (NumpadParenRight) -> linux:180 (KEY_KPRIGHTPAREN) -> atset1:57467 */
  "NumpadSubtract": 0x4a, /* html:NumpadSubtract (NumpadSubtract) -> linux:74 (KEY_KPMINUS) -> atset1:74 */
  "Open": 0x64, /* html:Open (Open) -> linux:134 (KEY_OPEN) -> atset1:100 */
  "PageDown": 0xe051, /* html:PageDown (PageDown) -> linux:109 (KEY_PAGEDOWN) -> atset1:57425 */
  "PageUp": 0xe049, /* html:PageUp (PageUp) -> linux:104 (KEY_PAGEUP) -> atset1:57417 */
  "Paste": 0x65, /* html:Paste (Paste) -> linux:135 (KEY_PASTE) -> atset1:101 */
  "Pause": 0xe046, /* html:Pause (Pause) -> linux:119 (KEY_PAUSE) -> atset1:57414 */
  "Period": 0x34, /* html:Period (Period) -> linux:52 (KEY_DOT) -> atset1:52 */
  "Power": 0xe05e, /* html:Power (Power) -> linux:116 (KEY_POWER) -> atset1:57438 */
  "PrintScreen": 0x54, /* html:PrintScreen (PrintScreen) -> linux:99 (KEY_SYSRQ) -> atset1:84 */
  "Props": 0xe006, /* html:Props (Props) -> linux:130 (KEY_PROPS) -> atset1:57350 */
  "Quote": 0x28, /* html:Quote (Quote) -> linux:40 (KEY_APOSTROPHE) -> atset1:40 */
  "ScrollLock": 0x46, /* html:ScrollLock (ScrollLock) -> linux:70 (KEY_SCROLLLOCK) -> atset1:70 */
  "Semicolon": 0x27, /* html:Semicolon (Semicolon) -> linux:39 (KEY_SEMICOLON) -> atset1:39 */
  "ShiftLeft": 0x2a, /* html:ShiftLeft (ShiftLeft) -> linux:42 (KEY_LEFTSHIFT) -> atset1:42 */
  "ShiftRight": 0x36, /* html:ShiftRight (ShiftRight) -> linux:54 (KEY_RIGHTSHIFT) -> atset1:54 */
  "Slash": 0x35, /* html:Slash (Slash) -> linux:53 (KEY_SLASH) -> atset1:53 */
  "Sleep": 0xe05f, /* html:Sleep (Sleep) -> linux:142 (KEY_SLEEP) -> atset1:57439 */
  "Space": 0x39, /* html:Space (Space) -> linux:57 (KEY_SPACE) -> atset1:57 */
  "Suspend": 0xe025, /* html:Suspend (Suspend) -> linux:205 (KEY_SUSPEND) -> atset1:57381 */
  "Tab": 0xf, /* html:Tab (Tab) -> linux:15 (KEY_TAB) -> atset1:15 */
  "Undo": 0xe007, /* html:Undo (Undo) -> linux:131 (KEY_UNDO) -> atset1:57351 */
  "WakeUp": 0xe063, /* html:WakeUp (WakeUp) -> linux:143 (KEY_WAKEUP) -> atset1:57443 */
});


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/rfb.js":
/*!***********************************************!*\
  !*** ./node_modules/@novnc/novnc/core/rfb.js ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return RFB; });
/* harmony import */ var _util_logging_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/logging.js */ "./node_modules/@novnc/novnc/core/util/logging.js");
/* harmony import */ var _util_strings_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util/strings.js */ "./node_modules/@novnc/novnc/core/util/strings.js");
/* harmony import */ var _util_browser_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util/browser.js */ "./node_modules/@novnc/novnc/core/util/browser.js");
/* harmony import */ var _util_eventtarget_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./util/eventtarget.js */ "./node_modules/@novnc/novnc/core/util/eventtarget.js");
/* harmony import */ var _display_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./display.js */ "./node_modules/@novnc/novnc/core/display.js");
/* harmony import */ var _input_keyboard_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./input/keyboard.js */ "./node_modules/@novnc/novnc/core/input/keyboard.js");
/* harmony import */ var _input_mouse_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./input/mouse.js */ "./node_modules/@novnc/novnc/core/input/mouse.js");
/* harmony import */ var _util_cursor_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./util/cursor.js */ "./node_modules/@novnc/novnc/core/util/cursor.js");
/* harmony import */ var _websock_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./websock.js */ "./node_modules/@novnc/novnc/core/websock.js");
/* harmony import */ var _des_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./des.js */ "./node_modules/@novnc/novnc/core/des.js");
/* harmony import */ var _input_keysym_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./input/keysym.js */ "./node_modules/@novnc/novnc/core/input/keysym.js");
/* harmony import */ var _input_xtscancodes_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./input/xtscancodes.js */ "./node_modules/@novnc/novnc/core/input/xtscancodes.js");
/* harmony import */ var _encodings_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./encodings.js */ "./node_modules/@novnc/novnc/core/encodings.js");
/* harmony import */ var _util_polyfill_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./util/polyfill.js */ "./node_modules/@novnc/novnc/core/util/polyfill.js");
/* harmony import */ var _util_polyfill_js__WEBPACK_IMPORTED_MODULE_13___default = /*#__PURE__*/__webpack_require__.n(_util_polyfill_js__WEBPACK_IMPORTED_MODULE_13__);
/* harmony import */ var _decoders_raw_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./decoders/raw.js */ "./node_modules/@novnc/novnc/core/decoders/raw.js");
/* harmony import */ var _decoders_copyrect_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./decoders/copyrect.js */ "./node_modules/@novnc/novnc/core/decoders/copyrect.js");
/* harmony import */ var _decoders_rre_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./decoders/rre.js */ "./node_modules/@novnc/novnc/core/decoders/rre.js");
/* harmony import */ var _decoders_hextile_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ./decoders/hextile.js */ "./node_modules/@novnc/novnc/core/decoders/hextile.js");
/* harmony import */ var _decoders_tight_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./decoders/tight.js */ "./node_modules/@novnc/novnc/core/decoders/tight.js");
/* harmony import */ var _decoders_tightpng_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./decoders/tightpng.js */ "./node_modules/@novnc/novnc/core/decoders/tightpng.js");
/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2018 The noVNC Authors
 * Licensed under MPL 2.0 (see LICENSE.txt)
 *
 * See README.md for usage and integration instructions.
 *
 */























// How many seconds to wait for a disconnect to finish
const DISCONNECT_TIMEOUT = 3;
const DEFAULT_BACKGROUND = 'rgb(40, 40, 40)';

class RFB extends _util_eventtarget_js__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor(target, url, options) {
        if (!target) {
            throw new Error("Must specify target");
        }
        if (!url) {
            throw new Error("Must specify URL");
        }

        super();

        this._target = target;
        this._url = url;

        // Connection details
        options = options || {};
        this._rfb_credentials = options.credentials || {};
        this._shared = 'shared' in options ? !!options.shared : true;
        this._repeaterID = options.repeaterID || '';
        this._showDotCursor = options.showDotCursor || false;

        // Internal state
        this._rfb_connection_state = '';
        this._rfb_init_state = '';
        this._rfb_auth_scheme = -1;
        this._rfb_clean_disconnect = true;

        // Server capabilities
        this._rfb_version = 0;
        this._rfb_max_version = 3.8;
        this._rfb_tightvnc = false;
        this._rfb_xvp_ver = 0;

        this._fb_width = 0;
        this._fb_height = 0;

        this._fb_name = "";

        this._capabilities = { power: false };

        this._supportsFence = false;

        this._supportsContinuousUpdates = false;
        this._enabledContinuousUpdates = false;

        this._supportsSetDesktopSize = false;
        this._screen_id = 0;
        this._screen_flags = 0;

        this._qemuExtKeyEventSupported = false;

        // Internal objects
        this._sock = null;              // Websock object
        this._display = null;           // Display object
        this._flushing = false;         // Display flushing state
        this._keyboard = null;          // Keyboard input handler object
        this._mouse = null;             // Mouse input handler object

        // Timers
        this._disconnTimer = null;      // disconnection timer
        this._resizeTimeout = null;     // resize rate limiting

        // Decoder states
        this._decoders = {};

        this._FBU = {
            rects: 0,
            x: 0,
            y: 0,
            width: 0,
            height: 0,
            encoding: null,
        };

        // Mouse state
        this._mouse_buttonMask = 0;
        this._mouse_arr = [];
        this._viewportDragging = false;
        this._viewportDragPos = {};
        this._viewportHasMoved = false;

        // Bound event handlers
        this._eventHandlers = {
            focusCanvas: this._focusCanvas.bind(this),
            windowResize: this._windowResize.bind(this),
        };

        // main setup
        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"](">> RFB.constructor");

        // Create DOM elements
        this._screen = document.createElement('div');
        this._screen.style.display = 'flex';
        this._screen.style.width = '100%';
        this._screen.style.height = '100%';
        this._screen.style.overflow = 'auto';
        this._screen.style.background = DEFAULT_BACKGROUND;
        this._canvas = document.createElement('canvas');
        this._canvas.style.margin = 'auto';
        // Some browsers add an outline on focus
        this._canvas.style.outline = 'none';
        // IE miscalculates width without this :(
        this._canvas.style.flexShrink = '0';
        this._canvas.width = 0;
        this._canvas.height = 0;
        this._canvas.tabIndex = -1;
        this._screen.appendChild(this._canvas);

        // Cursor
        this._cursor = new _util_cursor_js__WEBPACK_IMPORTED_MODULE_7__["default"]();

        // XXX: TightVNC 2.8.11 sends no cursor at all until Windows changes
        // it. Result: no cursor at all until a window border or an edit field
        // is hit blindly. But there are also VNC servers that draw the cursor
        // in the framebuffer and don't send the empty local cursor. There is
        // no way to satisfy both sides.
        //
        // The spec is unclear on this "initial cursor" issue. Many other
        // viewers (TigerVNC, RealVNC, Remmina) display an arrow as the
        // initial cursor instead.
        this._cursorImage = RFB.cursors.none;

        // populate decoder array with objects
        this._decoders[_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].encodingRaw] = new _decoders_raw_js__WEBPACK_IMPORTED_MODULE_14__["default"]();
        this._decoders[_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].encodingCopyRect] = new _decoders_copyrect_js__WEBPACK_IMPORTED_MODULE_15__["default"]();
        this._decoders[_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].encodingRRE] = new _decoders_rre_js__WEBPACK_IMPORTED_MODULE_16__["default"]();
        this._decoders[_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].encodingHextile] = new _decoders_hextile_js__WEBPACK_IMPORTED_MODULE_17__["default"]();
        this._decoders[_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].encodingTight] = new _decoders_tight_js__WEBPACK_IMPORTED_MODULE_18__["default"]();
        this._decoders[_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].encodingTightPNG] = new _decoders_tightpng_js__WEBPACK_IMPORTED_MODULE_19__["default"]();

        // NB: nothing that needs explicit teardown should be done
        // before this point, since this can throw an exception
        try {
            this._display = new _display_js__WEBPACK_IMPORTED_MODULE_4__["default"](this._canvas);
        } catch (exc) {
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Error"]("Display exception: " + exc);
            throw exc;
        }
        this._display.onflush = this._onFlush.bind(this);
        this._display.clear();

        this._keyboard = new _input_keyboard_js__WEBPACK_IMPORTED_MODULE_5__["default"](this._canvas);
        this._keyboard.onkeyevent = this._handleKeyEvent.bind(this);

        this._mouse = new _input_mouse_js__WEBPACK_IMPORTED_MODULE_6__["default"](this._canvas);
        this._mouse.onmousebutton = this._handleMouseButton.bind(this);
        this._mouse.onmousemove = this._handleMouseMove.bind(this);

        this._sock = new _websock_js__WEBPACK_IMPORTED_MODULE_8__["default"]();
        this._sock.on('message', () => {
            this._handle_message();
        });
        this._sock.on('open', () => {
            if ((this._rfb_connection_state === 'connecting') &&
                (this._rfb_init_state === '')) {
                this._rfb_init_state = 'ProtocolVersion';
                _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("Starting VNC handshake");
            } else {
                this._fail("Unexpected server connection while " +
                           this._rfb_connection_state);
            }
        });
        this._sock.on('close', (e) => {
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("WebSocket on-close event");
            let msg = "";
            if (e.code) {
                msg = "(code: " + e.code;
                if (e.reason) {
                    msg += ", reason: " + e.reason;
                }
                msg += ")";
            }
            switch (this._rfb_connection_state) {
                case 'connecting':
                    this._fail("Connection closed " + msg);
                    break;
                case 'connected':
                    // Handle disconnects that were initiated server-side
                    this._updateConnectionState('disconnecting');
                    this._updateConnectionState('disconnected');
                    break;
                case 'disconnecting':
                    // Normal disconnection path
                    this._updateConnectionState('disconnected');
                    break;
                case 'disconnected':
                    this._fail("Unexpected server disconnect " +
                               "when already disconnected " + msg);
                    break;
                default:
                    this._fail("Unexpected server disconnect before connecting " +
                               msg);
                    break;
            }
            this._sock.off('close');
        });
        this._sock.on('error', e => _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Warn"]("WebSocket on-error event"));

        // Slight delay of the actual connection so that the caller has
        // time to set up callbacks
        setTimeout(this._updateConnectionState.bind(this, 'connecting'));

        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("<< RFB.constructor");

        // ===== PROPERTIES =====

        this.dragViewport = false;
        this.focusOnClick = true;

        this._viewOnly = false;
        this._clipViewport = false;
        this._scaleViewport = false;
        this._resizeSession = false;
    }

    // ===== PROPERTIES =====

    get viewOnly() { return this._viewOnly; }
    set viewOnly(viewOnly) {
        this._viewOnly = viewOnly;

        if (this._rfb_connection_state === "connecting" ||
            this._rfb_connection_state === "connected") {
            if (viewOnly) {
                this._keyboard.ungrab();
                this._mouse.ungrab();
            } else {
                this._keyboard.grab();
                this._mouse.grab();
            }
        }
    }

    get capabilities() { return this._capabilities; }

    get touchButton() { return this._mouse.touchButton; }
    set touchButton(button) { this._mouse.touchButton = button; }

    get clipViewport() { return this._clipViewport; }
    set clipViewport(viewport) {
        this._clipViewport = viewport;
        this._updateClip();
    }

    get scaleViewport() { return this._scaleViewport; }
    set scaleViewport(scale) {
        this._scaleViewport = scale;
        // Scaling trumps clipping, so we may need to adjust
        // clipping when enabling or disabling scaling
        if (scale && this._clipViewport) {
            this._updateClip();
        }
        this._updateScale();
        if (!scale && this._clipViewport) {
            this._updateClip();
        }
    }

    get resizeSession() { return this._resizeSession; }
    set resizeSession(resize) {
        this._resizeSession = resize;
        if (resize) {
            this._requestRemoteResize();
        }
    }

    get showDotCursor() { return this._showDotCursor; }
    set showDotCursor(show) {
        this._showDotCursor = show;
        this._refreshCursor();
    }

    get background() { return this._screen.style.background; }
    set background(cssValue) { this._screen.style.background = cssValue; }

    // ===== PUBLIC METHODS =====

    disconnect() {
        this._updateConnectionState('disconnecting');
        this._sock.off('error');
        this._sock.off('message');
        this._sock.off('open');
    }

    sendCredentials(creds) {
        this._rfb_credentials = creds;
        setTimeout(this._init_msg.bind(this), 0);
    }

    sendCtrlAltDel() {
        if (this._rfb_connection_state !== 'connected' || this._viewOnly) { return; }
        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Info"]("Sending Ctrl-Alt-Del");

        this.sendKey(_input_keysym_js__WEBPACK_IMPORTED_MODULE_10__["default"].XK_Control_L, "ControlLeft", true);
        this.sendKey(_input_keysym_js__WEBPACK_IMPORTED_MODULE_10__["default"].XK_Alt_L, "AltLeft", true);
        this.sendKey(_input_keysym_js__WEBPACK_IMPORTED_MODULE_10__["default"].XK_Delete, "Delete", true);
        this.sendKey(_input_keysym_js__WEBPACK_IMPORTED_MODULE_10__["default"].XK_Delete, "Delete", false);
        this.sendKey(_input_keysym_js__WEBPACK_IMPORTED_MODULE_10__["default"].XK_Alt_L, "AltLeft", false);
        this.sendKey(_input_keysym_js__WEBPACK_IMPORTED_MODULE_10__["default"].XK_Control_L, "ControlLeft", false);
    }

    machineShutdown() {
        this._xvpOp(1, 2);
    }

    machineReboot() {
        this._xvpOp(1, 3);
    }

    machineReset() {
        this._xvpOp(1, 4);
    }

    // Send a key press. If 'down' is not specified then send a down key
    // followed by an up key.
    sendKey(keysym, code, down) {
        if (this._rfb_connection_state !== 'connected' || this._viewOnly) { return; }

        if (down === undefined) {
            this.sendKey(keysym, code, true);
            this.sendKey(keysym, code, false);
            return;
        }

        const scancode = _input_xtscancodes_js__WEBPACK_IMPORTED_MODULE_11__["default"][code];

        if (this._qemuExtKeyEventSupported && scancode) {
            // 0 is NoSymbol
            keysym = keysym || 0;

            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Info"]("Sending key (" + (down ? "down" : "up") + "): keysym " + keysym + ", scancode " + scancode);

            RFB.messages.QEMUExtendedKeyEvent(this._sock, keysym, down, scancode);
        } else {
            if (!keysym) {
                return;
            }
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Info"]("Sending keysym (" + (down ? "down" : "up") + "): " + keysym);
            RFB.messages.keyEvent(this._sock, keysym, down ? 1 : 0);
        }
    }

    focus() {
        this._canvas.focus();
    }

    blur() {
        this._canvas.blur();
    }

    clipboardPasteFrom(text) {
        if (this._rfb_connection_state !== 'connected' || this._viewOnly) { return; }
        RFB.messages.clientCutText(this._sock, text);
    }

    // ===== PRIVATE METHODS =====

    _connect() {
        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"](">> RFB.connect");

        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Info"]("connecting to " + this._url);

        try {
            // WebSocket.onopen transitions to the RFB init states
            this._sock.open(this._url, ['binary']);
        } catch (e) {
            if (e.name === 'SyntaxError') {
                this._fail("Invalid host or port (" + e + ")");
            } else {
                this._fail("Error when opening socket (" + e + ")");
            }
        }

        // Make our elements part of the page
        this._target.appendChild(this._screen);

        this._cursor.attach(this._canvas);
        this._refreshCursor();

        // Monitor size changes of the screen
        // FIXME: Use ResizeObserver, or hidden overflow
        window.addEventListener('resize', this._eventHandlers.windowResize);

        // Always grab focus on some kind of click event
        this._canvas.addEventListener("mousedown", this._eventHandlers.focusCanvas);
        this._canvas.addEventListener("touchstart", this._eventHandlers.focusCanvas);

        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("<< RFB.connect");
    }

    _disconnect() {
        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"](">> RFB.disconnect");
        this._cursor.detach();
        this._canvas.removeEventListener("mousedown", this._eventHandlers.focusCanvas);
        this._canvas.removeEventListener("touchstart", this._eventHandlers.focusCanvas);
        window.removeEventListener('resize', this._eventHandlers.windowResize);
        this._keyboard.ungrab();
        this._mouse.ungrab();
        this._sock.close();
        try {
            this._target.removeChild(this._screen);
        } catch (e) {
            if (e.name === 'NotFoundError') {
                // Some cases where the initial connection fails
                // can disconnect before the _screen is created
            } else {
                throw e;
            }
        }
        clearTimeout(this._resizeTimeout);
        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("<< RFB.disconnect");
    }

    _focusCanvas(event) {
        // Respect earlier handlers' request to not do side-effects
        if (event.defaultPrevented) {
            return;
        }

        if (!this.focusOnClick) {
            return;
        }

        this.focus();
    }

    _windowResize(event) {
        // If the window resized then our screen element might have
        // as well. Update the viewport dimensions.
        window.requestAnimationFrame(() => {
            this._updateClip();
            this._updateScale();
        });

        if (this._resizeSession) {
            // Request changing the resolution of the remote display to
            // the size of the local browser viewport.

            // In order to not send multiple requests before the browser-resize
            // is finished we wait 0.5 seconds before sending the request.
            clearTimeout(this._resizeTimeout);
            this._resizeTimeout = setTimeout(this._requestRemoteResize.bind(this), 500);
        }
    }

    // Update state of clipping in Display object, and make sure the
    // configured viewport matches the current screen size
    _updateClip() {
        const cur_clip = this._display.clipViewport;
        let new_clip = this._clipViewport;

        if (this._scaleViewport) {
            // Disable viewport clipping if we are scaling
            new_clip = false;
        }

        if (cur_clip !== new_clip) {
            this._display.clipViewport = new_clip;
        }

        if (new_clip) {
            // When clipping is enabled, the screen is limited to
            // the size of the container.
            const size = this._screenSize();
            this._display.viewportChangeSize(size.w, size.h);
            this._fixScrollbars();
        }
    }

    _updateScale() {
        if (!this._scaleViewport) {
            this._display.scale = 1.0;
        } else {
            const size = this._screenSize();
            this._display.autoscale(size.w, size.h);
        }
        this._fixScrollbars();
    }

    // Requests a change of remote desktop size. This message is an extension
    // and may only be sent if we have received an ExtendedDesktopSize message
    _requestRemoteResize() {
        clearTimeout(this._resizeTimeout);
        this._resizeTimeout = null;

        if (!this._resizeSession || this._viewOnly ||
            !this._supportsSetDesktopSize) {
            return;
        }

        const size = this._screenSize();
        RFB.messages.setDesktopSize(this._sock,
                                    Math.floor(size.w), Math.floor(size.h),
                                    this._screen_id, this._screen_flags);

        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]('Requested new desktop size: ' +
                   size.w + 'x' + size.h);
    }

    // Gets the the size of the available screen
    _screenSize() {
        let r = this._screen.getBoundingClientRect();
        return { w: r.width, h: r.height };
    }

    _fixScrollbars() {
        // This is a hack because Chrome screws up the calculation
        // for when scrollbars are needed. So to fix it we temporarily
        // toggle them off and on.
        const orig = this._screen.style.overflow;
        this._screen.style.overflow = 'hidden';
        // Force Chrome to recalculate the layout by asking for
        // an element's dimensions
        this._screen.getBoundingClientRect();
        this._screen.style.overflow = orig;
    }

    /*
     * Connection states:
     *   connecting
     *   connected
     *   disconnecting
     *   disconnected - permanent state
     */
    _updateConnectionState(state) {
        const oldstate = this._rfb_connection_state;

        if (state === oldstate) {
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("Already in state '" + state + "', ignoring");
            return;
        }

        // The 'disconnected' state is permanent for each RFB object
        if (oldstate === 'disconnected') {
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Error"]("Tried changing state of a disconnected RFB object");
            return;
        }

        // Ensure proper transitions before doing anything
        switch (state) {
            case 'connected':
                if (oldstate !== 'connecting') {
                    _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Error"]("Bad transition to connected state, " +
                               "previous connection state: " + oldstate);
                    return;
                }
                break;

            case 'disconnected':
                if (oldstate !== 'disconnecting') {
                    _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Error"]("Bad transition to disconnected state, " +
                               "previous connection state: " + oldstate);
                    return;
                }
                break;

            case 'connecting':
                if (oldstate !== '') {
                    _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Error"]("Bad transition to connecting state, " +
                               "previous connection state: " + oldstate);
                    return;
                }
                break;

            case 'disconnecting':
                if (oldstate !== 'connected' && oldstate !== 'connecting') {
                    _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Error"]("Bad transition to disconnecting state, " +
                               "previous connection state: " + oldstate);
                    return;
                }
                break;

            default:
                _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Error"]("Unknown connection state: " + state);
                return;
        }

        // State change actions

        this._rfb_connection_state = state;

        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("New state '" + state + "', was '" + oldstate + "'.");

        if (this._disconnTimer && state !== 'disconnecting') {
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("Clearing disconnect timer");
            clearTimeout(this._disconnTimer);
            this._disconnTimer = null;

            // make sure we don't get a double event
            this._sock.off('close');
        }

        switch (state) {
            case 'connecting':
                this._connect();
                break;

            case 'connected':
                this.dispatchEvent(new CustomEvent("connect", { detail: {} }));
                break;

            case 'disconnecting':
                this._disconnect();

                this._disconnTimer = setTimeout(() => {
                    _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Error"]("Disconnection timed out.");
                    this._updateConnectionState('disconnected');
                }, DISCONNECT_TIMEOUT * 1000);
                break;

            case 'disconnected':
                this.dispatchEvent(new CustomEvent(
                    "disconnect", { detail:
                                    { clean: this._rfb_clean_disconnect } }));
                break;
        }
    }

    /* Print errors and disconnect
     *
     * The parameter 'details' is used for information that
     * should be logged but not sent to the user interface.
     */
    _fail(details) {
        switch (this._rfb_connection_state) {
            case 'disconnecting':
                _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Error"]("Failed when disconnecting: " + details);
                break;
            case 'connected':
                _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Error"]("Failed while connected: " + details);
                break;
            case 'connecting':
                _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Error"]("Failed when connecting: " + details);
                break;
            default:
                _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Error"]("RFB failure: " + details);
                break;
        }
        this._rfb_clean_disconnect = false; //This is sent to the UI

        // Transition to disconnected without waiting for socket to close
        this._updateConnectionState('disconnecting');
        this._updateConnectionState('disconnected');

        return false;
    }

    _setCapability(cap, val) {
        this._capabilities[cap] = val;
        this.dispatchEvent(new CustomEvent("capabilities",
                                           { detail: { capabilities: this._capabilities } }));
    }

    _handle_message() {
        if (this._sock.rQlen === 0) {
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Warn"]("handle_message called on an empty receive queue");
            return;
        }

        switch (this._rfb_connection_state) {
            case 'disconnected':
                _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Error"]("Got data while disconnected");
                break;
            case 'connected':
                while (true) {
                    if (this._flushing) {
                        break;
                    }
                    if (!this._normal_msg()) {
                        break;
                    }
                    if (this._sock.rQlen === 0) {
                        break;
                    }
                }
                break;
            default:
                this._init_msg();
                break;
        }
    }

    _handleKeyEvent(keysym, code, down) {
        this.sendKey(keysym, code, down);
    }

    _handleMouseButton(x, y, down, bmask) {
        if (down) {
            this._mouse_buttonMask |= bmask;
        } else {
            this._mouse_buttonMask &= ~bmask;
        }

        if (this.dragViewport) {
            if (down && !this._viewportDragging) {
                this._viewportDragging = true;
                this._viewportDragPos = {'x': x, 'y': y};
                this._viewportHasMoved = false;

                // Skip sending mouse events
                return;
            } else {
                this._viewportDragging = false;

                // If we actually performed a drag then we are done
                // here and should not send any mouse events
                if (this._viewportHasMoved) {
                    return;
                }

                // Otherwise we treat this as a mouse click event.
                // Send the button down event here, as the button up
                // event is sent at the end of this function.
                RFB.messages.pointerEvent(this._sock,
                                          this._display.absX(x),
                                          this._display.absY(y),
                                          bmask);
            }
        }

        if (this._viewOnly) { return; } // View only, skip mouse events

        if (this._rfb_connection_state !== 'connected') { return; }
        RFB.messages.pointerEvent(this._sock, this._display.absX(x), this._display.absY(y), this._mouse_buttonMask);
    }

    _handleMouseMove(x, y) {
        if (this._viewportDragging) {
            const deltaX = this._viewportDragPos.x - x;
            const deltaY = this._viewportDragPos.y - y;

            if (this._viewportHasMoved || (Math.abs(deltaX) > _util_browser_js__WEBPACK_IMPORTED_MODULE_2__["dragThreshold"] ||
                                           Math.abs(deltaY) > _util_browser_js__WEBPACK_IMPORTED_MODULE_2__["dragThreshold"])) {
                this._viewportHasMoved = true;

                this._viewportDragPos = {'x': x, 'y': y};
                this._display.viewportChangePos(deltaX, deltaY);
            }

            // Skip sending mouse events
            return;
        }

        if (this._viewOnly) { return; } // View only, skip mouse events

        if (this._rfb_connection_state !== 'connected') { return; }
        RFB.messages.pointerEvent(this._sock, this._display.absX(x), this._display.absY(y), this._mouse_buttonMask);
    }

    // Message Handlers

    _negotiate_protocol_version() {
        if (this._sock.rQwait("version", 12)) {
            return false;
        }

        const sversion = this._sock.rQshiftStr(12).substr(4, 7);
        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Info"]("Server ProtocolVersion: " + sversion);
        let is_repeater = 0;
        switch (sversion) {
            case "000.000":  // UltraVNC repeater
                is_repeater = 1;
                break;
            case "003.003":
            case "003.006":  // UltraVNC
            case "003.889":  // Apple Remote Desktop
                this._rfb_version = 3.3;
                break;
            case "003.007":
                this._rfb_version = 3.7;
                break;
            case "003.008":
            case "004.000":  // Intel AMT KVM
            case "004.001":  // RealVNC 4.6
            case "005.000":  // RealVNC 5.3
                this._rfb_version = 3.8;
                break;
            default:
                return this._fail("Invalid server version " + sversion);
        }

        if (is_repeater) {
            let repeaterID = "ID:" + this._repeaterID;
            while (repeaterID.length < 250) {
                repeaterID += "\0";
            }
            this._sock.send_string(repeaterID);
            return true;
        }

        if (this._rfb_version > this._rfb_max_version) {
            this._rfb_version = this._rfb_max_version;
        }

        const cversion = "00" + parseInt(this._rfb_version, 10) +
                       ".00" + ((this._rfb_version * 10) % 10);
        this._sock.send_string("RFB " + cversion + "\n");
        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]('Sent ProtocolVersion: ' + cversion);

        this._rfb_init_state = 'Security';
    }

    _negotiate_security() {
        // Polyfill since IE and PhantomJS doesn't have
        // TypedArray.includes()
        function includes(item, array) {
            for (let i = 0; i < array.length; i++) {
                if (array[i] === item) {
                    return true;
                }
            }
            return false;
        }

        if (this._rfb_version >= 3.7) {
            // Server sends supported list, client decides
            const num_types = this._sock.rQshift8();
            if (this._sock.rQwait("security type", num_types, 1)) { return false; }

            if (num_types === 0) {
                this._rfb_init_state = "SecurityReason";
                this._security_context = "no security types";
                this._security_status = 1;
                return this._init_msg();
            }

            const types = this._sock.rQshiftBytes(num_types);
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("Server security types: " + types);

            // Look for each auth in preferred order
            if (includes(1, types)) {
                this._rfb_auth_scheme = 1; // None
            } else if (includes(22, types)) {
                this._rfb_auth_scheme = 22; // XVP
            } else if (includes(16, types)) {
                this._rfb_auth_scheme = 16; // Tight
            } else if (includes(2, types)) {
                this._rfb_auth_scheme = 2; // VNC Auth
            } else {
                return this._fail("Unsupported security types (types: " + types + ")");
            }

            this._sock.send([this._rfb_auth_scheme]);
        } else {
            // Server decides
            if (this._sock.rQwait("security scheme", 4)) { return false; }
            this._rfb_auth_scheme = this._sock.rQshift32();

            if (this._rfb_auth_scheme == 0) {
                this._rfb_init_state = "SecurityReason";
                this._security_context = "authentication scheme";
                this._security_status = 1;
                return this._init_msg();
            }
        }

        this._rfb_init_state = 'Authentication';
        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]('Authenticating using scheme: ' + this._rfb_auth_scheme);

        return this._init_msg(); // jump to authentication
    }

    _handle_security_reason() {
        if (this._sock.rQwait("reason length", 4)) {
            return false;
        }
        const strlen = this._sock.rQshift32();
        let reason = "";

        if (strlen > 0) {
            if (this._sock.rQwait("reason", strlen, 4)) { return false; }
            reason = this._sock.rQshiftStr(strlen);
        }

        if (reason !== "") {
            this.dispatchEvent(new CustomEvent(
                "securityfailure",
                { detail: { status: this._security_status,
                            reason: reason } }));

            return this._fail("Security negotiation failed on " +
                              this._security_context +
                              " (reason: " + reason + ")");
        } else {
            this.dispatchEvent(new CustomEvent(
                "securityfailure",
                { detail: { status: this._security_status } }));

            return this._fail("Security negotiation failed on " +
                              this._security_context);
        }
    }

    // authentication
    _negotiate_xvp_auth() {
        if (!this._rfb_credentials.username ||
            !this._rfb_credentials.password ||
            !this._rfb_credentials.target) {
            this.dispatchEvent(new CustomEvent(
                "credentialsrequired",
                { detail: { types: ["username", "password", "target"] } }));
            return false;
        }

        const xvp_auth_str = String.fromCharCode(this._rfb_credentials.username.length) +
                           String.fromCharCode(this._rfb_credentials.target.length) +
                           this._rfb_credentials.username +
                           this._rfb_credentials.target;
        this._sock.send_string(xvp_auth_str);
        this._rfb_auth_scheme = 2;
        return this._negotiate_authentication();
    }

    _negotiate_std_vnc_auth() {
        if (this._sock.rQwait("auth challenge", 16)) { return false; }

        if (!this._rfb_credentials.password) {
            this.dispatchEvent(new CustomEvent(
                "credentialsrequired",
                { detail: { types: ["password"] } }));
            return false;
        }

        // TODO(directxman12): make genDES not require an Array
        const challenge = Array.prototype.slice.call(this._sock.rQshiftBytes(16));
        const response = RFB.genDES(this._rfb_credentials.password, challenge);
        this._sock.send(response);
        this._rfb_init_state = "SecurityResult";
        return true;
    }

    _negotiate_tight_tunnels(numTunnels) {
        const clientSupportedTunnelTypes = {
            0: { vendor: 'TGHT', signature: 'NOTUNNEL' }
        };
        const serverSupportedTunnelTypes = {};
        // receive tunnel capabilities
        for (let i = 0; i < numTunnels; i++) {
            const cap_code = this._sock.rQshift32();
            const cap_vendor = this._sock.rQshiftStr(4);
            const cap_signature = this._sock.rQshiftStr(8);
            serverSupportedTunnelTypes[cap_code] = { vendor: cap_vendor, signature: cap_signature };
        }

        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("Server Tight tunnel types: " + serverSupportedTunnelTypes);

        // Siemens touch panels have a VNC server that supports NOTUNNEL,
        // but forgets to advertise it. Try to detect such servers by
        // looking for their custom tunnel type.
        if (serverSupportedTunnelTypes[1] &&
            (serverSupportedTunnelTypes[1].vendor === "SICR") &&
            (serverSupportedTunnelTypes[1].signature === "SCHANNEL")) {
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("Detected Siemens server. Assuming NOTUNNEL support.");
            serverSupportedTunnelTypes[0] = { vendor: 'TGHT', signature: 'NOTUNNEL' };
        }

        // choose the notunnel type
        if (serverSupportedTunnelTypes[0]) {
            if (serverSupportedTunnelTypes[0].vendor != clientSupportedTunnelTypes[0].vendor ||
                serverSupportedTunnelTypes[0].signature != clientSupportedTunnelTypes[0].signature) {
                return this._fail("Client's tunnel type had the incorrect " +
                                  "vendor or signature");
            }
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("Selected tunnel type: " + clientSupportedTunnelTypes[0]);
            this._sock.send([0, 0, 0, 0]);  // use NOTUNNEL
            return false; // wait until we receive the sub auth count to continue
        } else {
            return this._fail("Server wanted tunnels, but doesn't support " +
                              "the notunnel type");
        }
    }

    _negotiate_tight_auth() {
        if (!this._rfb_tightvnc) {  // first pass, do the tunnel negotiation
            if (this._sock.rQwait("num tunnels", 4)) { return false; }
            const numTunnels = this._sock.rQshift32();
            if (numTunnels > 0 && this._sock.rQwait("tunnel capabilities", 16 * numTunnels, 4)) { return false; }

            this._rfb_tightvnc = true;

            if (numTunnels > 0) {
                this._negotiate_tight_tunnels(numTunnels);
                return false;  // wait until we receive the sub auth to continue
            }
        }

        // second pass, do the sub-auth negotiation
        if (this._sock.rQwait("sub auth count", 4)) { return false; }
        const subAuthCount = this._sock.rQshift32();
        if (subAuthCount === 0) {  // empty sub-auth list received means 'no auth' subtype selected
            this._rfb_init_state = 'SecurityResult';
            return true;
        }

        if (this._sock.rQwait("sub auth capabilities", 16 * subAuthCount, 4)) { return false; }

        const clientSupportedTypes = {
            'STDVNOAUTH__': 1,
            'STDVVNCAUTH_': 2
        };

        const serverSupportedTypes = [];

        for (let i = 0; i < subAuthCount; i++) {
            this._sock.rQshift32(); // capNum
            const capabilities = this._sock.rQshiftStr(12);
            serverSupportedTypes.push(capabilities);
        }

        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("Server Tight authentication types: " + serverSupportedTypes);

        for (let authType in clientSupportedTypes) {
            if (serverSupportedTypes.indexOf(authType) != -1) {
                this._sock.send([0, 0, 0, clientSupportedTypes[authType]]);
                _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("Selected authentication type: " + authType);

                switch (authType) {
                    case 'STDVNOAUTH__':  // no auth
                        this._rfb_init_state = 'SecurityResult';
                        return true;
                    case 'STDVVNCAUTH_': // VNC auth
                        this._rfb_auth_scheme = 2;
                        return this._init_msg();
                    default:
                        return this._fail("Unsupported tiny auth scheme " +
                                          "(scheme: " + authType + ")");
                }
            }
        }

        return this._fail("No supported sub-auth types!");
    }

    _negotiate_authentication() {
        switch (this._rfb_auth_scheme) {
            case 1:  // no auth
                if (this._rfb_version >= 3.8) {
                    this._rfb_init_state = 'SecurityResult';
                    return true;
                }
                this._rfb_init_state = 'ClientInitialisation';
                return this._init_msg();

            case 22:  // XVP auth
                return this._negotiate_xvp_auth();

            case 2:  // VNC authentication
                return this._negotiate_std_vnc_auth();

            case 16:  // TightVNC Security Type
                return this._negotiate_tight_auth();

            default:
                return this._fail("Unsupported auth scheme (scheme: " +
                                  this._rfb_auth_scheme + ")");
        }
    }

    _handle_security_result() {
        if (this._sock.rQwait('VNC auth response ', 4)) { return false; }

        const status = this._sock.rQshift32();

        if (status === 0) { // OK
            this._rfb_init_state = 'ClientInitialisation';
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]('Authentication OK');
            return this._init_msg();
        } else {
            if (this._rfb_version >= 3.8) {
                this._rfb_init_state = "SecurityReason";
                this._security_context = "security result";
                this._security_status = status;
                return this._init_msg();
            } else {
                this.dispatchEvent(new CustomEvent(
                    "securityfailure",
                    { detail: { status: status } }));

                return this._fail("Security handshake failed");
            }
        }
    }

    _negotiate_server_init() {
        if (this._sock.rQwait("server initialization", 24)) { return false; }

        /* Screen size */
        const width = this._sock.rQshift16();
        const height = this._sock.rQshift16();

        /* PIXEL_FORMAT */
        const bpp         = this._sock.rQshift8();
        const depth       = this._sock.rQshift8();
        const big_endian  = this._sock.rQshift8();
        const true_color  = this._sock.rQshift8();

        const red_max     = this._sock.rQshift16();
        const green_max   = this._sock.rQshift16();
        const blue_max    = this._sock.rQshift16();
        const red_shift   = this._sock.rQshift8();
        const green_shift = this._sock.rQshift8();
        const blue_shift  = this._sock.rQshift8();
        this._sock.rQskipBytes(3);  // padding

        // NB(directxman12): we don't want to call any callbacks or print messages until
        //                   *after* we're past the point where we could backtrack

        /* Connection name/title */
        const name_length = this._sock.rQshift32();
        if (this._sock.rQwait('server init name', name_length, 24)) { return false; }
        this._fb_name = Object(_util_strings_js__WEBPACK_IMPORTED_MODULE_1__["decodeUTF8"])(this._sock.rQshiftStr(name_length));

        if (this._rfb_tightvnc) {
            if (this._sock.rQwait('TightVNC extended server init header', 8, 24 + name_length)) { return false; }
            // In TightVNC mode, ServerInit message is extended
            const numServerMessages = this._sock.rQshift16();
            const numClientMessages = this._sock.rQshift16();
            const numEncodings = this._sock.rQshift16();
            this._sock.rQskipBytes(2);  // padding

            const totalMessagesLength = (numServerMessages + numClientMessages + numEncodings) * 16;
            if (this._sock.rQwait('TightVNC extended server init header', totalMessagesLength, 32 + name_length)) { return false; }

            // we don't actually do anything with the capability information that TIGHT sends,
            // so we just skip the all of this.

            // TIGHT server message capabilities
            this._sock.rQskipBytes(16 * numServerMessages);

            // TIGHT client message capabilities
            this._sock.rQskipBytes(16 * numClientMessages);

            // TIGHT encoding capabilities
            this._sock.rQskipBytes(16 * numEncodings);
        }

        // NB(directxman12): these are down here so that we don't run them multiple times
        //                   if we backtrack
        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Info"]("Screen: " + width + "x" + height +
                  ", bpp: " + bpp + ", depth: " + depth +
                  ", big_endian: " + big_endian +
                  ", true_color: " + true_color +
                  ", red_max: " + red_max +
                  ", green_max: " + green_max +
                  ", blue_max: " + blue_max +
                  ", red_shift: " + red_shift +
                  ", green_shift: " + green_shift +
                  ", blue_shift: " + blue_shift);

        if (big_endian !== 0) {
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Warn"]("Server native endian is not little endian");
        }

        if (red_shift !== 16) {
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Warn"]("Server native red-shift is not 16");
        }

        if (blue_shift !== 0) {
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Warn"]("Server native blue-shift is not 0");
        }

        // we're past the point where we could backtrack, so it's safe to call this
        this.dispatchEvent(new CustomEvent(
            "desktopname",
            { detail: { name: this._fb_name } }));

        this._resize(width, height);

        if (!this._viewOnly) { this._keyboard.grab(); }
        if (!this._viewOnly) { this._mouse.grab(); }

        this._fb_depth = 24;

        if (this._fb_name === "Intel(r) AMT KVM") {
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Warn"]("Intel AMT KVM only supports 8/16 bit depths. Using low color mode.");
            this._fb_depth = 8;
        }

        RFB.messages.pixelFormat(this._sock, this._fb_depth, true);
        this._sendEncodings();
        RFB.messages.fbUpdateRequest(this._sock, false, 0, 0, this._fb_width, this._fb_height);

        this._updateConnectionState('connected');
        return true;
    }

    _sendEncodings() {
        const encs = [];

        // In preference order
        encs.push(_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].encodingCopyRect);
        // Only supported with full depth support
        if (this._fb_depth == 24) {
            encs.push(_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].encodingTight);
            encs.push(_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].encodingTightPNG);
            encs.push(_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].encodingHextile);
            encs.push(_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].encodingRRE);
        }
        encs.push(_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].encodingRaw);

        // Psuedo-encoding settings
        encs.push(_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].pseudoEncodingQualityLevel0 + 6);
        encs.push(_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].pseudoEncodingCompressLevel0 + 2);

        encs.push(_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].pseudoEncodingDesktopSize);
        encs.push(_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].pseudoEncodingLastRect);
        encs.push(_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].pseudoEncodingQEMUExtendedKeyEvent);
        encs.push(_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].pseudoEncodingExtendedDesktopSize);
        encs.push(_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].pseudoEncodingXvp);
        encs.push(_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].pseudoEncodingFence);
        encs.push(_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].pseudoEncodingContinuousUpdates);

        if (this._fb_depth == 24) {
            encs.push(_encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].pseudoEncodingCursor);
        }

        RFB.messages.clientEncodings(this._sock, encs);
    }

    /* RFB protocol initialization states:
     *   ProtocolVersion
     *   Security
     *   Authentication
     *   SecurityResult
     *   ClientInitialization - not triggered by server message
     *   ServerInitialization
     */
    _init_msg() {
        switch (this._rfb_init_state) {
            case 'ProtocolVersion':
                return this._negotiate_protocol_version();

            case 'Security':
                return this._negotiate_security();

            case 'Authentication':
                return this._negotiate_authentication();

            case 'SecurityResult':
                return this._handle_security_result();

            case 'SecurityReason':
                return this._handle_security_reason();

            case 'ClientInitialisation':
                this._sock.send([this._shared ? 1 : 0]); // ClientInitialisation
                this._rfb_init_state = 'ServerInitialisation';
                return true;

            case 'ServerInitialisation':
                return this._negotiate_server_init();

            default:
                return this._fail("Unknown init state (state: " +
                                  this._rfb_init_state + ")");
        }
    }

    _handle_set_colour_map_msg() {
        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("SetColorMapEntries");

        return this._fail("Unexpected SetColorMapEntries message");
    }

    _handle_server_cut_text() {
        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("ServerCutText");

        if (this._sock.rQwait("ServerCutText header", 7, 1)) { return false; }
        this._sock.rQskipBytes(3);  // Padding
        const length = this._sock.rQshift32();
        if (this._sock.rQwait("ServerCutText", length, 8)) { return false; }

        const text = this._sock.rQshiftStr(length);

        if (this._viewOnly) { return true; }

        this.dispatchEvent(new CustomEvent(
            "clipboard",
            { detail: { text: text } }));

        return true;
    }

    _handle_server_fence_msg() {
        if (this._sock.rQwait("ServerFence header", 8, 1)) { return false; }
        this._sock.rQskipBytes(3); // Padding
        let flags = this._sock.rQshift32();
        let length = this._sock.rQshift8();

        if (this._sock.rQwait("ServerFence payload", length, 9)) { return false; }

        if (length > 64) {
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Warn"]("Bad payload length (" + length + ") in fence response");
            length = 64;
        }

        const payload = this._sock.rQshiftStr(length);

        this._supportsFence = true;

        /*
         * Fence flags
         *
         *  (1<<0)  - BlockBefore
         *  (1<<1)  - BlockAfter
         *  (1<<2)  - SyncNext
         *  (1<<31) - Request
         */

        if (!(flags & (1<<31))) {
            return this._fail("Unexpected fence response");
        }

        // Filter out unsupported flags
        // FIXME: support syncNext
        flags &= (1<<0) | (1<<1);

        // BlockBefore and BlockAfter are automatically handled by
        // the fact that we process each incoming message
        // synchronuosly.
        RFB.messages.clientFence(this._sock, flags, payload);

        return true;
    }

    _handle_xvp_msg() {
        if (this._sock.rQwait("XVP version and message", 3, 1)) { return false; }
        this._sock.rQskipBytes(1);  // Padding
        const xvp_ver = this._sock.rQshift8();
        const xvp_msg = this._sock.rQshift8();

        switch (xvp_msg) {
            case 0:  // XVP_FAIL
                _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Error"]("XVP Operation Failed");
                break;
            case 1:  // XVP_INIT
                this._rfb_xvp_ver = xvp_ver;
                _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Info"]("XVP extensions enabled (version " + this._rfb_xvp_ver + ")");
                this._setCapability("power", true);
                break;
            default:
                this._fail("Illegal server XVP message (msg: " + xvp_msg + ")");
                break;
        }

        return true;
    }

    _normal_msg() {
        let msg_type;
        if (this._FBU.rects > 0) {
            msg_type = 0;
        } else {
            msg_type = this._sock.rQshift8();
        }

        let first, ret;
        switch (msg_type) {
            case 0:  // FramebufferUpdate
                ret = this._framebufferUpdate();
                if (ret && !this._enabledContinuousUpdates) {
                    RFB.messages.fbUpdateRequest(this._sock, true, 0, 0,
                                                 this._fb_width, this._fb_height);
                }
                return ret;

            case 1:  // SetColorMapEntries
                return this._handle_set_colour_map_msg();

            case 2:  // Bell
                _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("Bell");
                this.dispatchEvent(new CustomEvent(
                    "bell",
                    { detail: {} }));
                return true;

            case 3:  // ServerCutText
                return this._handle_server_cut_text();

            case 150: // EndOfContinuousUpdates
                first = !this._supportsContinuousUpdates;
                this._supportsContinuousUpdates = true;
                this._enabledContinuousUpdates = false;
                if (first) {
                    this._enabledContinuousUpdates = true;
                    this._updateContinuousUpdates();
                    _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Info"]("Enabling continuous updates.");
                } else {
                    // FIXME: We need to send a framebufferupdaterequest here
                    // if we add support for turning off continuous updates
                }
                return true;

            case 248: // ServerFence
                return this._handle_server_fence_msg();

            case 250:  // XVP
                return this._handle_xvp_msg();

            default:
                this._fail("Unexpected server message (type " + msg_type + ")");
                _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("sock.rQslice(0, 30): " + this._sock.rQslice(0, 30));
                return true;
        }
    }

    _onFlush() {
        this._flushing = false;
        // Resume processing
        if (this._sock.rQlen > 0) {
            this._handle_message();
        }
    }

    _framebufferUpdate() {
        if (this._FBU.rects === 0) {
            if (this._sock.rQwait("FBU header", 3, 1)) { return false; }
            this._sock.rQskipBytes(1);  // Padding
            this._FBU.rects = this._sock.rQshift16();

            // Make sure the previous frame is fully rendered first
            // to avoid building up an excessive queue
            if (this._display.pending()) {
                this._flushing = true;
                this._display.flush();
                return false;
            }
        }

        while (this._FBU.rects > 0) {
            if (this._FBU.encoding === null) {
                if (this._sock.rQwait("rect header", 12)) { return false; }
                /* New FramebufferUpdate */

                const hdr = this._sock.rQshiftBytes(12);
                this._FBU.x        = (hdr[0] << 8) + hdr[1];
                this._FBU.y        = (hdr[2] << 8) + hdr[3];
                this._FBU.width    = (hdr[4] << 8) + hdr[5];
                this._FBU.height   = (hdr[6] << 8) + hdr[7];
                this._FBU.encoding = parseInt((hdr[8] << 24) + (hdr[9] << 16) +
                                              (hdr[10] << 8) + hdr[11], 10);
            }

            if (!this._handleRect()) {
                return false;
            }

            this._FBU.rects--;
            this._FBU.encoding = null;
        }

        this._display.flip();

        return true;  // We finished this FBU
    }

    _handleRect() {
        switch (this._FBU.encoding) {
            case _encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].pseudoEncodingLastRect:
                this._FBU.rects = 1; // Will be decreased when we return
                return true;

            case _encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].pseudoEncodingCursor:
                return this._handleCursor();

            case _encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].pseudoEncodingQEMUExtendedKeyEvent:
                // Old Safari doesn't support creating keyboard events
                try {
                    const keyboardEvent = document.createEvent("keyboardEvent");
                    if (keyboardEvent.code !== undefined) {
                        this._qemuExtKeyEventSupported = true;
                    }
                } catch (err) {
                    // Do nothing
                }
                return true;

            case _encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].pseudoEncodingDesktopSize:
                this._resize(this._FBU.width, this._FBU.height);
                return true;

            case _encodings_js__WEBPACK_IMPORTED_MODULE_12__["encodings"].pseudoEncodingExtendedDesktopSize:
                return this._handleExtendedDesktopSize();

            default:
                return this._handleDataRect();
        }
    }

    _handleCursor() {
        const hotx = this._FBU.x;  // hotspot-x
        const hoty = this._FBU.y;  // hotspot-y
        const w = this._FBU.width;
        const h = this._FBU.height;

        const pixelslength = w * h * 4;
        const masklength = Math.ceil(w / 8) * h;

        let bytes = pixelslength + masklength;
        if (this._sock.rQwait("cursor encoding", bytes)) {
            return false;
        }

        // Decode from BGRX pixels + bit mask to RGBA
        const pixels = this._sock.rQshiftBytes(pixelslength);
        const mask = this._sock.rQshiftBytes(masklength);
        let rgba = new Uint8Array(w * h * 4);

        let pix_idx = 0;
        for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
                let mask_idx = y * Math.ceil(w / 8) + Math.floor(x / 8);
                let alpha = (mask[mask_idx] << (x % 8)) & 0x80 ? 255 : 0;
                rgba[pix_idx    ] = pixels[pix_idx + 2];
                rgba[pix_idx + 1] = pixels[pix_idx + 1];
                rgba[pix_idx + 2] = pixels[pix_idx];
                rgba[pix_idx + 3] = alpha;
                pix_idx += 4;
            }
        }

        this._updateCursor(rgba, hotx, hoty, w, h);

        return true;
    }

    _handleExtendedDesktopSize() {
        if (this._sock.rQwait("ExtendedDesktopSize", 4)) {
            return false;
        }

        const number_of_screens = this._sock.rQpeek8();

        let bytes = 4 + (number_of_screens * 16);
        if (this._sock.rQwait("ExtendedDesktopSize", bytes)) {
            return false;
        }

        const firstUpdate = !this._supportsSetDesktopSize;
        this._supportsSetDesktopSize = true;

        // Normally we only apply the current resize mode after a
        // window resize event. However there is no such trigger on the
        // initial connect. And we don't know if the server supports
        // resizing until we've gotten here.
        if (firstUpdate) {
            this._requestRemoteResize();
        }

        this._sock.rQskipBytes(1);  // number-of-screens
        this._sock.rQskipBytes(3);  // padding

        for (let i = 0; i < number_of_screens; i += 1) {
            // Save the id and flags of the first screen
            if (i === 0) {
                this._screen_id = this._sock.rQshiftBytes(4);    // id
                this._sock.rQskipBytes(2);                       // x-position
                this._sock.rQskipBytes(2);                       // y-position
                this._sock.rQskipBytes(2);                       // width
                this._sock.rQskipBytes(2);                       // height
                this._screen_flags = this._sock.rQshiftBytes(4); // flags
            } else {
                this._sock.rQskipBytes(16);
            }
        }

        /*
         * The x-position indicates the reason for the change:
         *
         *  0 - server resized on its own
         *  1 - this client requested the resize
         *  2 - another client requested the resize
         */

        // We need to handle errors when we requested the resize.
        if (this._FBU.x === 1 && this._FBU.y !== 0) {
            let msg = "";
            // The y-position indicates the status code from the server
            switch (this._FBU.y) {
                case 1:
                    msg = "Resize is administratively prohibited";
                    break;
                case 2:
                    msg = "Out of resources";
                    break;
                case 3:
                    msg = "Invalid screen layout";
                    break;
                default:
                    msg = "Unknown reason";
                    break;
            }
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Warn"]("Server did not accept the resize request: "
                     + msg);
        } else {
            this._resize(this._FBU.width, this._FBU.height);
        }

        return true;
    }

    _handleDataRect() {
        let decoder = this._decoders[this._FBU.encoding];
        if (!decoder) {
            this._fail("Unsupported encoding (encoding: " +
                       this._FBU.encoding + ")");
            return false;
        }

        try {
            return decoder.decodeRect(this._FBU.x, this._FBU.y,
                                      this._FBU.width, this._FBU.height,
                                      this._sock, this._display,
                                      this._fb_depth);
        } catch (err) {
            this._fail("Error decoding rect: " + err);
            return false;
        }
    }

    _updateContinuousUpdates() {
        if (!this._enabledContinuousUpdates) { return; }

        RFB.messages.enableContinuousUpdates(this._sock, true, 0, 0,
                                             this._fb_width, this._fb_height);
    }

    _resize(width, height) {
        this._fb_width = width;
        this._fb_height = height;

        this._display.resize(this._fb_width, this._fb_height);

        // Adjust the visible viewport based on the new dimensions
        this._updateClip();
        this._updateScale();

        this._updateContinuousUpdates();
    }

    _xvpOp(ver, op) {
        if (this._rfb_xvp_ver < ver) { return; }
        _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Info"]("Sending XVP operation " + op + " (version " + ver + ")");
        RFB.messages.xvpOp(this._sock, ver, op);
    }

    _updateCursor(rgba, hotx, hoty, w, h) {
        this._cursorImage = {
            rgbaPixels: rgba,
            hotx: hotx, hoty: hoty, w: w, h: h,
        };
        this._refreshCursor();
    }

    _shouldShowDotCursor() {
        // Called when this._cursorImage is updated
        if (!this._showDotCursor) {
            // User does not want to see the dot, so...
            return false;
        }

        // The dot should not be shown if the cursor is already visible,
        // i.e. contains at least one not-fully-transparent pixel.
        // So iterate through all alpha bytes in rgba and stop at the
        // first non-zero.
        for (let i = 3; i < this._cursorImage.rgbaPixels.length; i += 4) {
            if (this._cursorImage.rgbaPixels[i]) {
                return false;
            }
        }

        // At this point, we know that the cursor is fully transparent, and
        // the user wants to see the dot instead of this.
        return true;
    }

    _refreshCursor() {
        const image = this._shouldShowDotCursor() ? RFB.cursors.dot : this._cursorImage;
        this._cursor.change(image.rgbaPixels,
                            image.hotx, image.hoty,
                            image.w, image.h
        );
    }

    static genDES(password, challenge) {
        const passwordChars = password.split('').map(c => c.charCodeAt(0));
        return (new _des_js__WEBPACK_IMPORTED_MODULE_9__["default"](passwordChars)).encrypt(challenge);
    }
}

// Class Methods
RFB.messages = {
    keyEvent(sock, keysym, down) {
        const buff = sock._sQ;
        const offset = sock._sQlen;

        buff[offset] = 4;  // msg-type
        buff[offset + 1] = down;

        buff[offset + 2] = 0;
        buff[offset + 3] = 0;

        buff[offset + 4] = (keysym >> 24);
        buff[offset + 5] = (keysym >> 16);
        buff[offset + 6] = (keysym >> 8);
        buff[offset + 7] = keysym;

        sock._sQlen += 8;
        sock.flush();
    },

    QEMUExtendedKeyEvent(sock, keysym, down, keycode) {
        function getRFBkeycode(xt_scancode) {
            const upperByte = (keycode >> 8);
            const lowerByte = (keycode & 0x00ff);
            if (upperByte === 0xe0 && lowerByte < 0x7f) {
                return lowerByte | 0x80;
            }
            return xt_scancode;
        }

        const buff = sock._sQ;
        const offset = sock._sQlen;

        buff[offset] = 255; // msg-type
        buff[offset + 1] = 0; // sub msg-type

        buff[offset + 2] = (down >> 8);
        buff[offset + 3] = down;

        buff[offset + 4] = (keysym >> 24);
        buff[offset + 5] = (keysym >> 16);
        buff[offset + 6] = (keysym >> 8);
        buff[offset + 7] = keysym;

        const RFBkeycode = getRFBkeycode(keycode);

        buff[offset + 8] = (RFBkeycode >> 24);
        buff[offset + 9] = (RFBkeycode >> 16);
        buff[offset + 10] = (RFBkeycode >> 8);
        buff[offset + 11] = RFBkeycode;

        sock._sQlen += 12;
        sock.flush();
    },

    pointerEvent(sock, x, y, mask) {
        const buff = sock._sQ;
        const offset = sock._sQlen;

        buff[offset] = 5; // msg-type

        buff[offset + 1] = mask;

        buff[offset + 2] = x >> 8;
        buff[offset + 3] = x;

        buff[offset + 4] = y >> 8;
        buff[offset + 5] = y;

        sock._sQlen += 6;
        sock.flush();
    },

    // TODO(directxman12): make this unicode compatible?
    clientCutText(sock, text) {
        const buff = sock._sQ;
        const offset = sock._sQlen;

        buff[offset] = 6; // msg-type

        buff[offset + 1] = 0; // padding
        buff[offset + 2] = 0; // padding
        buff[offset + 3] = 0; // padding

        let length = text.length;

        buff[offset + 4] = length >> 24;
        buff[offset + 5] = length >> 16;
        buff[offset + 6] = length >> 8;
        buff[offset + 7] = length;

        sock._sQlen += 8;

        // We have to keep track of from where in the text we begin creating the
        // buffer for the flush in the next iteration.
        let textOffset = 0;

        let remaining = length;
        while (remaining > 0) {

            let flushSize = Math.min(remaining, (sock._sQbufferSize - sock._sQlen));
            for (let i = 0; i < flushSize; i++) {
                buff[sock._sQlen + i] =  text.charCodeAt(textOffset + i);
            }

            sock._sQlen += flushSize;
            sock.flush();

            remaining -= flushSize;
            textOffset += flushSize;
        }
    },

    setDesktopSize(sock, width, height, id, flags) {
        const buff = sock._sQ;
        const offset = sock._sQlen;

        buff[offset] = 251;              // msg-type
        buff[offset + 1] = 0;            // padding
        buff[offset + 2] = width >> 8;   // width
        buff[offset + 3] = width;
        buff[offset + 4] = height >> 8;  // height
        buff[offset + 5] = height;

        buff[offset + 6] = 1;            // number-of-screens
        buff[offset + 7] = 0;            // padding

        // screen array
        buff[offset + 8] = id >> 24;     // id
        buff[offset + 9] = id >> 16;
        buff[offset + 10] = id >> 8;
        buff[offset + 11] = id;
        buff[offset + 12] = 0;           // x-position
        buff[offset + 13] = 0;
        buff[offset + 14] = 0;           // y-position
        buff[offset + 15] = 0;
        buff[offset + 16] = width >> 8;  // width
        buff[offset + 17] = width;
        buff[offset + 18] = height >> 8; // height
        buff[offset + 19] = height;
        buff[offset + 20] = flags >> 24; // flags
        buff[offset + 21] = flags >> 16;
        buff[offset + 22] = flags >> 8;
        buff[offset + 23] = flags;

        sock._sQlen += 24;
        sock.flush();
    },

    clientFence(sock, flags, payload) {
        const buff = sock._sQ;
        const offset = sock._sQlen;

        buff[offset] = 248; // msg-type

        buff[offset + 1] = 0; // padding
        buff[offset + 2] = 0; // padding
        buff[offset + 3] = 0; // padding

        buff[offset + 4] = flags >> 24; // flags
        buff[offset + 5] = flags >> 16;
        buff[offset + 6] = flags >> 8;
        buff[offset + 7] = flags;

        const n = payload.length;

        buff[offset + 8] = n; // length

        for (let i = 0; i < n; i++) {
            buff[offset + 9 + i] = payload.charCodeAt(i);
        }

        sock._sQlen += 9 + n;
        sock.flush();
    },

    enableContinuousUpdates(sock, enable, x, y, width, height) {
        const buff = sock._sQ;
        const offset = sock._sQlen;

        buff[offset] = 150;             // msg-type
        buff[offset + 1] = enable;      // enable-flag

        buff[offset + 2] = x >> 8;      // x
        buff[offset + 3] = x;
        buff[offset + 4] = y >> 8;      // y
        buff[offset + 5] = y;
        buff[offset + 6] = width >> 8;  // width
        buff[offset + 7] = width;
        buff[offset + 8] = height >> 8; // height
        buff[offset + 9] = height;

        sock._sQlen += 10;
        sock.flush();
    },

    pixelFormat(sock, depth, true_color) {
        const buff = sock._sQ;
        const offset = sock._sQlen;

        let bpp;

        if (depth > 16) {
            bpp = 32;
        } else if (depth > 8) {
            bpp = 16;
        } else {
            bpp = 8;
        }

        const bits = Math.floor(depth/3);

        buff[offset] = 0;  // msg-type

        buff[offset + 1] = 0; // padding
        buff[offset + 2] = 0; // padding
        buff[offset + 3] = 0; // padding

        buff[offset + 4] = bpp;                 // bits-per-pixel
        buff[offset + 5] = depth;               // depth
        buff[offset + 6] = 0;                   // little-endian
        buff[offset + 7] = true_color ? 1 : 0;  // true-color

        buff[offset + 8] = 0;    // red-max
        buff[offset + 9] = (1 << bits) - 1;  // red-max

        buff[offset + 10] = 0;   // green-max
        buff[offset + 11] = (1 << bits) - 1; // green-max

        buff[offset + 12] = 0;   // blue-max
        buff[offset + 13] = (1 << bits) - 1; // blue-max

        buff[offset + 14] = bits * 2; // red-shift
        buff[offset + 15] = bits * 1; // green-shift
        buff[offset + 16] = bits * 0; // blue-shift

        buff[offset + 17] = 0;   // padding
        buff[offset + 18] = 0;   // padding
        buff[offset + 19] = 0;   // padding

        sock._sQlen += 20;
        sock.flush();
    },

    clientEncodings(sock, encodings) {
        const buff = sock._sQ;
        const offset = sock._sQlen;

        buff[offset] = 2; // msg-type
        buff[offset + 1] = 0; // padding

        buff[offset + 2] = encodings.length >> 8;
        buff[offset + 3] = encodings.length;

        let j = offset + 4;
        for (let i = 0; i < encodings.length; i++) {
            const enc = encodings[i];
            buff[j] = enc >> 24;
            buff[j + 1] = enc >> 16;
            buff[j + 2] = enc >> 8;
            buff[j + 3] = enc;

            j += 4;
        }

        sock._sQlen += j - offset;
        sock.flush();
    },

    fbUpdateRequest(sock, incremental, x, y, w, h) {
        const buff = sock._sQ;
        const offset = sock._sQlen;

        if (typeof(x) === "undefined") { x = 0; }
        if (typeof(y) === "undefined") { y = 0; }

        buff[offset] = 3;  // msg-type
        buff[offset + 1] = incremental ? 1 : 0;

        buff[offset + 2] = (x >> 8) & 0xFF;
        buff[offset + 3] = x & 0xFF;

        buff[offset + 4] = (y >> 8) & 0xFF;
        buff[offset + 5] = y & 0xFF;

        buff[offset + 6] = (w >> 8) & 0xFF;
        buff[offset + 7] = w & 0xFF;

        buff[offset + 8] = (h >> 8) & 0xFF;
        buff[offset + 9] = h & 0xFF;

        sock._sQlen += 10;
        sock.flush();
    },

    xvpOp(sock, ver, op) {
        const buff = sock._sQ;
        const offset = sock._sQlen;

        buff[offset] = 250; // msg-type
        buff[offset + 1] = 0; // padding

        buff[offset + 2] = ver;
        buff[offset + 3] = op;

        sock._sQlen += 4;
        sock.flush();
    }
};

RFB.cursors = {
    none: {
        rgbaPixels: new Uint8Array(),
        w: 0, h: 0,
        hotx: 0, hoty: 0,
    },

    dot: {
        /* eslint-disable indent */
        rgbaPixels: new Uint8Array([
            255, 255, 255, 255,   0,   0,   0, 255, 255, 255, 255, 255,
              0,   0,   0, 255,   0,   0,   0,   0,   0,   0,  0,  255,
            255, 255, 255, 255,   0,   0,   0, 255, 255, 255, 255, 255,
        ]),
        /* eslint-enable indent */
        w: 3, h: 3,
        hotx: 1, hoty: 1,
    }
};


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/util/browser.js":
/*!********************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/util/browser.js ***!
  \********************************************************/
/*! exports provided: isTouchDevice, dragThreshold, supportsCursorURIs, supportsImageMetadata, isMac, isWindows, isIOS, isAndroid, isSafari, isIE, isEdge, isFirefox */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isTouchDevice", function() { return isTouchDevice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "dragThreshold", function() { return dragThreshold; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportsCursorURIs", function() { return supportsCursorURIs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "supportsImageMetadata", function() { return supportsImageMetadata; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isMac", function() { return isMac; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isWindows", function() { return isWindows; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIOS", function() { return isIOS; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAndroid", function() { return isAndroid; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isSafari", function() { return isSafari; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isIE", function() { return isIE; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isEdge", function() { return isEdge; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isFirefox", function() { return isFirefox; });
/* harmony import */ var _logging_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./logging.js */ "./node_modules/@novnc/novnc/core/util/logging.js");
/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2018 The noVNC Authors
 * Licensed under MPL 2.0 (see LICENSE.txt)
 *
 * See README.md for usage and integration instructions.
 */



// Touch detection
let isTouchDevice = ('ontouchstart' in document.documentElement) ||
                                 // requried for Chrome debugger
                                 (document.ontouchstart !== undefined) ||
                                 // required for MS Surface
                                 (navigator.maxTouchPoints > 0) ||
                                 (navigator.msMaxTouchPoints > 0);
window.addEventListener('touchstart', function onFirstTouch() {
    isTouchDevice = true;
    window.removeEventListener('touchstart', onFirstTouch, false);
}, false);


// The goal is to find a certain physical width, the devicePixelRatio
// brings us a bit closer but is not optimal.
let dragThreshold = 10 * (window.devicePixelRatio || 1);

let _supportsCursorURIs = false;

try {
    const target = document.createElement('canvas');
    target.style.cursor = 'url("data:image/x-icon;base64,AAACAAEACAgAAAIAAgA4AQAAFgAAACgAAAAIAAAAEAAAAAEAIAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAD/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////AAAAAAAAAAAAAAAAAAAAAA==") 2 2, default';

    if (target.style.cursor) {
        _logging_js__WEBPACK_IMPORTED_MODULE_0__["Info"]("Data URI scheme cursor supported");
        _supportsCursorURIs = true;
    } else {
        _logging_js__WEBPACK_IMPORTED_MODULE_0__["Warn"]("Data URI scheme cursor not supported");
    }
} catch (exc) {
    _logging_js__WEBPACK_IMPORTED_MODULE_0__["Error"]("Data URI scheme cursor test exception: " + exc);
}

const supportsCursorURIs = _supportsCursorURIs;

let _supportsImageMetadata = false;
try {
    new ImageData(new Uint8ClampedArray(4), 1, 1);
    _supportsImageMetadata = true;
} catch (ex) {
    // ignore failure
}
const supportsImageMetadata = _supportsImageMetadata;

function isMac() {
    return navigator && !!(/mac/i).exec(navigator.platform);
}

function isWindows() {
    return navigator && !!(/win/i).exec(navigator.platform);
}

function isIOS() {
    return navigator &&
           (!!(/ipad/i).exec(navigator.platform) ||
            !!(/iphone/i).exec(navigator.platform) ||
            !!(/ipod/i).exec(navigator.platform));
}

function isAndroid() {
    return navigator && !!(/android/i).exec(navigator.userAgent);
}

function isSafari() {
    return navigator && (navigator.userAgent.indexOf('Safari') !== -1 &&
                         navigator.userAgent.indexOf('Chrome') === -1);
}

function isIE() {
    return navigator && !!(/trident/i).exec(navigator.userAgent);
}

function isEdge() {
    return navigator && !!(/edge/i).exec(navigator.userAgent);
}

function isFirefox() {
    return navigator && !!(/firefox/i).exec(navigator.userAgent);
}



/***/ }),

/***/ "./node_modules/@novnc/novnc/core/util/cursor.js":
/*!*******************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/util/cursor.js ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Cursor; });
/* harmony import */ var _browser_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./browser.js */ "./node_modules/@novnc/novnc/core/util/browser.js");
/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2018 The noVNC Authors
 * Licensed under MPL 2.0 or any later version (see LICENSE.txt)
 */



const useFallback = !_browser_js__WEBPACK_IMPORTED_MODULE_0__["supportsCursorURIs"] || _browser_js__WEBPACK_IMPORTED_MODULE_0__["isTouchDevice"];

class Cursor {
    constructor() {
        this._target = null;

        this._canvas = document.createElement('canvas');

        if (useFallback) {
            this._canvas.style.position = 'fixed';
            this._canvas.style.zIndex = '65535';
            this._canvas.style.pointerEvents = 'none';
            // Can't use "display" because of Firefox bug #1445997
            this._canvas.style.visibility = 'hidden';
            document.body.appendChild(this._canvas);
        }

        this._position = { x: 0, y: 0 };
        this._hotSpot = { x: 0, y: 0 };

        this._eventHandlers = {
            'mouseover': this._handleMouseOver.bind(this),
            'mouseleave': this._handleMouseLeave.bind(this),
            'mousemove': this._handleMouseMove.bind(this),
            'mouseup': this._handleMouseUp.bind(this),
            'touchstart': this._handleTouchStart.bind(this),
            'touchmove': this._handleTouchMove.bind(this),
            'touchend': this._handleTouchEnd.bind(this),
        };
    }

    attach(target) {
        if (this._target) {
            this.detach();
        }

        this._target = target;

        if (useFallback) {
            // FIXME: These don't fire properly except for mouse
            ///       movement in IE. We want to also capture element
            //        movement, size changes, visibility, etc.
            const options = { capture: true, passive: true };
            this._target.addEventListener('mouseover', this._eventHandlers.mouseover, options);
            this._target.addEventListener('mouseleave', this._eventHandlers.mouseleave, options);
            this._target.addEventListener('mousemove', this._eventHandlers.mousemove, options);
            this._target.addEventListener('mouseup', this._eventHandlers.mouseup, options);

            // There is no "touchleave" so we monitor touchstart globally
            window.addEventListener('touchstart', this._eventHandlers.touchstart, options);
            this._target.addEventListener('touchmove', this._eventHandlers.touchmove, options);
            this._target.addEventListener('touchend', this._eventHandlers.touchend, options);
        }

        this.clear();
    }

    detach() {
        if (useFallback) {
            const options = { capture: true, passive: true };
            this._target.removeEventListener('mouseover', this._eventHandlers.mouseover, options);
            this._target.removeEventListener('mouseleave', this._eventHandlers.mouseleave, options);
            this._target.removeEventListener('mousemove', this._eventHandlers.mousemove, options);
            this._target.removeEventListener('mouseup', this._eventHandlers.mouseup, options);

            window.removeEventListener('touchstart', this._eventHandlers.touchstart, options);
            this._target.removeEventListener('touchmove', this._eventHandlers.touchmove, options);
            this._target.removeEventListener('touchend', this._eventHandlers.touchend, options);
        }

        this._target = null;
    }

    change(rgba, hotx, hoty, w, h) {
        if ((w === 0) || (h === 0)) {
            this.clear();
            return;
        }

        this._position.x = this._position.x + this._hotSpot.x - hotx;
        this._position.y = this._position.y + this._hotSpot.y - hoty;
        this._hotSpot.x = hotx;
        this._hotSpot.y = hoty;

        let ctx = this._canvas.getContext('2d');

        this._canvas.width = w;
        this._canvas.height = h;

        let img;
        try {
            // IE doesn't support this
            img = new ImageData(new Uint8ClampedArray(rgba), w, h);
        } catch (ex) {
            img = ctx.createImageData(w, h);
            img.data.set(new Uint8ClampedArray(rgba));
        }
        ctx.clearRect(0, 0, w, h);
        ctx.putImageData(img, 0, 0);

        if (useFallback) {
            this._updatePosition();
        } else {
            let url = this._canvas.toDataURL();
            this._target.style.cursor = 'url(' + url + ')' + hotx + ' ' + hoty + ', default';
        }
    }

    clear() {
        this._target.style.cursor = 'none';
        this._canvas.width = 0;
        this._canvas.height = 0;
        this._position.x = this._position.x + this._hotSpot.x;
        this._position.y = this._position.y + this._hotSpot.y;
        this._hotSpot.x = 0;
        this._hotSpot.y = 0;
    }

    _handleMouseOver(event) {
        // This event could be because we're entering the target, or
        // moving around amongst its sub elements. Let the move handler
        // sort things out.
        this._handleMouseMove(event);
    }

    _handleMouseLeave(event) {
        this._hideCursor();
    }

    _handleMouseMove(event) {
        this._updateVisibility(event.target);

        this._position.x = event.clientX - this._hotSpot.x;
        this._position.y = event.clientY - this._hotSpot.y;

        this._updatePosition();
    }

    _handleMouseUp(event) {
        // We might get this event because of a drag operation that
        // moved outside of the target. Check what's under the cursor
        // now and adjust visibility based on that.
        let target = document.elementFromPoint(event.clientX, event.clientY);
        this._updateVisibility(target);
    }

    _handleTouchStart(event) {
        // Just as for mouseover, we let the move handler deal with it
        this._handleTouchMove(event);
    }

    _handleTouchMove(event) {
        this._updateVisibility(event.target);

        this._position.x = event.changedTouches[0].clientX - this._hotSpot.x;
        this._position.y = event.changedTouches[0].clientY - this._hotSpot.y;

        this._updatePosition();
    }

    _handleTouchEnd(event) {
        // Same principle as for mouseup
        let target = document.elementFromPoint(event.changedTouches[0].clientX,
                                               event.changedTouches[0].clientY);
        this._updateVisibility(target);
    }

    _showCursor() {
        if (this._canvas.style.visibility === 'hidden') {
            this._canvas.style.visibility = '';
        }
    }

    _hideCursor() {
        if (this._canvas.style.visibility !== 'hidden') {
            this._canvas.style.visibility = 'hidden';
        }
    }

    // Should we currently display the cursor?
    // (i.e. are we over the target, or a child of the target without a
    // different cursor set)
    _shouldShowCursor(target) {
        // Easy case
        if (target === this._target) {
            return true;
        }
        // Other part of the DOM?
        if (!this._target.contains(target)) {
            return false;
        }
        // Has the child its own cursor?
        // FIXME: How can we tell that a sub element has an
        //        explicit "cursor: none;"?
        if (window.getComputedStyle(target).cursor !== 'none') {
            return false;
        }
        return true;
    }

    _updateVisibility(target) {
        if (this._shouldShowCursor(target)) {
            this._showCursor();
        } else {
            this._hideCursor();
        }
    }

    _updatePosition() {
        this._canvas.style.left = this._position.x + "px";
        this._canvas.style.top = this._position.y + "px";
    }
}


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/util/events.js":
/*!*******************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/util/events.js ***!
  \*******************************************************/
/*! exports provided: getPointerEvent, stopEvent, setCapture, releaseCapture */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPointerEvent", function() { return getPointerEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stopEvent", function() { return stopEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setCapture", function() { return setCapture; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "releaseCapture", function() { return releaseCapture; });
/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2018 The noVNC Authors
 * Licensed under MPL 2.0 (see LICENSE.txt)
 *
 * See README.md for usage and integration instructions.
 */

/*
 * Cross-browser event and position routines
 */

function getPointerEvent(e) {
    return e.changedTouches ? e.changedTouches[0] : e.touches ? e.touches[0] : e;
}

function stopEvent(e) {
    e.stopPropagation();
    e.preventDefault();
}

// Emulate Element.setCapture() when not supported
let _captureRecursion = false;
let _captureElem = null;
function _captureProxy(e) {
    // Recursion protection as we'll see our own event
    if (_captureRecursion) return;

    // Clone the event as we cannot dispatch an already dispatched event
    const newEv = new e.constructor(e.type, e);

    _captureRecursion = true;
    _captureElem.dispatchEvent(newEv);
    _captureRecursion = false;

    // Avoid double events
    e.stopPropagation();

    // Respect the wishes of the redirected event handlers
    if (newEv.defaultPrevented) {
        e.preventDefault();
    }

    // Implicitly release the capture on button release
    if (e.type === "mouseup") {
        releaseCapture();
    }
}

// Follow cursor style of target element
function _captureElemChanged() {
    const captureElem = document.getElementById("noVNC_mouse_capture_elem");
    captureElem.style.cursor = window.getComputedStyle(_captureElem).cursor;
}

const _captureObserver = new MutationObserver(_captureElemChanged);

let _captureIndex = 0;

function setCapture(elem) {
    if (elem.setCapture) {

        elem.setCapture();

        // IE releases capture on 'click' events which might not trigger
        elem.addEventListener('mouseup', releaseCapture);

    } else {
        // Release any existing capture in case this method is
        // called multiple times without coordination
        releaseCapture();

        let captureElem = document.getElementById("noVNC_mouse_capture_elem");

        if (captureElem === null) {
            captureElem = document.createElement("div");
            captureElem.id = "noVNC_mouse_capture_elem";
            captureElem.style.position = "fixed";
            captureElem.style.top = "0px";
            captureElem.style.left = "0px";
            captureElem.style.width = "100%";
            captureElem.style.height = "100%";
            captureElem.style.zIndex = 10000;
            captureElem.style.display = "none";
            document.body.appendChild(captureElem);

            // This is to make sure callers don't get confused by having
            // our blocking element as the target
            captureElem.addEventListener('contextmenu', _captureProxy);

            captureElem.addEventListener('mousemove', _captureProxy);
            captureElem.addEventListener('mouseup', _captureProxy);
        }

        _captureElem = elem;
        _captureIndex++;

        // Track cursor and get initial cursor
        _captureObserver.observe(elem, {attributes: true});
        _captureElemChanged();

        captureElem.style.display = "";

        // We listen to events on window in order to keep tracking if it
        // happens to leave the viewport
        window.addEventListener('mousemove', _captureProxy);
        window.addEventListener('mouseup', _captureProxy);
    }
}

function releaseCapture() {
    if (document.releaseCapture) {

        document.releaseCapture();

    } else {
        if (!_captureElem) {
            return;
        }

        // There might be events already queued, so we need to wait for
        // them to flush. E.g. contextmenu in Microsoft Edge
        window.setTimeout((expected) => {
            // Only clear it if it's the expected grab (i.e. no one
            // else has initiated a new grab)
            if (_captureIndex === expected) {
                _captureElem = null;
            }
        }, 0, _captureIndex);

        _captureObserver.disconnect();

        const captureElem = document.getElementById("noVNC_mouse_capture_elem");
        captureElem.style.display = "none";

        window.removeEventListener('mousemove', _captureProxy);
        window.removeEventListener('mouseup', _captureProxy);
    }
}


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/util/eventtarget.js":
/*!************************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/util/eventtarget.js ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EventTargetMixin; });
/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2018 The noVNC Authors
 * Licensed under MPL 2.0 (see LICENSE.txt)
 *
 * See README.md for usage and integration instructions.
 */

class EventTargetMixin {
    constructor() {
        this._listeners = new Map();
    }

    addEventListener(type, callback) {
        if (!this._listeners.has(type)) {
            this._listeners.set(type, new Set());
        }
        this._listeners.get(type).add(callback);
    }

    removeEventListener(type, callback) {
        if (this._listeners.has(type)) {
            this._listeners.get(type).delete(callback);
        }
    }

    dispatchEvent(event) {
        if (!this._listeners.has(event.type)) {
            return true;
        }
        this._listeners.get(event.type)
            .forEach(callback => callback.call(this, event));
        return !event.defaultPrevented;
    }
}


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/util/logging.js":
/*!********************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/util/logging.js ***!
  \********************************************************/
/*! exports provided: init_logging, get_logging, Debug, Info, Warn, Error */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "init_logging", function() { return init_logging; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "get_logging", function() { return get_logging; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Debug", function() { return Debug; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Info", function() { return Info; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Warn", function() { return Warn; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Error", function() { return Error; });
/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2018 The noVNC Authors
 * Licensed under MPL 2.0 (see LICENSE.txt)
 *
 * See README.md for usage and integration instructions.
 */

/*
 * Logging/debug routines
 */

let _log_level = 'warn';

let Debug = () => {};
let Info = () => {};
let Warn = () => {};
let Error = () => {};

function init_logging(level) {
    if (typeof level === 'undefined') {
        level = _log_level;
    } else {
        _log_level = level;
    }

    Debug = Info = Warn = Error = () => {};

    if (typeof window.console !== "undefined") {
        /* eslint-disable no-console, no-fallthrough */
        switch (level) {
            case 'debug':
                Debug = console.debug.bind(window.console);
            case 'info':
                Info  = console.info.bind(window.console);
            case 'warn':
                Warn  = console.warn.bind(window.console);
            case 'error':
                Error = console.error.bind(window.console);
            case 'none':
                break;
            default:
                throw new window.Error("invalid logging type '" + level + "'");
        }
        /* eslint-enable no-console, no-fallthrough */
    }
}

function get_logging() {
    return _log_level;
}



// Initialize logging level
init_logging();


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/util/polyfill.js":
/*!*********************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/util/polyfill.js ***!
  \*********************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2018 The noVNC Authors
 * Licensed under MPL 2.0 or any later version (see LICENSE.txt)
 */

/* Polyfills to provide new APIs in old browsers */

/* Object.assign() (taken from MDN) */
if (typeof Object.assign != 'function') {
    // Must be writable: true, enumerable: false, configurable: true
    Object.defineProperty(Object, "assign", {
        value: function assign(target, varArgs) { // .length of function is 2
            'use strict';
            if (target == null) { // TypeError if undefined or null
                throw new TypeError('Cannot convert undefined or null to object');
            }

            const to = Object(target);

            for (let index = 1; index < arguments.length; index++) {
                const nextSource = arguments[index];

                if (nextSource != null) { // Skip over if undefined or null
                    for (let nextKey in nextSource) {
                        // Avoid bugs when hasOwnProperty is shadowed
                        if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                            to[nextKey] = nextSource[nextKey];
                        }
                    }
                }
            }
            return to;
        },
        writable: true,
        configurable: true
    });
}

/* CustomEvent constructor (taken from MDN) */
(() => {
    function CustomEvent(event, params) {
        params = params || { bubbles: false, cancelable: false, detail: undefined };
        const evt = document.createEvent( 'CustomEvent' );
        evt.initCustomEvent( event, params.bubbles, params.cancelable, params.detail );
        return evt;
    }

    CustomEvent.prototype = window.Event.prototype;

    if (typeof window.CustomEvent !== "function") {
        window.CustomEvent = CustomEvent;
    }
})();


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/util/strings.js":
/*!********************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/util/strings.js ***!
  \********************************************************/
/*! exports provided: decodeUTF8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decodeUTF8", function() { return decodeUTF8; });
/*
 * noVNC: HTML5 VNC client
 * Copyright (C) 2018 The noVNC Authors
 * Licensed under MPL 2.0 (see LICENSE.txt)
 *
 * See README.md for usage and integration instructions.
 */

/*
 * Decode from UTF-8
 */
function decodeUTF8(utf8string) {
    return decodeURIComponent(escape(utf8string));
}


/***/ }),

/***/ "./node_modules/@novnc/novnc/core/websock.js":
/*!***************************************************!*\
  !*** ./node_modules/@novnc/novnc/core/websock.js ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Websock; });
/* harmony import */ var _util_logging_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util/logging.js */ "./node_modules/@novnc/novnc/core/util/logging.js");
/*
 * Websock: high-performance binary WebSockets
 * Copyright (C) 2018 The noVNC Authors
 * Licensed under MPL 2.0 (see LICENSE.txt)
 *
 * Websock is similar to the standard WebSocket object but with extra
 * buffer handling.
 *
 * Websock has built-in receive queue buffering; the message event
 * does not contain actual data but is simply a notification that
 * there is new data available. Several rQ* methods are available to
 * read binary data off of the receive queue.
 */



// this has performance issues in some versions Chromium, and
// doesn't gain a tremendous amount of performance increase in Firefox
// at the moment.  It may be valuable to turn it on in the future.
const ENABLE_COPYWITHIN = false;
const MAX_RQ_GROW_SIZE = 40 * 1024 * 1024;  // 40 MiB

class Websock {
    constructor() {
        this._websocket = null;  // WebSocket object

        this._rQi = 0;           // Receive queue index
        this._rQlen = 0;         // Next write position in the receive queue
        this._rQbufferSize = 1024 * 1024 * 4; // Receive queue buffer size (4 MiB)
        this._rQmax = this._rQbufferSize / 8;
        // called in init: this._rQ = new Uint8Array(this._rQbufferSize);
        this._rQ = null; // Receive queue

        this._sQbufferSize = 1024 * 10;  // 10 KiB
        // called in init: this._sQ = new Uint8Array(this._sQbufferSize);
        this._sQlen = 0;
        this._sQ = null;  // Send queue

        this._eventHandlers = {
            message: () => {},
            open: () => {},
            close: () => {},
            error: () => {}
        };
    }

    // Getters and Setters
    get sQ() {
        return this._sQ;
    }

    get rQ() {
        return this._rQ;
    }

    get rQi() {
        return this._rQi;
    }

    set rQi(val) {
        this._rQi = val;
    }

    // Receive Queue
    get rQlen() {
        return this._rQlen - this._rQi;
    }

    rQpeek8() {
        return this._rQ[this._rQi];
    }

    rQskipBytes(bytes) {
        this._rQi += bytes;
    }

    rQshift8() {
        return this._rQshift(1);
    }

    rQshift16() {
        return this._rQshift(2);
    }

    rQshift32() {
        return this._rQshift(4);
    }

    // TODO(directxman12): test performance with these vs a DataView
    _rQshift(bytes) {
        let res = 0;
        for (let byte = bytes - 1; byte >= 0; byte--) {
            res += this._rQ[this._rQi++] << (byte * 8);
        }
        return res;
    }

    rQshiftStr(len) {
        if (typeof(len) === 'undefined') { len = this.rQlen; }
        let str = "";
        // Handle large arrays in steps to avoid long strings on the stack
        for (let i = 0; i < len; i += 4096) {
            let part = this.rQshiftBytes(Math.min(4096, len - i));
            str += String.fromCharCode.apply(null, part);
        }
        return str;
    }

    rQshiftBytes(len) {
        if (typeof(len) === 'undefined') { len = this.rQlen; }
        this._rQi += len;
        return new Uint8Array(this._rQ.buffer, this._rQi - len, len);
    }

    rQshiftTo(target, len) {
        if (len === undefined) { len = this.rQlen; }
        // TODO: make this just use set with views when using a ArrayBuffer to store the rQ
        target.set(new Uint8Array(this._rQ.buffer, this._rQi, len));
        this._rQi += len;
    }

    rQslice(start, end = this.rQlen) {
        return new Uint8Array(this._rQ.buffer, this._rQi + start, end - start);
    }

    // Check to see if we must wait for 'num' bytes (default to FBU.bytes)
    // to be available in the receive queue. Return true if we need to
    // wait (and possibly print a debug message), otherwise false.
    rQwait(msg, num, goback) {
        if (this.rQlen < num) {
            if (goback) {
                if (this._rQi < goback) {
                    throw new Error("rQwait cannot backup " + goback + " bytes");
                }
                this._rQi -= goback;
            }
            return true; // true means need more data
        }
        return false;
    }

    // Send Queue

    flush() {
        if (this._sQlen > 0 && this._websocket.readyState === WebSocket.OPEN) {
            this._websocket.send(this._encode_message());
            this._sQlen = 0;
        }
    }

    send(arr) {
        this._sQ.set(arr, this._sQlen);
        this._sQlen += arr.length;
        this.flush();
    }

    send_string(str) {
        this.send(str.split('').map(chr => chr.charCodeAt(0)));
    }

    // Event Handlers
    off(evt) {
        this._eventHandlers[evt] = () => {};
    }

    on(evt, handler) {
        this._eventHandlers[evt] = handler;
    }

    _allocate_buffers() {
        this._rQ = new Uint8Array(this._rQbufferSize);
        this._sQ = new Uint8Array(this._sQbufferSize);
    }

    init() {
        this._allocate_buffers();
        this._rQi = 0;
        this._websocket = null;
    }

    open(uri, protocols) {
        this.init();

        this._websocket = new WebSocket(uri, protocols);
        this._websocket.binaryType = 'arraybuffer';

        this._websocket.onmessage = this._recv_message.bind(this);
        this._websocket.onopen = () => {
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]('>> WebSock.onopen');
            if (this._websocket.protocol) {
                _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Info"]("Server choose sub-protocol: " + this._websocket.protocol);
            }

            this._eventHandlers.open();
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("<< WebSock.onopen");
        };
        this._websocket.onclose = (e) => {
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"](">> WebSock.onclose");
            this._eventHandlers.close(e);
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("<< WebSock.onclose");
        };
        this._websocket.onerror = (e) => {
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"](">> WebSock.onerror: " + e);
            this._eventHandlers.error(e);
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("<< WebSock.onerror: " + e);
        };
    }

    close() {
        if (this._websocket) {
            if ((this._websocket.readyState === WebSocket.OPEN) ||
                    (this._websocket.readyState === WebSocket.CONNECTING)) {
                _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Info"]("Closing WebSocket connection");
                this._websocket.close();
            }

            this._websocket.onmessage = () => {};
        }
    }

    // private methods
    _encode_message() {
        // Put in a binary arraybuffer
        // according to the spec, you can send ArrayBufferViews with the send method
        return new Uint8Array(this._sQ.buffer, 0, this._sQlen);
    }

    _expand_compact_rQ(min_fit) {
        const resizeNeeded = min_fit || this.rQlen > this._rQbufferSize / 2;
        if (resizeNeeded) {
            if (!min_fit) {
                // just double the size if we need to do compaction
                this._rQbufferSize *= 2;
            } else {
                // otherwise, make sure we satisy rQlen - rQi + min_fit < rQbufferSize / 8
                this._rQbufferSize = (this.rQlen + min_fit) * 8;
            }
        }

        // we don't want to grow unboundedly
        if (this._rQbufferSize > MAX_RQ_GROW_SIZE) {
            this._rQbufferSize = MAX_RQ_GROW_SIZE;
            if (this._rQbufferSize - this.rQlen < min_fit) {
                throw new Error("Receive Queue buffer exceeded " + MAX_RQ_GROW_SIZE + " bytes, and the new message could not fit");
            }
        }

        if (resizeNeeded) {
            const old_rQbuffer = this._rQ.buffer;
            this._rQmax = this._rQbufferSize / 8;
            this._rQ = new Uint8Array(this._rQbufferSize);
            this._rQ.set(new Uint8Array(old_rQbuffer, this._rQi));
        } else {
            if (ENABLE_COPYWITHIN) {
                this._rQ.copyWithin(0, this._rQi);
            } else {
                this._rQ.set(new Uint8Array(this._rQ.buffer, this._rQi));
            }
        }

        this._rQlen = this._rQlen - this._rQi;
        this._rQi = 0;
    }

    _decode_message(data) {
        // push arraybuffer values onto the end
        const u8 = new Uint8Array(data);
        if (u8.length > this._rQbufferSize - this._rQlen) {
            this._expand_compact_rQ(u8.length);
        }
        this._rQ.set(u8, this._rQlen);
        this._rQlen += u8.length;
    }

    _recv_message(e) {
        this._decode_message(e.data);
        if (this.rQlen > 0) {
            this._eventHandlers.message();
            // Compact the receive queue
            if (this._rQlen == this._rQi) {
                this._rQlen = 0;
                this._rQi = 0;
            } else if (this._rQlen > this._rQmax) {
                this._expand_compact_rQ();
            }
        } else {
            _util_logging_js__WEBPACK_IMPORTED_MODULE_0__["Debug"]("Ignoring empty message");
        }
    }
}


/***/ }),

/***/ "./node_modules/@novnc/novnc/vendor/pako/lib/utils/common.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@novnc/novnc/vendor/pako/lib/utils/common.js ***!
  \*******************************************************************/
/*! exports provided: shrinkBuf, arraySet, flattenChunks, Buf8, Buf16, Buf32 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shrinkBuf", function() { return shrinkBuf; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arraySet", function() { return arraySet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "flattenChunks", function() { return flattenChunks; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Buf8", function() { return Buf8; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Buf16", function() { return Buf16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Buf32", function() { return Buf32; });
// reduce buffer size, avoiding mem copy
function shrinkBuf (buf, size) {
  if (buf.length === size) { return buf; }
  if (buf.subarray) { return buf.subarray(0, size); }
  buf.length = size;
  return buf;
};


function arraySet (dest, src, src_offs, len, dest_offs) {
  if (src.subarray && dest.subarray) {
    dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
    return;
  }
  // Fallback to ordinary array
  for (var i = 0; i < len; i++) {
    dest[dest_offs + i] = src[src_offs + i];
  }
}

// Join array of chunks to single array.
function flattenChunks (chunks) {
  var i, l, len, pos, chunk, result;

  // calculate data length
  len = 0;
  for (i = 0, l = chunks.length; i < l; i++) {
    len += chunks[i].length;
  }

  // join chunks
  result = new Uint8Array(len);
  pos = 0;
  for (i = 0, l = chunks.length; i < l; i++) {
    chunk = chunks[i];
    result.set(chunk, pos);
    pos += chunk.length;
  }

  return result;
}

var Buf8  = Uint8Array;
var Buf16 = Uint16Array;
var Buf32 = Int32Array;


/***/ }),

/***/ "./node_modules/@novnc/novnc/vendor/pako/lib/zlib/adler32.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@novnc/novnc/vendor/pako/lib/zlib/adler32.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return adler32; });
// Note: adler32 takes 12% for level 0 and 2% for level 6.
// It doesn't worth to make additional optimizationa as in original.
// Small size is preferable.

function adler32(adler, buf, len, pos) {
  var s1 = (adler & 0xffff) |0,
      s2 = ((adler >>> 16) & 0xffff) |0,
      n = 0;

  while (len !== 0) {
    // Set limit ~ twice less than 5552, to keep
    // s2 in 31-bits, because we force signed ints.
    // in other case %= will fail.
    n = len > 2000 ? 2000 : len;
    len -= n;

    do {
      s1 = (s1 + buf[pos++]) |0;
      s2 = (s2 + s1) |0;
    } while (--n);

    s1 %= 65521;
    s2 %= 65521;
  }

  return (s1 | (s2 << 16)) |0;
}


/***/ }),

/***/ "./node_modules/@novnc/novnc/vendor/pako/lib/zlib/crc32.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@novnc/novnc/vendor/pako/lib/zlib/crc32.js ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return makeTable; });
// Note: we can't get significant speed boost here.
// So write code to minimize size - no pregenerated tables
// and array tools dependencies.


// Use ordinary array, since untyped makes no boost here
function makeTable() {
  var c, table = [];

  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
    }
    table[n] = c;
  }

  return table;
}

// Create table on load. Just 255 signed longs. Not a problem.
var crcTable = makeTable();


function crc32(crc, buf, len, pos) {
  var t = crcTable,
      end = pos + len;

  crc ^= -1;

  for (var i = pos; i < end; i++) {
    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];
  }

  return (crc ^ (-1)); // >>> 0;
}


/***/ }),

/***/ "./node_modules/@novnc/novnc/vendor/pako/lib/zlib/inffast.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@novnc/novnc/vendor/pako/lib/zlib/inffast.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return inflate_fast; });
// See state defs from inflate.js
var BAD = 30;       /* got a data error -- remain here until reset */
var TYPE = 12;      /* i: waiting for type bits, including last-flag bit */

/*
   Decode literal, length, and distance codes and write out the resulting
   literal and match bytes until either not enough input or output is
   available, an end-of-block is encountered, or a data error is encountered.
   When large enough input and output buffers are supplied to inflate(), for
   example, a 16K input buffer and a 64K output buffer, more than 95% of the
   inflate execution time is spent in this routine.

   Entry assumptions:

        state.mode === LEN
        strm.avail_in >= 6
        strm.avail_out >= 258
        start >= strm.avail_out
        state.bits < 8

   On return, state.mode is one of:

        LEN -- ran out of enough output space or enough available input
        TYPE -- reached end of block code, inflate() to interpret next block
        BAD -- error in block data

   Notes:

    - The maximum input bits used by a length/distance pair is 15 bits for the
      length code, 5 bits for the length extra, 15 bits for the distance code,
      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.
      Therefore if strm.avail_in >= 6, then there is enough input to avoid
      checking for available input while decoding.

    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm.avail_out >= 258 for each loop to avoid checking for
      output space.
 */
function inflate_fast(strm, start) {
  var state;
  var _in;                    /* local strm.input */
  var last;                   /* have enough input while in < last */
  var _out;                   /* local strm.output */
  var beg;                    /* inflate()'s initial strm.output */
  var end;                    /* while out < end, enough space available */
//#ifdef INFLATE_STRICT
  var dmax;                   /* maximum distance from zlib header */
//#endif
  var wsize;                  /* window size or zero if not using window */
  var whave;                  /* valid bytes in the window */
  var wnext;                  /* window write index */
  // Use `s_window` instead `window`, avoid conflict with instrumentation tools
  var s_window;               /* allocated sliding window, if wsize != 0 */
  var hold;                   /* local strm.hold */
  var bits;                   /* local strm.bits */
  var lcode;                  /* local strm.lencode */
  var dcode;                  /* local strm.distcode */
  var lmask;                  /* mask for first level of length codes */
  var dmask;                  /* mask for first level of distance codes */
  var here;                   /* retrieved table entry */
  var op;                     /* code bits, operation, extra bits, or */
                              /*  window position, window bytes to copy */
  var len;                    /* match length, unused bytes */
  var dist;                   /* match distance */
  var from;                   /* where to copy match from */
  var from_source;


  var input, output; // JS specific, because we have no pointers

  /* copy state to local variables */
  state = strm.state;
  //here = state.here;
  _in = strm.next_in;
  input = strm.input;
  last = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
//#ifdef INFLATE_STRICT
  dmax = state.dmax;
//#endif
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;


  /* decode literals and length/distances until end-of-block or not enough
     input data or output space */

  top:
  do {
    if (bits < 15) {
      hold += input[_in++] << bits;
      bits += 8;
      hold += input[_in++] << bits;
      bits += 8;
    }

    here = lcode[hold & lmask];

    dolen:
    for (;;) { // Goto emulation
      op = here >>> 24/*here.bits*/;
      hold >>>= op;
      bits -= op;
      op = (here >>> 16) & 0xff/*here.op*/;
      if (op === 0) {                          /* literal */
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        output[_out++] = here & 0xffff/*here.val*/;
      }
      else if (op & 16) {                     /* length base */
        len = here & 0xffff/*here.val*/;
        op &= 15;                           /* number of extra bits */
        if (op) {
          if (bits < op) {
            hold += input[_in++] << bits;
            bits += 8;
          }
          len += hold & ((1 << op) - 1);
          hold >>>= op;
          bits -= op;
        }
        //Tracevv((stderr, "inflate:         length %u\n", len));
        if (bits < 15) {
          hold += input[_in++] << bits;
          bits += 8;
          hold += input[_in++] << bits;
          bits += 8;
        }
        here = dcode[hold & dmask];

        dodist:
        for (;;) { // goto emulation
          op = here >>> 24/*here.bits*/;
          hold >>>= op;
          bits -= op;
          op = (here >>> 16) & 0xff/*here.op*/;

          if (op & 16) {                      /* distance base */
            dist = here & 0xffff/*here.val*/;
            op &= 15;                       /* number of extra bits */
            if (bits < op) {
              hold += input[_in++] << bits;
              bits += 8;
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
            }
            dist += hold & ((1 << op) - 1);
//#ifdef INFLATE_STRICT
            if (dist > dmax) {
              strm.msg = 'invalid distance too far back';
              state.mode = BAD;
              break top;
            }
//#endif
            hold >>>= op;
            bits -= op;
            //Tracevv((stderr, "inflate:         distance %u\n", dist));
            op = _out - beg;                /* max distance in output */
            if (dist > op) {                /* see if copy from window */
              op = dist - op;               /* distance back in window */
              if (op > whave) {
                if (state.sane) {
                  strm.msg = 'invalid distance too far back';
                  state.mode = BAD;
                  break top;
                }

// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//                if (len <= op - whave) {
//                  do {
//                    output[_out++] = 0;
//                  } while (--len);
//                  continue top;
//                }
//                len -= op - whave;
//                do {
//                  output[_out++] = 0;
//                } while (--op > whave);
//                if (op === 0) {
//                  from = _out - dist;
//                  do {
//                    output[_out++] = output[from++];
//                  } while (--len);
//                  continue top;
//                }
//#endif
              }
              from = 0; // window index
              from_source = s_window;
              if (wnext === 0) {           /* very common case */
                from += wsize - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              else if (wnext < op) {      /* wrap around window */
                from += wsize + wnext - op;
                op -= wnext;
                if (op < len) {         /* some from end of window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = 0;
                  if (wnext < len) {  /* some from start of window */
                    op = wnext;
                    len -= op;
                    do {
                      output[_out++] = s_window[from++];
                    } while (--op);
                    from = _out - dist;      /* rest from output */
                    from_source = output;
                  }
                }
              }
              else {                      /* contiguous in window */
                from += wnext - op;
                if (op < len) {         /* some from window */
                  len -= op;
                  do {
                    output[_out++] = s_window[from++];
                  } while (--op);
                  from = _out - dist;  /* rest from output */
                  from_source = output;
                }
              }
              while (len > 2) {
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                output[_out++] = from_source[from++];
                len -= 3;
              }
              if (len) {
                output[_out++] = from_source[from++];
                if (len > 1) {
                  output[_out++] = from_source[from++];
                }
              }
            }
            else {
              from = _out - dist;          /* copy direct from output */
              do {                        /* minimum length is three */
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                output[_out++] = output[from++];
                len -= 3;
              } while (len > 2);
              if (len) {
                output[_out++] = output[from++];
                if (len > 1) {
                  output[_out++] = output[from++];
                }
              }
            }
          }
          else if ((op & 64) === 0) {          /* 2nd level distance code */
            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
            continue dodist;
          }
          else {
            strm.msg = 'invalid distance code';
            state.mode = BAD;
            break top;
          }

          break; // need to emulate goto via "continue"
        }
      }
      else if ((op & 64) === 0) {              /* 2nd level length code */
        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];
        continue dolen;
      }
      else if (op & 32) {                     /* end-of-block */
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.mode = TYPE;
        break top;
      }
      else {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break top;
      }

      break; // need to emulate goto via "continue"
    }
  } while (_in < last && _out < end);

  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;

  /* update state and return */
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));
  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));
  state.hold = hold;
  state.bits = bits;
  return;
};


/***/ }),

/***/ "./node_modules/@novnc/novnc/vendor/pako/lib/zlib/inflate.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@novnc/novnc/vendor/pako/lib/zlib/inflate.js ***!
  \*******************************************************************/
/*! exports provided: inflateReset, inflateReset2, inflateResetKeep, inflateInit, inflateInit2, inflate, inflateEnd, inflateGetHeader, inflateSetDictionary, inflateInfo */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflateReset", function() { return inflateReset; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflateReset2", function() { return inflateReset2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflateResetKeep", function() { return inflateResetKeep; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflateInit", function() { return inflateInit; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflateInit2", function() { return inflateInit2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflate", function() { return inflate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflateEnd", function() { return inflateEnd; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflateGetHeader", function() { return inflateGetHeader; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflateSetDictionary", function() { return inflateSetDictionary; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "inflateInfo", function() { return inflateInfo; });
/* harmony import */ var _utils_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/common.js */ "./node_modules/@novnc/novnc/vendor/pako/lib/utils/common.js");
/* harmony import */ var _adler32_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./adler32.js */ "./node_modules/@novnc/novnc/vendor/pako/lib/zlib/adler32.js");
/* harmony import */ var _crc32_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./crc32.js */ "./node_modules/@novnc/novnc/vendor/pako/lib/zlib/crc32.js");
/* harmony import */ var _inffast_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./inffast.js */ "./node_modules/@novnc/novnc/vendor/pako/lib/zlib/inffast.js");
/* harmony import */ var _inftrees_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./inftrees.js */ "./node_modules/@novnc/novnc/vendor/pako/lib/zlib/inftrees.js");






var CODES = 0;
var LENS = 1;
var DISTS = 2;

/* Public constants ==========================================================*/
/* ===========================================================================*/


/* Allowed flush values; see deflate() and inflate() below for details */
//var Z_NO_FLUSH      = 0;
//var Z_PARTIAL_FLUSH = 1;
//var Z_SYNC_FLUSH    = 2;
//var Z_FULL_FLUSH    = 3;
var Z_FINISH        = 4;
var Z_BLOCK         = 5;
var Z_TREES         = 6;


/* Return codes for the compression/decompression functions. Negative values
 * are errors, positive values are used for special but normal events.
 */
var Z_OK            = 0;
var Z_STREAM_END    = 1;
var Z_NEED_DICT     = 2;
//var Z_ERRNO         = -1;
var Z_STREAM_ERROR  = -2;
var Z_DATA_ERROR    = -3;
var Z_MEM_ERROR     = -4;
var Z_BUF_ERROR     = -5;
//var Z_VERSION_ERROR = -6;

/* The deflate compression method */
var Z_DEFLATED  = 8;


/* STATES ====================================================================*/
/* ===========================================================================*/


var    HEAD = 1;       /* i: waiting for magic header */
var    FLAGS = 2;      /* i: waiting for method and flags (gzip) */
var    TIME = 3;       /* i: waiting for modification time (gzip) */
var    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */
var    EXLEN = 5;      /* i: waiting for extra length (gzip) */
var    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */
var    NAME = 7;       /* i: waiting for end of file name (gzip) */
var    COMMENT = 8;    /* i: waiting for end of comment (gzip) */
var    HCRC = 9;       /* i: waiting for header crc (gzip) */
var    DICTID = 10;    /* i: waiting for dictionary check value */
var    DICT = 11;      /* waiting for inflateSetDictionary() call */
var        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */
var        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */
var        STORED = 14;    /* i: waiting for stored size (length and complement) */
var        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */
var        COPY = 16;      /* i/o: waiting for input or output to copy stored block */
var        TABLE = 17;     /* i: waiting for dynamic block table lengths */
var        LENLENS = 18;   /* i: waiting for code length code lengths */
var        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */
var            LEN_ = 20;      /* i: same as LEN below, but only first time in */
var            LEN = 21;       /* i: waiting for length/lit/eob code */
var            LENEXT = 22;    /* i: waiting for length extra bits */
var            DIST = 23;      /* i: waiting for distance code */
var            DISTEXT = 24;   /* i: waiting for distance extra bits */
var            MATCH = 25;     /* o: waiting for output space to copy string */
var            LIT = 26;       /* o: waiting for output space to write literal */
var    CHECK = 27;     /* i: waiting for 32-bit check value */
var    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */
var    DONE = 29;      /* finished check, done -- remain here until reset */
var    BAD = 30;       /* got a data error -- remain here until reset */
var    MEM = 31;       /* got an inflate() memory error -- remain here until reset */
var    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */

/* ===========================================================================*/



var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);

var MAX_WBITS = 15;
/* 32K LZ77 window */
var DEF_WBITS = MAX_WBITS;


function zswap32(q) {
  return  (((q >>> 24) & 0xff) +
          ((q >>> 8) & 0xff00) +
          ((q & 0xff00) << 8) +
          ((q & 0xff) << 24));
}


function InflateState() {
  this.mode = 0;             /* current inflate mode */
  this.last = false;          /* true if processing last block */
  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */
  this.havedict = false;      /* true if dictionary provided */
  this.flags = 0;             /* gzip header method and flags (0 if zlib) */
  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */
  this.check = 0;             /* protected copy of check value */
  this.total = 0;             /* protected copy of output count */
  // TODO: may be {}
  this.head = null;           /* where to save gzip header information */

  /* sliding window */
  this.wbits = 0;             /* log base 2 of requested window size */
  this.wsize = 0;             /* window size or zero if not using window */
  this.whave = 0;             /* valid bytes in the window */
  this.wnext = 0;             /* window write index */
  this.window = null;         /* allocated sliding window, if needed */

  /* bit accumulator */
  this.hold = 0;              /* input bit accumulator */
  this.bits = 0;              /* number of bits in "in" */

  /* for string and stored block copying */
  this.length = 0;            /* literal or length of data to copy */
  this.offset = 0;            /* distance back to copy string from */

  /* for table and code decoding */
  this.extra = 0;             /* extra bits needed */

  /* fixed and dynamic code tables */
  this.lencode = null;          /* starting table for length/literal codes */
  this.distcode = null;         /* starting table for distance codes */
  this.lenbits = 0;           /* index bits for lencode */
  this.distbits = 0;          /* index bits for distcode */

  /* dynamic table building */
  this.ncode = 0;             /* number of code length code lengths */
  this.nlen = 0;              /* number of length code lengths */
  this.ndist = 0;             /* number of distance code lengths */
  this.have = 0;              /* number of code lengths in lens[] */
  this.next = null;              /* next available space in codes[] */

  this.lens = new _utils_common_js__WEBPACK_IMPORTED_MODULE_0__["Buf16"](320); /* temporary storage for code lengths */
  this.work = new _utils_common_js__WEBPACK_IMPORTED_MODULE_0__["Buf16"](288); /* work area for code table building */

  /*
   because we don't have pointers in js, we use lencode and distcode directly
   as buffers so we don't need codes
  */
  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */
  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */
  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */
  this.sane = 0;                   /* if false, allow invalid distance too far */
  this.back = 0;                   /* bits back of last unprocessed length/lit */
  this.was = 0;                    /* initial length of match */
}

function inflateResetKeep(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = ''; /*Z_NULL*/
  if (state.wrap) {       /* to support ill-conceived Java test suite */
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null/*Z_NULL*/;
  state.hold = 0;
  state.bits = 0;
  //state.lencode = state.distcode = state.next = state.codes;
  state.lencode = state.lendyn = new _utils_common_js__WEBPACK_IMPORTED_MODULE_0__["Buf32"](ENOUGH_LENS);
  state.distcode = state.distdyn = new _utils_common_js__WEBPACK_IMPORTED_MODULE_0__["Buf32"](ENOUGH_DISTS);

  state.sane = 1;
  state.back = -1;
  //Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}

function inflateReset(strm) {
  var state;

  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);

}

function inflateReset2(strm, windowBits) {
  var wrap;
  var state;

  /* get the state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;

  /* extract wrap request from windowBits parameter */
  if (windowBits < 0) {
    wrap = 0;
    windowBits = -windowBits;
  }
  else {
    wrap = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }

  /* set number of window bits, free window if different */
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }

  /* update state and reset the rest of it */
  state.wrap = wrap;
  state.wbits = windowBits;
  return inflateReset(strm);
}

function inflateInit2(strm, windowBits) {
  var ret;
  var state;

  if (!strm) { return Z_STREAM_ERROR; }
  //strm.msg = Z_NULL;                 /* in case we return an error */

  state = new InflateState();

  //if (state === Z_NULL) return Z_MEM_ERROR;
  //Tracev((stderr, "inflate: allocated\n"));
  strm.state = state;
  state.window = null/*Z_NULL*/;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK) {
    strm.state = null/*Z_NULL*/;
  }
  return ret;
}

function inflateInit(strm) {
  return inflateInit2(strm, DEF_WBITS);
}


/*
 Return state with length and distance decoding tables and index sizes set to
 fixed code decoding.  Normally this returns fixed tables from inffixed.h.
 If BUILDFIXED is defined, then instead this routine builds the tables the
 first time it's called, and returns those tables the first time and
 thereafter.  This reduces the size of the code by about 2K bytes, in
 exchange for a little execution time.  However, BUILDFIXED should not be
 used for threaded applications, since the rewriting of the tables and virgin
 may not be thread-safe.
 */
var virgin = true;

var lenfix, distfix; // We have no pointers in JS, so keep tables separate

function fixedtables(state) {
  /* build fixed huffman tables if first call (may not be thread safe) */
  if (virgin) {
    var sym;

    lenfix = new _utils_common_js__WEBPACK_IMPORTED_MODULE_0__["Buf32"](512);
    distfix = new _utils_common_js__WEBPACK_IMPORTED_MODULE_0__["Buf32"](32);

    /* literal/length table */
    sym = 0;
    while (sym < 144) { state.lens[sym++] = 8; }
    while (sym < 256) { state.lens[sym++] = 9; }
    while (sym < 280) { state.lens[sym++] = 7; }
    while (sym < 288) { state.lens[sym++] = 8; }

    Object(_inftrees_js__WEBPACK_IMPORTED_MODULE_4__["default"])(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });

    /* distance table */
    sym = 0;
    while (sym < 32) { state.lens[sym++] = 5; }

    Object(_inftrees_js__WEBPACK_IMPORTED_MODULE_4__["default"])(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });

    /* do this just once */
    virgin = false;
  }

  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}


/*
 Update the window with the last wsize (normally 32K) bytes written before
 returning.  If window does not exist yet, create it.  This is only called
 when a window is already in use, or when output has been written during this
 inflate call, but the end of the deflate stream has not been reached yet.
 It is also called to create a window for dictionary data when a dictionary
 is loaded.

 Providing output buffers larger than 32K to inflate() should provide a speed
 advantage, since only the last 32K of output is copied to the sliding window
 upon return from inflate(), and since all distances after the first 32K of
 output will fall in the output data, making match copies simpler and faster.
 The advantage may be dependent on the size of the processor's data caches.
 */
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;

  /* if it hasn't been done already, allocate space for the window */
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;

    state.window = new _utils_common_js__WEBPACK_IMPORTED_MODULE_0__["Buf8"](state.wsize);
  }

  /* copy state->wsize or less output bytes into the circular window */
  if (copy >= state.wsize) {
    _utils_common_js__WEBPACK_IMPORTED_MODULE_0__["arraySet"](state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  }
  else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    //zmemcpy(state->window + state->wnext, end - copy, dist);
    _utils_common_js__WEBPACK_IMPORTED_MODULE_0__["arraySet"](state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      //zmemcpy(state->window, end - copy, copy);
      _utils_common_js__WEBPACK_IMPORTED_MODULE_0__["arraySet"](state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    }
    else {
      state.wnext += dist;
      if (state.wnext === state.wsize) { state.wnext = 0; }
      if (state.whave < state.wsize) { state.whave += dist; }
    }
  }
  return 0;
}

function inflate(strm, flush) {
  var state;
  var input, output;          // input/output buffers
  var next;                   /* next input INDEX */
  var put;                    /* next output INDEX */
  var have, left;             /* available input and output */
  var hold;                   /* bit buffer */
  var bits;                   /* bits in bit buffer */
  var _in, _out;              /* save starting available input and output */
  var copy;                   /* number of stored or match bytes to copy */
  var from;                   /* where to copy match bytes from */
  var from_source;
  var here = 0;               /* current decoding table entry */
  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)
  //var last;                   /* parent table entry */
  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)
  var len;                    /* length to copy for repeats, bits to drop */
  var ret;                    /* return code */
  var hbuf = new _utils_common_js__WEBPACK_IMPORTED_MODULE_0__["Buf8"](4);    /* buffer for gzip header crc calculation */
  var opts;

  var n; // temporary var for NEED_BITS

  var order = /* permutation of code lengths */
    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];


  if (!strm || !strm.state || !strm.output ||
      (!strm.input && strm.avail_in !== 0)) {
    return Z_STREAM_ERROR;
  }

  state = strm.state;
  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */


  //--- LOAD() ---
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  //---

  _in = have;
  _out = left;
  ret = Z_OK;

  inf_leave: // goto emulation
  for (;;) {
    switch (state.mode) {
    case HEAD:
      if (state.wrap === 0) {
        state.mode = TYPEDO;
        break;
      }
      //=== NEEDBITS(16);
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */
        state.check = 0/*crc32(0L, Z_NULL, 0)*/;
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = Object(_crc32_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.check, hbuf, 2, 0);
        //===//

        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        state.mode = FLAGS;
        break;
      }
      state.flags = 0;           /* expect zlib header */
      if (state.head) {
        state.head.done = false;
      }
      if (!(state.wrap & 1) ||   /* check if zlib header allowed */
        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {
        strm.msg = 'incorrect header check';
        state.mode = BAD;
        break;
      }
      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
      len = (hold & 0x0f)/*BITS(4)*/ + 8;
      if (state.wbits === 0) {
        state.wbits = len;
      }
      else if (len > state.wbits) {
        strm.msg = 'invalid window size';
        state.mode = BAD;
        break;
      }
      state.dmax = 1 << len;
      //Tracev((stderr, "inflate:   zlib header ok\n"));
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = hold & 0x200 ? DICTID : TYPE;
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      break;
    case FLAGS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.flags = hold;
      if ((state.flags & 0xff) !== Z_DEFLATED) {
        strm.msg = 'unknown compression method';
        state.mode = BAD;
        break;
      }
      if (state.flags & 0xe000) {
        strm.msg = 'unknown header flags set';
        state.mode = BAD;
        break;
      }
      if (state.head) {
        state.head.text = ((hold >> 8) & 1);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = Object(_crc32_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = TIME;
      /* falls through */
    case TIME:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.time = hold;
      }
      if (state.flags & 0x0200) {
        //=== CRC4(state.check, hold)
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        hbuf[2] = (hold >>> 16) & 0xff;
        hbuf[3] = (hold >>> 24) & 0xff;
        state.check = Object(_crc32_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.check, hbuf, 4, 0);
        //===
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = OS;
      /* falls through */
    case OS:
      //=== NEEDBITS(16); */
      while (bits < 16) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if (state.head) {
        state.head.xflags = (hold & 0xff);
        state.head.os = (hold >> 8);
      }
      if (state.flags & 0x0200) {
        //=== CRC2(state.check, hold);
        hbuf[0] = hold & 0xff;
        hbuf[1] = (hold >>> 8) & 0xff;
        state.check = Object(_crc32_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.check, hbuf, 2, 0);
        //===//
      }
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = EXLEN;
      /* falls through */
    case EXLEN:
      if (state.flags & 0x0400) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length = hold;
        if (state.head) {
          state.head.extra_len = hold;
        }
        if (state.flags & 0x0200) {
          //=== CRC2(state.check, hold);
          hbuf[0] = hold & 0xff;
          hbuf[1] = (hold >>> 8) & 0xff;
          state.check = Object(_crc32_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.check, hbuf, 2, 0);
          //===//
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      else if (state.head) {
        state.head.extra = null/*Z_NULL*/;
      }
      state.mode = EXTRA;
      /* falls through */
    case EXTRA:
      if (state.flags & 0x0400) {
        copy = state.length;
        if (copy > have) { copy = have; }
        if (copy) {
          if (state.head) {
            len = state.head.extra_len - state.length;
            if (!state.head.extra) {
              // Use untyped array for more conveniend processing later
              state.head.extra = new Array(state.head.extra_len);
            }
            _utils_common_js__WEBPACK_IMPORTED_MODULE_0__["arraySet"](
              state.head.extra,
              input,
              next,
              // extra field is limited to 65536 bytes
              // - no need for additional size check
              copy,
              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
              len
            );
            //zmemcpy(state.head.extra + len, next,
            //        len + copy > state.head.extra_max ?
            //        state.head.extra_max - len : copy);
          }
          if (state.flags & 0x0200) {
            state.check = Object(_crc32_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.check, input, copy, next);
          }
          have -= copy;
          next += copy;
          state.length -= copy;
        }
        if (state.length) { break inf_leave; }
      }
      state.length = 0;
      state.mode = NAME;
      /* falls through */
    case NAME:
      if (state.flags & 0x0800) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          // TODO: 2 or 1 bytes?
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.name_max*/)) {
            state.head.name += String.fromCharCode(len);
          }
        } while (len && copy < have);

        if (state.flags & 0x0200) {
          state.check = Object(_crc32_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.name = null;
      }
      state.length = 0;
      state.mode = COMMENT;
      /* falls through */
    case COMMENT:
      if (state.flags & 0x1000) {
        if (have === 0) { break inf_leave; }
        copy = 0;
        do {
          len = input[next + copy++];
          /* use constant limit because in js we should not preallocate memory */
          if (state.head && len &&
              (state.length < 65536 /*state.head.comm_max*/)) {
            state.head.comment += String.fromCharCode(len);
          }
        } while (len && copy < have);
        if (state.flags & 0x0200) {
          state.check = Object(_crc32_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.check, input, copy, next);
        }
        have -= copy;
        next += copy;
        if (len) { break inf_leave; }
      }
      else if (state.head) {
        state.head.comment = null;
      }
      state.mode = HCRC;
      /* falls through */
    case HCRC:
      if (state.flags & 0x0200) {
        //=== NEEDBITS(16); */
        while (bits < 16) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.check & 0xffff)) {
          strm.msg = 'header crc mismatch';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
      }
      if (state.head) {
        state.head.hcrc = ((state.flags >> 9) & 1);
        state.head.done = true;
      }
      strm.adler = state.check = 0;
      state.mode = TYPE;
      break;
    case DICTID:
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      strm.adler = state.check = zswap32(hold);
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = DICT;
      /* falls through */
    case DICT:
      if (state.havedict === 0) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        return Z_NEED_DICT;
      }
      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;
      state.mode = TYPE;
      /* falls through */
    case TYPE:
      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case TYPEDO:
      if (state.last) {
        //--- BYTEBITS() ---//
        hold >>>= bits & 7;
        bits -= bits & 7;
        //---//
        state.mode = CHECK;
        break;
      }
      //=== NEEDBITS(3); */
      while (bits < 3) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.last = (hold & 0x01)/*BITS(1)*/;
      //--- DROPBITS(1) ---//
      hold >>>= 1;
      bits -= 1;
      //---//

      switch ((hold & 0x03)/*BITS(2)*/) {
      case 0:                             /* stored block */
        //Tracev((stderr, "inflate:     stored block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = STORED;
        break;
      case 1:                             /* fixed block */
        fixedtables(state);
        //Tracev((stderr, "inflate:     fixed codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = LEN_;             /* decode codes */
        if (flush === Z_TREES) {
          //--- DROPBITS(2) ---//
          hold >>>= 2;
          bits -= 2;
          //---//
          break inf_leave;
        }
        break;
      case 2:                             /* dynamic block */
        //Tracev((stderr, "inflate:     dynamic codes block%s\n",
        //        state.last ? " (last)" : ""));
        state.mode = TABLE;
        break;
      case 3:
        strm.msg = 'invalid block type';
        state.mode = BAD;
      }
      //--- DROPBITS(2) ---//
      hold >>>= 2;
      bits -= 2;
      //---//
      break;
    case STORED:
      //--- BYTEBITS() ---// /* go to byte boundary */
      hold >>>= bits & 7;
      bits -= bits & 7;
      //---//
      //=== NEEDBITS(32); */
      while (bits < 32) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {
        strm.msg = 'invalid stored block lengths';
        state.mode = BAD;
        break;
      }
      state.length = hold & 0xffff;
      //Tracev((stderr, "inflate:       stored length %u\n",
      //        state.length));
      //=== INITBITS();
      hold = 0;
      bits = 0;
      //===//
      state.mode = COPY_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case COPY_:
      state.mode = COPY;
      /* falls through */
    case COPY:
      copy = state.length;
      if (copy) {
        if (copy > have) { copy = have; }
        if (copy > left) { copy = left; }
        if (copy === 0) { break inf_leave; }
        //--- zmemcpy(put, next, copy); ---
        _utils_common_js__WEBPACK_IMPORTED_MODULE_0__["arraySet"](output, input, next, copy, put);
        //---//
        have -= copy;
        next += copy;
        left -= copy;
        put += copy;
        state.length -= copy;
        break;
      }
      //Tracev((stderr, "inflate:       stored end\n"));
      state.mode = TYPE;
      break;
    case TABLE:
      //=== NEEDBITS(14); */
      while (bits < 14) {
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
      }
      //===//
      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;
      //--- DROPBITS(5) ---//
      hold >>>= 5;
      bits -= 5;
      //---//
      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;
      //--- DROPBITS(4) ---//
      hold >>>= 4;
      bits -= 4;
      //---//
//#ifndef PKZIP_BUG_WORKAROUND
      if (state.nlen > 286 || state.ndist > 30) {
        strm.msg = 'too many length or distance symbols';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracev((stderr, "inflate:       table sizes ok\n"));
      state.have = 0;
      state.mode = LENLENS;
      /* falls through */
    case LENLENS:
      while (state.have < state.ncode) {
        //=== NEEDBITS(3);
        while (bits < 3) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);
        //--- DROPBITS(3) ---//
        hold >>>= 3;
        bits -= 3;
        //---//
      }
      while (state.have < 19) {
        state.lens[order[state.have++]] = 0;
      }
      // We have separate tables & no pointers. 2 commented lines below not needed.
      //state.next = state.codes;
      //state.lencode = state.next;
      // Switch to use dynamic table
      state.lencode = state.lendyn;
      state.lenbits = 7;

      opts = { bits: state.lenbits };
      ret = Object(_inftrees_js__WEBPACK_IMPORTED_MODULE_4__["default"])(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);
      state.lenbits = opts.bits;

      if (ret) {
        strm.msg = 'invalid code lengths set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, "inflate:       code lengths ok\n"));
      state.have = 0;
      state.mode = CODELENS;
      /* falls through */
    case CODELENS:
      while (state.have < state.nlen + state.ndist) {
        for (;;) {
          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        if (here_val < 16) {
          //--- DROPBITS(here.bits) ---//
          hold >>>= here_bits;
          bits -= here_bits;
          //---//
          state.lens[state.have++] = here_val;
        }
        else {
          if (here_val === 16) {
            //=== NEEDBITS(here.bits + 2);
            n = here_bits + 2;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            if (state.have === 0) {
              strm.msg = 'invalid bit length repeat';
              state.mode = BAD;
              break;
            }
            len = state.lens[state.have - 1];
            copy = 3 + (hold & 0x03);//BITS(2);
            //--- DROPBITS(2) ---//
            hold >>>= 2;
            bits -= 2;
            //---//
          }
          else if (here_val === 17) {
            //=== NEEDBITS(here.bits + 3);
            n = here_bits + 3;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 3 + (hold & 0x07);//BITS(3);
            //--- DROPBITS(3) ---//
            hold >>>= 3;
            bits -= 3;
            //---//
          }
          else {
            //=== NEEDBITS(here.bits + 7);
            n = here_bits + 7;
            while (bits < n) {
              if (have === 0) { break inf_leave; }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            //===//
            //--- DROPBITS(here.bits) ---//
            hold >>>= here_bits;
            bits -= here_bits;
            //---//
            len = 0;
            copy = 11 + (hold & 0x7f);//BITS(7);
            //--- DROPBITS(7) ---//
            hold >>>= 7;
            bits -= 7;
            //---//
          }
          if (state.have + copy > state.nlen + state.ndist) {
            strm.msg = 'invalid bit length repeat';
            state.mode = BAD;
            break;
          }
          while (copy--) {
            state.lens[state.have++] = len;
          }
        }
      }

      /* handle error breaks in while */
      if (state.mode === BAD) { break; }

      /* check for end-of-block code (better have one) */
      if (state.lens[256] === 0) {
        strm.msg = 'invalid code -- missing end-of-block';
        state.mode = BAD;
        break;
      }

      /* build code tables -- note: do not change the lenbits or distbits
         values here (9 and 6) without reading the comments in inftrees.h
         concerning the ENOUGH constants, which depend on those values */
      state.lenbits = 9;

      opts = { bits: state.lenbits };
      ret = Object(_inftrees_js__WEBPACK_IMPORTED_MODULE_4__["default"])(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.lenbits = opts.bits;
      // state.lencode = state.next;

      if (ret) {
        strm.msg = 'invalid literal/lengths set';
        state.mode = BAD;
        break;
      }

      state.distbits = 6;
      //state.distcode.copy(state.codes);
      // Switch to use dynamic table
      state.distcode = state.distdyn;
      opts = { bits: state.distbits };
      ret = Object(_inftrees_js__WEBPACK_IMPORTED_MODULE_4__["default"])(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
      // We have separate tables & no pointers. 2 commented lines below not needed.
      // state.next_index = opts.table_index;
      state.distbits = opts.bits;
      // state.distcode = state.next;

      if (ret) {
        strm.msg = 'invalid distances set';
        state.mode = BAD;
        break;
      }
      //Tracev((stderr, 'inflate:       codes ok\n'));
      state.mode = LEN_;
      if (flush === Z_TREES) { break inf_leave; }
      /* falls through */
    case LEN_:
      state.mode = LEN;
      /* falls through */
    case LEN:
      if (have >= 6 && left >= 258) {
        //--- RESTORE() ---
        strm.next_out = put;
        strm.avail_out = left;
        strm.next_in = next;
        strm.avail_in = have;
        state.hold = hold;
        state.bits = bits;
        //---
        Object(_inffast_js__WEBPACK_IMPORTED_MODULE_3__["default"])(strm, _out);
        //--- LOAD() ---
        put = strm.next_out;
        output = strm.output;
        left = strm.avail_out;
        next = strm.next_in;
        input = strm.input;
        have = strm.avail_in;
        hold = state.hold;
        bits = state.bits;
        //---

        if (state.mode === TYPE) {
          state.back = -1;
        }
        break;
      }
      state.back = 0;
      for (;;) {
        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if (here_bits <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if (here_op && (here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.lencode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      state.length = here_val;
      if (here_op === 0) {
        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?
        //        "inflate:         literal '%c'\n" :
        //        "inflate:         literal 0x%02x\n", here.val));
        state.mode = LIT;
        break;
      }
      if (here_op & 32) {
        //Tracevv((stderr, "inflate:         end of block\n"));
        state.back = -1;
        state.mode = TYPE;
        break;
      }
      if (here_op & 64) {
        strm.msg = 'invalid literal/length code';
        state.mode = BAD;
        break;
      }
      state.extra = here_op & 15;
      state.mode = LENEXT;
      /* falls through */
    case LENEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
      //Tracevv((stderr, "inflate:         length %u\n", state.length));
      state.was = state.length;
      state.mode = DIST;
      /* falls through */
    case DIST:
      for (;;) {
        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/
        here_bits = here >>> 24;
        here_op = (here >>> 16) & 0xff;
        here_val = here & 0xffff;

        if ((here_bits) <= bits) { break; }
        //--- PULLBYTE() ---//
        if (have === 0) { break inf_leave; }
        have--;
        hold += input[next++] << bits;
        bits += 8;
        //---//
      }
      if ((here_op & 0xf0) === 0) {
        last_bits = here_bits;
        last_op = here_op;
        last_val = here_val;
        for (;;) {
          here = state.distcode[last_val +
                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];
          here_bits = here >>> 24;
          here_op = (here >>> 16) & 0xff;
          here_val = here & 0xffff;

          if ((last_bits + here_bits) <= bits) { break; }
          //--- PULLBYTE() ---//
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
          //---//
        }
        //--- DROPBITS(last.bits) ---//
        hold >>>= last_bits;
        bits -= last_bits;
        //---//
        state.back += last_bits;
      }
      //--- DROPBITS(here.bits) ---//
      hold >>>= here_bits;
      bits -= here_bits;
      //---//
      state.back += here_bits;
      if (here_op & 64) {
        strm.msg = 'invalid distance code';
        state.mode = BAD;
        break;
      }
      state.offset = here_val;
      state.extra = (here_op) & 15;
      state.mode = DISTEXT;
      /* falls through */
    case DISTEXT:
      if (state.extra) {
        //=== NEEDBITS(state.extra);
        n = state.extra;
        while (bits < n) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;
        //--- DROPBITS(state.extra) ---//
        hold >>>= state.extra;
        bits -= state.extra;
        //---//
        state.back += state.extra;
      }
//#ifdef INFLATE_STRICT
      if (state.offset > state.dmax) {
        strm.msg = 'invalid distance too far back';
        state.mode = BAD;
        break;
      }
//#endif
      //Tracevv((stderr, "inflate:         distance %u\n", state.offset));
      state.mode = MATCH;
      /* falls through */
    case MATCH:
      if (left === 0) { break inf_leave; }
      copy = _out - left;
      if (state.offset > copy) {         /* copy from window */
        copy = state.offset - copy;
        if (copy > state.whave) {
          if (state.sane) {
            strm.msg = 'invalid distance too far back';
            state.mode = BAD;
            break;
          }
// (!) This block is disabled in zlib defailts,
// don't enable it for binary compatibility
//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR
//          Trace((stderr, "inflate.c too far\n"));
//          copy -= state.whave;
//          if (copy > state.length) { copy = state.length; }
//          if (copy > left) { copy = left; }
//          left -= copy;
//          state.length -= copy;
//          do {
//            output[put++] = 0;
//          } while (--copy);
//          if (state.length === 0) { state.mode = LEN; }
//          break;
//#endif
        }
        if (copy > state.wnext) {
          copy -= state.wnext;
          from = state.wsize - copy;
        }
        else {
          from = state.wnext - copy;
        }
        if (copy > state.length) { copy = state.length; }
        from_source = state.window;
      }
      else {                              /* copy from output */
        from_source = output;
        from = put - state.offset;
        copy = state.length;
      }
      if (copy > left) { copy = left; }
      left -= copy;
      state.length -= copy;
      do {
        output[put++] = from_source[from++];
      } while (--copy);
      if (state.length === 0) { state.mode = LEN; }
      break;
    case LIT:
      if (left === 0) { break inf_leave; }
      output[put++] = state.length;
      left--;
      state.mode = LEN;
      break;
    case CHECK:
      if (state.wrap) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          // Use '|' insdead of '+' to make sure that result is signed
          hold |= input[next++] << bits;
          bits += 8;
        }
        //===//
        _out -= left;
        strm.total_out += _out;
        state.total += _out;
        if (_out) {
          strm.adler = state.check =
              /*UPDATE(state.check, put - _out, _out);*/
              (state.flags ? Object(_crc32_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.check, output, _out, put - _out) : Object(_adler32_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state.check, output, _out, put - _out));

        }
        _out = left;
        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too
        if ((state.flags ? hold : zswap32(hold)) !== state.check) {
          strm.msg = 'incorrect data check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   check matches trailer\n"));
      }
      state.mode = LENGTH;
      /* falls through */
    case LENGTH:
      if (state.wrap && state.flags) {
        //=== NEEDBITS(32);
        while (bits < 32) {
          if (have === 0) { break inf_leave; }
          have--;
          hold += input[next++] << bits;
          bits += 8;
        }
        //===//
        if (hold !== (state.total & 0xffffffff)) {
          strm.msg = 'incorrect length check';
          state.mode = BAD;
          break;
        }
        //=== INITBITS();
        hold = 0;
        bits = 0;
        //===//
        //Tracev((stderr, "inflate:   length matches trailer\n"));
      }
      state.mode = DONE;
      /* falls through */
    case DONE:
      ret = Z_STREAM_END;
      break inf_leave;
    case BAD:
      ret = Z_DATA_ERROR;
      break inf_leave;
    case MEM:
      return Z_MEM_ERROR;
    case SYNC:
      /* falls through */
    default:
      return Z_STREAM_ERROR;
    }
  }

  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"

  /*
     Return from inflate(), updating the total counts and the check value.
     If there was no progress during the inflate() call, return a buffer
     error.  Call updatewindow() to create and/or update the window state.
     Note: a memory error from inflate() is non-recoverable.
   */

  //--- RESTORE() ---
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  //---

  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&
                      (state.mode < CHECK || flush !== Z_FINISH))) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {
      state.mode = MEM;
      return Z_MEM_ERROR;
    }
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
      (state.flags ? Object(_crc32_js__WEBPACK_IMPORTED_MODULE_2__["default"])(state.check, output, _out, strm.next_out - _out) : Object(_adler32_js__WEBPACK_IMPORTED_MODULE_1__["default"])(state.check, output, _out, strm.next_out - _out));
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) +
                    (state.mode === TYPE ? 128 : 0) +
                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {
    ret = Z_BUF_ERROR;
  }
  return ret;
}

function inflateEnd(strm) {

  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {
    return Z_STREAM_ERROR;
  }

  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK;
}

function inflateGetHeader(strm, head) {
  var state;

  /* check state */
  if (!strm || !strm.state) { return Z_STREAM_ERROR; }
  state = strm.state;
  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }

  /* save header structure */
  state.head = head;
  head.done = false;
  return Z_OK;
}

function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;

  var state;
  var dictid;
  var ret;

  /* check state */
  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }
  state = strm.state;

  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR;
  }

  /* check for correct dictionary identifier */
  if (state.mode === DICT) {
    dictid = 1; /* adler32(0, null, 0)*/
    /* dictid = adler32(dictid, dictionary, dictLength); */
    dictid = Object(_adler32_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR;
    }
  }
  /* copy dictionary to window using updatewindow(), which will amend the
   existing dictionary if appropriate */
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  // Tracev((stderr, "inflate:   dictionary set\n"));
  return Z_OK;
}


var inflateInfo = 'pako inflate (from Nodeca project)';

/* Not implemented
exports.inflateCopy = inflateCopy;
exports.inflateGetDictionary = inflateGetDictionary;
exports.inflateMark = inflateMark;
exports.inflatePrime = inflatePrime;
exports.inflateSync = inflateSync;
exports.inflateSyncPoint = inflateSyncPoint;
exports.inflateUndermine = inflateUndermine;
*/


/***/ }),

/***/ "./node_modules/@novnc/novnc/vendor/pako/lib/zlib/inftrees.js":
/*!********************************************************************!*\
  !*** ./node_modules/@novnc/novnc/vendor/pako/lib/zlib/inftrees.js ***!
  \********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return inflate_table; });
/* harmony import */ var _utils_common_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/common.js */ "./node_modules/@novnc/novnc/vendor/pako/lib/utils/common.js");


var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);

var CODES = 0;
var LENS = 1;
var DISTS = 2;

var lbase = [ /* Length codes 257..285 base */
  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0
];

var lext = [ /* Length codes 257..285 extra */
  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78
];

var dbase = [ /* Distance codes 0..29 base */
  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
  8193, 12289, 16385, 24577, 0, 0
];

var dext = [ /* Distance codes 0..29 extra */
  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
  28, 28, 29, 29, 64, 64
];

function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)
{
  var bits = opts.bits;
      //here = opts.here; /* table entry for duplication */

  var len = 0;               /* a code's length in bits */
  var sym = 0;               /* index of code symbols */
  var min = 0, max = 0;          /* minimum and maximum code lengths */
  var root = 0;              /* number of index bits for root table */
  var curr = 0;              /* number of index bits for current table */
  var drop = 0;              /* code bits to drop for sub-table */
  var left = 0;                   /* number of prefix codes available */
  var used = 0;              /* code entries in table used */
  var huff = 0;              /* Huffman code */
  var incr;              /* for incrementing code, index */
  var fill;              /* index for replicating entries */
  var low;               /* low bits for current root entry */
  var mask;              /* mask for low root bits */
  var next;             /* next available space in table */
  var base = null;     /* base value table to use */
  var base_index = 0;
//  var shoextra;    /* extra bits table to use */
  var end;                    /* use base and extra for symbol > end */
  var count = new _utils_common_js__WEBPACK_IMPORTED_MODULE_0__["Buf16"](MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */
  var offs = new _utils_common_js__WEBPACK_IMPORTED_MODULE_0__["Buf16"](MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */
  var extra = null;
  var extra_index = 0;

  var here_bits, here_op, here_val;

  /*
   Process a set of code lengths to create a canonical Huffman code.  The
   code lengths are lens[0..codes-1].  Each length corresponds to the
   symbols 0..codes-1.  The Huffman code is generated by first sorting the
   symbols by length from short to long, and retaining the symbol order
   for codes with equal lengths.  Then the code starts with all zero bits
   for the first code of the shortest length, and the codes are integer
   increments for the same length, and zeros are appended as the length
   increases.  For the deflate format, these bits are stored backwards
   from their more natural integer increment ordering, and so when the
   decoding tables are built in the large loop below, the integer codes
   are incremented backwards.

   This routine assumes, but does not check, that all of the entries in
   lens[] are in the range 0..MAXBITS.  The caller must assure this.
   1..MAXBITS is interpreted as that code length.  zero means that that
   symbol does not occur in this code.

   The codes are sorted by computing a count of codes for each length,
   creating from that a table of starting indices for each length in the
   sorted table, and then entering the symbols in order in the sorted
   table.  The sorted table is work[], with that space being provided by
   the caller.

   The length counts are used for other purposes as well, i.e. finding
   the minimum and maximum length codes, determining if there are any
   codes at all, checking for a valid set of lengths, and looking ahead
   at length counts to determine sub-table sizes when building the
   decoding tables.
   */

  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }

  /* bound code lengths, force root to be within code lengths */
  root = bits;
  for (max = MAXBITS; max >= 1; max--) {
    if (count[max] !== 0) { break; }
  }
  if (root > max) {
    root = max;
  }
  if (max === 0) {                     /* no symbols to code at all */
    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */
    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;
    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;


    //table.op[opts.table_index] = 64;
    //table.bits[opts.table_index] = 1;
    //table.val[opts.table_index++] = 0;
    table[table_index++] = (1 << 24) | (64 << 16) | 0;

    opts.bits = 1;
    return 0;     /* no symbols, but wait for decoding to report error */
  }
  for (min = 1; min < max; min++) {
    if (count[min] !== 0) { break; }
  }
  if (root < min) {
    root = min;
  }

  /* check for an over-subscribed or incomplete set of lengths */
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }        /* over-subscribed */
  }
  if (left > 0 && (type === CODES || max !== 1)) {
    return -1;                      /* incomplete set */
  }

  /* generate offsets into symbol table for each length for sorting */
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }

  /* sort symbols by length, by symbol order within each length */
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }

  /*
   Create and fill in decoding tables.  In this loop, the table being
   filled is at next and has curr index bits.  The code being used is huff
   with length len.  That code is converted to an index by dropping drop
   bits off of the bottom.  For codes where len is less than drop + curr,
   those top drop + curr - len bits are incremented through all values to
   fill the table with replicated entries.

   root is the number of index bits for the root table.  When len exceeds
   root, sub-tables are created pointed to by the root entry with an index
   of the low root bits of huff.  This is saved in low to check for when a
   new sub-table should be started.  drop is zero when the root table is
   being filled, and drop is root when sub-tables are being filled.

   When a new sub-table is needed, it is necessary to look ahead in the
   code lengths to determine what size sub-table is needed.  The length
   counts are used for this, and so count[] is decremented as codes are
   entered in the tables.

   used keeps track of how many table entries have been allocated from the
   provided *table space.  It is checked for LENS and DIST tables against
   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in
   the initial root table size constants.  See the comments in inftrees.h
   for more information.

   sym increments through all symbols, and the loop terminates when
   all codes of length max, i.e. all codes, have been processed.  This
   routine permits incomplete codes, so another loop after this one fills
   in the rest of the decoding tables with invalid code markers.
   */

  /* set up for code type */
  // poor man optimization - use if-else instead of switch,
  // to avoid deopts in old v8
  if (type === CODES) {
    base = extra = work;    /* dummy value--not used */
    end = 19;

  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;

  } else {                    /* DISTS */
    base = dbase;
    extra = dext;
    end = -1;
  }

  /* initialize opts for loop */
  huff = 0;                   /* starting code */
  sym = 0;                    /* starting code symbol */
  len = min;                  /* starting code length */
  next = table_index;              /* current table to fill in */
  curr = root;                /* current table index bits */
  drop = 0;                   /* current bits to drop from code for index */
  low = -1;                   /* trigger new sub-table when len > root */
  used = 1 << root;          /* use root table entries */
  mask = used - 1;            /* mask for comparing low */

  /* check available table space */
  if ((type === LENS && used > ENOUGH_LENS) ||
    (type === DISTS && used > ENOUGH_DISTS)) {
    return 1;
  }

  /* process all codes and make table entries */
  for (;;) {
    /* create table entry */
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    }
    else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    }
    else {
      here_op = 32 + 64;         /* end of block */
      here_val = 0;
    }

    /* replicate for those indices with low len bits equal to huff */
    incr = 1 << (len - drop);
    fill = 1 << curr;
    min = fill;                 /* save offset to next table */
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;
    } while (fill !== 0);

    /* backwards increment the len-bit code huff */
    incr = 1 << (len - 1);
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }

    /* go to next symbol, update count, len */
    sym++;
    if (--count[len] === 0) {
      if (len === max) { break; }
      len = lens[lens_index + work[sym]];
    }

    /* create new sub-table if needed */
    if (len > root && (huff & mask) !== low) {
      /* if first time, transition to sub-tables */
      if (drop === 0) {
        drop = root;
      }

      /* increment past last table */
      next += min;            /* here min is 1 << curr */

      /* determine length of next table */
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max) {
        left -= count[curr + drop];
        if (left <= 0) { break; }
        curr++;
        left <<= 1;
      }

      /* check for enough space */
      used += 1 << curr;
      if ((type === LENS && used > ENOUGH_LENS) ||
        (type === DISTS && used > ENOUGH_DISTS)) {
        return 1;
      }

      /* point entry in root table to sub-table */
      low = huff & mask;
      /*table.op[low] = curr;
      table.bits[low] = root;
      table.val[low] = next - opts.table_index;*/
      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;
    }
  }

  /* fill in remaining table entry if code is incomplete (guaranteed to have
   at most one remaining entry, since if the code is incomplete, the
   maximum code length that was allowed to get this far is one bit) */
  if (huff !== 0) {
    //table.op[next + huff] = 64;            /* invalid code marker */
    //table.bits[next + huff] = len - drop;
    //table.val[next + huff] = 0;
    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;
  }

  /* set return parameters */
  //opts.table_index += used;
  opts.bits = root;
  return 0;
};


/***/ }),

/***/ "./node_modules/@novnc/novnc/vendor/pako/lib/zlib/zstream.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@novnc/novnc/vendor/pako/lib/zlib/zstream.js ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ZStream; });
function ZStream() {
  /* next input byte */
  this.input = null; // JS specific, because we have no pointers
  this.next_in = 0;
  /* number of bytes available at input */
  this.avail_in = 0;
  /* total number of input bytes read so far */
  this.total_in = 0;
  /* next output byte should be put there */
  this.output = null; // JS specific, because we have no pointers
  this.next_out = 0;
  /* remaining free space at output */
  this.avail_out = 0;
  /* total number of bytes output so far */
  this.total_out = 0;
  /* last error message, NULL if no error */
  this.msg = ''/*Z_NULL*/;
  /* not visible by applications */
  this.state = null;
  /* best guess about the data type: binary or text */
  this.data_type = 2/*Z_UNKNOWN*/;
  /* adler32 value of the uncompressed data */
  this.adler = 0;
}


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/promise-polyfill/src/finally.js":
/*!******************************************************!*\
  !*** ./node_modules/promise-polyfill/src/finally.js ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/**
 * @this {Promise}
 */
function finallyConstructor(callback) {
  var constructor = this.constructor;
  return this.then(
    function(value) {
      return constructor.resolve(callback()).then(function() {
        return value;
      });
    },
    function(reason) {
      return constructor.resolve(callback()).then(function() {
        return constructor.reject(reason);
      });
    }
  );
}

/* harmony default export */ __webpack_exports__["default"] = (finallyConstructor);


/***/ }),

/***/ "./node_modules/promise-polyfill/src/index.js":
/*!****************************************************!*\
  !*** ./node_modules/promise-polyfill/src/index.js ***!
  \****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(setImmediate) {/* harmony import */ var _finally__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./finally */ "./node_modules/promise-polyfill/src/finally.js");


// Store setTimeout reference so promise-polyfill will be unaffected by
// other code modifying setTimeout (like sinon.useFakeTimers())
var setTimeoutFunc = setTimeout;

function noop() {}

// Polyfill for Function.prototype.bind
function bind(fn, thisArg) {
  return function() {
    fn.apply(thisArg, arguments);
  };
}

/**
 * @constructor
 * @param {Function} fn
 */
function Promise(fn) {
  if (!(this instanceof Promise))
    throw new TypeError('Promises must be constructed via new');
  if (typeof fn !== 'function') throw new TypeError('not a function');
  /** @type {!number} */
  this._state = 0;
  /** @type {!boolean} */
  this._handled = false;
  /** @type {Promise|undefined} */
  this._value = undefined;
  /** @type {!Array<!Function>} */
  this._deferreds = [];

  doResolve(fn, this);
}

function handle(self, deferred) {
  while (self._state === 3) {
    self = self._value;
  }
  if (self._state === 0) {
    self._deferreds.push(deferred);
    return;
  }
  self._handled = true;
  Promise._immediateFn(function() {
    var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
    if (cb === null) {
      (self._state === 1 ? resolve : reject)(deferred.promise, self._value);
      return;
    }
    var ret;
    try {
      ret = cb(self._value);
    } catch (e) {
      reject(deferred.promise, e);
      return;
    }
    resolve(deferred.promise, ret);
  });
}

function resolve(self, newValue) {
  try {
    // Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
    if (newValue === self)
      throw new TypeError('A promise cannot be resolved with itself.');
    if (
      newValue &&
      (typeof newValue === 'object' || typeof newValue === 'function')
    ) {
      var then = newValue.then;
      if (newValue instanceof Promise) {
        self._state = 3;
        self._value = newValue;
        finale(self);
        return;
      } else if (typeof then === 'function') {
        doResolve(bind(then, newValue), self);
        return;
      }
    }
    self._state = 1;
    self._value = newValue;
    finale(self);
  } catch (e) {
    reject(self, e);
  }
}

function reject(self, newValue) {
  self._state = 2;
  self._value = newValue;
  finale(self);
}

function finale(self) {
  if (self._state === 2 && self._deferreds.length === 0) {
    Promise._immediateFn(function() {
      if (!self._handled) {
        Promise._unhandledRejectionFn(self._value);
      }
    });
  }

  for (var i = 0, len = self._deferreds.length; i < len; i++) {
    handle(self, self._deferreds[i]);
  }
  self._deferreds = null;
}

/**
 * @constructor
 */
function Handler(onFulfilled, onRejected, promise) {
  this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
  this.onRejected = typeof onRejected === 'function' ? onRejected : null;
  this.promise = promise;
}

/**
 * Take a potentially misbehaving resolver function and make sure
 * onFulfilled and onRejected are only called once.
 *
 * Makes no guarantees about asynchrony.
 */
function doResolve(fn, self) {
  var done = false;
  try {
    fn(
      function(value) {
        if (done) return;
        done = true;
        resolve(self, value);
      },
      function(reason) {
        if (done) return;
        done = true;
        reject(self, reason);
      }
    );
  } catch (ex) {
    if (done) return;
    done = true;
    reject(self, ex);
  }
}

Promise.prototype['catch'] = function(onRejected) {
  return this.then(null, onRejected);
};

Promise.prototype.then = function(onFulfilled, onRejected) {
  // @ts-ignore
  var prom = new this.constructor(noop);

  handle(this, new Handler(onFulfilled, onRejected, prom));
  return prom;
};

Promise.prototype['finally'] = _finally__WEBPACK_IMPORTED_MODULE_0__["default"];

Promise.all = function(arr) {
  return new Promise(function(resolve, reject) {
    if (!arr || typeof arr.length === 'undefined')
      throw new TypeError('Promise.all accepts an array');
    var args = Array.prototype.slice.call(arr);
    if (args.length === 0) return resolve([]);
    var remaining = args.length;

    function res(i, val) {
      try {
        if (val && (typeof val === 'object' || typeof val === 'function')) {
          var then = val.then;
          if (typeof then === 'function') {
            then.call(
              val,
              function(val) {
                res(i, val);
              },
              reject
            );
            return;
          }
        }
        args[i] = val;
        if (--remaining === 0) {
          resolve(args);
        }
      } catch (ex) {
        reject(ex);
      }
    }

    for (var i = 0; i < args.length; i++) {
      res(i, args[i]);
    }
  });
};

Promise.resolve = function(value) {
  if (value && typeof value === 'object' && value.constructor === Promise) {
    return value;
  }

  return new Promise(function(resolve) {
    resolve(value);
  });
};

Promise.reject = function(value) {
  return new Promise(function(resolve, reject) {
    reject(value);
  });
};

Promise.race = function(values) {
  return new Promise(function(resolve, reject) {
    for (var i = 0, len = values.length; i < len; i++) {
      values[i].then(resolve, reject);
    }
  });
};

// Use polyfill for setImmediate for performance gains
Promise._immediateFn =
  (typeof setImmediate === 'function' &&
    function(fn) {
      setImmediate(fn);
    }) ||
  function(fn) {
    setTimeoutFunc(fn, 0);
  };

Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
  if (typeof console !== 'undefined' && console) {
    console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
  }
};

/* harmony default export */ __webpack_exports__["default"] = (Promise);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../timers-browserify/main.js */ "./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "./node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/unfetch/polyfill/index.js":
/*!************************************************!*\
  !*** ./node_modules/unfetch/polyfill/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

self.fetch||(self.fetch=function(e,n){return n=n||{},new Promise(function(t,r){var s=new XMLHttpRequest;for(var o in s.open(n.method||"get",e,!0),n.headers)s.setRequestHeader(o,n.headers[o]);function u(){var e,n=[],t=[],r={};return s.getAllResponseHeaders().replace(/^(.*?):[^\S\n]*([\s\S]*?)$/gm,function(s,o,u){n.push(o=o.toLowerCase()),t.push([o,u]),r[o]=(e=r[o])?e+","+u:u}),{ok:2==(s.status/100|0),status:s.status,statusText:s.statusText,url:s.responseURL,clone:u,text:function(){return Promise.resolve(s.responseText)},json:function(){return Promise.resolve(s.responseText).then(JSON.parse)},blob:function(){return Promise.resolve(new Blob([s.response]))},headers:{keys:function(){return n},entries:function(){return t},get:function(e){return r[e.toLowerCase()]},has:function(e){return e.toLowerCase()in r}}}}s.withCredentials="include"==n.credentials,s.onload=function(){t(u())},s.onerror=r,s.send(n.body||null)})});


/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./src/audio-mediasource.js":
/*!**********************************!*\
  !*** ./src/audio-mediasource.js ***!
  \**********************************/
/*! exports provided: getBestAudioType, MSAudio, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getBestAudioType", function() { return getBestAudioType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MSAudio", function() { return MSAudio; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MSAudio; });
// Play Audio with MediaSource extensions received over a websocket
var OPUS_MIME_TYPE = 'audio/webm; codecs="opus"';
var MP3_MIME_TYPE = 'audio/mpeg';

// This represents the order in which the types are tried
const AUDIO_TYPES = [
  {"id": "mp3",
    "type": MP3_MIME_TYPE},

  {"id": "opus",
    "type": OPUS_MIME_TYPE},
];




function getBestAudioType() {
  if (window.MediaSource) {
    for (var i = 0; i < AUDIO_TYPES.length; i++) {
      if (window.MediaSource.isTypeSupported(AUDIO_TYPES[i].type)) {
        return AUDIO_TYPES[i].id;
      } else {
          console.log("do not support " + AUDIO_TYPES[i].type);
      }
    }
  }
};

class MSAudio {
  constructor (format, media_controller, lock_audio) {
    this.format = format;
    this.media_controller = media_controller;
    this.lock_audio = lock_audio;

    this.MAX_BUFFERS = 250;
    this.MIN_START_BUFFERS = 10;

    this.minLatency = 0.2; // 200ms
    this.maxLatency = 0.5;  // 500ms

    this.latencyCheck = null;

    this.ws = null;
    this.ws_url = null;

    this.errCount = 0;

    this.allowAppend = false;

    this.audio = null;
    this.audio_mime = null;
    this.mediasource = null;
    this.buffer = null;

    this.buffQ = [];
    this.buffCount = 0;
    this.buffSize = 0;

  }

  get_audio_mime() {
    for (var i = 0; i < AUDIO_TYPES.length; i++) {
      if (AUDIO_TYPES[i].id == this.format) {
        return AUDIO_TYPES[i].type;
      }
    }

    console.log("Audio not inited, unknown audio type: " + this.format);
    return null;
  }

  unlockAudio() {
    if (this.debug) {
      console.log("Unlock MSAudio");
    }
    this.lock_audio = false;
    if (this.audio != null) {
      this.audio.muted = false;
      this.audio.play().catch(function() { });
    }
  }

  start() {
    console.log('start MS Audio with format ' + this.format);
    this.audio_mime = this.get_audio_mime();

    if (!this.audio_mime) {
      console.log("audio Mime not found");
      return false;
    }

    this.latencyCheck = setInterval(this.latencyController.bind(this), 250);

    this.mediasource = new MediaSource();
    this.mediasource.addEventListener("sourceopen", this.sourceOpen.bind(this));

    this.mediasource.addEventListener("error", (function(event) {
      this.audioError("MediaSource Error", event);
    }).bind(this));

    this.audio = new Audio();
    this.audio.src = URL.createObjectURL(this.mediasource);
    this.audio.autoplay = true;
    this.audio.muted = this.lock_audio;
    this.audio.load();
    this.audio.play().catch(function(e) { console.log(e); });

    let msg = {"ms_audio": getBestAudioType()};
    this.media_controller.send(msg);
    this.media_controller.ws_conn.binaryType = 'arraybuffer';

    return true;
  }

  sourceOpen() {
    if (this.mediasource.sourceBuffers.length) {
      console.log("source already open");
      return;
    }

    var buffer = null;

    try {
      buffer = this.mediasource.addSourceBuffer(this.audio_mime);
    } catch (e) {
      console.log("Opening Source Error: " + e);
      return;
    }

    buffer.mode = "sequence";
    //buffer.timestampOffset = 0;

    buffer.addEventListener("error", (function(event) {
      this.audioError("buffer error: " + (this.buffCount), event);
    }).bind(this));

    buffer.addEventListener("updateend", this.onUpdateEnd.bind(this));

    this.buffer = buffer;

    this.allowAppend = true;

  };

  close() {
    console.log("Closing Audio");
    try {
      if (this.latencyCheck) {
        clearInterval(this.latencyCheck);
      }

      if (this.mediasource) {
        this.mediasource.removeSourceBuffer(this.buffer);
        if (this.mediasource.readyState == "open") {
          this.mediasource.endOfStream();
        }
      }
      this.buffer = null;

    } catch(e) {
      console.log("Error Closing mediasource: " + e);
    }
    this.mediasource = null;

    try {
      if (this.audio) {
        this.audio.pause();
      }
      this.audio = null;
    } catch (e) {
      console.log("Error Closing audio : " + e);
    }
  }

  mergeBuffers() {
    var merged;

    if (this.buffQ.length == 1) {
      merged = this.buffQ[0];
    } else {
      merged = new Uint8Array(this.buffSize);

      var length = this.buffQ.length;
      var offset = 0;

      for (var i = 0; i < length; i++) {
        var curr = this.buffQ[i];
        if (curr.length <= 0) {
          continue;
        }
        merged.set(curr, offset);
        offset += curr.length;
      }
    }

    this.buffQ = [];
    this.buffCount++;
    return merged;
  }

  onUpdateEnd() {
    this.allowAppend = true;
    this.updateNext();
  }

  updateNext() {
    if (!this.buffQ.length) {
      return;
    }

    try {
      var merged = this.mergeBuffers();
      this.buffer.appendBuffer(merged);
      this.allowAppend = false;
      this.buffSize -= merged.length;
      this.errCount = 0;
    } catch (e) {
      this.audioError("Error Adding Buffer: " + e);
    }
  }

  latencyController() {
    // check for latency and seek forward if necessary
    try {
      var latency = this.audio.buffered.end(0) - this.audio.currentTime;
      if (latency > this.maxLatency) {
        this.audio.currentTime = this.audio.buffered.end(0) - this.minLatency;
        console.log("Audio has been seeked by ", Math.round((latency - this.minLatency) * 1000), " ms");
      }

    } catch(e) {

    }
  }

  audioError(msg, event) {
    if (this.audio && this.audio.error) {
      console.log(msg);
      console.log(this.audio.error);
      this.errCount += 1;

    }
  }

  queue(buffer) {
    buffer = new Uint8Array(buffer);
    this.buffQ.push(buffer);
    this.buffSize += buffer.length;
    if (this.allowAppend) {
      this.updateNext();
    }
  }

  handleMessage(data) {
    if (this.errCount < 10) {

      this.queue(data);
    } else {
      console.log('too much error');
    }
    return true;
  }

};


/***/ }),

/***/ "./src/browser.js":
/*!************************!*\
  !*** ./src/browser.js ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return CBrowser; });
/* harmony import */ var unfetch_polyfill_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! unfetch/polyfill/index */ "./node_modules/unfetch/polyfill/index.js");
/* harmony import */ var unfetch_polyfill_index__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(unfetch_polyfill_index__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _novnc_novnc_core_rfb__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @novnc/novnc/core/rfb */ "./node_modules/@novnc/novnc/core/rfb.js");
/* harmony import */ var promise_polyfill__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! promise-polyfill */ "./node_modules/promise-polyfill/src/index.js");
/* harmony import */ var _media_controller__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./media-controller */ "./src/media-controller.js");






function toQueryString(obj) {
  var parts = [];
  for (var i in obj) {
    if (obj.hasOwnProperty(i)) {
      parts.push(encodeURIComponent(i) + '=' + encodeURIComponent(obj[i]));
    }
  }
  return parts.join('&');
}


function CBrowser(reqid, target_div, init_params) {
  var controller = typeof AbortController !== 'undefined' ? new AbortController() : null;

  var cmd_port = undefined;
  var vnc_port = undefined;
  var proxy_ws_url = null;

  var clipEvents = ['paste'];
  var connected = false;
  var countdownTimer = null;
  var visibilityHandle = null;
  var ever_connected = false;
  var fail_count = 0;
  var hasClipboard = false;
  var lastText = undefined;
  var maxRetry = 10;
  var retryCount = 0;
  var retryHandle = null;
  var stagedText = null;
  var timers = []

  var min_width = 300;
  var min_height = 300;

  var rfb;
  var resizeTimeout;
  var vnc_pass = "secret";

  var end_time = undefined;

  var environ = {};
  var audioType = null;

  var targetDivNode = document.querySelector(target_div);

  var waiting_for_container = false;
  var waiting_for_vnc = false;

  init_params = init_params || {};

  init_params.api_prefix = init_params.api_prefix || "";

  var num_vnc_retries = init_params.num_vnc_retries || 3;

  // rfb event callbacks
  var credentialsRequired;
  var connect;
  var disconnect;
  var securityFailure;
  var clipboard
  var rfbEventsBound = false;


  function start() {
    // Countdown updater
    if (init_params.on_countdown) {
      countdownTimer = setInterval(update_countdown, 1000);
    }

    init_html(target_div);

    setup_browser();
  }

  function clipHandler(e) {
    if (!hasClipboard) {
      return false;
    }

    var text;
    if (window.clipboardData && window.clipboardData.getData) { // ie
      text = window.clipboardData.getData('Text');
    } else if (e.clipboardData && e.clipboardData.getData) {
      text = e.clipboardData.getData('text/plain');
    }

    if (connected && rfb && text) {
      rfb.clipboardPasteFrom(text);

      // attempt sending paste command
      rfb.sendKey(0xffe3, null, true);
      rfb.sendKey(0x0076, null, true);
      rfb.sendKey(0x0076, null, false);
      rfb.sendKey(0xffe3, null, false);
    }
  }

  function init_clipboard() {
    if (!init_params.clipboard) {
      return;
    }

    hasClipboard = true;
    lastText = undefined;

    // if remote browser cut/copy opperation occured, insert into clipboard field
    if (stagedText) {
        document.querySelector(init_params.clipboard).value = stagedText;
        stagedText = null;
    }

    for (var i = 0; i < clipEvents.length; i++) {
      document.querySelector(init_params.clipboard).addEventListener(clipEvents[i], clipHandler);
    }
  }

  function destroy_clipboard() {
    if (!init_params.clipboard) {
      return;
    }

    hasClipboard = false;
  }

  function canvas() {
    return targetDivNode.querySelector('.canvas');
  }

  function msgdiv() {
    return targetDivNode.querySelector('#browserMsg');
  }

  function screen() {
    return targetDivNode.querySelector('#noVNC_screen');
  }

  function init_html() {
    // ensure container is emptied of previous browsers
    targetDivNode.innerHTML = '';

    var msgDiv = document.createElement('div');
    msgDiv.setAttribute('id', 'browserMsg');
    msgDiv.setAttribute('class', 'loading');
    targetDivNode.appendChild(msgDiv);

    var canvasEle = document.createElement('div');
    canvasEle.setAttribute('class', 'canvas');
    var canvasDiv = document.createElement('div');
    canvasDiv.setAttribute('id', 'noVNC_screen');
    canvasDiv.appendChild(canvasEle);
    targetDivNode.appendChild(canvasDiv);

    canvasEle.style.display = 'none';
  }

  function setup_browser() {
    if (waiting_for_vnc || waiting_for_container) {
      return;
    }

    var msg;

    if (ever_connected) {
      msg = "Reconnecting to Remote Browser...";
    } else {
      msg = "Initializing Remote Browser...";
    }

    msgdiv().innerHTML = msg;
    msgdiv().style.display = 'block';

    // calculate dimensions
    const bcr = targetDivNode.getBoundingClientRect();
    let w = bcr.width;
    let h = bcr.height;

    if (!init_params.fill_window) {
      w *= 0.96;
      h -= 25;
    }

    if (w < h) {
      // flip mins for vertical layout
      var t = min_width;
      min_width = min_height;
      min_height = t;
    }

    let width = Math.max(w, min_width);
    let height = Math.max(h, min_height);
    width = parseInt(width / 8) * 8;
    height = parseInt(height / 8) * 8;
    //req_params['reqid'] = reqid;

    if (init_params.webrtc) {
      audioType = 'webrtc';
    } else {
      audioType = null;
    }

    if (!audioType) {
      console.log("No Supported Audio Types");
    }

    environ = {'SCREEN_WIDTH': width,
               'SCREEN_HEIGHT': height,
               'AUDIO_TYPE': audioType,
               'REQ_ID': reqid
              };

    init_browser()
  }

  function init_browser() {
    if (waiting_for_container) {
      return;
    }

    waiting_for_container = true;

    //var init_url = init_params.api_prefix + "/init_browser?" + toQueryString(req_params);
    var init_url = init_params.api_prefix + "/api/flock/start/" + reqid;

    var req_params = {"environ": environ};

    var headers = init_params.headers || {};
    headers['Content-Type'] = 'application/json';

    var options = { headers: new Headers(headers),
                    method: "POST",
                    body: JSON.stringify(req_params),
                  };

    if (controller) {
      options.signal = controller.signal;
    }

    // expects json response
    fetch(init_url, options)
      .then(function (res) {
        if (!res.ok) {
          throw new Error(res.status);
        }

        return res.json();
      })
      .then(function (data) {
        waiting_for_container = false;
        handle_browser_response(data);
      })
      .catch(function (err) {
        console.log('fetch error', err);
        waiting_for_container = false;

        // user canceled
        if (err.message === 'AbortError') {
          return;
        }

        if (!err || err.message != 404) {
          msgdiv().innerHTML = 'Reconnecting to Remote Browser...';
          msgdiv().style.display = 'block';

          if (retryCount++ < maxRetry) {
            timers.push(setTimeout(init_browser, 1000));
          }

          return;
        }

        if (init_params.on_event) {
          init_params.on_event('error');
        } else {
          msgdiv().innerHTML = 'Remote Browser Expired... Please try again...';
          msgdiv().style.display = 'block';
        }
      });
  }

  function handle_browser_response(data) {
    
    if (data.containers && data.containers.xserver && data.containers.xserver.ports) {
      let ports = data.containers.xserver.ports;

      vnc_port = ports["vnc-port"];
      cmd_port = ports["cmd-port"];

      end_time = parseInt(Date.now() / 1000, 10) + data.ttl;

      vnc_pass = data.containers.xserver.environ.VNC_PASS;

      if (data.containers.pywb && data.containers.pywb.ports['pywb-port']) {
        window.open("http://localhost:" + data.containers.pywb.ports['pywb-port'] + "/combined/" + data.containers.pywb.environ["URL"]);
      }

      if (init_params.proxy_ws) {
        var ip = data.containers.xserver.ip;
        proxy_ws_url = `_websockify?ip=${ip}&port=`;
      }

      let media_params = {"ports":ports,
        "proxy_ws":proxy_ws_url,
        "lock_audio": (init_params.audio == "wait_for_click"),
        "webrtc": init_params.webrtc,
        "webrtc_video": init_params.webrtc_video
      };
      window.mediaController = new _media_controller__WEBPACK_IMPORTED_MODULE_3__["default"](targetDivNode, media_params);

      if (init_params.audio == "wait_for_click") {
        document.body.addEventListener('click', function () {
          window.mediaController.unlockAudio();
        }, { once: true });

      }

      if (init_params.on_event) {
        init_params.on_event("init", data);
      }

      timers.push(window.setTimeout(try_init_vnc, 3000));

    } else if (data.queue != undefined) {
      var msg = "Waiting for empty slot... ";
      if (data.queue == 0) {
        msg += "<b>You are next!</b>";
      } else {
        msg += "At most <b>" + data.queue + " user(s)</b> ahead of you";
      }
      msgdiv().innerHTML = msg;

      timers.push(window.setTimeout(init_browser, 3000));
    }
  }

  function try_init_vnc() {
    do_vnc()
      .then(function () { waiting_for_vnc = false; })
      .catch(function(err) {
        console.log('failed', err);

        waiting_for_vnc = false;
        fail_count++;

        if (fail_count <= num_vnc_retries) {
          msgdiv().innerHTML = "Retrying to connect to remote browser...";
          timers.push(setTimeout(init_browser, 500));
        } else {
          if (init_params.on_event) {
            init_params.on_event("fail");
          } else {
            msgdiv().innerHTML = "Failed to connect to remote browser... Please try again later";
          }
        }
      })
  }

  function clientPosition() {
    const bcr = targetDivNode.getBoundingClientRect();
    var c = canvas();
    var ch = c.getBoundingClientRect().height;
    var cw = c.getBoundingClientRect().width;
    if (!init_params.fill_window) {
      c.style.marginLeft = ((bcr.width - cw)/2) + 'px';
      c.style.marginTop = ((bcr.height - (ch + 25))/2) + 'px';
    }
  }

  function clientResize() {
    const bcr = targetDivNode.getBoundingClientRect();

    let w = bcr.width;
    let h = bcr.height;

    if (!init_params.fill_window) {
      w = Math.round(w * 0.96);
      h = h - 25;
    }

    if (rfb) {
      var s = rfb._display.autoscale(w, h);
    }
  }

  function onVNCCopyCut(rfb, text) {
    if (init_params.clipboard && hasClipboard) {
      // document.querySelector(init_params.clipboard).innerHTML = (text);
    } else if(init_params.clipboard) {
      stagedText = text;
    }
  }

  function do_vnc() {
    if (waiting_for_vnc) {
      return;
    }

    waiting_for_vnc = true;

    var host = window.location.hostname;
    var port = vnc_port;
    var path = "websockify";
    var protocol = "ws";

    if (window.location.protocol === "https:") {
      protocol = "wss";
    }

    // Proxy WS via the origin host, instead of making direct conn
    // 'proxy_ws' specifies the proxy path, port is appended
    if (proxy_ws_url) {
      path = proxy_ws_url + port;
      port = window.location.port;
      if (!port) {
        port = (window.location.protocol == "https:" ? 443 : 80);
      }
    }

    var target = canvas();
    var webservice_url = protocol + '://' + host + ':' + port + '/' + path;

    console.log("Connecting to " + webservice_url);

    var promise = new promise_polyfill__WEBPACK_IMPORTED_MODULE_2__["default"](function (resolve, reject) {
      rfb = new _novnc_novnc_core_rfb__WEBPACK_IMPORTED_MODULE_1__["default"](target, webservice_url, {'credentials': {'password': vnc_pass}});
      window.rfb = rfb;

      //if (!rfbEventsBound) {
      credentialsRequired = function () {
        reject("credentialsrequired");
      }

      connect = function () {
        canvas().style.display = 'block';

        if (init_params.fill_window) {
          canvas().focus();
        }

        msgdiv().style.display = 'none';

        ever_connected = true;
        connected = true;
        fail_count = 0;

        if (init_params.on_event) {
          init_params.on_event("connect");
        }
        rfb.resizeSession = true;
        rfb.scaleViewport = true;

        resolve("connected");
      }

      disconnect = function () {
        connected = false;

        canvas().style.display = 'none';

        var reinit = !document.hidden;

        if (init_params.on_event) {
          init_params.on_event("disconnect");
        }

        if (reinit) {
          setup_browser();
        }
        reject("disconnected");
      }

      securityFailure = function () {
        reject("securityFailure");
      }

      clipboard = function (event) {
        onVNCCopyCut(rfb, event.detail.text);
      }

      rfb.addEventListener("credentialsrequired", credentialsRequired);
      rfb.addEventListener("connect", connect);
      rfb.addEventListener("disconnect", disconnect);
      rfb.addEventListener("securityfailure", securityFailure);
      rfb.addEventListener("clipboard", clipboard);
      //   rfbEventsBound = true;
      // }
    });

    return promise;
  }


  window.onresize = function () {
    // When the window has been resized, wait until the size remains
    // the same for 0.5 seconds before sending the request for changing
    // the resolution of the session
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(function(){
      clientResize();
      //clientPosition();
    }, 500);
  };

  function visibilityChangeCB() {
    if (document.hidden) {
      visibilityHandle = setTimeout(function() {
        if (rfb) {
          rfb.disconnect();
        }
      },
      init_params.inactiveSecs * 1000);
    } else {
      clearTimeout(visibilityHandle);
      if (!connected) {
        if (init_params.on_event) {
          init_params.on_event("reconnect");
        }

        setup_browser();
      }
    }
  }

  function update_countdown() {
    if (!end_time) {
      return;
    }
    var curr = Math.floor(new Date().getTime() / 1000);
    var secdiff = end_time - curr;

    if (secdiff < 0) {
      init_params.on_countdown(0, "00:00");
      return;
    }

    var min = Math.floor(secdiff / 60);
    var sec = secdiff % 60;
    if (sec <= 9) {
      sec = "0" + sec;
    }
    if (min <= 9) {
      min = "0" + min;
    }

    init_params.on_countdown(secdiff, min + ":" + sec);
  }

  if (init_params.inactiveSecs) {
    document.addEventListener("visibilitychange", visibilityChangeCB);
  }

  function clearTimers() {
    // clear intervals and timers
    clearInterval(countdownTimer);
    clearTimeout(visibilityHandle);
    for (var i = 0; i < timers.length; i++) {
      clearTimeout(timers[i]);
    }
    timers = [];
  }

  function close() {
    if (controller) {
      // cancel fetch requests
      controller.abort();
    }

    if (window.mediaController) {
      window.mediaController.stop();
    }

    // stop audio plugin
    if (window.audioPlugin) {
      try {
        console.log("Close Audio");
        window.audioPlugin.close();
        window.audioPlugin = undefined;
      } catch (err){}
    }

    if (rfb) {
      rfb.removeEventListener("credentialsrequired", credentialsRequired);
      rfb.removeEventListener("connect", connect);
      rfb.removeEventListener("disconnect", disconnect);
      rfb.removeEventListener("securityfailure", securityFailure);
      rfb.removeEventListener("clipboard", clipboard);
      rfb.disconnect();
    }

    var cnvs = canvas();
    var _screen = screen();

    clearTimers();

    document.removeEventListener("visibilitychange", visibilityChangeCB);
  }

  start();

  return {
    "close": close,
    "destroy_clipboard": destroy_clipboard,
    "init_clipboard": init_clipboard
   }
}





/***/ }),

/***/ "./src/media-controller.js":
/*!*********************************!*\
  !*** ./src/media-controller.js ***!
  \*********************************/
/*! exports provided: MediaController, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MediaController", function() { return MediaController; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MediaController; });
/* harmony import */ var _webrtc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./webrtc */ "./src/webrtc.js");
/* harmony import */ var _audio_mediasource__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./audio-mediasource */ "./src/audio-mediasource.js");






class MediaController {

  constructor(target, data){
    this.target = target;
    this.data = data;
    this.debug = true;
    this.connect_attempts = 0;
    this.ws_conn;
    this.webrtc_video_formats;

    this.webrtc = data.webrtc;
    this.webrtc_video = data.webrtc_video;

    this.lock_audio = data['lock_audio'];

    this.connectToServer();
  }

  getCommandServer() {
    let ws_url = (window.location.protocol === "https:" ? "wss://" : "ws://");
    ws_url += window.location.hostname;

    var audio_port = this.data.ports["cmd-port"];

    if (this.data.proxy_ws) {
      ws_url += "/" + this.data.proxy_ws + audio_port;
    } else {
      ws_url += ":" + audio_port + "/audio_ws";
    }

    return ws_url;
  }

  connectToServer() {
    this.connect_attempts++;
    if (this.connect_attempts > 100) {
      console.log("Too many connection attempts, aborting. Refresh page to try again");
      return;
    }

    let ws_url = this.getCommandServer();
    this.setStatus("Connecting to server " + ws_url + ", attempt= " + this.connect_attempts);
    this.ws_conn = new WebSocket(ws_url);
    /* When connected, immediately register with the server */
    this.ws_conn.addEventListener('open', () => {
      this.ws_conn.send('HELLO ');
      this.setStatus("Registering with server");
    });

    this.ws_conn.addEventListener('error', this.onServerError.bind(this));
    this.ws_conn.addEventListener('message', this.onServerMessage.bind(this));
    this.ws_conn.addEventListener('close', this.onServerClose.bind(this));

    window.onbeforeunload = this.close.bind(this);
  }

  webrtcInitOptions(formats) {
    if (!this.webrtc) {
      return {"webrtc": false};
    }

    if (this.webrtc_video && formats) {
      if (typeof(this.webrtc_video) === "string") {
        formats.unshift(this.webrtc_video);
      }

      if (formats.includes("VP8") || formats.includes("H264")) {
        return {"webrtc": true, "webrtc_video": formats}
      }
    }

    return {"webrtc": true};
  }

  unlockAudio() {
    this.lock_audio = false;
    if (window.mediaPlugin != null) {
      window.mediaPlugin.unlockAudio()
    }
  }

  async initConnection() {
    const formats = await Object(_webrtc__WEBPACK_IMPORTED_MODULE_0__["determineVideoFormats"])();
    const message = this.webrtcInitOptions(formats);

    this.webrtc_video_formats = formats;

    console.log(message);
    this.send(message);

    // instantiate right plugins
    if (message.webrtc) {
      window.mediaPlugin = new _webrtc__WEBPACK_IMPORTED_MODULE_0__["WebRTC"](this.target, 1, this, this.lock_audio);
    } else {
      let audio_format = Object(_audio_mediasource__WEBPACK_IMPORTED_MODULE_1__["getBestAudioType"])();
      window.mediaPlugin = new _audio_mediasource__WEBPACK_IMPORTED_MODULE_1__["MSAudio"](audio_format, this, this.lock_audio);
    }
    window.mediaPlugin.start();
  }

  close () {
    this.disconnectWebsocket();
    if (window.mediaPlugin) {
      window.mediaPlugin.close();
      window.mediaPlugin = null;
    }
  }

  onServerClose(event) {
    this.setStatus('Disconnected from server with code=' + event.code + ' reason=' + event.reason);

    this.disconnectWebsocket();

    if (event.code !== 1002) {
      // Reset after a second
      window.setTimeout(this.connectToServer.bind(this), 2000);
    } else {
      if (this.connect_attempts < 5) {
        // Retrieve to connect up to 5 times (peer-id might be in conflict if init_browser is called again)
        window.setTimeout(this.connectToServer.bind(this), 2000);
      }
    }
  }

  disconnectWebsocket() {
    if (this.ws_conn) {
      this.setStatus("disconnect websocket");
      this.ws_conn.close();
    }
  }

  send(message) {
    this.ws_conn.send(JSON.stringify(message));
  }

  onServerError() {
    this.setStatus("Unable to connect to server, did you add an exception for the certificate?");
    // Retry after 3 seconds
    window.setTimeout(this.connectToServer.bind(this), 3000);
  }

  setStatus(status) {
    if (this.debug) {
      console.log("Media Controller - status:" + status);
    }
  }

  handleIncomingError(message) {
    if (this.debug) {
      console.log("handleIncomingError: " + message);
    }
  }

  onServerMessage(event) {
    let data = event.data;
    if (window.mediaPlugin != null) {
      if(window.mediaPlugin.handleMessage(data)) {
        return;
      }
    }
    let msg;

    switch (data) {
      case "HELLO":
        this.setStatus("Registered with server, determine which protocol to use");
        this.initConnection();
        return;
      default:
        if (event.data.startsWith("ERROR")) {
          this.handleIncomingError(event.data);
          return;
        }
        try {
          msg = JSON.parse(event.data);
        } catch (e) {
          if (e instanceof SyntaxError) {
            this.handleIncomingError("Error parsing incoming JSON: " + event.data);
          } else {
            this.handleIncomingError("Unknown error parsing response: " + event.data);
          }
          return;
        }
    }
  }

};


/***/ }),

/***/ "./src/webrtc.js":
/*!***********************!*\
  !*** ./src/webrtc.js ***!
  \***********************/
/*! exports provided: WebRTC, determineVideoFormats, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebRTC", function() { return WebRTC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "determineVideoFormats", function() { return determineVideoFormats; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return WebRTC; });



class WebRTC {

  constructor(target, peer_id, media_controller, lock_audio) {

    this.debug = true;
    this.lock_audio = lock_audio;
    this.peer_connection;
    this.media_controller = media_controller;

    this.video_element;
    this.audio_element;

    this.target = target;
    this.peer_id = peer_id;
    this.candidate_number = 0;
  }

  start() {
    if (this.video_element || this.audio_element) {
      console.log("already started");
      return;
    }
  };

  getPeerId() {
    return this.peer_id;
  }

  initIceServers(username, password) {
    const stun = "stun:stun.l.google.com:19302";
    const hostname = window.location.hostname;
    const port = window.location.protocol === "https:" ? 443 : 30478;

    const iceServers = [
      {'urls': stun},
      {"urls":[`turn:${hostname}:${port}?transport=udp`,
               `turn:${hostname}:${port}?transport=tcp`],
       "username": username,
       "credential": password}
    ];

    return {'iceTransportPolicy': 'relay', 'iceServers': iceServers};
  }

  onIncomingConfiguration(msg) {
    msg = this.initIceServers(msg.username, msg.password);

    if (this.debug) {
      console.log("Create peerConnection with configuration" + JSON.stringify(msg));
    }
    this.createCall(msg);
  }

  // ICE candidate received from peer, add it to the peer connection
  onIncomingICE(ice) {
    let candidate = new RTCIceCandidate(ice);
    this.peer_connection.addIceCandidate(candidate).catch(() => this.setError("Error adding ice candidate"));
  }

  setStatus(status) {
    if (this.debug) {
      console.log("WebRTC-status:" + status);
    }
  }

  setError(error) {
    if (this.debug) {
      console.log("WebRTC-error: " + error);
    }
  }

  onIncomingSDP(sdp) {
    this.peer_connection.setRemoteDescription(sdp).then(() => {
      this.setStatus("Remote SDP set");
      if (sdp.type !== "offer")
        return;
      this.setStatus("Got SDP offer");
      this.peer_connection.createAnswer()
        .then(this.onLocalDescription.bind(this)).catch(() => this.setError("Error setting local description"));
    }).catch((event) => this.setError("Error setting remote description:" + event));
  }

  // Local description was set, send it to peer
  onLocalDescription(desc) {
    if (this.debug) {
      console.log("Got local description: " + JSON.stringify(desc));
    }
    this.peer_connection.setLocalDescription(desc).then(function() {
      this.setStatus("Sending SDP answer");
      let sdp = {'sdp': this.peer_connection.localDescription};
      this.media_controller.send(sdp);
    }.bind(this));
  }


  handleMessage(data) {
    try {
      let msg = JSON.parse(data);
      // Incoming JSON signals the beginning of a call
      if (msg.sdp != null) {
        this.onIncomingSDP(msg.sdp);
        return true;
      } else if (msg.ice != null) {
        this.onIncomingICE(msg.ice);
        return true;
      } else if (msg.username && msg.password) {
        this.onIncomingConfiguration(msg);
        return true;
      }
    } catch (e) {}

    return false;
  }

  unlockAudio() {
    if (this.debug) {
      console.log("Unlock webrtc audio");
    }
    this.lock_audio = false;
    if (this.audio_element != null) {
      this.audio_element.muted = false;
      console.log(" paused: " + this.audio_element.paused);
      this.audio_element.play().catch((err) => this.setError("unlock audio_element.play() error: " + err));
    }
    if (this.video_element != null) {
      this.video_element.muted = false;
    }
  }

  close() {
    this.setStatus("Closing WebRTC connection");
    this.peer_connection.close();
    this.peer_connection = null;
  };

  createCall(configuration) {

    this.peer_connection = new RTCPeerConnection(configuration);
    this.peer_connection.ontrack = this.onRemoteTrackAdded.bind(this);
    this.peer_connection.oniceconnectionstatechange = this.onIceConnectionStateChange.bind(this);
    this.peer_connection.onicecandidate = this.onIceCandidate.bind(this);

    this.setStatus("Created peer connection for call, waiting for SDP");
  }

  onIceCandidate(event) {
      let candidate = event.candidate;

      if (candidate == null) {
        console.log("Ice Candidates Done, Sent " + this.candidate_number);
        return;
      }

      console.log("send candidate remotely: " + candidate.candidate);
      this.media_controller.send({'ice': candidate});
      this.candidate_number++;
    };

  onIceConnectionStateChange(event) {
    if (this.peer_connection.iceConnectionState === "connected") {
        if (this.debug) {
          console.log("WebRTC is on!");
        }
    }
  }

  syncVideoElement() {
    let canvas = this.target.getElementsByTagName('canvas')[0];
    if (this.video_element != null  && canvas != undefined) {
      let canvas_position = canvas.getBoundingClientRect();
      let left = canvas_position.x;
      let top = canvas_position.y;
      let width = canvas_position.width;
      let height = canvas_position.height;

      if (this.debug) {
        console.log("Video position is left " + left + ", top " + top + ", width " + width + ", height " + height);
      }

      this.video_element.style.left = left + "px";
      this.video_element.style.top = top + "px";
      if (width > 0) {
        this.video_element.style.width = width + "px";
      }
      if (height > 0) {
        this.video_element.style.height = height + "px";
      }
    }
  }

  onRemoteTrackAdded(event) {
    console.log('receive ' + event.streams.length + 'Streams. stream 1  = ' + event.streams[0].getVideoTracks().length + ' video tracks and ' + event.streams[0].getAudioTracks().length + ' audio tracks' );

    if (event.streams[0].getAudioTracks().length > 0 && event.streams[0].getVideoTracks().length == 0) {
      if (this.audio_element != null) {
        try {
          this.audio_element.pause();
        } catch (e) {
          console.log('can not pause audio element');
        }
      } else {
        this.audio_element = document.createElement('audio');
        this.audio_element.autoplay = true;
        this.target.append(this.audio_element);
      }

      this.audio_element.srcObject = event.streams[0];

      this.audio_element.play().catch((err) => this.mediaPlayError(err, this.audio_element, "audio_element.play()"));

    }

    if (event.streams[0].getVideoTracks().length > 0) {
      if (this.audio_element != null) {
        this.audio_element.pause();
      }

      if (this.video_element == null) {
        // Full WebRTC
        this.video_element = document.createElement('video');
        if (this.debug) {
          this.video_element.style.backgroundColor = "blue";
        }
        //this.video_element.style.opacity = "0.5";
        this.video_element.style.position = "absolute"
        this.video_element.style.top = "0px";
        this.video_element.style.left = "0px";
        //this.video_element.style.width = "100%"
        this.video_element.style.zIndex = "-1";

        this.video_element.contentEditable = true;
        // Hide real VNC
        this.target.getElementsByClassName('canvas')[0].style.opacity = 0;

        if (this.lock_audio) {
          this.video_element.muted = true;
        }


        this.target.append(this.video_element);
        window.onresize = this.syncVideoElement.bind(this);
        this.syncVideoElement();
      } else {
        try {
          this.video_element.pause();
        } catch (e) {
          console.log('can not pause video element');
        }
      }

      this.video_element.srcObject = event.streams[0];

      var video = this.video_element;

      this.video_element.play().catch((err) => this.mediaPlayError(err, this.video_element, "video_element.play()"));
    }
  }

  mediaPlayError(err, elem, msg) {
    if (err.name === 'NotAllowedError') {
      elem.muted = true;
      document.body.addEventListener("click", () => this.unlockAudio());
      elem.play().catch((err) => this.setError(msg + " muted error: " + err));
    } else {
      this.setError(msg + " error: " + err);
    }
  }
};

function determineVideoFormats() {

  return new Promise((resolve, reject) => {
    try {
      var conn = new RTCPeerConnection();
      if (conn.addTransceiver) {
        conn.addTransceiver("video", {"direction": "recvonly"});
      }
      conn.createOffer({"offerToReceiveVideo": true}).then((offer) => {
        conn.close();

        var formats = [];
        var found = {};

        var rx = /a=rtpmap[:]\d+ (\w+)\//g;

        var res = null;

        while ((res = rx.exec(offer.sdp)) != null) {
          var format = res[1];
          if (!found[format]) {
            formats.push(format);
            found[format] = 1;
          }
        }

        resolve(formats);
      });
    } catch (e) {
      console.log("Error WebRTC not supported")
      resolve();
    }

  });
}



/***/ })

/******/ })));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bub3ZuYy9ub3ZuYy9jb3JlL2Jhc2U2NC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5vdm5jL25vdm5jL2NvcmUvZGVjb2RlcnMvY29weXJlY3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bub3ZuYy9ub3ZuYy9jb3JlL2RlY29kZXJzL2hleHRpbGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bub3ZuYy9ub3ZuYy9jb3JlL2RlY29kZXJzL3Jhdy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5vdm5jL25vdm5jL2NvcmUvZGVjb2RlcnMvcnJlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Abm92bmMvbm92bmMvY29yZS9kZWNvZGVycy90aWdodC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5vdm5jL25vdm5jL2NvcmUvZGVjb2RlcnMvdGlnaHRwbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bub3ZuYy9ub3ZuYy9jb3JlL2Rlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5vdm5jL25vdm5jL2NvcmUvZGlzcGxheS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5vdm5jL25vdm5jL2NvcmUvZW5jb2RpbmdzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Abm92bmMvbm92bmMvY29yZS9pbmZsYXRvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5vdm5jL25vdm5jL2NvcmUvaW5wdXQvZG9ta2V5dGFibGUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bub3ZuYy9ub3ZuYy9jb3JlL2lucHV0L2ZpeGVka2V5cy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5vdm5jL25vdm5jL2NvcmUvaW5wdXQva2V5Ym9hcmQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bub3ZuYy9ub3ZuYy9jb3JlL2lucHV0L2tleXN5bS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5vdm5jL25vdm5jL2NvcmUvaW5wdXQva2V5c3ltZGVmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Abm92bmMvbm92bmMvY29yZS9pbnB1dC9tb3VzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5vdm5jL25vdm5jL2NvcmUvaW5wdXQvdXRpbC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5vdm5jL25vdm5jL2NvcmUvaW5wdXQvdmtleXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bub3ZuYy9ub3ZuYy9jb3JlL2lucHV0L3h0c2NhbmNvZGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Abm92bmMvbm92bmMvY29yZS9yZmIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bub3ZuYy9ub3ZuYy9jb3JlL3V0aWwvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5vdm5jL25vdm5jL2NvcmUvdXRpbC9jdXJzb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bub3ZuYy9ub3ZuYy9jb3JlL3V0aWwvZXZlbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Abm92bmMvbm92bmMvY29yZS91dGlsL2V2ZW50dGFyZ2V0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Abm92bmMvbm92bmMvY29yZS91dGlsL2xvZ2dpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bub3ZuYy9ub3ZuYy9jb3JlL3V0aWwvcG9seWZpbGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bub3ZuYy9ub3ZuYy9jb3JlL3V0aWwvc3RyaW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5vdm5jL25vdm5jL2NvcmUvd2Vic29jay5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5vdm5jL25vdm5jL3ZlbmRvci9wYWtvL2xpYi91dGlscy9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bub3ZuYy9ub3ZuYy92ZW5kb3IvcGFrby9saWIvemxpYi9hZGxlcjMyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Abm92bmMvbm92bmMvdmVuZG9yL3Bha28vbGliL3psaWIvY3JjMzIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0Bub3ZuYy9ub3ZuYy92ZW5kb3IvcGFrby9saWIvemxpYi9pbmZmYXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Abm92bmMvbm92bmMvdmVuZG9yL3Bha28vbGliL3psaWIvaW5mbGF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQG5vdm5jL25vdm5jL3ZlbmRvci9wYWtvL2xpYi96bGliL2luZnRyZWVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9Abm92bmMvbm92bmMvdmVuZG9yL3Bha28vbGliL3psaWIvenN0cmVhbS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9taXNlLXBvbHlmaWxsL3NyYy9maW5hbGx5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9taXNlLXBvbHlmaWxsL3NyYy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2V0aW1tZWRpYXRlL3NldEltbWVkaWF0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdW5mZXRjaC9wb2x5ZmlsbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vZ2xvYmFsLmpzIiwid2VicGFjazovLy8uL3NyYy9hdWRpby1tZWRpYXNvdXJjZS5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvbWVkaWEtY29udHJvbGxlci5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvd2VicnRjLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtEQUEwQyxnQ0FBZ0M7QUFDMUU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnRUFBd0Qsa0JBQWtCO0FBQzFFO0FBQ0EseURBQWlELGNBQWM7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUF5QyxpQ0FBaUM7QUFDMUUsd0hBQWdILG1CQUFtQixFQUFFO0FBQ3JJO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsbUNBQTJCLDBCQUEwQixFQUFFO0FBQ3ZELHlDQUFpQyxlQUFlO0FBQ2hEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDhEQUFzRCwrREFBK0Q7O0FBRXJIO0FBQ0E7OztBQUdBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNsRkE7QUFBQTtBQUFBO0FBQW9DOztBQUU3QjtBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0NBQWdDO0FBQ2pFOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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QUFDQTtBQUNBOztBQUVBLFlBQVksc0RBQVM7QUFDckI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNDQUFzQyxXQUFXLGtEQUFNO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLHdCQUF3QjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDLDJCQUEyQixVQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3QkFBd0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyx3QkFBd0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVksc0VBQXFCO0FBQ2pDO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDN29CQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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OztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxZQUFZLDBEQUFpQixNQUFNLDBEQUFpQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDalhBO0FBQUE7O0FBRWU7QUFDZjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0IscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFDOzs7Ozs7Ozs7Ozs7O0FDdm1CRjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUMsRUFBQzs7Ozs7Ozs7Ozs7OztBQy9xQkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRTBDO0FBQ1M7QUFDd0I7O0FBRTNFLHNCQUFzQjtBQUN0Qiw4QkFBOEI7QUFDOUI7O0FBRWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw2QkFBNkI7O0FBRTdCOztBQUVBLHNDQUFzQztBQUN0QyxvQ0FBb0M7QUFDcEM7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7O0FBRUEsUUFBUSxzREFBUztBQUNqQjtBQUNBOztBQUVBLFFBQVEsaUVBQVM7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrRUFBVTtBQUN0Qjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLGlFQUFTO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsaUVBQVM7QUFDakI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksaUVBQVM7QUFDckI7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSx1RUFBZTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjs7QUFFQTs7QUFFQTtBQUNBLFlBQVksOERBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsWUFBWSw4REFBYTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQ25SQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBcUM7QUFDTjtBQUNRO0FBQ0k7QUFDRzs7QUFFOUM7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EscURBQXFELGlEQUFLO0FBQzFELG1CQUFtQixpREFBSzs7QUFFeEI7QUFDQSxZQUFZLHNEQUFhO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdDQUF3QyxxREFBWSxPQUFPLHVEQUFjO0FBQ3pFO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLHFEQUFTO0FBQ3pCLGVBQWUscURBQVM7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ087QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLHVEQUFXO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxlQUFlLHVEQUFXO0FBQzFCOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLHFEQUFPO0FBQ3RCOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUNuS0E7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsRUFBQzs7Ozs7Ozs7Ozs7OztBQ3BIRjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QUFFaUU7O0FBRWpFLHFCQUFxQiw4REFBa0IsSUFBSSx5REFBYTs7QUFFekM7QUFDZjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMEJBQTBCO0FBQzFCLHlCQUF5Qjs7QUFFekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzVOQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVPO0FBQ1A7QUFDQTs7QUFFTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRU87QUFDUDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pEOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFTztBQUNQOztBQUVBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7OztBQzFJQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNB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Q3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQix5REFBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHlEQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix5REFBSztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsYUFBYTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseURBQWM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix5REFBSztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQSx3QkFBd0IseURBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSx3QkFBd0IseURBQUs7QUFDN0I7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxpQkFBaUI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixhQUFhO0FBQ3ZDLDBCQUEwQixhQUFhO0FBQ3ZDLHlCQUF5QixpQkFBaUI7QUFDMUMsdUNBQXVDO0FBQ3ZDLFFBQVEseURBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0EseUJBQXlCLGlCQUFpQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdEO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkLFlBQVksNERBQWE7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZixrRUFBa0U7QUFDbEU7QUFDQTtBQUNBOztBQUVBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGlCQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQixPQUFPOztBQUV0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYztBQUNkLFlBQVksNERBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCxZQUFZLDREQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGlCQUFpQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwyREFBWTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsZ0VBQWdFO0FBQ2hFO0FBQ0E7QUFDQTs7QUFFQSxnQ0FBZ0MsT0FBTztBQUN2QztBQUNBLHlCQUF5QixpQkFBaUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZ0RBQWdELE9BQU87QUFDdkQ7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLGtFQUFrRTtBQUNsRTtBQUNBO0FBQ0E7O0FBRUEsa0NBQWtDLE9BQU87QUFDekM7QUFDQSx5QkFBeUIsaUJBQWlCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdEQUFnRCxPQUFPO0FBQ3ZEO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxxQkFBcUI7QUFDM0QsOEJBQThCLGFBQWE7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IscUNBQXFDLGtCQUFrQjtBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxxQkFBcUI7QUFDdkQ7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixhQUFhO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLCtCQUErQixrQkFBa0I7QUFDakQ7QUFDQTtBQUNBLHVCQUF1QixpQkFBaUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCw2QkFBNkIseURBQUssMENBQTBDLDJEQUFPOztBQUVuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGlCQUFpQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGLHFCQUFxQix5REFBSyxvREFBb0QsMkRBQU87QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLHVCQUF1QjtBQUNwRDtBQUNBLCtCQUErQix1QkFBdUI7O0FBRXREO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQsdUJBQXVCO0FBQ3BGOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLHdEQUF3RDtBQUN4RCxhQUFhLDJEQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFaUo7QUFDMUk7O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDdC9DQTtBQUFBO0FBQUE7QUFBNEM7O0FBRTVDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0EseUJBQXlCOztBQUV6QixjQUFjO0FBQ2QsY0FBYztBQUNkLHVCQUF1QjtBQUN2QixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixlQUFlO0FBQ2YsZUFBZTtBQUNmLGVBQWU7QUFDZixXQUFXO0FBQ1gsV0FBVztBQUNYLFVBQVU7QUFDVixXQUFXO0FBQ1gsV0FBVztBQUNYLGtCQUFrQjtBQUNsQjtBQUNBLGlCQUFpQjtBQUNqQixVQUFVO0FBQ1Ysa0JBQWtCLHNEQUFXLGNBQWMsZUFBZTtBQUMxRCxpQkFBaUIsc0RBQVcsY0FBYyxlQUFlO0FBQ3pEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZSxnQkFBZ0I7QUFDL0I7QUFDQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxxQkFBcUIsVUFBVTtBQUMvQiwyQkFBMkIsT0FBTztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixzQ0FBc0MsMkJBQTJCO0FBQ2pFLHVDQUF1QztBQUN2Qyx3Q0FBd0M7QUFDeEM7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsZUFBZSxXQUFXO0FBQzFCLDJCQUEyQixPQUFPO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYztBQUNkOztBQUVBO0FBQ0E7QUFDQSxlQUFlLGVBQWU7QUFDOUI7QUFDQTs7QUFFQTtBQUNBLGVBQWUsYUFBYTtBQUM1QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4Qjs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxHQUFHLE9BQU87QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1YsWUFBWTtBQUNaLHFCQUFxQjtBQUNyQixjQUFjO0FBQ2QsV0FBVztBQUNYLFdBQVc7QUFDWCxtQkFBbUI7QUFDbkIsa0JBQWtCOztBQUVsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0I7O0FBRWxCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsT0FBTztBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDalVBO0FBQUE7QUFBZTtBQUNmO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN2QkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs7Ozs7OztBQ3ZMdEM7QUFBQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFZSxpRkFBa0IsRUFBQzs7Ozs7Ozs7Ozs7OztBQ25CbEM7QUFBQTtBQUF1Qzs7QUFFdkM7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBLGFBQWEsa0JBQWtCO0FBQy9COztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUEsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLCtCQUErQixnREFBYzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0MsU0FBUztBQUNqRDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTs7QUFFZSxzRUFBTyxFQUFDOzs7Ozs7Ozs7Ozs7O0FDL092QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7QUN6TEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLG1CQUFPLENBQUMsaUVBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDOURBLHNDQUFzQyxjQUFjLDJCQUEyQix5QkFBeUIsdUZBQXVGLGFBQWEscUJBQXFCLHdGQUF3RixnRUFBZ0UsR0FBRyx5R0FBeUcsdUNBQXVDLGlCQUFpQix3REFBd0QsaUJBQWlCLCtDQUErQyxVQUFVLGdCQUFnQixTQUFTLG9CQUFvQixTQUFTLGlCQUFpQiwwQkFBMEIsaUJBQWlCLDhCQUE4QiwrREFBK0QsT0FBTyxrQ0FBa0MsRUFBRTs7Ozs7Ozs7Ozs7O0FDQXo1Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDRDQUE0Qzs7QUFFNUM7Ozs7Ozs7Ozs7Ozs7QUNuQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILDBCQUEwQjs7QUFFMUIsR0FBRztBQUNILDJCQUEyQjtBQUMzQjs7QUFFbUM7OztBQUduQztBQUNBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQiwwQkFBMEI7O0FBRTFCOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsRUFBRTtBQUM1QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsZ0JBQWdCLEVBQUU7O0FBRTNELGVBQWU7QUFDZjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBLHFCQUFxQixZQUFZO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBOzs7Ozs7Ozs7Ozs7O0FDdlFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWdDO0FBQ1E7QUFDRDtBQUNVOzs7QUFHakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHZTtBQUNmOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQix1QkFBdUI7QUFDMUM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQSxzQkFBc0I7O0FBRXRCO0FBQ0E7O0FBRUEsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlDQUF5QyxHQUFHO0FBQzVDOztBQUVBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLHlEQUFlOztBQUVsRDtBQUNBO0FBQ0E7QUFDQSxTQUFTLEdBQUcsYUFBYTs7QUFFekI7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EseUJBQXlCLHlCQUF5QixFQUFFO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBLHNCQUFzQix3REFBTztBQUM3QixnQkFBZ0IsNkRBQUcsMEJBQTBCLGdCQUFnQixzQkFBc0I7QUFDbkY7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQW1CO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7QUNsbUJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBdUQ7QUFDTzs7QUFFckM7OztBQUdWOztBQUVmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msd0JBQXdCO0FBQzlEO0FBQ0Esd0JBQXdCLDRCQUE0QjtBQUNwRDs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIIiwiZmlsZSI6InNoZXBoZXJkLWNsaWVudC5idW5kbGUuanMiLCJzb3VyY2VzQ29udGVudCI6WyIgXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gXCIuL2luZGV4LmpzXCIpO1xuIiwiaW1wb3J0IENCcm93c2VyIGZyb20gJy4vc3JjL2Jyb3dzZXInXG5cbmV4cG9ydCBmdW5jdGlvbiBJbml0QnJvd3NlckRlZmF1bHQocmVxaWQsIG9wdHMpIHtcbiAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlYWR5c3RhdGVjaGFuZ2VcIiwgZnVuY3Rpb24oKSB7XG4gICAgaWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgIT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3B0cyA9IG9wdHMgfHwge307XG5cbiAgICAvLyBpZiBpbiBpZnJhbWUsIG5vdGlmeSBwYXJlbnQgb2YgcmVxaWRcbiAgICBpZiAod2luZG93ICE9IHdpbmRvdy5wYXJlbnQgJiYgIW9wdHMubm9Ob3RpZnlQYXJlbnQpIHtcbiAgICAgIHdpbmRvdy5wYXJlbnQucG9zdE1lc3NhZ2Uoe1widHlwZVwiOiBcInJlcWlkXCIsIFwicmVxaWRcIjogcmVxaWR9LCBcIipcIik7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRzLm9uX2NvdW50ZG93bikge1xuICAgICAgb3B0cy5vbl9jb3VudGRvd24gPSBmdW5jdGlvbihzZWNvbmRzLCBjb3VudGRvd25fdGV4dCkge1xuICAgICAgICB2YXIgdGV4dCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiY291bnRkb3duXCIpO1xuICAgICAgICBpZiAodGV4dCkge1xuICAgICAgICAgIHRleHQuaW5uZXJUZXh0ID0gY291bnRkb3duX3RleHQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoIW9wdHMub25fZXZlbnQpIHtcbiAgICAgIG9wdHMub25fZXZlbnQgPSBmdW5jdGlvbih0eXBlLCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlID09IFwiZmFpbFwiIHx8IHR5cGUgPT0gXCJleHBpcmVcIikge1xuICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChvcHRzLnByb3h5X3dzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmICghd2luZG93LmxvY2F0aW9uLnBvcnQpIHtcbiAgICAgICAgb3B0cy5wcm94eV93cyA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuYXVkaW8gPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0cy5hdWRpbyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuZmlsbF93aW5kb3cgPT09IHVuZGVmaW5lZCkge1xuICAgICAgb3B0cy5maWxsX3dpbmRvdyA9IHRydWU7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuaW5hY3RpdmVTZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICAgIG9wdHMuaW5hY3RpdmVTZWNzID0gMTA7XG4gICAgfVxuXG4gICAgdmFyIGlkID0gb3B0cy5pZCB8fCBcIiNicm93c2VyXCI7XG5cbiAgICByZXR1cm4gbmV3IENCcm93c2VyKHJlcWlkLCBpZCwgb3B0cyk7XG4gIH0pO1xufVxuXG5cblxuIiwiLyogVGhpcyBTb3VyY2UgQ29kZSBGb3JtIGlzIHN1YmplY3QgdG8gdGhlIHRlcm1zIG9mIHRoZSBNb3ppbGxhIFB1YmxpY1xuICogTGljZW5zZSwgdi4gMi4wLiBJZiBhIGNvcHkgb2YgdGhlIE1QTCB3YXMgbm90IGRpc3RyaWJ1dGVkIHdpdGggdGhpc1xuICogZmlsZSwgWW91IGNhbiBvYnRhaW4gb25lIGF0IGh0dHA6Ly9tb3ppbGxhLm9yZy9NUEwvMi4wLy4gKi9cblxuLy8gRnJvbTogaHR0cDovL2hnLm1vemlsbGEub3JnL21vemlsbGEtY2VudHJhbC9yYXctZmlsZS9lYzEwNjMwYjFhNTQvanMvc3JjL2RldnRvb2xzL2ppbnQvc3Vuc3BpZGVyL3N0cmluZy1iYXNlNjQuanNcblxuaW1wb3J0ICogYXMgTG9nIGZyb20gJy4vdXRpbC9sb2dnaW5nLmpzJztcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIC8qIENvbnZlcnQgZGF0YSAoYW4gYXJyYXkgb2YgaW50ZWdlcnMpIHRvIGEgQmFzZTY0IHN0cmluZy4gKi9cbiAgICB0b0Jhc2U2NFRhYmxlOiAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLz0nLnNwbGl0KCcnKSxcbiAgICBiYXNlNjRQYWQ6ICc9JyxcblxuICAgIGVuY29kZShkYXRhKSB7XG4gICAgICAgIFwidXNlIHN0cmljdFwiO1xuICAgICAgICBsZXQgcmVzdWx0ID0gJyc7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgICBjb25zdCBsZW5ndGhwYWQgPSAobGVuZ3RoICUgMyk7XG4gICAgICAgIC8vIENvbnZlcnQgZXZlcnkgdGhyZWUgYnl0ZXMgdG8gNCBhc2NpaSBjaGFyYWN0ZXJzLlxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgKGxlbmd0aCAtIDIpOyBpICs9IDMpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnRvQmFzZTY0VGFibGVbZGF0YVtpXSA+PiAyXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnRvQmFzZTY0VGFibGVbKChkYXRhW2ldICYgMHgwMykgPDwgNCkgKyAoZGF0YVtpICsgMV0gPj4gNCldO1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudG9CYXNlNjRUYWJsZVsoKGRhdGFbaSArIDFdICYgMHgwZikgPDwgMikgKyAoZGF0YVtpICsgMl0gPj4gNildO1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudG9CYXNlNjRUYWJsZVtkYXRhW2kgKyAyXSAmIDB4M2ZdO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29udmVydCB0aGUgcmVtYWluaW5nIDEgb3IgMiBieXRlcywgcGFkIG91dCB0byA0IGNoYXJhY3RlcnMuXG4gICAgICAgIGNvbnN0IGogPSBsZW5ndGggLSBsZW5ndGhwYWQ7XG4gICAgICAgIGlmIChsZW5ndGhwYWQgPT09IDIpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnRvQmFzZTY0VGFibGVbZGF0YVtqXSA+PiAyXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnRvQmFzZTY0VGFibGVbKChkYXRhW2pdICYgMHgwMykgPDwgNCkgKyAoZGF0YVtqICsgMV0gPj4gNCldO1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudG9CYXNlNjRUYWJsZVsoZGF0YVtqICsgMV0gJiAweDBmKSA8PCAyXTtcbiAgICAgICAgICAgIHJlc3VsdCArPSB0aGlzLnRvQmFzZTY0VGFibGVbNjRdO1xuICAgICAgICB9IGVsc2UgaWYgKGxlbmd0aHBhZCA9PT0gMSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudG9CYXNlNjRUYWJsZVtkYXRhW2pdID4+IDJdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudG9CYXNlNjRUYWJsZVsoZGF0YVtqXSAmIDB4MDMpIDw8IDRdO1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMudG9CYXNlNjRUYWJsZVs2NF07XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy50b0Jhc2U2NFRhYmxlWzY0XTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIC8qIENvbnZlcnQgQmFzZTY0IGRhdGEgdG8gYSBzdHJpbmcgKi9cbiAgICAvKiBlc2xpbnQtZGlzYWJsZSBjb21tYS1zcGFjaW5nICovXG4gICAgdG9CaW5hcnlUYWJsZTogW1xuICAgICAgICAtMSwtMSwtMSwtMSwgLTEsLTEsLTEsLTEsIC0xLC0xLC0xLC0xLCAtMSwtMSwtMSwtMSxcbiAgICAgICAgLTEsLTEsLTEsLTEsIC0xLC0xLC0xLC0xLCAtMSwtMSwtMSwtMSwgLTEsLTEsLTEsLTEsXG4gICAgICAgIC0xLC0xLC0xLC0xLCAtMSwtMSwtMSwtMSwgLTEsLTEsLTEsNjIsIC0xLC0xLC0xLDYzLFxuICAgICAgICA1Miw1Myw1NCw1NSwgNTYsNTcsNTgsNTksIDYwLDYxLC0xLC0xLCAtMSwgMCwtMSwtMSxcbiAgICAgICAgLTEsIDAsIDEsIDIsICAzLCA0LCA1LCA2LCAgNywgOCwgOSwxMCwgMTEsMTIsMTMsMTQsXG4gICAgICAgIDE1LDE2LDE3LDE4LCAxOSwyMCwyMSwyMiwgMjMsMjQsMjUsLTEsIC0xLC0xLC0xLC0xLFxuICAgICAgICAtMSwyNiwyNywyOCwgMjksMzAsMzEsMzIsIDMzLDM0LDM1LDM2LCAzNywzOCwzOSw0MCxcbiAgICAgICAgNDEsNDIsNDMsNDQsIDQ1LDQ2LDQ3LDQ4LCA0OSw1MCw1MSwtMSwgLTEsLTEsLTEsLTFcbiAgICBdLFxuICAgIC8qIGVzbGludC1lbmFibGUgY29tbWEtc3BhY2luZyAqL1xuXG4gICAgZGVjb2RlKGRhdGEsIG9mZnNldCA9IDApIHtcbiAgICAgICAgbGV0IGRhdGFfbGVuZ3RoID0gZGF0YS5pbmRleE9mKCc9JykgLSBvZmZzZXQ7XG4gICAgICAgIGlmIChkYXRhX2xlbmd0aCA8IDApIHsgZGF0YV9sZW5ndGggPSBkYXRhLmxlbmd0aCAtIG9mZnNldDsgfVxuXG4gICAgICAgIC8qIEV2ZXJ5IGZvdXIgY2hhcmFjdGVycyBpcyAzIHJlc3VsdGluZyBudW1iZXJzICovXG4gICAgICAgIGNvbnN0IHJlc3VsdF9sZW5ndGggPSAoZGF0YV9sZW5ndGggPj4gMikgKiAzICsgTWF0aC5mbG9vcigoZGF0YV9sZW5ndGggJSA0KSAvIDEuNSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBBcnJheShyZXN1bHRfbGVuZ3RoKTtcblxuICAgICAgICAvLyBDb252ZXJ0IG9uZSBieSBvbmUuXG5cbiAgICAgICAgbGV0IGxlZnRiaXRzID0gMDsgLy8gbnVtYmVyIG9mIGJpdHMgZGVjb2RlZCwgYnV0IHlldCB0byBiZSBhcHBlbmRlZFxuICAgICAgICBsZXQgbGVmdGRhdGEgPSAwOyAvLyBiaXRzIGRlY29kZWQsIGJ1dCB5ZXQgdG8gYmUgYXBwZW5kZWRcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMCwgaSA9IG9mZnNldDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSB0aGlzLnRvQmluYXJ5VGFibGVbZGF0YS5jaGFyQ29kZUF0KGkpICYgMHg3Zl07XG4gICAgICAgICAgICBjb25zdCBwYWRkaW5nID0gKGRhdGEuY2hhckF0KGkpID09PSB0aGlzLmJhc2U2NFBhZCk7XG4gICAgICAgICAgICAvLyBTa2lwIGlsbGVnYWwgY2hhcmFjdGVycyBhbmQgd2hpdGVzcGFjZVxuICAgICAgICAgICAgaWYgKGMgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgTG9nLkVycm9yKFwiSWxsZWdhbCBjaGFyYWN0ZXIgY29kZSBcIiArIGRhdGEuY2hhckNvZGVBdChpKSArIFwiIGF0IHBvc2l0aW9uIFwiICsgaSk7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIENvbGxlY3QgZGF0YSBpbnRvIGxlZnRkYXRhLCB1cGRhdGUgYml0Y291bnRcbiAgICAgICAgICAgIGxlZnRkYXRhID0gKGxlZnRkYXRhIDw8IDYpIHwgYztcbiAgICAgICAgICAgIGxlZnRiaXRzICs9IDY7XG5cbiAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgOCBvciBtb3JlIGJpdHMsIGFwcGVuZCA4IGJpdHMgdG8gdGhlIHJlc3VsdFxuICAgICAgICAgICAgaWYgKGxlZnRiaXRzID49IDgpIHtcbiAgICAgICAgICAgICAgICBsZWZ0Yml0cyAtPSA4O1xuICAgICAgICAgICAgICAgIC8vIEFwcGVuZCBpZiBub3QgcGFkZGluZy5cbiAgICAgICAgICAgICAgICBpZiAoIXBhZGRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0W2lkeCsrXSA9IChsZWZ0ZGF0YSA+PiBsZWZ0Yml0cykgJiAweGZmO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZWZ0ZGF0YSAmPSAoMSA8PCBsZWZ0Yml0cykgLSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgdGhlcmUgYXJlIGFueSBiaXRzIGxlZnQsIHRoZSBiYXNlNjQgc3RyaW5nIHdhcyBjb3JydXB0ZWRcbiAgICAgICAgaWYgKGxlZnRiaXRzKSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0NvcnJ1cHRlZCBiYXNlNjQgc3RyaW5nJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdCYXNlNjQtRXJyb3InO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59OyAvKiBFbmQgb2YgQmFzZTY0IG5hbWVzcGFjZSAqL1xuIiwiLypcbiAqIG5vVk5DOiBIVE1MNSBWTkMgY2xpZW50XG4gKiBDb3B5cmlnaHQgKEMpIDIwMTIgSm9lbCBNYXJ0aW5cbiAqIENvcHlyaWdodCAoQykgMjAxOCBTYW11ZWwgTWFubmVoZWQgZm9yIENlbmRpbyBBQlxuICogQ29weXJpZ2h0IChDKSAyMDE4IFBpZXJyZSBPc3NtYW4gZm9yIENlbmRpbyBBQlxuICogTGljZW5zZWQgdW5kZXIgTVBMIDIuMCAoc2VlIExJQ0VOU0UudHh0KVxuICpcbiAqIFNlZSBSRUFETUUubWQgZm9yIHVzYWdlIGFuZCBpbnRlZ3JhdGlvbiBpbnN0cnVjdGlvbnMuXG4gKlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENvcHlSZWN0RGVjb2RlciB7XG4gICAgZGVjb2RlUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzb2NrLCBkaXNwbGF5LCBkZXB0aCkge1xuICAgICAgICBpZiAoc29jay5yUXdhaXQoXCJDT1BZUkVDVFwiLCA0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRlbHRhWCA9IHNvY2suclFzaGlmdDE2KCk7XG4gICAgICAgIGxldCBkZWx0YVkgPSBzb2NrLnJRc2hpZnQxNigpO1xuICAgICAgICBkaXNwbGF5LmNvcHlJbWFnZShkZWx0YVgsIGRlbHRhWSwgeCwgeSwgd2lkdGgsIGhlaWdodCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuIiwiLypcbiAqIG5vVk5DOiBIVE1MNSBWTkMgY2xpZW50XG4gKiBDb3B5cmlnaHQgKEMpIDIwMTIgSm9lbCBNYXJ0aW5cbiAqIENvcHlyaWdodCAoQykgMjAxOCBTYW11ZWwgTWFubmVoZWQgZm9yIENlbmRpbyBBQlxuICogQ29weXJpZ2h0IChDKSAyMDE4IFBpZXJyZSBPc3NtYW4gZm9yIENlbmRpbyBBQlxuICogTGljZW5zZWQgdW5kZXIgTVBMIDIuMCAoc2VlIExJQ0VOU0UudHh0KVxuICpcbiAqIFNlZSBSRUFETUUubWQgZm9yIHVzYWdlIGFuZCBpbnRlZ3JhdGlvbiBpbnN0cnVjdGlvbnMuXG4gKlxuICovXG5cbmltcG9ydCAqIGFzIExvZyBmcm9tICcuLi91dGlsL2xvZ2dpbmcuanMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIZXh0aWxlRGVjb2RlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3RpbGVzID0gMDtcbiAgICAgICAgdGhpcy5fbGFzdHN1YmVuY29kaW5nID0gMDtcbiAgICB9XG5cbiAgICBkZWNvZGVSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIHNvY2ssIGRpc3BsYXksIGRlcHRoKSB7XG4gICAgICAgIGlmICh0aGlzLl90aWxlcyA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fdGlsZXNfeCA9IE1hdGguY2VpbCh3aWR0aCAvIDE2KTtcbiAgICAgICAgICAgIHRoaXMuX3RpbGVzX3kgPSBNYXRoLmNlaWwoaGVpZ2h0IC8gMTYpO1xuICAgICAgICAgICAgdGhpcy5fdG90YWxfdGlsZXMgPSB0aGlzLl90aWxlc194ICogdGhpcy5fdGlsZXNfeTtcbiAgICAgICAgICAgIHRoaXMuX3RpbGVzID0gdGhpcy5fdG90YWxfdGlsZXM7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAodGhpcy5fdGlsZXMgPiAwKSB7XG4gICAgICAgICAgICBsZXQgYnl0ZXMgPSAxO1xuXG4gICAgICAgICAgICBpZiAoc29jay5yUXdhaXQoXCJIRVhUSUxFXCIsIGJ5dGVzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHJRID0gc29jay5yUTtcbiAgICAgICAgICAgIGxldCByUWkgPSBzb2NrLnJRaTtcblxuICAgICAgICAgICAgbGV0IHN1YmVuY29kaW5nID0gclFbclFpXTsgIC8vIFBlZWtcbiAgICAgICAgICAgIGlmIChzdWJlbmNvZGluZyA+IDMwKSB7ICAvLyBSYXdcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGhleHRpbGUgc3ViZW5jb2RpbmcgKHN1YmVuY29kaW5nOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3ViZW5jb2RpbmcgKyBcIilcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IGN1cnJfdGlsZSA9IHRoaXMuX3RvdGFsX3RpbGVzIC0gdGhpcy5fdGlsZXM7XG4gICAgICAgICAgICBjb25zdCB0aWxlX3ggPSBjdXJyX3RpbGUgJSB0aGlzLl90aWxlc194O1xuICAgICAgICAgICAgY29uc3QgdGlsZV95ID0gTWF0aC5mbG9vcihjdXJyX3RpbGUgLyB0aGlzLl90aWxlc194KTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0geCArIHRpbGVfeCAqIDE2O1xuICAgICAgICAgICAgY29uc3QgdHkgPSB5ICsgdGlsZV95ICogMTY7XG4gICAgICAgICAgICBjb25zdCB0dyA9IE1hdGgubWluKDE2LCAoeCArIHdpZHRoKSAtIHR4KTtcbiAgICAgICAgICAgIGNvbnN0IHRoID0gTWF0aC5taW4oMTYsICh5ICsgaGVpZ2h0KSAtIHR5KTtcblxuICAgICAgICAgICAgLy8gRmlndXJlIG91dCBob3cgbXVjaCB3ZSBhcmUgZXhwZWN0aW5nXG4gICAgICAgICAgICBpZiAoc3ViZW5jb2RpbmcgJiAweDAxKSB7ICAvLyBSYXdcbiAgICAgICAgICAgICAgICBieXRlcyArPSB0dyAqIHRoICogNDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1YmVuY29kaW5nICYgMHgwMikgeyAgLy8gQmFja2dyb3VuZFxuICAgICAgICAgICAgICAgICAgICBieXRlcyArPSA0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3ViZW5jb2RpbmcgJiAweDA0KSB7ICAvLyBGb3JlZ3JvdW5kXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzICs9IDQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdWJlbmNvZGluZyAmIDB4MDgpIHsgIC8vIEFueVN1YnJlY3RzXG4gICAgICAgICAgICAgICAgICAgIGJ5dGVzKys7ICAvLyBTaW5jZSB3ZSBhcmVuJ3Qgc2hpZnRpbmcgaXQgb2ZmXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvY2suclF3YWl0KFwiSEVYVElMRVwiLCBieXRlcykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGxldCBzdWJyZWN0cyA9IHJRW3JRaSArIGJ5dGVzIC0gMV07ICAvLyBQZWVrXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdWJlbmNvZGluZyAmIDB4MTApIHsgIC8vIFN1YnJlY3RzQ29sb3VyZWRcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzICs9IHN1YnJlY3RzICogKDQgKyAyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ5dGVzICs9IHN1YnJlY3RzICogMjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNvY2suclF3YWl0KFwiSEVYVElMRVwiLCBieXRlcykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFdlIGtub3cgdGhlIGVuY29kaW5nIGFuZCBoYXZlIGEgd2hvbGUgdGlsZVxuICAgICAgICAgICAgclFpKys7XG4gICAgICAgICAgICBpZiAoc3ViZW5jb2RpbmcgPT09IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbGFzdHN1YmVuY29kaW5nICYgMHgwMSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBXZWlyZDogaWdub3JlIGJsYW5rcyBhcmUgUkFXXG4gICAgICAgICAgICAgICAgICAgIExvZy5EZWJ1ZyhcIiAgICAgSWdub3JpbmcgYmxhbmsgYWZ0ZXIgUkFXXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BsYXkuZmlsbFJlY3QodHgsIHR5LCB0dywgdGgsIHRoaXMuX2JhY2tncm91bmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoc3ViZW5jb2RpbmcgJiAweDAxKSB7ICAvLyBSYXdcbiAgICAgICAgICAgICAgICBkaXNwbGF5LmJsaXRJbWFnZSh0eCwgdHksIHR3LCB0aCwgclEsIHJRaSk7XG4gICAgICAgICAgICAgICAgclFpICs9IGJ5dGVzIC0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1YmVuY29kaW5nICYgMHgwMikgeyAgLy8gQmFja2dyb3VuZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9iYWNrZ3JvdW5kID0gW3JRW3JRaV0sIHJRW3JRaSArIDFdLCByUVtyUWkgKyAyXSwgclFbclFpICsgM11dO1xuICAgICAgICAgICAgICAgICAgICByUWkgKz0gNDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN1YmVuY29kaW5nICYgMHgwNCkgeyAgLy8gRm9yZWdyb3VuZFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mb3JlZ3JvdW5kID0gW3JRW3JRaV0sIHJRW3JRaSArIDFdLCByUVtyUWkgKyAyXSwgclFbclFpICsgM11dO1xuICAgICAgICAgICAgICAgICAgICByUWkgKz0gNDtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBkaXNwbGF5LnN0YXJ0VGlsZSh0eCwgdHksIHR3LCB0aCwgdGhpcy5fYmFja2dyb3VuZCk7XG4gICAgICAgICAgICAgICAgaWYgKHN1YmVuY29kaW5nICYgMHgwOCkgeyAgLy8gQW55U3VicmVjdHNcbiAgICAgICAgICAgICAgICAgICAgbGV0IHN1YnJlY3RzID0gclFbclFpXTtcbiAgICAgICAgICAgICAgICAgICAgclFpKys7XG5cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgcyA9IDA7IHMgPCBzdWJyZWN0czsgcysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgY29sb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3ViZW5jb2RpbmcgJiAweDEwKSB7ICAvLyBTdWJyZWN0c0NvbG91cmVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29sb3IgPSBbclFbclFpXSwgclFbclFpICsgMV0sIHJRW3JRaSArIDJdLCByUVtyUWkgKyAzXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgclFpICs9IDQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9yID0gdGhpcy5fZm9yZWdyb3VuZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHh5ID0gclFbclFpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJRaSsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ggPSAoeHkgPj4gNCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzeSA9ICh4eSAmIDB4MGYpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB3aCA9IHJRW3JRaV07XG4gICAgICAgICAgICAgICAgICAgICAgICByUWkrKztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHN3ID0gKHdoID4+IDQpICsgMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHNoID0gKHdoICYgMHgwZikgKyAxO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5LnN1YlRpbGUoc3gsIHN5LCBzdywgc2gsIGNvbG9yKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkaXNwbGF5LmZpbmlzaFRpbGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNvY2suclFpID0gclFpO1xuICAgICAgICAgICAgdGhpcy5fbGFzdHN1YmVuY29kaW5nID0gc3ViZW5jb2Rpbmc7XG4gICAgICAgICAgICB0aGlzLl90aWxlcy0tO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuIiwiLypcbiAqIG5vVk5DOiBIVE1MNSBWTkMgY2xpZW50XG4gKiBDb3B5cmlnaHQgKEMpIDIwMTIgSm9lbCBNYXJ0aW5cbiAqIENvcHlyaWdodCAoQykgMjAxOCBTYW11ZWwgTWFubmVoZWQgZm9yIENlbmRpbyBBQlxuICogQ29weXJpZ2h0IChDKSAyMDE4IFBpZXJyZSBPc3NtYW4gZm9yIENlbmRpbyBBQlxuICogTGljZW5zZWQgdW5kZXIgTVBMIDIuMCAoc2VlIExJQ0VOU0UudHh0KVxuICpcbiAqIFNlZSBSRUFETUUubWQgZm9yIHVzYWdlIGFuZCBpbnRlZ3JhdGlvbiBpbnN0cnVjdGlvbnMuXG4gKlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJhd0RlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9saW5lcyA9IDA7XG4gICAgfVxuXG4gICAgZGVjb2RlUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzb2NrLCBkaXNwbGF5LCBkZXB0aCkge1xuICAgICAgICBpZiAodGhpcy5fbGluZXMgPT09IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2xpbmVzID0gaGVpZ2h0O1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgcGl4ZWxTaXplID0gZGVwdGggPT0gOCA/IDEgOiA0O1xuICAgICAgICBjb25zdCBieXRlc1BlckxpbmUgPSB3aWR0aCAqIHBpeGVsU2l6ZTtcblxuICAgICAgICBpZiAoc29jay5yUXdhaXQoXCJSQVdcIiwgYnl0ZXNQZXJMaW5lKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgY3VyX3kgPSB5ICsgKGhlaWdodCAtIHRoaXMuX2xpbmVzKTtcbiAgICAgICAgY29uc3QgY3Vycl9oZWlnaHQgPSBNYXRoLm1pbih0aGlzLl9saW5lcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKHNvY2suclFsZW4gLyBieXRlc1BlckxpbmUpKTtcbiAgICAgICAgbGV0IGRhdGEgPSBzb2NrLnJRO1xuICAgICAgICBsZXQgaW5kZXggPSBzb2NrLnJRaTtcblxuICAgICAgICAvLyBDb252ZXJ0IGRhdGEgaWYgbmVlZGVkXG4gICAgICAgIGlmIChkZXB0aCA9PSA4KSB7XG4gICAgICAgICAgICBjb25zdCBwaXhlbHMgPSB3aWR0aCAqIGN1cnJfaGVpZ2h0O1xuICAgICAgICAgICAgY29uc3QgbmV3ZGF0YSA9IG5ldyBVaW50OEFycmF5KHBpeGVscyAqIDQpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwaXhlbHM7IGkrKykge1xuICAgICAgICAgICAgICAgIG5ld2RhdGFbaSAqIDQgKyAwXSA9ICgoZGF0YVtpbmRleCArIGldID4+IDApICYgMHgzKSAqIDI1NSAvIDM7XG4gICAgICAgICAgICAgICAgbmV3ZGF0YVtpICogNCArIDFdID0gKChkYXRhW2luZGV4ICsgaV0gPj4gMikgJiAweDMpICogMjU1IC8gMztcbiAgICAgICAgICAgICAgICBuZXdkYXRhW2kgKiA0ICsgMl0gPSAoKGRhdGFbaW5kZXggKyBpXSA+PiA0KSAmIDB4MykgKiAyNTUgLyAzO1xuICAgICAgICAgICAgICAgIG5ld2RhdGFbaSAqIDQgKyA0XSA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhID0gbmV3ZGF0YTtcbiAgICAgICAgICAgIGluZGV4ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3BsYXkuYmxpdEltYWdlKHgsIGN1cl95LCB3aWR0aCwgY3Vycl9oZWlnaHQsIGRhdGEsIGluZGV4KTtcbiAgICAgICAgc29jay5yUXNraXBCeXRlcyhjdXJyX2hlaWdodCAqIGJ5dGVzUGVyTGluZSk7XG4gICAgICAgIHRoaXMuX2xpbmVzIC09IGN1cnJfaGVpZ2h0O1xuICAgICAgICBpZiAodGhpcy5fbGluZXMgPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4iLCIvKlxuICogbm9WTkM6IEhUTUw1IFZOQyBjbGllbnRcbiAqIENvcHlyaWdodCAoQykgMjAxMiBKb2VsIE1hcnRpblxuICogQ29weXJpZ2h0IChDKSAyMDE4IFNhbXVlbCBNYW5uZWhlZCBmb3IgQ2VuZGlvIEFCXG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggUGllcnJlIE9zc21hbiBmb3IgQ2VuZGlvIEFCXG4gKiBMaWNlbnNlZCB1bmRlciBNUEwgMi4wIChzZWUgTElDRU5TRS50eHQpXG4gKlxuICogU2VlIFJFQURNRS5tZCBmb3IgdXNhZ2UgYW5kIGludGVncmF0aW9uIGluc3RydWN0aW9ucy5cbiAqXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgUlJFRGVjb2RlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuX3N1YnJlY3RzID0gMDtcbiAgICB9XG5cbiAgICBkZWNvZGVSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIHNvY2ssIGRpc3BsYXksIGRlcHRoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zdWJyZWN0cyA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHNvY2suclF3YWl0KFwiUlJFXCIsIDQgKyA0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fc3VicmVjdHMgPSBzb2NrLnJRc2hpZnQzMigpO1xuXG4gICAgICAgICAgICBsZXQgY29sb3IgPSBzb2NrLnJRc2hpZnRCeXRlcyg0KTsgIC8vIEJhY2tncm91bmRcbiAgICAgICAgICAgIGRpc3BsYXkuZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgY29sb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgd2hpbGUgKHRoaXMuX3N1YnJlY3RzID4gMCkge1xuICAgICAgICAgICAgaWYgKHNvY2suclF3YWl0KFwiUlJFXCIsIDQgKyA4KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IGNvbG9yID0gc29jay5yUXNoaWZ0Qnl0ZXMoNCk7XG4gICAgICAgICAgICBsZXQgc3ggPSBzb2NrLnJRc2hpZnQxNigpO1xuICAgICAgICAgICAgbGV0IHN5ID0gc29jay5yUXNoaWZ0MTYoKTtcbiAgICAgICAgICAgIGxldCBzd2lkdGggPSBzb2NrLnJRc2hpZnQxNigpO1xuICAgICAgICAgICAgbGV0IHNoZWlnaHQgPSBzb2NrLnJRc2hpZnQxNigpO1xuICAgICAgICAgICAgZGlzcGxheS5maWxsUmVjdCh4ICsgc3gsIHkgKyBzeSwgc3dpZHRoLCBzaGVpZ2h0LCBjb2xvcik7XG5cbiAgICAgICAgICAgIHRoaXMuX3N1YnJlY3RzLS07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG4iLCIvKlxuICogbm9WTkM6IEhUTUw1IFZOQyBjbGllbnRcbiAqIENvcHlyaWdodCAoQykgMjAxMiBKb2VsIE1hcnRpblxuICogKGMpIDIwMTIgTWljaGFlbCBUaW5nbG9mLCBKb2UgQmFsYXosIExlcyBQaWVjaCAoTWVyY3VyaS5jYSlcbiAqIENvcHlyaWdodCAoQykgMjAxOCBTYW11ZWwgTWFubmVoZWQgZm9yIENlbmRpbyBBQlxuICogQ29weXJpZ2h0IChDKSAyMDE4IFBpZXJyZSBPc3NtYW4gZm9yIENlbmRpbyBBQlxuICogTGljZW5zZWQgdW5kZXIgTVBMIDIuMCAoc2VlIExJQ0VOU0UudHh0KVxuICpcbiAqIFNlZSBSRUFETUUubWQgZm9yIHVzYWdlIGFuZCBpbnRlZ3JhdGlvbiBpbnN0cnVjdGlvbnMuXG4gKlxuICovXG5cbmltcG9ydCAqIGFzIExvZyBmcm9tICcuLi91dGlsL2xvZ2dpbmcuanMnO1xuaW1wb3J0IEluZmxhdG9yIGZyb20gXCIuLi9pbmZsYXRvci5qc1wiO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaWdodERlY29kZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9jdGwgPSBudWxsO1xuICAgICAgICB0aGlzLl9maWx0ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9udW1Db2xvcnMgPSAwO1xuICAgICAgICB0aGlzLl9wYWxldHRlID0gbmV3IFVpbnQ4QXJyYXkoMTAyNCk7ICAvLyAyNTYgKiA0IChtYXggcGFsZXR0ZSBzaXplICogbWF4IGJ5dGVzLXBlci1waXhlbClcbiAgICAgICAgdGhpcy5fbGVuID0gMDtcblxuICAgICAgICB0aGlzLl96bGlicyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5femxpYnNbaV0gPSBuZXcgSW5mbGF0b3IoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRlY29kZVJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgc29jaywgZGlzcGxheSwgZGVwdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2N0bCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHNvY2suclF3YWl0KFwiVElHSFQgY29tcHJlc3Npb24tY29udHJvbFwiLCAxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fY3RsID0gc29jay5yUXNoaWZ0OCgpO1xuXG4gICAgICAgICAgICAvLyBSZXNldCBzdHJlYW1zIGlmIHRoZSBzZXJ2ZXIgcmVxdWVzdHMgaXRcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLl9jdGwgPj4gaSkgJiAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3psaWJzW2ldLnJlc2V0KCk7XG4gICAgICAgICAgICAgICAgICAgIExvZy5JbmZvKFwiUmVzZXQgemxpYiBzdHJlYW0gXCIgKyBpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEZpZ3VyZSBvdXQgZmlsdGVyXG4gICAgICAgICAgICB0aGlzLl9jdGwgPSB0aGlzLl9jdGwgPj4gNDtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCByZXQ7XG5cbiAgICAgICAgaWYgKHRoaXMuX2N0bCA9PT0gMHgwOCkge1xuICAgICAgICAgICAgcmV0ID0gdGhpcy5fZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2ssIGRpc3BsYXksIGRlcHRoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9jdGwgPT09IDB4MDkpIHtcbiAgICAgICAgICAgIHJldCA9IHRoaXMuX2pwZWdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrLCBkaXNwbGF5LCBkZXB0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fY3RsID09PSAweDBBKSB7XG4gICAgICAgICAgICByZXQgPSB0aGlzLl9wbmdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2ssIGRpc3BsYXksIGRlcHRoKTtcbiAgICAgICAgfSBlbHNlIGlmICgodGhpcy5fY3RsICYgMHg4MCkgPT0gMCkge1xuICAgICAgICAgICAgcmV0ID0gdGhpcy5fYmFzaWNSZWN0KHRoaXMuX2N0bCwgeCwgeSwgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrLCBkaXNwbGF5LCBkZXB0aCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHRpZ2h0IGNvbXByZXNzaW9uIHJlY2VpdmVkIChjdGw6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fY3RsICsgXCIpXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJldCkge1xuICAgICAgICAgICAgdGhpcy5fY3RsID0gbnVsbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuXG4gICAgX2ZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIHNvY2ssIGRpc3BsYXksIGRlcHRoKSB7XG4gICAgICAgIGlmIChzb2NrLnJRd2FpdChcIlRJR0hUXCIsIDMpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByUWkgPSBzb2NrLnJRaTtcbiAgICAgICAgY29uc3QgclEgPSBzb2NrLnJRO1xuXG4gICAgICAgIGRpc3BsYXkuZmlsbFJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBbclFbclFpICsgMl0sIHJRW3JRaSArIDFdLCByUVtyUWldXSwgZmFsc2UpO1xuICAgICAgICBzb2NrLnJRc2tpcEJ5dGVzKDMpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIF9qcGVnUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzb2NrLCBkaXNwbGF5LCBkZXB0aCkge1xuICAgICAgICBsZXQgZGF0YSA9IHRoaXMuX3JlYWREYXRhKHNvY2spO1xuICAgICAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgZGlzcGxheS5pbWFnZVJlY3QoeCwgeSwgXCJpbWFnZS9qcGVnXCIsIGRhdGEpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIF9wbmdSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIHNvY2ssIGRpc3BsYXksIGRlcHRoKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBORyByZWNlaXZlZCBpbiBzdGFuZGFyZCBUaWdodCByZWN0XCIpO1xuICAgIH1cblxuICAgIF9iYXNpY1JlY3QoY3RsLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzb2NrLCBkaXNwbGF5LCBkZXB0aCkge1xuICAgICAgICBpZiAodGhpcy5fZmlsdGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoY3RsICYgMHg0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHNvY2suclF3YWl0KFwiVElHSFRcIiwgMSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbHRlciA9IHNvY2suclFzaGlmdDgoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSW1wbGljaXQgQ29weUZpbHRlclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZpbHRlciA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgc3RyZWFtSWQgPSBjdGwgJiAweDM7XG5cbiAgICAgICAgbGV0IHJldDtcblxuICAgICAgICBzd2l0Y2ggKHRoaXMuX2ZpbHRlcikge1xuICAgICAgICAgICAgY2FzZSAwOiAvLyBDb3B5RmlsdGVyXG4gICAgICAgICAgICAgICAgcmV0ID0gdGhpcy5fY29weUZpbHRlcihzdHJlYW1JZCwgeCwgeSwgd2lkdGgsIGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNvY2ssIGRpc3BsYXksIGRlcHRoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMTogLy8gUGFsZXR0ZUZpbHRlclxuICAgICAgICAgICAgICAgIHJldCA9IHRoaXMuX3BhbGV0dGVGaWx0ZXIoc3RyZWFtSWQsIHgsIHksIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzb2NrLCBkaXNwbGF5LCBkZXB0aCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6IC8vIEdyYWRpZW50RmlsdGVyXG4gICAgICAgICAgICAgICAgcmV0ID0gdGhpcy5fZ3JhZGllbnRGaWx0ZXIoc3RyZWFtSWQsIHgsIHksIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc29jaywgZGlzcGxheSwgZGVwdGgpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIHRpZ2h0IGZpbHRlciByZWNlaXZlZCAoY3RsOiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9maWx0ZXIgKyBcIilcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmV0KSB7XG4gICAgICAgICAgICB0aGlzLl9maWx0ZXIgPSBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG5cbiAgICBfY29weUZpbHRlcihzdHJlYW1JZCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgc29jaywgZGlzcGxheSwgZGVwdGgpIHtcbiAgICAgICAgY29uc3QgdW5jb21wcmVzc2VkU2l6ZSA9IHdpZHRoICogaGVpZ2h0ICogMztcbiAgICAgICAgbGV0IGRhdGE7XG5cbiAgICAgICAgaWYgKHVuY29tcHJlc3NlZFNpemUgPCAxMikge1xuICAgICAgICAgICAgaWYgKHNvY2suclF3YWl0KFwiVElHSFRcIiwgdW5jb21wcmVzc2VkU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGEgPSBzb2NrLnJRc2hpZnRCeXRlcyh1bmNvbXByZXNzZWRTaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9yZWFkRGF0YShzb2NrKTtcbiAgICAgICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5femxpYnNbc3RyZWFtSWRdLmluZmxhdGUoZGF0YSwgdHJ1ZSwgdW5jb21wcmVzc2VkU2l6ZSk7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT0gdW5jb21wcmVzc2VkU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29tcGxldGUgemxpYiBibG9ja1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3BsYXkuYmxpdFJnYkltYWdlKHgsIHksIHdpZHRoLCBoZWlnaHQsIGRhdGEsIDAsIGZhbHNlKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBfcGFsZXR0ZUZpbHRlcihzdHJlYW1JZCwgeCwgeSwgd2lkdGgsIGhlaWdodCwgc29jaywgZGlzcGxheSwgZGVwdGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX251bUNvbG9ycyA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKHNvY2suclF3YWl0KFwiVElHSFQgcGFsZXR0ZVwiLCAxKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgbnVtQ29sb3JzID0gc29jay5yUXBlZWs4KCkgKyAxO1xuICAgICAgICAgICAgY29uc3QgcGFsZXR0ZVNpemUgPSBudW1Db2xvcnMgKiAzO1xuXG4gICAgICAgICAgICBpZiAoc29jay5yUXdhaXQoXCJUSUdIVCBwYWxldHRlXCIsIDEgKyBwYWxldHRlU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX251bUNvbG9ycyA9IG51bUNvbG9ycztcbiAgICAgICAgICAgIHNvY2suclFza2lwQnl0ZXMoMSk7XG5cbiAgICAgICAgICAgIHNvY2suclFzaGlmdFRvKHRoaXMuX3BhbGV0dGUsIHBhbGV0dGVTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJwcCA9ICh0aGlzLl9udW1Db2xvcnMgPD0gMikgPyAxIDogODtcbiAgICAgICAgY29uc3Qgcm93U2l6ZSA9IE1hdGguZmxvb3IoKHdpZHRoICogYnBwICsgNykgLyA4KTtcbiAgICAgICAgY29uc3QgdW5jb21wcmVzc2VkU2l6ZSA9IHJvd1NpemUgKiBoZWlnaHQ7XG5cbiAgICAgICAgbGV0IGRhdGE7XG5cbiAgICAgICAgaWYgKHVuY29tcHJlc3NlZFNpemUgPCAxMikge1xuICAgICAgICAgICAgaWYgKHNvY2suclF3YWl0KFwiVElHSFRcIiwgdW5jb21wcmVzc2VkU2l6ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGRhdGEgPSBzb2NrLnJRc2hpZnRCeXRlcyh1bmNvbXByZXNzZWRTaXplKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRhdGEgPSB0aGlzLl9yZWFkRGF0YShzb2NrKTtcbiAgICAgICAgICAgIGlmIChkYXRhID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5femxpYnNbc3RyZWFtSWRdLmluZmxhdGUoZGF0YSwgdHJ1ZSwgdW5jb21wcmVzc2VkU2l6ZSk7XG4gICAgICAgICAgICBpZiAoZGF0YS5sZW5ndGggIT0gdW5jb21wcmVzc2VkU2l6ZSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkluY29tcGxldGUgemxpYiBibG9ja1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIENvbnZlcnQgaW5kZXhlZCAocGFsZXR0ZSBiYXNlZCkgaW1hZ2UgZGF0YSB0byBSR0JcbiAgICAgICAgaWYgKHRoaXMuX251bUNvbG9ycyA9PSAyKSB7XG4gICAgICAgICAgICB0aGlzLl9tb25vUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBkYXRhLCB0aGlzLl9wYWxldHRlLCBkaXNwbGF5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3BhbGV0dGVSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQsIGRhdGEsIHRoaXMuX3BhbGV0dGUsIGRpc3BsYXkpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbnVtQ29sb3JzID0gMDtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBfbW9ub1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgZGF0YSwgcGFsZXR0ZSwgZGlzcGxheSkge1xuICAgICAgICAvLyBDb252ZXJ0IGluZGV4ZWQgKHBhbGV0dGUgYmFzZWQpIGltYWdlIGRhdGEgdG8gUkdCXG4gICAgICAgIC8vIFRPRE86IHJlZHVjZSBudW1iZXIgb2YgY2FsY3VsYXRpb25zIGluc2lkZSBsb29wXG4gICAgICAgIGNvbnN0IGRlc3QgPSB0aGlzLl9nZXRTY3JhdGNoQnVmZmVyKHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgIGNvbnN0IHcgPSBNYXRoLmZsb29yKCh3aWR0aCArIDcpIC8gOCk7XG4gICAgICAgIGNvbnN0IHcxID0gTWF0aC5mbG9vcih3aWR0aCAvIDgpO1xuXG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyB5KyspIHtcbiAgICAgICAgICAgIGxldCBkcCwgc3AsIHg7XG4gICAgICAgICAgICBmb3IgKHggPSAwOyB4IDwgdzE7IHgrKykge1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGIgPSA3OyBiID49IDA7IGItLSkge1xuICAgICAgICAgICAgICAgICAgICBkcCA9ICh5ICogd2lkdGggKyB4ICogOCArIDcgLSBiKSAqIDQ7XG4gICAgICAgICAgICAgICAgICAgIHNwID0gKGRhdGFbeSAqIHcgKyB4XSA+PiBiICYgMSkgKiAzO1xuICAgICAgICAgICAgICAgICAgICBkZXN0W2RwXSA9IHBhbGV0dGVbc3BdO1xuICAgICAgICAgICAgICAgICAgICBkZXN0W2RwICsgMV0gPSBwYWxldHRlW3NwICsgMV07XG4gICAgICAgICAgICAgICAgICAgIGRlc3RbZHAgKyAyXSA9IHBhbGV0dGVbc3AgKyAyXTtcbiAgICAgICAgICAgICAgICAgICAgZGVzdFtkcCArIDNdID0gMjU1O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZm9yIChsZXQgYiA9IDc7IGIgPj0gOCAtIHdpZHRoICUgODsgYi0tKSB7XG4gICAgICAgICAgICAgICAgZHAgPSAoeSAqIHdpZHRoICsgeCAqIDggKyA3IC0gYikgKiA0O1xuICAgICAgICAgICAgICAgIHNwID0gKGRhdGFbeSAqIHcgKyB4XSA+PiBiICYgMSkgKiAzO1xuICAgICAgICAgICAgICAgIGRlc3RbZHBdID0gcGFsZXR0ZVtzcF07XG4gICAgICAgICAgICAgICAgZGVzdFtkcCArIDFdID0gcGFsZXR0ZVtzcCArIDFdO1xuICAgICAgICAgICAgICAgIGRlc3RbZHAgKyAyXSA9IHBhbGV0dGVbc3AgKyAyXTtcbiAgICAgICAgICAgICAgICBkZXN0W2RwICsgM10gPSAyNTU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBkaXNwbGF5LmJsaXRSZ2J4SW1hZ2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgZGVzdCwgMCwgZmFsc2UpO1xuICAgIH1cblxuICAgIF9wYWxldHRlUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBkYXRhLCBwYWxldHRlLCBkaXNwbGF5KSB7XG4gICAgICAgIC8vIENvbnZlcnQgaW5kZXhlZCAocGFsZXR0ZSBiYXNlZCkgaW1hZ2UgZGF0YSB0byBSR0JcbiAgICAgICAgY29uc3QgZGVzdCA9IHRoaXMuX2dldFNjcmF0Y2hCdWZmZXIod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgY29uc3QgdG90YWwgPSB3aWR0aCAqIGhlaWdodCAqIDQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHRvdGFsOyBpICs9IDQsIGorKykge1xuICAgICAgICAgICAgY29uc3Qgc3AgPSBkYXRhW2pdICogMztcbiAgICAgICAgICAgIGRlc3RbaV0gPSBwYWxldHRlW3NwXTtcbiAgICAgICAgICAgIGRlc3RbaSArIDFdID0gcGFsZXR0ZVtzcCArIDFdO1xuICAgICAgICAgICAgZGVzdFtpICsgMl0gPSBwYWxldHRlW3NwICsgMl07XG4gICAgICAgICAgICBkZXN0W2kgKyAzXSA9IDI1NTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3BsYXkuYmxpdFJnYnhJbWFnZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBkZXN0LCAwLCBmYWxzZSk7XG4gICAgfVxuXG4gICAgX2dyYWRpZW50RmlsdGVyKHN0cmVhbUlkLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzb2NrLCBkaXNwbGF5LCBkZXB0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJHcmFkaWVudCBmaWx0ZXIgbm90IGltcGxlbWVudGVkXCIpO1xuICAgIH1cblxuICAgIF9yZWFkRGF0YShzb2NrKSB7XG4gICAgICAgIGlmICh0aGlzLl9sZW4gPT09IDApIHtcbiAgICAgICAgICAgIGlmIChzb2NrLnJRd2FpdChcIlRJR0hUXCIsIDMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGxldCBieXRlO1xuXG4gICAgICAgICAgICBieXRlID0gc29jay5yUXNoaWZ0OCgpO1xuICAgICAgICAgICAgdGhpcy5fbGVuID0gYnl0ZSAmIDB4N2Y7XG4gICAgICAgICAgICBpZiAoYnl0ZSAmIDB4ODApIHtcbiAgICAgICAgICAgICAgICBieXRlID0gc29jay5yUXNoaWZ0OCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xlbiB8PSAoYnl0ZSAmIDB4N2YpIDw8IDc7XG4gICAgICAgICAgICAgICAgaWYgKGJ5dGUgJiAweDgwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJ5dGUgPSBzb2NrLnJRc2hpZnQ4KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2xlbiB8PSBieXRlIDw8IDE0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzb2NrLnJRd2FpdChcIlRJR0hUXCIsIHRoaXMuX2xlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG5cbiAgICAgICAgbGV0IGRhdGEgPSBzb2NrLnJRc2hpZnRCeXRlcyh0aGlzLl9sZW4pO1xuICAgICAgICB0aGlzLl9sZW4gPSAwO1xuXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIF9nZXRTY3JhdGNoQnVmZmVyKHNpemUpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zY3JhdGNoQnVmZmVyIHx8ICh0aGlzLl9zY3JhdGNoQnVmZmVyLmxlbmd0aCA8IHNpemUpKSB7XG4gICAgICAgICAgICB0aGlzLl9zY3JhdGNoQnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoc2l6ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjcmF0Y2hCdWZmZXI7XG4gICAgfVxufVxuIiwiLypcbiAqIG5vVk5DOiBIVE1MNSBWTkMgY2xpZW50XG4gKiBDb3B5cmlnaHQgKEMpIDIwMTIgSm9lbCBNYXJ0aW5cbiAqIENvcHlyaWdodCAoQykgMjAxOCBTYW11ZWwgTWFubmVoZWQgZm9yIENlbmRpbyBBQlxuICogQ29weXJpZ2h0IChDKSAyMDE4IFBpZXJyZSBPc3NtYW4gZm9yIENlbmRpbyBBQlxuICogTGljZW5zZWQgdW5kZXIgTVBMIDIuMCAoc2VlIExJQ0VOU0UudHh0KVxuICpcbiAqIFNlZSBSRUFETUUubWQgZm9yIHVzYWdlIGFuZCBpbnRlZ3JhdGlvbiBpbnN0cnVjdGlvbnMuXG4gKlxuICovXG5cbmltcG9ydCBUaWdodERlY29kZXIgZnJvbSAnLi90aWdodC5qcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpZ2h0UE5HRGVjb2RlciBleHRlbmRzIFRpZ2h0RGVjb2RlciB7XG4gICAgX3BuZ1JlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCwgc29jaywgZGlzcGxheSwgZGVwdGgpIHtcbiAgICAgICAgbGV0IGRhdGEgPSB0aGlzLl9yZWFkRGF0YShzb2NrKTtcbiAgICAgICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRpc3BsYXkuaW1hZ2VSZWN0KHgsIHksIFwiaW1hZ2UvcG5nXCIsIGRhdGEpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIF9iYXNpY1JlY3QoY3RsLCB4LCB5LCB3aWR0aCwgaGVpZ2h0LCBzb2NrLCBkaXNwbGF5LCBkZXB0aCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCYXNpY0NvbXByZXNzaW9uIHJlY2VpdmVkIGluIFRpZ2h0UE5HIHJlY3RcIik7XG4gICAgfVxufVxuIiwiLypcbiAqIFBvcnRlZCBmcm9tIEZsYXNobGlnaHQgVk5DIEFjdGlvblNjcmlwdCBpbXBsZW1lbnRhdGlvbjpcbiAqICAgICBodHRwOi8vd3d3LndpemhlbHAuY29tL2ZsYXNobGlnaHQtdm5jL1xuICpcbiAqIEZ1bGwgYXR0cmlidXRpb24gZm9sbG93czpcbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gKlxuICogVGhpcyBERVMgY2xhc3MgaGFzIGJlZW4gZXh0cmFjdGVkIGZyb20gcGFja2FnZSBBY21lLkNyeXB0byBmb3IgdXNlIGluIFZOQy5cbiAqIFRoZSB1bm5lY2Vzc2FyeSBvZGQgcGFyaXR5IGNvZGUgaGFzIGJlZW4gcmVtb3ZlZC5cbiAqXG4gKiBUaGVzZSBjaGFuZ2VzIGFyZTpcbiAqICBDb3B5cmlnaHQgKEMpIDE5OTkgQVQmVCBMYWJvcmF0b3JpZXMgQ2FtYnJpZGdlLiAgQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBUaGlzIHNvZnR3YXJlIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLlxuICpcblxuICogRGVzQ2lwaGVyIC0gdGhlIERFUyBlbmNyeXB0aW9uIG1ldGhvZFxuICpcbiAqIFRoZSBtZWF0IG9mIHRoaXMgY29kZSBpcyBieSBEYXZlIFppbW1lcm1hbiA8ZHppbW1Ad2lkZ2V0LmNvbT4sIGFuZCBpczpcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDE5OTYgV2lkZ2V0IFdvcmtzaG9wLCBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZVxuICogYW5kIGl0cyBkb2N1bWVudGF0aW9uIGZvciBOT04tQ09NTUVSQ0lBTCBvciBDT01NRVJDSUFMIHB1cnBvc2VzIGFuZFxuICogd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhpcyBjb3B5cmlnaHQgbm90aWNlIGlzIGtlcHRcbiAqIGludGFjdC5cbiAqXG4gKiBXSURHRVQgV09SS1NIT1AgTUFLRVMgTk8gUkVQUkVTRU5UQVRJT05TIE9SIFdBUlJBTlRJRVMgQUJPVVQgVEhFIFNVSVRBQklMSVRZXG4gKiBPRiBUSEUgU09GVFdBUkUsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURURcbiAqIFRPIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBXG4gKiBQQVJUSUNVTEFSIFBVUlBPU0UsIE9SIE5PTi1JTkZSSU5HRU1FTlQuIFdJREdFVCBXT1JLU0hPUCBTSEFMTCBOT1QgQkUgTElBQkxFXG4gKiBGT1IgQU5ZIERBTUFHRVMgU1VGRkVSRUQgQlkgTElDRU5TRUUgQVMgQSBSRVNVTFQgT0YgVVNJTkcsIE1PRElGWUlORyBPUlxuICogRElTVFJJQlVUSU5HIFRISVMgU09GVFdBUkUgT1IgSVRTIERFUklWQVRJVkVTLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgTk9UIERFU0lHTkVEIE9SIElOVEVOREVEIEZPUiBVU0UgT1IgUkVTQUxFIEFTIE9OLUxJTkVcbiAqIENPTlRST0wgRVFVSVBNRU5UIElOIEhBWkFSRE9VUyBFTlZJUk9OTUVOVFMgUkVRVUlSSU5HIEZBSUwtU0FGRVxuICogUEVSRk9STUFOQ0UsIFNVQ0ggQVMgSU4gVEhFIE9QRVJBVElPTiBPRiBOVUNMRUFSIEZBQ0lMSVRJRVMsIEFJUkNSQUZUXG4gKiBOQVZJR0FUSU9OIE9SIENPTU1VTklDQVRJT04gU1lTVEVNUywgQUlSIFRSQUZGSUMgQ09OVFJPTCwgRElSRUNUIExJRkVcbiAqIFNVUFBPUlQgTUFDSElORVMsIE9SIFdFQVBPTlMgU1lTVEVNUywgSU4gV0hJQ0ggVEhFIEZBSUxVUkUgT0YgVEhFXG4gKiBTT0ZUV0FSRSBDT1VMRCBMRUFEIERJUkVDVExZIFRPIERFQVRILCBQRVJTT05BTCBJTkpVUlksIE9SIFNFVkVSRVxuICogUEhZU0lDQUwgT1IgRU5WSVJPTk1FTlRBTCBEQU1BR0UgKFwiSElHSCBSSVNLIEFDVElWSVRJRVNcIikuICBXSURHRVQgV09SS1NIT1BcbiAqIFNQRUNJRklDQUxMWSBESVNDTEFJTVMgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5UWSBPRiBGSVRORVNTIEZPUlxuICogSElHSCBSSVNLIEFDVElWSVRJRVMuXG4gKlxuICpcbiAqIFRoZSByZXN0IGlzOlxuICpcbiAqIENvcHlyaWdodCAoQykgMTk5NiBieSBKZWYgUG9za2FuemVyIDxqZWZAYWNtZS5jb20+LiAgQWxsIHJpZ2h0cyByZXNlcnZlZC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uc1xuICogYXJlIG1ldDpcbiAqIDEuIFJlZGlzdHJpYnV0aW9ucyBvZiBzb3VyY2UgY29kZSBtdXN0IHJldGFpbiB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIuXG4gKiAyLiBSZWRpc3RyaWJ1dGlvbnMgaW4gYmluYXJ5IGZvcm0gbXVzdCByZXByb2R1Y2UgdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZVxuICogICAgZG9jdW1lbnRhdGlvbiBhbmQvb3Igb3RoZXIgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIFRIRSBBVVRIT1IgQU5EIENPTlRSSUJVVE9SUyBgYEFTIElTJycgQU5EXG4gKiBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiBBUkUgRElTQ0xBSU1FRC4gIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgT1IgQ09OVFJJQlVUT1JTIEJFIExJQUJMRVxuICogRk9SIEFOWSBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUxcbiAqIERBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTXG4gKiBPUiBTRVJWSUNFUzsgTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTilcbiAqIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUXG4gKiBMSUFCSUxJVFksIE9SIFRPUlQgKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZXG4gKiBPVVQgT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GXG4gKiBTVUNIIERBTUFHRS5cbiAqXG4gKiBWaXNpdCB0aGUgQUNNRSBMYWJzIEphdmEgcGFnZSBmb3IgdXAtdG8tZGF0ZSB2ZXJzaW9ucyBvZiB0aGlzIGFuZCBvdGhlclxuICogZmluZSBKYXZhIHV0aWxpdGllczogaHR0cDovL3d3dy5hY21lLmNvbS9qYXZhL1xuICovXG5cbi8qIGVzbGludC1kaXNhYmxlIGNvbW1hLXNwYWNpbmcgKi9cblxuLy8gVGFibGVzLCBwZXJtdXRhdGlvbnMsIFMtYm94ZXMsIGV0Yy5cbmNvbnN0IFBDMiA9IFsxMywxNiwxMCwyMywgMCwgNCwgMiwyNywxNCwgNSwyMCwgOSwyMiwxOCwxMSwgMyxcbiAgICAgICAgICAgICAyNSwgNywxNSwgNiwyNiwxOSwxMiwgMSw0MCw1MSwzMCwzNiw0Niw1NCwyOSwzOSxcbiAgICAgICAgICAgICA1MCw0NCwzMiw0Nyw0Myw0OCwzOCw1NSwzMyw1Miw0NSw0MSw0OSwzNSwyOCwzMSBdLFxuICAgIHRvdHJvdCA9IFsgMSwgMiwgNCwgNiwgOCwxMCwxMiwxNCwxNSwxNywxOSwyMSwyMywyNSwyNywyOF07XG5cbmNvbnN0IHogPSAweDA7XG5sZXQgYSxiLGMsZCxlLGY7XG5hPTE8PDE2OyBiPTE8PDI0OyBjPWF8YjsgZD0xPDwyOyBlPTE8PDEwOyBmPWR8ZTtcbmNvbnN0IFNQMSA9IFtjfGUsenx6LGF8eixjfGYsY3xkLGF8Zix6fGQsYXx6LHp8ZSxjfGUsY3xmLHp8ZSxifGYsY3xkLGJ8eix6fGQsXG4gICAgICAgICAgICAgenxmLGJ8ZSxifGUsYXxlLGF8ZSxjfHosY3x6LGJ8ZixhfGQsYnxkLGJ8ZCxhfGQsenx6LHp8ZixhfGYsYnx6LFxuICAgICAgICAgICAgIGF8eixjfGYsenxkLGN8eixjfGUsYnx6LGJ8eix6fGUsY3xkLGF8eixhfGUsYnxkLHp8ZSx6fGQsYnxmLGF8ZixcbiAgICAgICAgICAgICBjfGYsYXxkLGN8eixifGYsYnxkLHp8ZixhfGYsY3xlLHp8ZixifGUsYnxlLHp8eixhfGQsYXxlLHp8eixjfGRdO1xuYT0xPDwyMDsgYj0xPDwzMTsgYz1hfGI7IGQ9MTw8NTsgZT0xPDwxNTsgZj1kfGU7XG5jb25zdCBTUDIgPSBbY3xmLGJ8ZSx6fGUsYXxmLGF8eix6fGQsY3xkLGJ8ZixifGQsY3xmLGN8ZSxifHosYnxlLGF8eix6fGQsY3xkLFxuICAgICAgICAgICAgIGF8ZSxhfGQsYnxmLHp8eixifHosenxlLGF8ZixjfHosYXxkLGJ8ZCx6fHosYXxlLHp8ZixjfGUsY3x6LHp8ZixcbiAgICAgICAgICAgICB6fHosYXxmLGN8ZCxhfHosYnxmLGN8eixjfGUsenxlLGN8eixifGUsenxkLGN8ZixhfGYsenxkLHp8ZSxifHosXG4gICAgICAgICAgICAgenxmLGN8ZSxhfHosYnxkLGF8ZCxifGYsYnxkLGF8ZCxhfGUsenx6LGJ8ZSx6fGYsYnx6LGN8ZCxjfGYsYXxlXTtcbmE9MTw8MTc7IGI9MTw8Mjc7IGM9YXxiOyBkPTE8PDM7IGU9MTw8OTsgZj1kfGU7XG5jb25zdCBTUDMgPSBbenxmLGN8ZSx6fHosY3xkLGJ8ZSx6fHosYXxmLGJ8ZSxhfGQsYnxkLGJ8ZCxhfHosY3xmLGF8ZCxjfHosenxmLFxuICAgICAgICAgICAgIGJ8eix6fGQsY3xlLHp8ZSxhfGUsY3x6LGN8ZCxhfGYsYnxmLGF8ZSxhfHosYnxmLHp8ZCxjfGYsenxlLGJ8eixcbiAgICAgICAgICAgICBjfGUsYnx6LGF8ZCx6fGYsYXx6LGN8ZSxifGUsenx6LHp8ZSxhfGQsY3xmLGJ8ZSxifGQsenxlLHp8eixjfGQsXG4gICAgICAgICAgICAgYnxmLGF8eixifHosY3xmLHp8ZCxhfGYsYXxlLGJ8ZCxjfHosYnxmLHp8ZixjfHosYXxmLHp8ZCxjfGQsYXxlXTtcbmE9MTw8MTM7IGI9MTw8MjM7IGM9YXxiOyBkPTE8PDA7IGU9MTw8NzsgZj1kfGU7XG5jb25zdCBTUDQgPSBbY3xkLGF8ZixhfGYsenxlLGN8ZSxifGYsYnxkLGF8ZCx6fHosY3x6LGN8eixjfGYsenxmLHp8eixifGUsYnxkLFxuICAgICAgICAgICAgIHp8ZCxhfHosYnx6LGN8ZCx6fGUsYnx6LGF8ZCxhfGUsYnxmLHp8ZCxhfGUsYnxlLGF8eixjfGUsY3xmLHp8ZixcbiAgICAgICAgICAgICBifGUsYnxkLGN8eixjfGYsenxmLHp8eix6fHosY3x6LGF8ZSxifGUsYnxmLHp8ZCxjfGQsYXxmLGF8Zix6fGUsXG4gICAgICAgICAgICAgY3xmLHp8Zix6fGQsYXx6LGJ8ZCxhfGQsY3xlLGJ8ZixhfGQsYXxlLGJ8eixjfGQsenxlLGJ8eixhfHosY3xlXTtcbmE9MTw8MjU7IGI9MTw8MzA7IGM9YXxiOyBkPTE8PDg7IGU9MTw8MTk7IGY9ZHxlO1xuY29uc3QgU1A1ID0gW3p8ZCxhfGYsYXxlLGN8ZCx6fGUsenxkLGJ8eixhfGUsYnxmLHp8ZSxhfGQsYnxmLGN8ZCxjfGUsenxmLGJ8eixcbiAgICAgICAgICAgICBhfHosYnxlLGJ8ZSx6fHosYnxkLGN8ZixjfGYsYXxkLGN8ZSxifGQsenx6LGN8eixhfGYsYXx6LGN8eix6fGYsXG4gICAgICAgICAgICAgenxlLGN8ZCx6fGQsYXx6LGJ8eixhfGUsY3xkLGJ8ZixhfGQsYnx6LGN8ZSxhfGYsYnxmLHp8ZCxhfHosY3xlLFxuICAgICAgICAgICAgIGN8Zix6fGYsY3x6LGN8ZixhfGUsenx6LGJ8ZSxjfHosenxmLGF8ZCxifGQsenxlLHp8eixifGUsYXxmLGJ8ZF07XG5hPTE8PDIyOyBiPTE8PDI5OyBjPWF8YjsgZD0xPDw0OyBlPTE8PDE0OyBmPWR8ZTtcbmNvbnN0IFNQNiA9IFtifGQsY3x6LHp8ZSxjfGYsY3x6LHp8ZCxjfGYsYXx6LGJ8ZSxhfGYsYXx6LGJ8ZCxhfGQsYnxlLGJ8eix6fGYsXG4gICAgICAgICAgICAgenx6LGF8ZCxifGYsenxlLGF8ZSxifGYsenxkLGN8ZCxjfGQsenx6LGF8ZixjfGUsenxmLGF8ZSxjfGUsYnx6LFxuICAgICAgICAgICAgIGJ8ZSx6fGQsY3xkLGF8ZSxjfGYsYXx6LHp8ZixifGQsYXx6LGJ8ZSxifHosenxmLGJ8ZCxjfGYsYXxlLGN8eixcbiAgICAgICAgICAgICBhfGYsY3xlLHp8eixjfGQsenxkLHp8ZSxjfHosYXxmLHp8ZSxhfGQsYnxmLHp8eixjfGUsYnx6LGF8ZCxifGZdO1xuYT0xPDwyMTsgYj0xPDwyNjsgYz1hfGI7IGQ9MTw8MTsgZT0xPDwxMTsgZj1kfGU7XG5jb25zdCBTUDcgPSBbYXx6LGN8ZCxifGYsenx6LHp8ZSxifGYsYXxmLGN8ZSxjfGYsYXx6LHp8eixifGQsenxkLGJ8eixjfGQsenxmLFxuICAgICAgICAgICAgIGJ8ZSxhfGYsYXxkLGJ8ZSxifGQsY3x6LGN8ZSxhfGQsY3x6LHp8ZSx6fGYsY3xmLGF8ZSx6fGQsYnx6LGF8ZSxcbiAgICAgICAgICAgICBifHosYXxlLGF8eixifGYsYnxmLGN8ZCxjfGQsenxkLGF8ZCxifHosYnxlLGF8eixjfGUsenxmLGF8ZixjfGUsXG4gICAgICAgICAgICAgenxmLGJ8ZCxjfGYsY3x6LGF8ZSx6fHosenxkLGN8Zix6fHosYXxmLGN8eix6fGUsYnxkLGJ8ZSx6fGUsYXxkXTtcbmE9MTw8MTg7IGI9MTw8Mjg7IGM9YXxiOyBkPTE8PDY7IGU9MTw8MTI7IGY9ZHxlO1xuY29uc3QgU1A4ID0gW2J8Zix6fGUsYXx6LGN8ZixifHosYnxmLHp8ZCxifHosYXxkLGN8eixjfGYsYXxlLGN8ZSxhfGYsenxlLHp8ZCxcbiAgICAgICAgICAgICBjfHosYnxkLGJ8ZSx6fGYsYXxlLGF8ZCxjfGQsY3xlLHp8Zix6fHosenx6LGN8ZCxifGQsYnxlLGF8ZixhfHosXG4gICAgICAgICAgICAgYXxmLGF8eixjfGUsenxlLHp8ZCxjfGQsenxlLGF8ZixifGUsenxkLGJ8ZCxjfHosY3xkLGJ8eixhfHosYnxmLFxuICAgICAgICAgICAgIHp8eixjfGYsYXxkLGJ8ZCxjfHosYnxlLGJ8Zix6fHosY3xmLGF8ZSxhfGUsenxmLHp8ZixhfGQsYnx6LGN8ZV07XG5cbi8qIGVzbGludC1lbmFibGUgY29tbWEtc3BhY2luZyAqL1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBERVMge1xuICAgIGNvbnN0cnVjdG9yKHBhc3N3b3JkKSB7XG4gICAgICAgIHRoaXMua2V5cyA9IFtdO1xuXG4gICAgICAgIC8vIFNldCB0aGUga2V5LlxuICAgICAgICBjb25zdCBwYzFtID0gW10sIHBjciA9IFtdLCBrbiA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwLCBsID0gNTY7IGogPCA1NjsgKytqLCBsIC09IDgpIHtcbiAgICAgICAgICAgIGwgKz0gbCA8IC01ID8gNjUgOiBsIDwgLTMgPyAzMSA6IGwgPCAtMSA/IDYzIDogbCA9PT0gMjcgPyAzNSA6IDA7IC8vIFBDMVxuICAgICAgICAgICAgY29uc3QgbSA9IGwgJiAweDc7XG4gICAgICAgICAgICBwYzFtW2pdID0gKChwYXNzd29yZFtsID4+PiAzXSAmICgxPDxtKSkgIT09IDApID8gMTogMDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgbSA9IGkgPDwgMTtcbiAgICAgICAgICAgIGNvbnN0IG4gPSBtICsgMTtcbiAgICAgICAgICAgIGtuW21dID0ga25bbl0gPSAwO1xuICAgICAgICAgICAgZm9yIChsZXQgbyA9IDI4OyBvIDwgNTk7IG8gKz0gMjgpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gbyAtIDI4OyBqIDwgbzsgKytqKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGwgPSBqICsgdG90cm90W2ldO1xuICAgICAgICAgICAgICAgICAgICBwY3Jbal0gPSBsIDwgbyA/IHBjMW1bbF0gOiBwYzFtW2wgLSAyOF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCAyNDsgKytqKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBjcltQQzJbal1dICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGtuW21dIHw9IDEgPDwgKDIzIC0gaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwY3JbUEMyW2ogKyAyNF1dICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGtuW25dIHw9IDEgPDwgKDIzIC0gaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29va2V5XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCByYXdpID0gMCwgS25MaSA9IDA7IGkgPCAxNjsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCByYXcwID0ga25bcmF3aSsrXTtcbiAgICAgICAgICAgIGNvbnN0IHJhdzEgPSBrbltyYXdpKytdO1xuICAgICAgICAgICAgdGhpcy5rZXlzW0tuTGldID0gKHJhdzAgJiAweDAwZmMwMDAwKSA8PCA2O1xuICAgICAgICAgICAgdGhpcy5rZXlzW0tuTGldIHw9IChyYXcwICYgMHgwMDAwMGZjMCkgPDwgMTA7XG4gICAgICAgICAgICB0aGlzLmtleXNbS25MaV0gfD0gKHJhdzEgJiAweDAwZmMwMDAwKSA+Pj4gMTA7XG4gICAgICAgICAgICB0aGlzLmtleXNbS25MaV0gfD0gKHJhdzEgJiAweDAwMDAwZmMwKSA+Pj4gNjtcbiAgICAgICAgICAgICsrS25MaTtcbiAgICAgICAgICAgIHRoaXMua2V5c1tLbkxpXSA9IChyYXcwICYgMHgwMDAzZjAwMCkgPDwgMTI7XG4gICAgICAgICAgICB0aGlzLmtleXNbS25MaV0gfD0gKHJhdzAgJiAweDAwMDAwMDNmKSA8PCAxNjtcbiAgICAgICAgICAgIHRoaXMua2V5c1tLbkxpXSB8PSAocmF3MSAmIDB4MDAwM2YwMDApID4+PiA0O1xuICAgICAgICAgICAgdGhpcy5rZXlzW0tuTGldIHw9IChyYXcxICYgMHgwMDAwMDAzZik7XG4gICAgICAgICAgICArK0tuTGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBFbmNyeXB0IDggYnl0ZXMgb2YgdGV4dFxuICAgIGVuYzgodGV4dCkge1xuICAgICAgICBjb25zdCBiID0gdGV4dC5zbGljZSgpO1xuICAgICAgICBsZXQgaSA9IDAsIGwsIHIsIHg7IC8vIGxlZnQsIHJpZ2h0LCBhY2N1bXVsYXRvclxuXG4gICAgICAgIC8vIFNxdWFzaCA4IGJ5dGVzIHRvIDIgaW50c1xuICAgICAgICBsID0gYltpKytdPDwyNCB8IGJbaSsrXTw8MTYgfCBiW2krK108PDggfCBiW2krK107XG4gICAgICAgIHIgPSBiW2krK108PDI0IHwgYltpKytdPDwxNiB8IGJbaSsrXTw8OCB8IGJbaSsrXTtcblxuICAgICAgICB4ID0gKChsID4+PiA0KSBeIHIpICYgMHgwZjBmMGYwZjtcbiAgICAgICAgciBePSB4O1xuICAgICAgICBsIF49ICh4IDw8IDQpO1xuICAgICAgICB4ID0gKChsID4+PiAxNikgXiByKSAmIDB4MDAwMGZmZmY7XG4gICAgICAgIHIgXj0geDtcbiAgICAgICAgbCBePSAoeCA8PCAxNik7XG4gICAgICAgIHggPSAoKHIgPj4+IDIpIF4gbCkgJiAweDMzMzMzMzMzO1xuICAgICAgICBsIF49IHg7XG4gICAgICAgIHIgXj0gKHggPDwgMik7XG4gICAgICAgIHggPSAoKHIgPj4+IDgpIF4gbCkgJiAweDAwZmYwMGZmO1xuICAgICAgICBsIF49IHg7XG4gICAgICAgIHIgXj0gKHggPDwgOCk7XG4gICAgICAgIHIgPSAociA8PCAxKSB8ICgociA+Pj4gMzEpICYgMSk7XG4gICAgICAgIHggPSAobCBeIHIpICYgMHhhYWFhYWFhYTtcbiAgICAgICAgbCBePSB4O1xuICAgICAgICByIF49IHg7XG4gICAgICAgIGwgPSAobCA8PCAxKSB8ICgobCA+Pj4gMzEpICYgMSk7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGtleXNpID0gMDsgaSA8IDg7ICsraSkge1xuICAgICAgICAgICAgeCA9IChyIDw8IDI4KSB8IChyID4+PiA0KTtcbiAgICAgICAgICAgIHggXj0gdGhpcy5rZXlzW2tleXNpKytdO1xuICAgICAgICAgICAgbGV0IGZ2YWwgPSAgU1A3W3ggJiAweDNmXTtcbiAgICAgICAgICAgIGZ2YWwgfD0gU1A1Wyh4ID4+PiA4KSAmIDB4M2ZdO1xuICAgICAgICAgICAgZnZhbCB8PSBTUDNbKHggPj4+IDE2KSAmIDB4M2ZdO1xuICAgICAgICAgICAgZnZhbCB8PSBTUDFbKHggPj4+IDI0KSAmIDB4M2ZdO1xuICAgICAgICAgICAgeCA9IHIgXiB0aGlzLmtleXNba2V5c2krK107XG4gICAgICAgICAgICBmdmFsIHw9IFNQOFt4ICYgMHgzZl07XG4gICAgICAgICAgICBmdmFsIHw9IFNQNlsoeCA+Pj4gOCkgJiAweDNmXTtcbiAgICAgICAgICAgIGZ2YWwgfD0gU1A0Wyh4ID4+PiAxNikgJiAweDNmXTtcbiAgICAgICAgICAgIGZ2YWwgfD0gU1AyWyh4ID4+PiAyNCkgJiAweDNmXTtcbiAgICAgICAgICAgIGwgXj0gZnZhbDtcbiAgICAgICAgICAgIHggPSAobCA8PCAyOCkgfCAobCA+Pj4gNCk7XG4gICAgICAgICAgICB4IF49IHRoaXMua2V5c1trZXlzaSsrXTtcbiAgICAgICAgICAgIGZ2YWwgPSAgU1A3W3ggJiAweDNmXTtcbiAgICAgICAgICAgIGZ2YWwgfD0gU1A1Wyh4ID4+PiA4KSAmIDB4M2ZdO1xuICAgICAgICAgICAgZnZhbCB8PSBTUDNbKHggPj4+IDE2KSAmIDB4M2ZdO1xuICAgICAgICAgICAgZnZhbCB8PSBTUDFbKHggPj4+IDI0KSAmIDB4M2ZdO1xuICAgICAgICAgICAgeCA9IGwgXiB0aGlzLmtleXNba2V5c2krK107XG4gICAgICAgICAgICBmdmFsIHw9IFNQOFt4ICYgMHgwMDAwMDAzZl07XG4gICAgICAgICAgICBmdmFsIHw9IFNQNlsoeCA+Pj4gOCkgJiAweDNmXTtcbiAgICAgICAgICAgIGZ2YWwgfD0gU1A0Wyh4ID4+PiAxNikgJiAweDNmXTtcbiAgICAgICAgICAgIGZ2YWwgfD0gU1AyWyh4ID4+PiAyNCkgJiAweDNmXTtcbiAgICAgICAgICAgIHIgXj0gZnZhbDtcbiAgICAgICAgfVxuXG4gICAgICAgIHIgPSAociA8PCAzMSkgfCAociA+Pj4gMSk7XG4gICAgICAgIHggPSAobCBeIHIpICYgMHhhYWFhYWFhYTtcbiAgICAgICAgbCBePSB4O1xuICAgICAgICByIF49IHg7XG4gICAgICAgIGwgPSAobCA8PCAzMSkgfCAobCA+Pj4gMSk7XG4gICAgICAgIHggPSAoKGwgPj4+IDgpIF4gcikgJiAweDAwZmYwMGZmO1xuICAgICAgICByIF49IHg7XG4gICAgICAgIGwgXj0gKHggPDwgOCk7XG4gICAgICAgIHggPSAoKGwgPj4+IDIpIF4gcikgJiAweDMzMzMzMzMzO1xuICAgICAgICByIF49IHg7XG4gICAgICAgIGwgXj0gKHggPDwgMik7XG4gICAgICAgIHggPSAoKHIgPj4+IDE2KSBeIGwpICYgMHgwMDAwZmZmZjtcbiAgICAgICAgbCBePSB4O1xuICAgICAgICByIF49ICh4IDw8IDE2KTtcbiAgICAgICAgeCA9ICgociA+Pj4gNCkgXiBsKSAmIDB4MGYwZjBmMGY7XG4gICAgICAgIGwgXj0geDtcbiAgICAgICAgciBePSAoeCA8PCA0KTtcblxuICAgICAgICAvLyBTcHJlYWQgaW50cyB0byBieXRlc1xuICAgICAgICB4ID0gW3IsIGxdO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgODsgaSsrKSB7XG4gICAgICAgICAgICBiW2ldID0gKHhbaT4+PjJdID4+PiAoOCAqICgzIC0gKGkgJSA0KSkpKSAlIDI1NjtcbiAgICAgICAgICAgIGlmIChiW2ldIDwgMCkgeyBiW2ldICs9IDI1NjsgfSAvLyB1bnNpZ25lZFxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiO1xuICAgIH1cblxuICAgIC8vIEVuY3J5cHQgMTYgYnl0ZXMgb2YgdGV4dCB1c2luZyBwYXNzd2QgYXMga2V5XG4gICAgZW5jcnlwdCh0KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuYzgodC5zbGljZSgwLCA4KSkuY29uY2F0KHRoaXMuZW5jOCh0LnNsaWNlKDgsIDE2KSkpO1xuICAgIH1cbn1cbiIsIi8qXG4gKiBub1ZOQzogSFRNTDUgVk5DIGNsaWVudFxuICogQ29weXJpZ2h0IChDKSAyMDE4IFRoZSBub1ZOQyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciBNUEwgMi4wIChzZWUgTElDRU5TRS50eHQpXG4gKlxuICogU2VlIFJFQURNRS5tZCBmb3IgdXNhZ2UgYW5kIGludGVncmF0aW9uIGluc3RydWN0aW9ucy5cbiAqL1xuXG5pbXBvcnQgKiBhcyBMb2cgZnJvbSAnLi91dGlsL2xvZ2dpbmcuanMnO1xuaW1wb3J0IEJhc2U2NCBmcm9tIFwiLi9iYXNlNjQuanNcIjtcbmltcG9ydCB7IHN1cHBvcnRzSW1hZ2VNZXRhZGF0YSB9IGZyb20gJy4vdXRpbC9icm93c2VyLmpzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRGlzcGxheSB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX2RyYXdDdHggPSBudWxsO1xuICAgICAgICB0aGlzLl9jX2ZvcmNlQ2FudmFzID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fcmVuZGVyUSA9IFtdOyAgLy8gcXVldWUgZHJhd2luZyBhY3Rpb25zIGZvciBpbi1vZGVyIHJlbmRlcmluZ1xuICAgICAgICB0aGlzLl9mbHVzaGluZyA9IGZhbHNlO1xuXG4gICAgICAgIC8vIHRoZSBmdWxsIGZyYW1lIGJ1ZmZlciAobG9naWNhbCBjYW52YXMpIHNpemVcbiAgICAgICAgdGhpcy5fZmJfd2lkdGggPSAwO1xuICAgICAgICB0aGlzLl9mYl9oZWlnaHQgPSAwO1xuXG4gICAgICAgIHRoaXMuX3ByZXZEcmF3U3R5bGUgPSBcIlwiO1xuICAgICAgICB0aGlzLl90aWxlID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGlsZTE2eDE2ID0gbnVsbDtcbiAgICAgICAgdGhpcy5fdGlsZV94ID0gMDtcbiAgICAgICAgdGhpcy5fdGlsZV95ID0gMDtcblxuICAgICAgICBMb2cuRGVidWcoXCI+PiBEaXNwbGF5LmNvbnN0cnVjdG9yXCIpO1xuXG4gICAgICAgIC8vIFRoZSB2aXNpYmxlIGNhbnZhc1xuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgICAgaWYgKCF0aGlzLl90YXJnZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRhcmdldCBtdXN0IGJlIHNldFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5fdGFyZ2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0YXJnZXQgbXVzdCBiZSBhIERPTSBlbGVtZW50Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIXRoaXMuX3RhcmdldC5nZXRDb250ZXh0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBnZXRDb250ZXh0IG1ldGhvZFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RhcmdldEN0eCA9IHRoaXMuX3RhcmdldC5nZXRDb250ZXh0KCcyZCcpO1xuXG4gICAgICAgIC8vIHRoZSB2aXNpYmxlIGNhbnZhcyB2aWV3cG9ydCAoaS5lLiB3aGF0IGFjdHVhbGx5IGdldHMgc2VlbilcbiAgICAgICAgdGhpcy5fdmlld3BvcnRMb2MgPSB7ICd4JzogMCwgJ3knOiAwLCAndyc6IHRoaXMuX3RhcmdldC53aWR0aCwgJ2gnOiB0aGlzLl90YXJnZXQuaGVpZ2h0IH07XG5cbiAgICAgICAgLy8gVGhlIGhpZGRlbiBjYW52YXMsIHdoZXJlIHdlIGRvIHRoZSBhY3R1YWwgcmVuZGVyaW5nXG4gICAgICAgIHRoaXMuX2JhY2tidWZmZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgdGhpcy5fZHJhd0N0eCA9IHRoaXMuX2JhY2tidWZmZXIuZ2V0Q29udGV4dCgnMmQnKTtcblxuICAgICAgICB0aGlzLl9kYW1hZ2VCb3VuZHMgPSB7IGxlZnQ6IDAsIHRvcDogMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByaWdodDogdGhpcy5fYmFja2J1ZmZlci53aWR0aCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3R0b206IHRoaXMuX2JhY2tidWZmZXIuaGVpZ2h0IH07XG5cbiAgICAgICAgTG9nLkRlYnVnKFwiVXNlciBBZ2VudDogXCIgKyBuYXZpZ2F0b3IudXNlckFnZW50KTtcblxuICAgICAgICB0aGlzLmNsZWFyKCk7XG5cbiAgICAgICAgLy8gQ2hlY2sgY2FudmFzIGZlYXR1cmVzXG4gICAgICAgIGlmICghKCdjcmVhdGVJbWFnZURhdGEnIGluIHRoaXMuX2RyYXdDdHgpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgZG9lcyBub3Qgc3VwcG9ydCBjcmVhdGVJbWFnZURhdGFcIik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90aWxlMTZ4MTYgPSB0aGlzLl9kcmF3Q3R4LmNyZWF0ZUltYWdlRGF0YSgxNiwgMTYpO1xuICAgICAgICBMb2cuRGVidWcoXCI8PCBEaXNwbGF5LmNvbnN0cnVjdG9yXCIpO1xuXG4gICAgICAgIC8vID09PT09IFBST1BFUlRJRVMgPT09PT1cblxuICAgICAgICB0aGlzLl9zY2FsZSA9IDEuMDtcbiAgICAgICAgdGhpcy5fY2xpcFZpZXdwb3J0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMubG9nbyA9IG51bGw7XG5cbiAgICAgICAgLy8gPT09PT0gRVZFTlQgSEFORExFUlMgPT09PT1cblxuICAgICAgICB0aGlzLm9uZmx1c2ggPSAoKSA9PiB7fTsgLy8gQSBmbHVzaCByZXF1ZXN0IGhhcyBmaW5pc2hlZFxuICAgIH1cblxuICAgIC8vID09PT09IFBST1BFUlRJRVMgPT09PT1cblxuICAgIGdldCBzY2FsZSgpIHsgcmV0dXJuIHRoaXMuX3NjYWxlOyB9XG4gICAgc2V0IHNjYWxlKHNjYWxlKSB7XG4gICAgICAgIHRoaXMuX3Jlc2NhbGUoc2NhbGUpO1xuICAgIH1cblxuICAgIGdldCBjbGlwVmlld3BvcnQoKSB7IHJldHVybiB0aGlzLl9jbGlwVmlld3BvcnQ7IH1cbiAgICBzZXQgY2xpcFZpZXdwb3J0KHZpZXdwb3J0KSB7XG4gICAgICAgIHRoaXMuX2NsaXBWaWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgICAgICAvLyBNYXkgbmVlZCB0byByZWFkanVzdCB0aGUgdmlld3BvcnQgZGltZW5zaW9uc1xuICAgICAgICBjb25zdCB2cCA9IHRoaXMuX3ZpZXdwb3J0TG9jO1xuICAgICAgICB0aGlzLnZpZXdwb3J0Q2hhbmdlU2l6ZSh2cC53LCB2cC5oKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydENoYW5nZVBvcygwLCAwKTtcbiAgICB9XG5cbiAgICBnZXQgd2lkdGgoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9mYl93aWR0aDtcbiAgICB9XG5cbiAgICBnZXQgaGVpZ2h0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmJfaGVpZ2h0O1xuICAgIH1cblxuICAgIC8vID09PT09IFBVQkxJQyBNRVRIT0RTID09PT09XG5cbiAgICB2aWV3cG9ydENoYW5nZVBvcyhkZWx0YVgsIGRlbHRhWSkge1xuICAgICAgICBjb25zdCB2cCA9IHRoaXMuX3ZpZXdwb3J0TG9jO1xuICAgICAgICBkZWx0YVggPSBNYXRoLmZsb29yKGRlbHRhWCk7XG4gICAgICAgIGRlbHRhWSA9IE1hdGguZmxvb3IoZGVsdGFZKTtcblxuICAgICAgICBpZiAoIXRoaXMuX2NsaXBWaWV3cG9ydCkge1xuICAgICAgICAgICAgZGVsdGFYID0gLXZwLnc7ICAvLyBjbGFtcGVkIGxhdGVyIG9mIG91dCBvZiBib3VuZHNcbiAgICAgICAgICAgIGRlbHRhWSA9IC12cC5oO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgdngyID0gdnAueCArIHZwLncgLSAxO1xuICAgICAgICBjb25zdCB2eTIgPSB2cC55ICsgdnAuaCAtIDE7XG5cbiAgICAgICAgLy8gUG9zaXRpb24gY2hhbmdlXG5cbiAgICAgICAgaWYgKGRlbHRhWCA8IDAgJiYgdnAueCArIGRlbHRhWCA8IDApIHtcbiAgICAgICAgICAgIGRlbHRhWCA9IC12cC54O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2eDIgKyBkZWx0YVggPj0gdGhpcy5fZmJfd2lkdGgpIHtcbiAgICAgICAgICAgIGRlbHRhWCAtPSB2eDIgKyBkZWx0YVggLSB0aGlzLl9mYl93aWR0aCArIDE7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodnAueSArIGRlbHRhWSA8IDApIHtcbiAgICAgICAgICAgIGRlbHRhWSA9IC12cC55O1xuICAgICAgICB9XG4gICAgICAgIGlmICh2eTIgKyBkZWx0YVkgPj0gdGhpcy5fZmJfaGVpZ2h0KSB7XG4gICAgICAgICAgICBkZWx0YVkgLT0gKHZ5MiArIGRlbHRhWSAtIHRoaXMuX2ZiX2hlaWdodCArIDEpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGRlbHRhWCA9PT0gMCAmJiBkZWx0YVkgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBMb2cuRGVidWcoXCJ2aWV3cG9ydENoYW5nZSBkZWx0YVg6IFwiICsgZGVsdGFYICsgXCIsIGRlbHRhWTogXCIgKyBkZWx0YVkpO1xuXG4gICAgICAgIHZwLnggKz0gZGVsdGFYO1xuICAgICAgICB2cC55ICs9IGRlbHRhWTtcblxuICAgICAgICB0aGlzLl9kYW1hZ2UodnAueCwgdnAueSwgdnAudywgdnAuaCk7XG5cbiAgICAgICAgdGhpcy5mbGlwKCk7XG4gICAgfVxuXG4gICAgdmlld3BvcnRDaGFuZ2VTaXplKHdpZHRoLCBoZWlnaHQpIHtcblxuICAgICAgICBpZiAoIXRoaXMuX2NsaXBWaWV3cG9ydCB8fFxuICAgICAgICAgICAgdHlwZW9mKHdpZHRoKSA9PT0gXCJ1bmRlZmluZWRcIiB8fFxuICAgICAgICAgICAgdHlwZW9mKGhlaWdodCkgPT09IFwidW5kZWZpbmVkXCIpIHtcblxuICAgICAgICAgICAgTG9nLkRlYnVnKFwiU2V0dGluZyB2aWV3cG9ydCB0byBmdWxsIGRpc3BsYXkgcmVnaW9uXCIpO1xuICAgICAgICAgICAgd2lkdGggPSB0aGlzLl9mYl93aWR0aDtcbiAgICAgICAgICAgIGhlaWdodCA9IHRoaXMuX2ZiX2hlaWdodDtcbiAgICAgICAgfVxuXG4gICAgICAgIHdpZHRoID0gTWF0aC5mbG9vcih3aWR0aCk7XG4gICAgICAgIGhlaWdodCA9IE1hdGguZmxvb3IoaGVpZ2h0KTtcblxuICAgICAgICBpZiAod2lkdGggPiB0aGlzLl9mYl93aWR0aCkge1xuICAgICAgICAgICAgd2lkdGggPSB0aGlzLl9mYl93aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVpZ2h0ID4gdGhpcy5fZmJfaGVpZ2h0KSB7XG4gICAgICAgICAgICBoZWlnaHQgPSB0aGlzLl9mYl9oZWlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB2cCA9IHRoaXMuX3ZpZXdwb3J0TG9jO1xuICAgICAgICBpZiAodnAudyAhPT0gd2lkdGggfHwgdnAuaCAhPT0gaGVpZ2h0KSB7XG4gICAgICAgICAgICB2cC53ID0gd2lkdGg7XG4gICAgICAgICAgICB2cC5oID0gaGVpZ2h0O1xuXG4gICAgICAgICAgICBjb25zdCBjYW52YXMgPSB0aGlzLl90YXJnZXQ7XG4gICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgICAgIC8vIFRoZSBwb3NpdGlvbiBtaWdodCBuZWVkIHRvIGJlIHVwZGF0ZWQgaWYgd2UndmUgZ3Jvd25cbiAgICAgICAgICAgIHRoaXMudmlld3BvcnRDaGFuZ2VQb3MoMCwgMCk7XG5cbiAgICAgICAgICAgIHRoaXMuX2RhbWFnZSh2cC54LCB2cC55LCB2cC53LCB2cC5oKTtcbiAgICAgICAgICAgIHRoaXMuZmxpcCgpO1xuXG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIHZpc2libGUgc2l6ZSBvZiB0aGUgdGFyZ2V0IGNhbnZhc1xuICAgICAgICAgICAgdGhpcy5fcmVzY2FsZSh0aGlzLl9zY2FsZSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBhYnNYKHgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NjYWxlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geCAvIHRoaXMuX3NjYWxlICsgdGhpcy5fdmlld3BvcnRMb2MueDtcbiAgICB9XG5cbiAgICBhYnNZKHkpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NjYWxlID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geSAvIHRoaXMuX3NjYWxlICsgdGhpcy5fdmlld3BvcnRMb2MueTtcbiAgICB9XG5cbiAgICByZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLl9wcmV2RHJhd1N0eWxlID0gXCJcIjtcblxuICAgICAgICB0aGlzLl9mYl93aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9mYl9oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgY29uc3QgY2FudmFzID0gdGhpcy5fYmFja2J1ZmZlcjtcbiAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gd2lkdGggfHwgY2FudmFzLmhlaWdodCAhPT0gaGVpZ2h0KSB7XG5cbiAgICAgICAgICAgIC8vIFdlIGhhdmUgdG8gc2F2ZSB0aGUgY2FudmFzIGRhdGEgc2luY2UgY2hhbmdpbmcgdGhlIHNpemUgd2lsbCBjbGVhciBpdFxuICAgICAgICAgICAgbGV0IHNhdmVJbWcgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGNhbnZhcy53aWR0aCA+IDAgJiYgY2FudmFzLmhlaWdodCA+IDApIHtcbiAgICAgICAgICAgICAgICBzYXZlSW1nID0gdGhpcy5fZHJhd0N0eC5nZXRJbWFnZURhdGEoMCwgMCwgY2FudmFzLndpZHRoLCBjYW52YXMuaGVpZ2h0KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKGNhbnZhcy53aWR0aCAhPT0gd2lkdGgpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjYW52YXMuaGVpZ2h0ICE9PSBoZWlnaHQpIHtcbiAgICAgICAgICAgICAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoc2F2ZUltZykge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RyYXdDdHgucHV0SW1hZ2VEYXRhKHNhdmVJbWcsIDAsIDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUmVhZGp1c3QgdGhlIHZpZXdwb3J0IGFzIGl0IG1heSBiZSBpbmNvcnJlY3RseSBzaXplZFxuICAgICAgICAvLyBhbmQgcG9zaXRpb25lZFxuICAgICAgICBjb25zdCB2cCA9IHRoaXMuX3ZpZXdwb3J0TG9jO1xuICAgICAgICB0aGlzLnZpZXdwb3J0Q2hhbmdlU2l6ZSh2cC53LCB2cC5oKTtcbiAgICAgICAgdGhpcy52aWV3cG9ydENoYW5nZVBvcygwLCAwKTtcbiAgICB9XG5cbiAgICAvLyBUcmFjayB3aGF0IHBhcnRzIG9mIHRoZSB2aXNpYmxlIGNhbnZhcyB0aGF0IG5lZWQgdXBkYXRpbmdcbiAgICBfZGFtYWdlKHgsIHksIHcsIGgpIHtcbiAgICAgICAgaWYgKHggPCB0aGlzLl9kYW1hZ2VCb3VuZHMubGVmdCkge1xuICAgICAgICAgICAgdGhpcy5fZGFtYWdlQm91bmRzLmxlZnQgPSB4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh5IDwgdGhpcy5fZGFtYWdlQm91bmRzLnRvcCkge1xuICAgICAgICAgICAgdGhpcy5fZGFtYWdlQm91bmRzLnRvcCA9IHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCh4ICsgdykgPiB0aGlzLl9kYW1hZ2VCb3VuZHMucmlnaHQpIHtcbiAgICAgICAgICAgIHRoaXMuX2RhbWFnZUJvdW5kcy5yaWdodCA9IHggKyB3O1xuICAgICAgICB9XG4gICAgICAgIGlmICgoeSArIGgpID4gdGhpcy5fZGFtYWdlQm91bmRzLmJvdHRvbSkge1xuICAgICAgICAgICAgdGhpcy5fZGFtYWdlQm91bmRzLmJvdHRvbSA9IHkgKyBoO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHRoZSB2aXNpYmxlIGNhbnZhcyB3aXRoIHRoZSBjb250ZW50cyBvZiB0aGVcbiAgICAvLyByZW5kZXJpbmcgY2FudmFzXG4gICAgZmxpcChmcm9tX3F1ZXVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJRLmxlbmd0aCAhPT0gMCAmJiAhZnJvbV9xdWV1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyUV9wdXNoKHtcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdmbGlwJ1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZXQgeCA9IHRoaXMuX2RhbWFnZUJvdW5kcy5sZWZ0O1xuICAgICAgICAgICAgbGV0IHkgPSB0aGlzLl9kYW1hZ2VCb3VuZHMudG9wO1xuICAgICAgICAgICAgbGV0IHcgPSB0aGlzLl9kYW1hZ2VCb3VuZHMucmlnaHQgLSB4O1xuICAgICAgICAgICAgbGV0IGggPSB0aGlzLl9kYW1hZ2VCb3VuZHMuYm90dG9tIC0geTtcblxuICAgICAgICAgICAgbGV0IHZ4ID0geCAtIHRoaXMuX3ZpZXdwb3J0TG9jLng7XG4gICAgICAgICAgICBsZXQgdnkgPSB5IC0gdGhpcy5fdmlld3BvcnRMb2MueTtcblxuICAgICAgICAgICAgaWYgKHZ4IDwgMCkge1xuICAgICAgICAgICAgICAgIHcgKz0gdng7XG4gICAgICAgICAgICAgICAgeCAtPSB2eDtcbiAgICAgICAgICAgICAgICB2eCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodnkgPCAwKSB7XG4gICAgICAgICAgICAgICAgaCArPSB2eTtcbiAgICAgICAgICAgICAgICB5IC09IHZ5O1xuICAgICAgICAgICAgICAgIHZ5ID0gMDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCh2eCArIHcpID4gdGhpcy5fdmlld3BvcnRMb2Mudykge1xuICAgICAgICAgICAgICAgIHcgPSB0aGlzLl92aWV3cG9ydExvYy53IC0gdng7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHZ5ICsgaCkgPiB0aGlzLl92aWV3cG9ydExvYy5oKSB7XG4gICAgICAgICAgICAgICAgaCA9IHRoaXMuX3ZpZXdwb3J0TG9jLmggLSB2eTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCh3ID4gMCkgJiYgKGggPiAwKSkge1xuICAgICAgICAgICAgICAgIC8vIEZJWE1FOiBXZSBtYXkgbmVlZCB0byBkaXNhYmxlIGltYWdlIHNtb290aGluZyBoZXJlXG4gICAgICAgICAgICAgICAgLy8gICAgICAgIGFzIHdlbGwgKHNlZSBjb3B5SW1hZ2UoKSksIGJ1dCB3ZSBoYXZlbid0XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIG5vdGljZWQgYW55IHByb2JsZW0geWV0LlxuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldEN0eC5kcmF3SW1hZ2UodGhpcy5fYmFja2J1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgsIHksIHcsIGgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2eCwgdnksIHcsIGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9kYW1hZ2VCb3VuZHMubGVmdCA9IHRoaXMuX2RhbWFnZUJvdW5kcy50b3AgPSA2NTUzNTtcbiAgICAgICAgICAgIHRoaXMuX2RhbWFnZUJvdW5kcy5yaWdodCA9IHRoaXMuX2RhbWFnZUJvdW5kcy5ib3R0b20gPSAwO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIGlmICh0aGlzLl9sb2dvKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSh0aGlzLl9sb2dvLndpZHRoLCB0aGlzLl9sb2dvLmhlaWdodCk7XG4gICAgICAgICAgICB0aGlzLmltYWdlUmVjdCgwLCAwLCB0aGlzLl9sb2dvLnR5cGUsIHRoaXMuX2xvZ28uZGF0YSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnJlc2l6ZSgyNDAsIDIwKTtcbiAgICAgICAgICAgIHRoaXMuX2RyYXdDdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuX2ZiX3dpZHRoLCB0aGlzLl9mYl9oZWlnaHQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmxpcCgpO1xuICAgIH1cblxuICAgIHBlbmRpbmcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJRLmxlbmd0aCA+IDA7XG4gICAgfVxuXG4gICAgZmx1c2goKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJRLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5vbmZsdXNoKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9mbHVzaGluZyA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmaWxsUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvciwgZnJvbV9xdWV1ZSkge1xuICAgICAgICBpZiAodGhpcy5fcmVuZGVyUS5sZW5ndGggIT09IDAgJiYgIWZyb21fcXVldWUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclFfcHVzaCh7XG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnZmlsbCcsXG4gICAgICAgICAgICAgICAgJ3gnOiB4LFxuICAgICAgICAgICAgICAgICd5JzogeSxcbiAgICAgICAgICAgICAgICAnd2lkdGgnOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAnaGVpZ2h0JzogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICdjb2xvcic6IGNvbG9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldEZpbGxDb2xvcihjb2xvcik7XG4gICAgICAgICAgICB0aGlzLl9kcmF3Q3R4LmZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICAgICAgdGhpcy5fZGFtYWdlKHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29weUltYWdlKG9sZF94LCBvbGRfeSwgbmV3X3gsIG5ld195LCB3LCBoLCBmcm9tX3F1ZXVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJRLmxlbmd0aCAhPT0gMCAmJiAhZnJvbV9xdWV1ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyUV9wdXNoKHtcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdjb3B5JyxcbiAgICAgICAgICAgICAgICAnb2xkX3gnOiBvbGRfeCxcbiAgICAgICAgICAgICAgICAnb2xkX3knOiBvbGRfeSxcbiAgICAgICAgICAgICAgICAneCc6IG5ld194LFxuICAgICAgICAgICAgICAgICd5JzogbmV3X3ksXG4gICAgICAgICAgICAgICAgJ3dpZHRoJzogdyxcbiAgICAgICAgICAgICAgICAnaGVpZ2h0JzogaCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRHVlIHRvIHRoaXMgYnVnIGFtb25nIG90aGVycyBbMV0gd2UgbmVlZCB0byBkaXNhYmxlIHRoZSBpbWFnZS1zbW9vdGhpbmcgdG9cbiAgICAgICAgICAgIC8vIGF2b2lkIGdldHRpbmcgYSBibHVyIGVmZmVjdCB3aGVuIGNvcHlpbmcgZGF0YS5cbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyAxLiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0xMTk0NzE5XG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBzZXQgdGhlc2UgZXZlcnkgdGltZSBzaW5jZSBhbGwgcHJvcGVydGllcyBhcmUgcmVzZXRcbiAgICAgICAgICAgIC8vIHdoZW4gdGhlIHRoZSBzaXplIGlzIGNoYW5nZWRcbiAgICAgICAgICAgIHRoaXMuX2RyYXdDdHgubW96SW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLl9kcmF3Q3R4LndlYmtpdEltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZHJhd0N0eC5tc0ltYWdlU21vb3RoaW5nRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZHJhd0N0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcblxuICAgICAgICAgICAgdGhpcy5fZHJhd0N0eC5kcmF3SW1hZ2UodGhpcy5fYmFja2J1ZmZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9sZF94LCBvbGRfeSwgdywgaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld194LCBuZXdfeSwgdywgaCk7XG4gICAgICAgICAgICB0aGlzLl9kYW1hZ2UobmV3X3gsIG5ld195LCB3LCBoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGltYWdlUmVjdCh4LCB5LCBtaW1lLCBhcnIpIHtcbiAgICAgICAgY29uc3QgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgIGltZy5zcmMgPSBcImRhdGE6IFwiICsgbWltZSArIFwiO2Jhc2U2NCxcIiArIEJhc2U2NC5lbmNvZGUoYXJyKTtcbiAgICAgICAgdGhpcy5fcmVuZGVyUV9wdXNoKHtcbiAgICAgICAgICAgICd0eXBlJzogJ2ltZycsXG4gICAgICAgICAgICAnaW1nJzogaW1nLFxuICAgICAgICAgICAgJ3gnOiB4LFxuICAgICAgICAgICAgJ3knOiB5XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8vIHN0YXJ0IHVwZGF0aW5nIGEgdGlsZVxuICAgIHN0YXJ0VGlsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBjb2xvcikge1xuICAgICAgICB0aGlzLl90aWxlX3ggPSB4O1xuICAgICAgICB0aGlzLl90aWxlX3kgPSB5O1xuICAgICAgICBpZiAod2lkdGggPT09IDE2ICYmIGhlaWdodCA9PT0gMTYpIHtcbiAgICAgICAgICAgIHRoaXMuX3RpbGUgPSB0aGlzLl90aWxlMTZ4MTY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl90aWxlID0gdGhpcy5fZHJhd0N0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCByZWQgPSBjb2xvclsyXTtcbiAgICAgICAgY29uc3QgZ3JlZW4gPSBjb2xvclsxXTtcbiAgICAgICAgY29uc3QgYmx1ZSA9IGNvbG9yWzBdO1xuXG4gICAgICAgIGNvbnN0IGRhdGEgPSB0aGlzLl90aWxlLmRhdGE7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2lkdGggKiBoZWlnaHQgKiA0OyBpICs9IDQpIHtcbiAgICAgICAgICAgIGRhdGFbaV0gPSByZWQ7XG4gICAgICAgICAgICBkYXRhW2kgKyAxXSA9IGdyZWVuO1xuICAgICAgICAgICAgZGF0YVtpICsgMl0gPSBibHVlO1xuICAgICAgICAgICAgZGF0YVtpICsgM10gPSAyNTU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB1cGRhdGUgc3ViLXJlY3RhbmdsZSBvZiB0aGUgY3VycmVudCB0aWxlXG4gICAgc3ViVGlsZSh4LCB5LCB3LCBoLCBjb2xvcikge1xuICAgICAgICBjb25zdCByZWQgPSBjb2xvclsyXTtcbiAgICAgICAgY29uc3QgZ3JlZW4gPSBjb2xvclsxXTtcbiAgICAgICAgY29uc3QgYmx1ZSA9IGNvbG9yWzBdO1xuICAgICAgICBjb25zdCB4ZW5kID0geCArIHc7XG4gICAgICAgIGNvbnN0IHllbmQgPSB5ICsgaDtcblxuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5fdGlsZS5kYXRhO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuX3RpbGUud2lkdGg7XG4gICAgICAgIGZvciAobGV0IGogPSB5OyBqIDwgeWVuZDsgaisrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0geDsgaSA8IHhlbmQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHAgPSAoaSArIChqICogd2lkdGgpKSAqIDQ7XG4gICAgICAgICAgICAgICAgZGF0YVtwXSA9IHJlZDtcbiAgICAgICAgICAgICAgICBkYXRhW3AgKyAxXSA9IGdyZWVuO1xuICAgICAgICAgICAgICAgIGRhdGFbcCArIDJdID0gYmx1ZTtcbiAgICAgICAgICAgICAgICBkYXRhW3AgKyAzXSA9IDI1NTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIGRyYXcgdGhlIGN1cnJlbnQgdGlsZSB0byB0aGUgc2NyZWVuXG4gICAgZmluaXNoVGlsZSgpIHtcbiAgICAgICAgdGhpcy5fZHJhd0N0eC5wdXRJbWFnZURhdGEodGhpcy5fdGlsZSwgdGhpcy5fdGlsZV94LCB0aGlzLl90aWxlX3kpO1xuICAgICAgICB0aGlzLl9kYW1hZ2UodGhpcy5fdGlsZV94LCB0aGlzLl90aWxlX3ksXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLl90aWxlLndpZHRoLCB0aGlzLl90aWxlLmhlaWdodCk7XG4gICAgfVxuXG4gICAgYmxpdEltYWdlKHgsIHksIHdpZHRoLCBoZWlnaHQsIGFyciwgb2Zmc2V0LCBmcm9tX3F1ZXVlKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZW5kZXJRLmxlbmd0aCAhPT0gMCAmJiAhZnJvbV9xdWV1ZSkge1xuICAgICAgICAgICAgLy8gTkIoZGlyZWN0eG1hbjEyKTogaXQncyB0ZWNobmljYWxseSBtb3JlIHBlcmZvcm1hbnQgaGVyZSB0byB1c2UgcHJlYWxsb2NhdGVkIGFycmF5cyxcbiAgICAgICAgICAgIC8vIGJ1dCBpdCdzIGEgbG90IG9mIGV4dHJhIHdvcmsgZm9yIG5vdCBhIGxvdCBvZiBwYXlvZmYgLS0gaWYgd2UncmUgdXNpbmcgdGhlIHJlbmRlciBxdWV1ZSxcbiAgICAgICAgICAgIC8vIHRoaXMgcHJvYmFibHkgaXNuJ3QgZ2V0dGluZyBjYWxsZWQgKm5lYXJseSogYXMgbXVjaFxuICAgICAgICAgICAgY29uc3QgbmV3X2FyciA9IG5ldyBVaW50OEFycmF5KHdpZHRoICogaGVpZ2h0ICogNCk7XG4gICAgICAgICAgICBuZXdfYXJyLnNldChuZXcgVWludDhBcnJheShhcnIuYnVmZmVyLCAwLCBuZXdfYXJyLmxlbmd0aCkpO1xuICAgICAgICAgICAgdGhpcy5fcmVuZGVyUV9wdXNoKHtcbiAgICAgICAgICAgICAgICAndHlwZSc6ICdibGl0JyxcbiAgICAgICAgICAgICAgICAnZGF0YSc6IG5ld19hcnIsXG4gICAgICAgICAgICAgICAgJ3gnOiB4LFxuICAgICAgICAgICAgICAgICd5JzogeSxcbiAgICAgICAgICAgICAgICAnd2lkdGgnOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAnaGVpZ2h0JzogaGVpZ2h0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9iZ3J4SW1hZ2VEYXRhKHgsIHksIHdpZHRoLCBoZWlnaHQsIGFyciwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJsaXRSZ2JJbWFnZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBhcnIsIG9mZnNldCwgZnJvbV9xdWV1ZSkge1xuICAgICAgICBpZiAodGhpcy5fcmVuZGVyUS5sZW5ndGggIT09IDAgJiYgIWZyb21fcXVldWUpIHtcbiAgICAgICAgICAgIC8vIE5CKGRpcmVjdHhtYW4xMik6IGl0J3MgdGVjaG5pY2FsbHkgbW9yZSBwZXJmb3JtYW50IGhlcmUgdG8gdXNlIHByZWFsbG9jYXRlZCBhcnJheXMsXG4gICAgICAgICAgICAvLyBidXQgaXQncyBhIGxvdCBvZiBleHRyYSB3b3JrIGZvciBub3QgYSBsb3Qgb2YgcGF5b2ZmIC0tIGlmIHdlJ3JlIHVzaW5nIHRoZSByZW5kZXIgcXVldWUsXG4gICAgICAgICAgICAvLyB0aGlzIHByb2JhYmx5IGlzbid0IGdldHRpbmcgY2FsbGVkICpuZWFybHkqIGFzIG11Y2hcbiAgICAgICAgICAgIGNvbnN0IG5ld19hcnIgPSBuZXcgVWludDhBcnJheSh3aWR0aCAqIGhlaWdodCAqIDMpO1xuICAgICAgICAgICAgbmV3X2Fyci5zZXQobmV3IFVpbnQ4QXJyYXkoYXJyLmJ1ZmZlciwgMCwgbmV3X2Fyci5sZW5ndGgpKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlclFfcHVzaCh7XG4gICAgICAgICAgICAgICAgJ3R5cGUnOiAnYmxpdFJnYicsXG4gICAgICAgICAgICAgICAgJ2RhdGEnOiBuZXdfYXJyLFxuICAgICAgICAgICAgICAgICd4JzogeCxcbiAgICAgICAgICAgICAgICAneSc6IHksXG4gICAgICAgICAgICAgICAgJ3dpZHRoJzogd2lkdGgsXG4gICAgICAgICAgICAgICAgJ2hlaWdodCc6IGhlaWdodCxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fcmdiSW1hZ2VEYXRhKHgsIHksIHdpZHRoLCBoZWlnaHQsIGFyciwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGJsaXRSZ2J4SW1hZ2UoeCwgeSwgd2lkdGgsIGhlaWdodCwgYXJyLCBvZmZzZXQsIGZyb21fcXVldWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX3JlbmRlclEubGVuZ3RoICE9PSAwICYmICFmcm9tX3F1ZXVlKSB7XG4gICAgICAgICAgICAvLyBOQihkaXJlY3R4bWFuMTIpOiBpdCdzIHRlY2huaWNhbGx5IG1vcmUgcGVyZm9ybWFudCBoZXJlIHRvIHVzZSBwcmVhbGxvY2F0ZWQgYXJyYXlzLFxuICAgICAgICAgICAgLy8gYnV0IGl0J3MgYSBsb3Qgb2YgZXh0cmEgd29yayBmb3Igbm90IGEgbG90IG9mIHBheW9mZiAtLSBpZiB3ZSdyZSB1c2luZyB0aGUgcmVuZGVyIHF1ZXVlLFxuICAgICAgICAgICAgLy8gdGhpcyBwcm9iYWJseSBpc24ndCBnZXR0aW5nIGNhbGxlZCAqbmVhcmx5KiBhcyBtdWNoXG4gICAgICAgICAgICBjb25zdCBuZXdfYXJyID0gbmV3IFVpbnQ4QXJyYXkod2lkdGggKiBoZWlnaHQgKiA0KTtcbiAgICAgICAgICAgIG5ld19hcnIuc2V0KG5ldyBVaW50OEFycmF5KGFyci5idWZmZXIsIDAsIG5ld19hcnIubGVuZ3RoKSk7XG4gICAgICAgICAgICB0aGlzLl9yZW5kZXJRX3B1c2goe1xuICAgICAgICAgICAgICAgICd0eXBlJzogJ2JsaXRSZ2J4JyxcbiAgICAgICAgICAgICAgICAnZGF0YSc6IG5ld19hcnIsXG4gICAgICAgICAgICAgICAgJ3gnOiB4LFxuICAgICAgICAgICAgICAgICd5JzogeSxcbiAgICAgICAgICAgICAgICAnd2lkdGgnOiB3aWR0aCxcbiAgICAgICAgICAgICAgICAnaGVpZ2h0JzogaGVpZ2h0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZ2J4SW1hZ2VEYXRhKHgsIHksIHdpZHRoLCBoZWlnaHQsIGFyciwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGRyYXdJbWFnZShpbWcsIHgsIHkpIHtcbiAgICAgICAgdGhpcy5fZHJhd0N0eC5kcmF3SW1hZ2UoaW1nLCB4LCB5KTtcbiAgICAgICAgdGhpcy5fZGFtYWdlKHgsIHksIGltZy53aWR0aCwgaW1nLmhlaWdodCk7XG4gICAgfVxuXG4gICAgYXV0b3NjYWxlKGNvbnRhaW5lcldpZHRoLCBjb250YWluZXJIZWlnaHQpIHtcbiAgICAgICAgbGV0IHNjYWxlUmF0aW87XG5cbiAgICAgICAgaWYgKGNvbnRhaW5lcldpZHRoID09PSAwIHx8IGNvbnRhaW5lckhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgc2NhbGVSYXRpbyA9IDA7XG5cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgY29uc3QgdnAgPSB0aGlzLl92aWV3cG9ydExvYztcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldEFzcGVjdFJhdGlvID0gY29udGFpbmVyV2lkdGggLyBjb250YWluZXJIZWlnaHQ7XG4gICAgICAgICAgICBjb25zdCBmYkFzcGVjdFJhdGlvID0gdnAudyAvIHZwLmg7XG5cbiAgICAgICAgICAgIGlmIChmYkFzcGVjdFJhdGlvID49IHRhcmdldEFzcGVjdFJhdGlvKSB7XG4gICAgICAgICAgICAgICAgc2NhbGVSYXRpbyA9IGNvbnRhaW5lcldpZHRoIC8gdnAudztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2NhbGVSYXRpbyA9IGNvbnRhaW5lckhlaWdodCAvIHZwLmg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9yZXNjYWxlKHNjYWxlUmF0aW8pO1xuICAgIH1cblxuICAgIC8vID09PT09IFBSSVZBVEUgTUVUSE9EUyA9PT09PVxuXG4gICAgX3Jlc2NhbGUoZmFjdG9yKSB7XG4gICAgICAgIHRoaXMuX3NjYWxlID0gZmFjdG9yO1xuICAgICAgICBjb25zdCB2cCA9IHRoaXMuX3ZpZXdwb3J0TG9jO1xuXG4gICAgICAgIC8vIE5CKGRpcmVjdHhtYW4xMik6IElmIHlvdSBzZXQgdGhlIHdpZHRoIGRpcmVjdGx5LCBvciBzZXQgdGhlXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgIHN0eWxlIHdpZHRoIHRvIGEgbnVtYmVyLCB0aGUgY2FudmFzIGlzIGNsZWFyZWQuXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgIEhvd2V2ZXIsIGlmIHlvdSBzZXQgdGhlIHN0eWxlIHdpZHRoIHRvIGEgc3RyaW5nXG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICgnTk5OcHgnKSwgdGhlIGNhbnZhcyBpcyBzY2FsZWQgd2l0aG91dCBjbGVhcmluZy5cbiAgICAgICAgY29uc3Qgd2lkdGggPSBmYWN0b3IgKiB2cC53ICsgJ3B4JztcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gZmFjdG9yICogdnAuaCArICdweCc7XG5cbiAgICAgICAgaWYgKCh0aGlzLl90YXJnZXQuc3R5bGUud2lkdGggIT09IHdpZHRoKSB8fFxuICAgICAgICAgICAgKHRoaXMuX3RhcmdldC5zdHlsZS5oZWlnaHQgIT09IGhlaWdodCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldC5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9zZXRGaWxsQ29sb3IoY29sb3IpIHtcbiAgICAgICAgY29uc3QgbmV3U3R5bGUgPSAncmdiKCcgKyBjb2xvclsyXSArICcsJyArIGNvbG9yWzFdICsgJywnICsgY29sb3JbMF0gKyAnKSc7XG4gICAgICAgIGlmIChuZXdTdHlsZSAhPT0gdGhpcy5fcHJldkRyYXdTdHlsZSkge1xuICAgICAgICAgICAgdGhpcy5fZHJhd0N0eC5maWxsU3R5bGUgPSBuZXdTdHlsZTtcbiAgICAgICAgICAgIHRoaXMuX3ByZXZEcmF3U3R5bGUgPSBuZXdTdHlsZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9yZ2JJbWFnZURhdGEoeCwgeSwgd2lkdGgsIGhlaWdodCwgYXJyLCBvZmZzZXQpIHtcbiAgICAgICAgY29uc3QgaW1nID0gdGhpcy5fZHJhd0N0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBpbWcuZGF0YTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGogPSBvZmZzZXQ7IGkgPCB3aWR0aCAqIGhlaWdodCAqIDQ7IGkgKz0gNCwgaiArPSAzKSB7XG4gICAgICAgICAgICBkYXRhW2ldICAgICA9IGFycltqXTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gYXJyW2ogKyAxXTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYXJyW2ogKyAyXTtcbiAgICAgICAgICAgIGRhdGFbaSArIDNdID0gMjU1OyAgLy8gQWxwaGFcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kcmF3Q3R4LnB1dEltYWdlRGF0YShpbWcsIHgsIHkpO1xuICAgICAgICB0aGlzLl9kYW1hZ2UoeCwgeSwgaW1nLndpZHRoLCBpbWcuaGVpZ2h0KTtcbiAgICB9XG5cbiAgICBfYmdyeEltYWdlRGF0YSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBhcnIsIG9mZnNldCkge1xuICAgICAgICBjb25zdCBpbWcgPSB0aGlzLl9kcmF3Q3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgY29uc3QgZGF0YSA9IGltZy5kYXRhO1xuICAgICAgICBmb3IgKGxldCBpID0gMCwgaiA9IG9mZnNldDsgaSA8IHdpZHRoICogaGVpZ2h0ICogNDsgaSArPSA0LCBqICs9IDQpIHtcbiAgICAgICAgICAgIGRhdGFbaV0gICAgID0gYXJyW2ogKyAyXTtcbiAgICAgICAgICAgIGRhdGFbaSArIDFdID0gYXJyW2ogKyAxXTtcbiAgICAgICAgICAgIGRhdGFbaSArIDJdID0gYXJyW2pdO1xuICAgICAgICAgICAgZGF0YVtpICsgM10gPSAyNTU7ICAvLyBBbHBoYVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RyYXdDdHgucHV0SW1hZ2VEYXRhKGltZywgeCwgeSk7XG4gICAgICAgIHRoaXMuX2RhbWFnZSh4LCB5LCBpbWcud2lkdGgsIGltZy5oZWlnaHQpO1xuICAgIH1cblxuICAgIF9yZ2J4SW1hZ2VEYXRhKHgsIHksIHdpZHRoLCBoZWlnaHQsIGFyciwgb2Zmc2V0KSB7XG4gICAgICAgIC8vIE5CKGRpcmVjdHhtYW4xMik6IGFyciBtdXN0IGJlIGFuIFR5cGUgQXJyYXkgdmlld1xuICAgICAgICBsZXQgaW1nO1xuICAgICAgICBpZiAoc3VwcG9ydHNJbWFnZU1ldGFkYXRhKSB7XG4gICAgICAgICAgICBpbWcgPSBuZXcgSW1hZ2VEYXRhKG5ldyBVaW50OENsYW1wZWRBcnJheShhcnIuYnVmZmVyLCBhcnIuYnl0ZU9mZnNldCwgd2lkdGggKiBoZWlnaHQgKiA0KSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpbWcgPSB0aGlzLl9kcmF3Q3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgICAgIGltZy5kYXRhLnNldChuZXcgVWludDhDbGFtcGVkQXJyYXkoYXJyLmJ1ZmZlciwgYXJyLmJ5dGVPZmZzZXQsIHdpZHRoICogaGVpZ2h0ICogNCkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RyYXdDdHgucHV0SW1hZ2VEYXRhKGltZywgeCwgeSk7XG4gICAgICAgIHRoaXMuX2RhbWFnZSh4LCB5LCBpbWcud2lkdGgsIGltZy5oZWlnaHQpO1xuICAgIH1cblxuICAgIF9yZW5kZXJRX3B1c2goYWN0aW9uKSB7XG4gICAgICAgIHRoaXMuX3JlbmRlclEucHVzaChhY3Rpb24pO1xuICAgICAgICBpZiAodGhpcy5fcmVuZGVyUS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgY2FuIGJlIHJlbmRlcmVkIGltbWVkaWF0ZWx5IGl0IHdpbGwgYmUsIG90aGVyd2lzZVxuICAgICAgICAgICAgLy8gdGhlIHNjYW5uZXIgd2lsbCB3YWl0IGZvciB0aGUgcmVsZXZhbnQgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuX3NjYW5fcmVuZGVyUSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3Jlc3VtZV9yZW5kZXJRKCkge1xuICAgICAgICAvLyBcInRoaXNcIiBpcyB0aGUgb2JqZWN0IHRoYXQgaXMgcmVhZHksIG5vdCB0aGVcbiAgICAgICAgLy8gZGlzcGxheSBvYmplY3RcbiAgICAgICAgdGhpcy5yZW1vdmVFdmVudExpc3RlbmVyKCdsb2FkJywgdGhpcy5fbm9WTkNfZGlzcGxheS5fcmVzdW1lX3JlbmRlclEpO1xuICAgICAgICB0aGlzLl9ub1ZOQ19kaXNwbGF5Ll9zY2FuX3JlbmRlclEoKTtcbiAgICB9XG5cbiAgICBfc2Nhbl9yZW5kZXJRKCkge1xuICAgICAgICBsZXQgcmVhZHkgPSB0cnVlO1xuICAgICAgICB3aGlsZSAocmVhZHkgJiYgdGhpcy5fcmVuZGVyUS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBhID0gdGhpcy5fcmVuZGVyUVswXTtcbiAgICAgICAgICAgIHN3aXRjaCAoYS50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmxpcCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmxpcCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29weSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29weUltYWdlKGEub2xkX3gsIGEub2xkX3ksIGEueCwgYS55LCBhLndpZHRoLCBhLmhlaWdodCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpbGwnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGxSZWN0KGEueCwgYS55LCBhLndpZHRoLCBhLmhlaWdodCwgYS5jb2xvciwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JsaXQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJsaXRJbWFnZShhLngsIGEueSwgYS53aWR0aCwgYS5oZWlnaHQsIGEuZGF0YSwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JsaXRSZ2InOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmJsaXRSZ2JJbWFnZShhLngsIGEueSwgYS53aWR0aCwgYS5oZWlnaHQsIGEuZGF0YSwgMCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2JsaXRSZ2J4JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ibGl0UmdieEltYWdlKGEueCwgYS55LCBhLndpZHRoLCBhLmhlaWdodCwgYS5kYXRhLCAwLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaW1nJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKGEuaW1nLmNvbXBsZXRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRyYXdJbWFnZShhLmltZywgYS54LCBhLnkpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5pbWcuX25vVk5DX2Rpc3BsYXkgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgYS5pbWcuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIHRoaXMuX3Jlc3VtZV9yZW5kZXJRKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gd2FpdCBmb3IgdGhpcyBpbWFnZSB0byAnbG9hZCdcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRvIGtlZXAgdGhpbmdzIGluLW9yZGVyXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkeSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVhZHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW5kZXJRLnNoaWZ0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcmVuZGVyUS5sZW5ndGggPT09IDAgJiYgdGhpcy5fZmx1c2hpbmcpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZsdXNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm9uZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8qXG4gKiBub1ZOQzogSFRNTDUgVk5DIGNsaWVudFxuICogQ29weXJpZ2h0IChDKSAyMDE4IFRoZSBub1ZOQyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciBNUEwgMi4wIChzZWUgTElDRU5TRS50eHQpXG4gKlxuICogU2VlIFJFQURNRS5tZCBmb3IgdXNhZ2UgYW5kIGludGVncmF0aW9uIGluc3RydWN0aW9ucy5cbiAqL1xuXG5leHBvcnQgY29uc3QgZW5jb2RpbmdzID0ge1xuICAgIGVuY29kaW5nUmF3OiAwLFxuICAgIGVuY29kaW5nQ29weVJlY3Q6IDEsXG4gICAgZW5jb2RpbmdSUkU6IDIsXG4gICAgZW5jb2RpbmdIZXh0aWxlOiA1LFxuICAgIGVuY29kaW5nVGlnaHQ6IDcsXG4gICAgZW5jb2RpbmdUaWdodFBORzogLTI2MCxcblxuICAgIHBzZXVkb0VuY29kaW5nUXVhbGl0eUxldmVsOTogLTIzLFxuICAgIHBzZXVkb0VuY29kaW5nUXVhbGl0eUxldmVsMDogLTMyLFxuICAgIHBzZXVkb0VuY29kaW5nRGVza3RvcFNpemU6IC0yMjMsXG4gICAgcHNldWRvRW5jb2RpbmdMYXN0UmVjdDogLTIyNCxcbiAgICBwc2V1ZG9FbmNvZGluZ0N1cnNvcjogLTIzOSxcbiAgICBwc2V1ZG9FbmNvZGluZ1FFTVVFeHRlbmRlZEtleUV2ZW50OiAtMjU4LFxuICAgIHBzZXVkb0VuY29kaW5nRXh0ZW5kZWREZXNrdG9wU2l6ZTogLTMwOCxcbiAgICBwc2V1ZG9FbmNvZGluZ1h2cDogLTMwOSxcbiAgICBwc2V1ZG9FbmNvZGluZ0ZlbmNlOiAtMzEyLFxuICAgIHBzZXVkb0VuY29kaW5nQ29udGludW91c1VwZGF0ZXM6IC0zMTMsXG4gICAgcHNldWRvRW5jb2RpbmdDb21wcmVzc0xldmVsOTogLTI0NyxcbiAgICBwc2V1ZG9FbmNvZGluZ0NvbXByZXNzTGV2ZWwwOiAtMjU2LFxufTtcblxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kaW5nTmFtZShudW0pIHtcbiAgICBzd2l0Y2ggKG51bSkge1xuICAgICAgICBjYXNlIGVuY29kaW5ncy5lbmNvZGluZ1JhdzogICAgICByZXR1cm4gXCJSYXdcIjtcbiAgICAgICAgY2FzZSBlbmNvZGluZ3MuZW5jb2RpbmdDb3B5UmVjdDogcmV0dXJuIFwiQ29weVJlY3RcIjtcbiAgICAgICAgY2FzZSBlbmNvZGluZ3MuZW5jb2RpbmdSUkU6ICAgICAgcmV0dXJuIFwiUlJFXCI7XG4gICAgICAgIGNhc2UgZW5jb2RpbmdzLmVuY29kaW5nSGV4dGlsZTogIHJldHVybiBcIkhleHRpbGVcIjtcbiAgICAgICAgY2FzZSBlbmNvZGluZ3MuZW5jb2RpbmdUaWdodDogICAgcmV0dXJuIFwiVGlnaHRcIjtcbiAgICAgICAgY2FzZSBlbmNvZGluZ3MuZW5jb2RpbmdUaWdodFBORzogcmV0dXJuIFwiVGlnaHRQTkdcIjtcbiAgICAgICAgZGVmYXVsdDogICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFwiW3Vua25vd24gZW5jb2RpbmcgXCIgKyBudW0gKyBcIl1cIjtcbiAgICB9XG59XG4iLCJpbXBvcnQgeyBpbmZsYXRlSW5pdCwgaW5mbGF0ZSwgaW5mbGF0ZVJlc2V0IH0gZnJvbSBcIi4uL3ZlbmRvci9wYWtvL2xpYi96bGliL2luZmxhdGUuanNcIjtcbmltcG9ydCBaU3RyZWFtIGZyb20gXCIuLi92ZW5kb3IvcGFrby9saWIvemxpYi96c3RyZWFtLmpzXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEluZmxhdGUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnN0cm0gPSBuZXcgWlN0cmVhbSgpO1xuICAgICAgICB0aGlzLmNodW5rU2l6ZSA9IDEwMjQgKiAxMCAqIDEwO1xuICAgICAgICB0aGlzLnN0cm0ub3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5jaHVua1NpemUpO1xuICAgICAgICB0aGlzLndpbmRvd0JpdHMgPSA1O1xuXG4gICAgICAgIGluZmxhdGVJbml0KHRoaXMuc3RybSwgdGhpcy53aW5kb3dCaXRzKTtcbiAgICB9XG5cbiAgICBpbmZsYXRlKGRhdGEsIGZsdXNoLCBleHBlY3RlZCkge1xuICAgICAgICB0aGlzLnN0cm0uaW5wdXQgPSBkYXRhO1xuICAgICAgICB0aGlzLnN0cm0uYXZhaWxfaW4gPSB0aGlzLnN0cm0uaW5wdXQubGVuZ3RoO1xuICAgICAgICB0aGlzLnN0cm0ubmV4dF9pbiA9IDA7XG4gICAgICAgIHRoaXMuc3RybS5uZXh0X291dCA9IDA7XG5cbiAgICAgICAgLy8gcmVzaXplIG91ciBvdXRwdXQgYnVmZmVyIGlmIGl0J3MgdG9vIHNtYWxsXG4gICAgICAgIC8vICh3ZSBjb3VsZCBqdXN0IHVzZSBtdWx0aXBsZSBjaHVua3MsIGJ1dCB0aGF0IHdvdWxkIGNhdXNlIGFuIGV4dHJhXG4gICAgICAgIC8vIGFsbG9jYXRpb24gZWFjaCB0aW1lIHRvIGZsYXR0ZW4gdGhlIGNodW5rcylcbiAgICAgICAgaWYgKGV4cGVjdGVkID4gdGhpcy5jaHVua1NpemUpIHtcbiAgICAgICAgICAgIHRoaXMuY2h1bmtTaXplID0gZXhwZWN0ZWQ7XG4gICAgICAgICAgICB0aGlzLnN0cm0ub3V0cHV0ID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5jaHVua1NpemUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5zdHJtLmF2YWlsX291dCA9IHRoaXMuY2h1bmtTaXplO1xuXG4gICAgICAgIGluZmxhdGUodGhpcy5zdHJtLCBmbHVzaCk7XG5cbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHRoaXMuc3RybS5vdXRwdXQuYnVmZmVyLCAwLCB0aGlzLnN0cm0ubmV4dF9vdXQpO1xuICAgIH1cblxuICAgIHJlc2V0KCkge1xuICAgICAgICBpbmZsYXRlUmVzZXQodGhpcy5zdHJtKTtcbiAgICB9XG59XG4iLCIvKlxuICogbm9WTkM6IEhUTUw1IFZOQyBjbGllbnRcbiAqIENvcHlyaWdodCAoQykgMjAxOCBUaGUgbm9WTkMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgTVBMIDIuMCBvciBhbnkgbGF0ZXIgdmVyc2lvbiAoc2VlIExJQ0VOU0UudHh0KVxuICovXG5cbmltcG9ydCBLZXlUYWJsZSBmcm9tIFwiLi9rZXlzeW0uanNcIjtcblxuLypcbiAqIE1hcHBpbmcgYmV0d2VlbiBIVE1MIGtleSB2YWx1ZXMgYW5kIFZOQy9YMTEga2V5c3ltcyBmb3IgXCJzcGVjaWFsXCJcbiAqIGtleXMgdGhhdCBjYW5ub3QgYmUgaGFuZGxlZCB2aWEgdGhlaXIgVW5pY29kZSBjb2RlcG9pbnQuXG4gKlxuICogU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi91aWV2ZW50cy1rZXkvIGZvciBwb3NzaWJsZSB2YWx1ZXMuXG4gKi9cblxuY29uc3QgRE9NS2V5VGFibGUgPSB7fTtcblxuZnVuY3Rpb24gYWRkU3RhbmRhcmQoa2V5LCBzdGFuZGFyZCkge1xuICAgIGlmIChzdGFuZGFyZCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmRlZmluZWQga2V5c3ltIGZvciBrZXkgXFxcIlwiICsga2V5ICsgXCJcXFwiXCIpO1xuICAgIGlmIChrZXkgaW4gRE9NS2V5VGFibGUpIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBlbnRyeSBmb3Iga2V5IFxcXCJcIiArIGtleSArIFwiXFxcIlwiKTtcbiAgICBET01LZXlUYWJsZVtrZXldID0gW3N0YW5kYXJkLCBzdGFuZGFyZCwgc3RhbmRhcmQsIHN0YW5kYXJkXTtcbn1cblxuZnVuY3Rpb24gYWRkTGVmdFJpZ2h0KGtleSwgbGVmdCwgcmlnaHQpIHtcbiAgICBpZiAobGVmdCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmRlZmluZWQga2V5c3ltIGZvciBrZXkgXFxcIlwiICsga2V5ICsgXCJcXFwiXCIpO1xuICAgIGlmIChyaWdodCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmRlZmluZWQga2V5c3ltIGZvciBrZXkgXFxcIlwiICsga2V5ICsgXCJcXFwiXCIpO1xuICAgIGlmIChrZXkgaW4gRE9NS2V5VGFibGUpIHRocm93IG5ldyBFcnJvcihcIkR1cGxpY2F0ZSBlbnRyeSBmb3Iga2V5IFxcXCJcIiArIGtleSArIFwiXFxcIlwiKTtcbiAgICBET01LZXlUYWJsZVtrZXldID0gW2xlZnQsIGxlZnQsIHJpZ2h0LCBsZWZ0XTtcbn1cblxuZnVuY3Rpb24gYWRkTnVtcGFkKGtleSwgc3RhbmRhcmQsIG51bXBhZCkge1xuICAgIGlmIChzdGFuZGFyZCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJVbmRlZmluZWQga2V5c3ltIGZvciBrZXkgXFxcIlwiICsga2V5ICsgXCJcXFwiXCIpO1xuICAgIGlmIChudW1wYWQgPT09IHVuZGVmaW5lZCkgdGhyb3cgbmV3IEVycm9yKFwiVW5kZWZpbmVkIGtleXN5bSBmb3Iga2V5IFxcXCJcIiArIGtleSArIFwiXFxcIlwiKTtcbiAgICBpZiAoa2V5IGluIERPTUtleVRhYmxlKSB0aHJvdyBuZXcgRXJyb3IoXCJEdXBsaWNhdGUgZW50cnkgZm9yIGtleSBcXFwiXCIgKyBrZXkgKyBcIlxcXCJcIik7XG4gICAgRE9NS2V5VGFibGVba2V5XSA9IFtzdGFuZGFyZCwgc3RhbmRhcmQsIHN0YW5kYXJkLCBudW1wYWRdO1xufVxuXG4vLyAyLjIuIE1vZGlmaWVyIEtleXNcblxuYWRkTGVmdFJpZ2h0KFwiQWx0XCIsIEtleVRhYmxlLlhLX0FsdF9MLCBLZXlUYWJsZS5YS19BbHRfUik7XG5hZGRTdGFuZGFyZChcIkFsdEdyYXBoXCIsIEtleVRhYmxlLlhLX0lTT19MZXZlbDNfU2hpZnQpO1xuYWRkU3RhbmRhcmQoXCJDYXBzTG9ja1wiLCBLZXlUYWJsZS5YS19DYXBzX0xvY2spO1xuYWRkTGVmdFJpZ2h0KFwiQ29udHJvbFwiLCBLZXlUYWJsZS5YS19Db250cm9sX0wsIEtleVRhYmxlLlhLX0NvbnRyb2xfUik7XG4vLyAtIEZuXG4vLyAtIEZuTG9ja1xuYWRkTGVmdFJpZ2h0KFwiSHlwZXJcIiwgS2V5VGFibGUuWEtfU3VwZXJfTCwgS2V5VGFibGUuWEtfU3VwZXJfUik7XG5hZGRMZWZ0UmlnaHQoXCJNZXRhXCIsIEtleVRhYmxlLlhLX1N1cGVyX0wsIEtleVRhYmxlLlhLX1N1cGVyX1IpO1xuYWRkU3RhbmRhcmQoXCJOdW1Mb2NrXCIsIEtleVRhYmxlLlhLX051bV9Mb2NrKTtcbmFkZFN0YW5kYXJkKFwiU2Nyb2xsTG9ja1wiLCBLZXlUYWJsZS5YS19TY3JvbGxfTG9jayk7XG5hZGRMZWZ0UmlnaHQoXCJTaGlmdFwiLCBLZXlUYWJsZS5YS19TaGlmdF9MLCBLZXlUYWJsZS5YS19TaGlmdF9SKTtcbmFkZExlZnRSaWdodChcIlN1cGVyXCIsIEtleVRhYmxlLlhLX1N1cGVyX0wsIEtleVRhYmxlLlhLX1N1cGVyX1IpO1xuLy8gLSBTeW1ib2xcbi8vIC0gU3ltYm9sTG9ja1xuXG4vLyAyLjMuIFdoaXRlc3BhY2UgS2V5c1xuXG5hZGROdW1wYWQoXCJFbnRlclwiLCBLZXlUYWJsZS5YS19SZXR1cm4sIEtleVRhYmxlLlhLX0tQX0VudGVyKTtcbmFkZFN0YW5kYXJkKFwiVGFiXCIsIEtleVRhYmxlLlhLX1RhYik7XG5hZGROdW1wYWQoXCIgXCIsIEtleVRhYmxlLlhLX3NwYWNlLCBLZXlUYWJsZS5YS19LUF9TcGFjZSk7XG5cbi8vIDIuNC4gTmF2aWdhdGlvbiBLZXlzXG5cbmFkZE51bXBhZChcIkFycm93RG93blwiLCBLZXlUYWJsZS5YS19Eb3duLCBLZXlUYWJsZS5YS19LUF9Eb3duKTtcbmFkZE51bXBhZChcIkFycm93VXBcIiwgS2V5VGFibGUuWEtfVXAsIEtleVRhYmxlLlhLX0tQX1VwKTtcbmFkZE51bXBhZChcIkFycm93TGVmdFwiLCBLZXlUYWJsZS5YS19MZWZ0LCBLZXlUYWJsZS5YS19LUF9MZWZ0KTtcbmFkZE51bXBhZChcIkFycm93UmlnaHRcIiwgS2V5VGFibGUuWEtfUmlnaHQsIEtleVRhYmxlLlhLX0tQX1JpZ2h0KTtcbmFkZE51bXBhZChcIkVuZFwiLCBLZXlUYWJsZS5YS19FbmQsIEtleVRhYmxlLlhLX0tQX0VuZCk7XG5hZGROdW1wYWQoXCJIb21lXCIsIEtleVRhYmxlLlhLX0hvbWUsIEtleVRhYmxlLlhLX0tQX0hvbWUpO1xuYWRkTnVtcGFkKFwiUGFnZURvd25cIiwgS2V5VGFibGUuWEtfTmV4dCwgS2V5VGFibGUuWEtfS1BfTmV4dCk7XG5hZGROdW1wYWQoXCJQYWdlVXBcIiwgS2V5VGFibGUuWEtfUHJpb3IsIEtleVRhYmxlLlhLX0tQX1ByaW9yKTtcblxuLy8gMi41LiBFZGl0aW5nIEtleXNcblxuYWRkU3RhbmRhcmQoXCJCYWNrc3BhY2VcIiwgS2V5VGFibGUuWEtfQmFja1NwYWNlKTtcbmFkZE51bXBhZChcIkNsZWFyXCIsIEtleVRhYmxlLlhLX0NsZWFyLCBLZXlUYWJsZS5YS19LUF9CZWdpbik7XG5hZGRTdGFuZGFyZChcIkNvcHlcIiwgS2V5VGFibGUuWEY4NlhLX0NvcHkpO1xuLy8gLSBDclNlbFxuYWRkU3RhbmRhcmQoXCJDdXRcIiwgS2V5VGFibGUuWEY4NlhLX0N1dCk7XG5hZGROdW1wYWQoXCJEZWxldGVcIiwgS2V5VGFibGUuWEtfRGVsZXRlLCBLZXlUYWJsZS5YS19LUF9EZWxldGUpO1xuLy8gLSBFcmFzZUVvZlxuLy8gLSBFeFNlbFxuYWRkTnVtcGFkKFwiSW5zZXJ0XCIsIEtleVRhYmxlLlhLX0luc2VydCwgS2V5VGFibGUuWEtfS1BfSW5zZXJ0KTtcbmFkZFN0YW5kYXJkKFwiUGFzdGVcIiwgS2V5VGFibGUuWEY4NlhLX1Bhc3RlKTtcbmFkZFN0YW5kYXJkKFwiUmVkb1wiLCBLZXlUYWJsZS5YS19SZWRvKTtcbmFkZFN0YW5kYXJkKFwiVW5kb1wiLCBLZXlUYWJsZS5YS19VbmRvKTtcblxuLy8gMi42LiBVSSBLZXlzXG5cbi8vIC0gQWNjZXB0XG4vLyAtIEFnYWluIChjb3VsZCBqdXN0IGJlIFhLX1JlZG8pXG4vLyAtIEF0dG5cbmFkZFN0YW5kYXJkKFwiQ2FuY2VsXCIsIEtleVRhYmxlLlhLX0NhbmNlbCk7XG5hZGRTdGFuZGFyZChcIkNvbnRleHRNZW51XCIsIEtleVRhYmxlLlhLX01lbnUpO1xuYWRkU3RhbmRhcmQoXCJFc2NhcGVcIiwgS2V5VGFibGUuWEtfRXNjYXBlKTtcbmFkZFN0YW5kYXJkKFwiRXhlY3V0ZVwiLCBLZXlUYWJsZS5YS19FeGVjdXRlKTtcbmFkZFN0YW5kYXJkKFwiRmluZFwiLCBLZXlUYWJsZS5YS19GaW5kKTtcbmFkZFN0YW5kYXJkKFwiSGVscFwiLCBLZXlUYWJsZS5YS19IZWxwKTtcbmFkZFN0YW5kYXJkKFwiUGF1c2VcIiwgS2V5VGFibGUuWEtfUGF1c2UpO1xuLy8gLSBQbGF5XG4vLyAtIFByb3BzXG5hZGRTdGFuZGFyZChcIlNlbGVjdFwiLCBLZXlUYWJsZS5YS19TZWxlY3QpO1xuYWRkU3RhbmRhcmQoXCJab29tSW5cIiwgS2V5VGFibGUuWEY4NlhLX1pvb21Jbik7XG5hZGRTdGFuZGFyZChcIlpvb21PdXRcIiwgS2V5VGFibGUuWEY4NlhLX1pvb21PdXQpO1xuXG4vLyAyLjcuIERldmljZSBLZXlzXG5cbmFkZFN0YW5kYXJkKFwiQnJpZ2h0bmVzc0Rvd25cIiwgS2V5VGFibGUuWEY4NlhLX01vbkJyaWdodG5lc3NEb3duKTtcbmFkZFN0YW5kYXJkKFwiQnJpZ2h0bmVzc1VwXCIsIEtleVRhYmxlLlhGODZYS19Nb25CcmlnaHRuZXNzVXApO1xuYWRkU3RhbmRhcmQoXCJFamVjdFwiLCBLZXlUYWJsZS5YRjg2WEtfRWplY3QpO1xuYWRkU3RhbmRhcmQoXCJMb2dPZmZcIiwgS2V5VGFibGUuWEY4NlhLX0xvZ09mZik7XG5hZGRTdGFuZGFyZChcIlBvd2VyXCIsIEtleVRhYmxlLlhGODZYS19Qb3dlck9mZik7XG5hZGRTdGFuZGFyZChcIlBvd2VyT2ZmXCIsIEtleVRhYmxlLlhGODZYS19Qb3dlckRvd24pO1xuYWRkU3RhbmRhcmQoXCJQcmludFNjcmVlblwiLCBLZXlUYWJsZS5YS19QcmludCk7XG5hZGRTdGFuZGFyZChcIkhpYmVybmF0ZVwiLCBLZXlUYWJsZS5YRjg2WEtfSGliZXJuYXRlKTtcbmFkZFN0YW5kYXJkKFwiU3RhbmRieVwiLCBLZXlUYWJsZS5YRjg2WEtfU3RhbmRieSk7XG5hZGRTdGFuZGFyZChcIldha2VVcFwiLCBLZXlUYWJsZS5YRjg2WEtfV2FrZVVwKTtcblxuLy8gMi44LiBJTUUgYW5kIENvbXBvc2l0aW9uIEtleXNcblxuYWRkU3RhbmRhcmQoXCJBbGxDYW5kaWRhdGVzXCIsIEtleVRhYmxlLlhLX011bHRpcGxlQ2FuZGlkYXRlKTtcbmFkZFN0YW5kYXJkKFwiQWxwaGFudW1lcmljXCIsIEtleVRhYmxlLlhLX0Vpc3VfU2hpZnQpOyAvLyBjb3VsZCBhbHNvIGJlIF9FaXN1X1RvZ2dsZVxuYWRkU3RhbmRhcmQoXCJDb2RlSW5wdXRcIiwgS2V5VGFibGUuWEtfQ29kZWlucHV0KTtcbmFkZFN0YW5kYXJkKFwiQ29tcG9zZVwiLCBLZXlUYWJsZS5YS19NdWx0aV9rZXkpO1xuYWRkU3RhbmRhcmQoXCJDb252ZXJ0XCIsIEtleVRhYmxlLlhLX0hlbmthbik7XG4vLyAtIERlYWRcbi8vIC0gRmluYWxNb2RlXG5hZGRTdGFuZGFyZChcIkdyb3VwRmlyc3RcIiwgS2V5VGFibGUuWEtfSVNPX0ZpcnN0X0dyb3VwKTtcbmFkZFN0YW5kYXJkKFwiR3JvdXBMYXN0XCIsIEtleVRhYmxlLlhLX0lTT19MYXN0X0dyb3VwKTtcbmFkZFN0YW5kYXJkKFwiR3JvdXBOZXh0XCIsIEtleVRhYmxlLlhLX0lTT19OZXh0X0dyb3VwKTtcbmFkZFN0YW5kYXJkKFwiR3JvdXBQcmV2aW91c1wiLCBLZXlUYWJsZS5YS19JU09fUHJldl9Hcm91cCk7XG4vLyAtIE1vZGVDaGFuZ2UgKFhLX01vZGVfc3dpdGNoIGlzIG9mdGVuIHVzZWQgZm9yIEFsdEdyKVxuLy8gLSBOZXh0Q2FuZGlkYXRlXG5hZGRTdGFuZGFyZChcIk5vbkNvbnZlcnRcIiwgS2V5VGFibGUuWEtfTXVoZW5rYW4pO1xuYWRkU3RhbmRhcmQoXCJQcmV2aW91c0NhbmRpZGF0ZVwiLCBLZXlUYWJsZS5YS19QcmV2aW91c0NhbmRpZGF0ZSk7XG4vLyAtIFByb2Nlc3NcbmFkZFN0YW5kYXJkKFwiU2luZ2xlQ2FuZGlkYXRlXCIsIEtleVRhYmxlLlhLX1NpbmdsZUNhbmRpZGF0ZSk7XG5hZGRTdGFuZGFyZChcIkhhbmd1bE1vZGVcIiwgS2V5VGFibGUuWEtfSGFuZ3VsKTtcbmFkZFN0YW5kYXJkKFwiSGFuamFNb2RlXCIsIEtleVRhYmxlLlhLX0hhbmd1bF9IYW5qYSk7XG5hZGRTdGFuZGFyZChcIkp1bmp1YU1vZGVcIiwgS2V5VGFibGUuWEtfSGFuZ3VsX0plb25qYSk7XG5hZGRTdGFuZGFyZChcIkVpc3VcIiwgS2V5VGFibGUuWEtfRWlzdV90b2dnbGUpO1xuYWRkU3RhbmRhcmQoXCJIYW5rYWt1XCIsIEtleVRhYmxlLlhLX0hhbmtha3UpO1xuYWRkU3RhbmRhcmQoXCJIaXJhZ2FuYVwiLCBLZXlUYWJsZS5YS19IaXJhZ2FuYSk7XG5hZGRTdGFuZGFyZChcIkhpcmFnYW5hS2F0YWthbmFcIiwgS2V5VGFibGUuWEtfSGlyYWdhbmFfS2F0YWthbmEpO1xuYWRkU3RhbmRhcmQoXCJLYW5hTW9kZVwiLCBLZXlUYWJsZS5YS19LYW5hX1NoaWZ0KTsgLy8gY291bGQgYWxzbyBiZSBfS2FuYV9Mb2NrXG5hZGRTdGFuZGFyZChcIkthbmppTW9kZVwiLCBLZXlUYWJsZS5YS19LYW5qaSk7XG5hZGRTdGFuZGFyZChcIkthdGFrYW5hXCIsIEtleVRhYmxlLlhLX0thdGFrYW5hKTtcbmFkZFN0YW5kYXJkKFwiUm9tYWppXCIsIEtleVRhYmxlLlhLX1JvbWFqaSk7XG5hZGRTdGFuZGFyZChcIlplbmtha3VcIiwgS2V5VGFibGUuWEtfWmVua2FrdSk7XG5hZGRTdGFuZGFyZChcIlplbmtha3VIYW5ha3VcIiwgS2V5VGFibGUuWEtfWmVua2FrdV9IYW5rYWt1KTtcblxuLy8gMi45LiBHZW5lcmFsLVB1cnBvc2UgRnVuY3Rpb24gS2V5c1xuXG5hZGRTdGFuZGFyZChcIkYxXCIsIEtleVRhYmxlLlhLX0YxKTtcbmFkZFN0YW5kYXJkKFwiRjJcIiwgS2V5VGFibGUuWEtfRjIpO1xuYWRkU3RhbmRhcmQoXCJGM1wiLCBLZXlUYWJsZS5YS19GMyk7XG5hZGRTdGFuZGFyZChcIkY0XCIsIEtleVRhYmxlLlhLX0Y0KTtcbmFkZFN0YW5kYXJkKFwiRjVcIiwgS2V5VGFibGUuWEtfRjUpO1xuYWRkU3RhbmRhcmQoXCJGNlwiLCBLZXlUYWJsZS5YS19GNik7XG5hZGRTdGFuZGFyZChcIkY3XCIsIEtleVRhYmxlLlhLX0Y3KTtcbmFkZFN0YW5kYXJkKFwiRjhcIiwgS2V5VGFibGUuWEtfRjgpO1xuYWRkU3RhbmRhcmQoXCJGOVwiLCBLZXlUYWJsZS5YS19GOSk7XG5hZGRTdGFuZGFyZChcIkYxMFwiLCBLZXlUYWJsZS5YS19GMTApO1xuYWRkU3RhbmRhcmQoXCJGMTFcIiwgS2V5VGFibGUuWEtfRjExKTtcbmFkZFN0YW5kYXJkKFwiRjEyXCIsIEtleVRhYmxlLlhLX0YxMik7XG5hZGRTdGFuZGFyZChcIkYxM1wiLCBLZXlUYWJsZS5YS19GMTMpO1xuYWRkU3RhbmRhcmQoXCJGMTRcIiwgS2V5VGFibGUuWEtfRjE0KTtcbmFkZFN0YW5kYXJkKFwiRjE1XCIsIEtleVRhYmxlLlhLX0YxNSk7XG5hZGRTdGFuZGFyZChcIkYxNlwiLCBLZXlUYWJsZS5YS19GMTYpO1xuYWRkU3RhbmRhcmQoXCJGMTdcIiwgS2V5VGFibGUuWEtfRjE3KTtcbmFkZFN0YW5kYXJkKFwiRjE4XCIsIEtleVRhYmxlLlhLX0YxOCk7XG5hZGRTdGFuZGFyZChcIkYxOVwiLCBLZXlUYWJsZS5YS19GMTkpO1xuYWRkU3RhbmRhcmQoXCJGMjBcIiwgS2V5VGFibGUuWEtfRjIwKTtcbmFkZFN0YW5kYXJkKFwiRjIxXCIsIEtleVRhYmxlLlhLX0YyMSk7XG5hZGRTdGFuZGFyZChcIkYyMlwiLCBLZXlUYWJsZS5YS19GMjIpO1xuYWRkU3RhbmRhcmQoXCJGMjNcIiwgS2V5VGFibGUuWEtfRjIzKTtcbmFkZFN0YW5kYXJkKFwiRjI0XCIsIEtleVRhYmxlLlhLX0YyNCk7XG5hZGRTdGFuZGFyZChcIkYyNVwiLCBLZXlUYWJsZS5YS19GMjUpO1xuYWRkU3RhbmRhcmQoXCJGMjZcIiwgS2V5VGFibGUuWEtfRjI2KTtcbmFkZFN0YW5kYXJkKFwiRjI3XCIsIEtleVRhYmxlLlhLX0YyNyk7XG5hZGRTdGFuZGFyZChcIkYyOFwiLCBLZXlUYWJsZS5YS19GMjgpO1xuYWRkU3RhbmRhcmQoXCJGMjlcIiwgS2V5VGFibGUuWEtfRjI5KTtcbmFkZFN0YW5kYXJkKFwiRjMwXCIsIEtleVRhYmxlLlhLX0YzMCk7XG5hZGRTdGFuZGFyZChcIkYzMVwiLCBLZXlUYWJsZS5YS19GMzEpO1xuYWRkU3RhbmRhcmQoXCJGMzJcIiwgS2V5VGFibGUuWEtfRjMyKTtcbmFkZFN0YW5kYXJkKFwiRjMzXCIsIEtleVRhYmxlLlhLX0YzMyk7XG5hZGRTdGFuZGFyZChcIkYzNFwiLCBLZXlUYWJsZS5YS19GMzQpO1xuYWRkU3RhbmRhcmQoXCJGMzVcIiwgS2V5VGFibGUuWEtfRjM1KTtcbi8vIC0gU29mdDEuLi5cblxuLy8gMi4xMC4gTXVsdGltZWRpYSBLZXlzXG5cbi8vIC0gQ2hhbm5lbERvd25cbi8vIC0gQ2hhbm5lbFVwXG5hZGRTdGFuZGFyZChcIkNsb3NlXCIsIEtleVRhYmxlLlhGODZYS19DbG9zZSk7XG5hZGRTdGFuZGFyZChcIk1haWxGb3J3YXJkXCIsIEtleVRhYmxlLlhGODZYS19NYWlsRm9yd2FyZCk7XG5hZGRTdGFuZGFyZChcIk1haWxSZXBseVwiLCBLZXlUYWJsZS5YRjg2WEtfUmVwbHkpO1xuYWRkU3RhbmRhcmQoXCJNYWluU2VuZFwiLCBLZXlUYWJsZS5YRjg2WEtfU2VuZCk7XG5hZGRTdGFuZGFyZChcIk1lZGlhRmFzdEZvcndhcmRcIiwgS2V5VGFibGUuWEY4NlhLX0F1ZGlvRm9yd2FyZCk7XG5hZGRTdGFuZGFyZChcIk1lZGlhUGF1c2VcIiwgS2V5VGFibGUuWEY4NlhLX0F1ZGlvUGF1c2UpO1xuYWRkU3RhbmRhcmQoXCJNZWRpYVBsYXlcIiwgS2V5VGFibGUuWEY4NlhLX0F1ZGlvUGxheSk7XG5hZGRTdGFuZGFyZChcIk1lZGlhUmVjb3JkXCIsIEtleVRhYmxlLlhGODZYS19BdWRpb1JlY29yZCk7XG5hZGRTdGFuZGFyZChcIk1lZGlhUmV3aW5kXCIsIEtleVRhYmxlLlhGODZYS19BdWRpb1Jld2luZCk7XG5hZGRTdGFuZGFyZChcIk1lZGlhU3RvcFwiLCBLZXlUYWJsZS5YRjg2WEtfQXVkaW9TdG9wKTtcbmFkZFN0YW5kYXJkKFwiTWVkaWFUcmFja05leHRcIiwgS2V5VGFibGUuWEY4NlhLX0F1ZGlvTmV4dCk7XG5hZGRTdGFuZGFyZChcIk1lZGlhVHJhY2tQcmV2aW91c1wiLCBLZXlUYWJsZS5YRjg2WEtfQXVkaW9QcmV2KTtcbmFkZFN0YW5kYXJkKFwiTmV3XCIsIEtleVRhYmxlLlhGODZYS19OZXcpO1xuYWRkU3RhbmRhcmQoXCJPcGVuXCIsIEtleVRhYmxlLlhGODZYS19PcGVuKTtcbmFkZFN0YW5kYXJkKFwiUHJpbnRcIiwgS2V5VGFibGUuWEtfUHJpbnQpO1xuYWRkU3RhbmRhcmQoXCJTYXZlXCIsIEtleVRhYmxlLlhGODZYS19TYXZlKTtcbmFkZFN0YW5kYXJkKFwiU3BlbGxDaGVja1wiLCBLZXlUYWJsZS5YRjg2WEtfU3BlbGwpO1xuXG4vLyAyLjExLiBNdWx0aW1lZGlhIE51bXBhZCBLZXlzXG5cbi8vIC0gS2V5MTFcbi8vIC0gS2V5MTJcblxuLy8gMi4xMi4gQXVkaW8gS2V5c1xuXG4vLyAtIEF1ZGlvQmFsYW5jZUxlZnRcbi8vIC0gQXVkaW9CYWxhbmNlUmlnaHRcbi8vIC0gQXVkaW9CYXNzRG93blxuLy8gLSBBdWRpb0Jhc3NCb29zdERvd25cbi8vIC0gQXVkaW9CYXNzQm9vc3RUb2dnbGVcbi8vIC0gQXVkaW9CYXNzQm9vc3RVcFxuLy8gLSBBdWRpb0Jhc3NVcFxuLy8gLSBBdWRpb0ZhZGVyRnJvbnRcbi8vIC0gQXVkaW9GYWRlclJlYXJcbi8vIC0gQXVkaW9TdXJyb3VuZE1vZGVOZXh0XG4vLyAtIEF1ZGlvVHJlYmxlRG93blxuLy8gLSBBdWRpb1RyZWJsZVVwXG5hZGRTdGFuZGFyZChcIkF1ZGlvVm9sdW1lRG93blwiLCBLZXlUYWJsZS5YRjg2WEtfQXVkaW9Mb3dlclZvbHVtZSk7XG5hZGRTdGFuZGFyZChcIkF1ZGlvVm9sdW1lVXBcIiwgS2V5VGFibGUuWEY4NlhLX0F1ZGlvUmFpc2VWb2x1bWUpO1xuYWRkU3RhbmRhcmQoXCJBdWRpb1ZvbHVtZU11dGVcIiwgS2V5VGFibGUuWEY4NlhLX0F1ZGlvTXV0ZSk7XG4vLyAtIE1pY3JvcGhvbmVUb2dnbGVcbi8vIC0gTWljcm9waG9uZVZvbHVtZURvd25cbi8vIC0gTWljcm9waG9uZVZvbHVtZVVwXG5hZGRTdGFuZGFyZChcIk1pY3JvcGhvbmVWb2x1bWVNdXRlXCIsIEtleVRhYmxlLlhGODZYS19BdWRpb01pY011dGUpO1xuXG4vLyAyLjEzLiBTcGVlY2ggS2V5c1xuXG4vLyAtIFNwZWVjaENvcnJlY3Rpb25MaXN0XG4vLyAtIFNwZWVjaElucHV0VG9nZ2xlXG5cbi8vIDIuMTQuIEFwcGxpY2F0aW9uIEtleXNcblxuYWRkU3RhbmRhcmQoXCJMYXVuY2hDYWxjdWxhdG9yXCIsIEtleVRhYmxlLlhGODZYS19DYWxjdWxhdG9yKTtcbmFkZFN0YW5kYXJkKFwiTGF1bmNoQ2FsZW5kYXJcIiwgS2V5VGFibGUuWEY4NlhLX0NhbGVuZGFyKTtcbmFkZFN0YW5kYXJkKFwiTGF1bmNoTWFpbFwiLCBLZXlUYWJsZS5YRjg2WEtfTWFpbCk7XG5hZGRTdGFuZGFyZChcIkxhdW5jaE1lZGlhUGxheWVyXCIsIEtleVRhYmxlLlhGODZYS19BdWRpb01lZGlhKTtcbmFkZFN0YW5kYXJkKFwiTGF1bmNoTXVzaWNQbGF5ZXJcIiwgS2V5VGFibGUuWEY4NlhLX011c2ljKTtcbmFkZFN0YW5kYXJkKFwiTGF1bmNoTXlDb21wdXRlclwiLCBLZXlUYWJsZS5YRjg2WEtfTXlDb21wdXRlcik7XG5hZGRTdGFuZGFyZChcIkxhdW5jaFBob25lXCIsIEtleVRhYmxlLlhGODZYS19QaG9uZSk7XG5hZGRTdGFuZGFyZChcIkxhdW5jaFNjcmVlblNhdmVyXCIsIEtleVRhYmxlLlhGODZYS19TY3JlZW5TYXZlcik7XG5hZGRTdGFuZGFyZChcIkxhdW5jaFNwcmVhZHNoZWV0XCIsIEtleVRhYmxlLlhGODZYS19FeGNlbCk7XG5hZGRTdGFuZGFyZChcIkxhdW5jaFdlYkJyb3dzZXJcIiwgS2V5VGFibGUuWEY4NlhLX1dXVyk7XG5hZGRTdGFuZGFyZChcIkxhdW5jaFdlYkNhbVwiLCBLZXlUYWJsZS5YRjg2WEtfV2ViQ2FtKTtcbmFkZFN0YW5kYXJkKFwiTGF1bmNoV29yZFByb2Nlc3NvclwiLCBLZXlUYWJsZS5YRjg2WEtfV29yZCk7XG5cbi8vIDIuMTUuIEJyb3dzZXIgS2V5c1xuXG5hZGRTdGFuZGFyZChcIkJyb3dzZXJCYWNrXCIsIEtleVRhYmxlLlhGODZYS19CYWNrKTtcbmFkZFN0YW5kYXJkKFwiQnJvd3NlckZhdm9yaXRlc1wiLCBLZXlUYWJsZS5YRjg2WEtfRmF2b3JpdGVzKTtcbmFkZFN0YW5kYXJkKFwiQnJvd3NlckZvcndhcmRcIiwgS2V5VGFibGUuWEY4NlhLX0ZvcndhcmQpO1xuYWRkU3RhbmRhcmQoXCJCcm93c2VySG9tZVwiLCBLZXlUYWJsZS5YRjg2WEtfSG9tZVBhZ2UpO1xuYWRkU3RhbmRhcmQoXCJCcm93c2VyUmVmcmVzaFwiLCBLZXlUYWJsZS5YRjg2WEtfUmVmcmVzaCk7XG5hZGRTdGFuZGFyZChcIkJyb3dzZXJTZWFyY2hcIiwgS2V5VGFibGUuWEY4NlhLX1NlYXJjaCk7XG5hZGRTdGFuZGFyZChcIkJyb3dzZXJTdG9wXCIsIEtleVRhYmxlLlhGODZYS19TdG9wKTtcblxuLy8gMi4xNi4gTW9iaWxlIFBob25lIEtleXNcblxuLy8gLSBBIHdob2xlIGJ1bmNoLi4uXG5cbi8vIDIuMTcuIFRWIEtleXNcblxuLy8gLSBBIHdob2xlIGJ1bmNoLi4uXG5cbi8vIDIuMTguIE1lZGlhIENvbnRyb2xsZXIgS2V5c1xuXG4vLyAtIEEgd2hvbGUgYnVuY2guLi5cbmFkZFN0YW5kYXJkKFwiRGltbWVyXCIsIEtleVRhYmxlLlhGODZYS19CcmlnaHRuZXNzQWRqdXN0KTtcbmFkZFN0YW5kYXJkKFwiTWVkaWFBdWRpb1RyYWNrXCIsIEtleVRhYmxlLlhGODZYS19BdWRpb0N5Y2xlVHJhY2spO1xuYWRkU3RhbmRhcmQoXCJSYW5kb21Ub2dnbGVcIiwgS2V5VGFibGUuWEY4NlhLX0F1ZGlvUmFuZG9tUGxheSk7XG5hZGRTdGFuZGFyZChcIlNwbGl0U2NyZWVuVG9nZ2xlXCIsIEtleVRhYmxlLlhGODZYS19TcGxpdFNjcmVlbik7XG5hZGRTdGFuZGFyZChcIlN1YnRpdGxlXCIsIEtleVRhYmxlLlhGODZYS19TdWJ0aXRsZSk7XG5hZGRTdGFuZGFyZChcIlZpZGVvTW9kZU5leHRcIiwgS2V5VGFibGUuWEY4NlhLX05leHRfVk1vZGUpO1xuXG4vLyBFeHRyYTogTnVtcGFkXG5cbmFkZE51bXBhZChcIj1cIiwgS2V5VGFibGUuWEtfZXF1YWwsIEtleVRhYmxlLlhLX0tQX0VxdWFsKTtcbmFkZE51bXBhZChcIitcIiwgS2V5VGFibGUuWEtfcGx1cywgS2V5VGFibGUuWEtfS1BfQWRkKTtcbmFkZE51bXBhZChcIi1cIiwgS2V5VGFibGUuWEtfbWludXMsIEtleVRhYmxlLlhLX0tQX1N1YnRyYWN0KTtcbmFkZE51bXBhZChcIipcIiwgS2V5VGFibGUuWEtfYXN0ZXJpc2ssIEtleVRhYmxlLlhLX0tQX011bHRpcGx5KTtcbmFkZE51bXBhZChcIi9cIiwgS2V5VGFibGUuWEtfc2xhc2gsIEtleVRhYmxlLlhLX0tQX0RpdmlkZSk7XG5hZGROdW1wYWQoXCIuXCIsIEtleVRhYmxlLlhLX3BlcmlvZCwgS2V5VGFibGUuWEtfS1BfRGVjaW1hbCk7XG5hZGROdW1wYWQoXCIsXCIsIEtleVRhYmxlLlhLX2NvbW1hLCBLZXlUYWJsZS5YS19LUF9TZXBhcmF0b3IpO1xuYWRkTnVtcGFkKFwiMFwiLCBLZXlUYWJsZS5YS18wLCBLZXlUYWJsZS5YS19LUF8wKTtcbmFkZE51bXBhZChcIjFcIiwgS2V5VGFibGUuWEtfMSwgS2V5VGFibGUuWEtfS1BfMSk7XG5hZGROdW1wYWQoXCIyXCIsIEtleVRhYmxlLlhLXzIsIEtleVRhYmxlLlhLX0tQXzIpO1xuYWRkTnVtcGFkKFwiM1wiLCBLZXlUYWJsZS5YS18zLCBLZXlUYWJsZS5YS19LUF8zKTtcbmFkZE51bXBhZChcIjRcIiwgS2V5VGFibGUuWEtfNCwgS2V5VGFibGUuWEtfS1BfNCk7XG5hZGROdW1wYWQoXCI1XCIsIEtleVRhYmxlLlhLXzUsIEtleVRhYmxlLlhLX0tQXzUpO1xuYWRkTnVtcGFkKFwiNlwiLCBLZXlUYWJsZS5YS182LCBLZXlUYWJsZS5YS19LUF82KTtcbmFkZE51bXBhZChcIjdcIiwgS2V5VGFibGUuWEtfNywgS2V5VGFibGUuWEtfS1BfNyk7XG5hZGROdW1wYWQoXCI4XCIsIEtleVRhYmxlLlhLXzgsIEtleVRhYmxlLlhLX0tQXzgpO1xuYWRkTnVtcGFkKFwiOVwiLCBLZXlUYWJsZS5YS185LCBLZXlUYWJsZS5YS19LUF85KTtcblxuZXhwb3J0IGRlZmF1bHQgRE9NS2V5VGFibGU7XG4iLCIvKlxuICogbm9WTkM6IEhUTUw1IFZOQyBjbGllbnRcbiAqIENvcHlyaWdodCAoQykgMjAxOCBUaGUgbm9WTkMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgTVBMIDIuMCBvciBhbnkgbGF0ZXIgdmVyc2lvbiAoc2VlIExJQ0VOU0UudHh0KVxuICovXG5cbi8qXG4gKiBGYWxsYmFjayBtYXBwaW5nIGJldHdlZW4gSFRNTCBrZXkgY29kZXMgKHBoeXNpY2FsIGtleXMpIGFuZFxuICogSFRNTCBrZXkgdmFsdWVzLiBUaGlzIG9ubHkgd29ya3MgZm9yIGtleXMgdGhhdCBkb24ndCB2YXJ5XG4gKiBiZXR3ZWVuIGxheW91dHMuIFdlIGFsc28gb21pdCB0aG9zZSB3aG8gbWFuYWdlIGZpbmUgYnkgbWFwcGluZyB0aGVcbiAqIFVuaWNvZGUgcmVwcmVzZW50YXRpb24uXG4gKlxuICogU2VlIGh0dHBzOi8vd3d3LnczLm9yZy9UUi91aWV2ZW50cy1jb2RlLyBmb3IgcG9zc2libGUgY29kZXMuXG4gKiBTZWUgaHR0cHM6Ly93d3cudzMub3JnL1RSL3VpZXZlbnRzLWtleS8gZm9yIHBvc3NpYmxlIHZhbHVlcy5cbiAqL1xuXG4vKiBlc2xpbnQtZGlzYWJsZSBrZXktc3BhY2luZyAqL1xuXG5leHBvcnQgZGVmYXVsdCB7XG5cbi8vIDMuMS4xLjEuIFdyaXRpbmcgU3lzdGVtIEtleXNcblxuICAgICdCYWNrc3BhY2UnOiAgICAgICAgJ0JhY2tzcGFjZScsXG5cbi8vIDMuMS4xLjIuIEZ1bmN0aW9uYWwgS2V5c1xuXG4gICAgJ0FsdExlZnQnOiAgICAgICAgICAnQWx0JyxcbiAgICAnQWx0UmlnaHQnOiAgICAgICAgICdBbHQnLCAvLyBUaGlzIGNvdWxkIGFsc28gYmUgJ0FsdEdyYXBoJ1xuICAgICdDYXBzTG9jayc6ICAgICAgICAgJ0NhcHNMb2NrJyxcbiAgICAnQ29udGV4dE1lbnUnOiAgICAgICdDb250ZXh0TWVudScsXG4gICAgJ0NvbnRyb2xMZWZ0JzogICAgICAnQ29udHJvbCcsXG4gICAgJ0NvbnRyb2xSaWdodCc6ICAgICAnQ29udHJvbCcsXG4gICAgJ0VudGVyJzogICAgICAgICAgICAnRW50ZXInLFxuICAgICdNZXRhTGVmdCc6ICAgICAgICAgJ01ldGEnLFxuICAgICdNZXRhUmlnaHQnOiAgICAgICAgJ01ldGEnLFxuICAgICdTaGlmdExlZnQnOiAgICAgICAgJ1NoaWZ0JyxcbiAgICAnU2hpZnRSaWdodCc6ICAgICAgICdTaGlmdCcsXG4gICAgJ1RhYic6ICAgICAgICAgICAgICAnVGFiJyxcbiAgICAvLyBGSVhNRTogSmFwYW5lc2UvS29yZWFuIGtleXNcblxuLy8gMy4xLjIuIENvbnRyb2wgUGFkIFNlY3Rpb25cblxuICAgICdEZWxldGUnOiAgICAgICAgICAgJ0RlbGV0ZScsXG4gICAgJ0VuZCc6ICAgICAgICAgICAgICAnRW5kJyxcbiAgICAnSGVscCc6ICAgICAgICAgICAgICdIZWxwJyxcbiAgICAnSG9tZSc6ICAgICAgICAgICAgICdIb21lJyxcbiAgICAnSW5zZXJ0JzogICAgICAgICAgICdJbnNlcnQnLFxuICAgICdQYWdlRG93bic6ICAgICAgICAgJ1BhZ2VEb3duJyxcbiAgICAnUGFnZVVwJzogICAgICAgICAgICdQYWdlVXAnLFxuXG4vLyAzLjEuMy4gQXJyb3cgUGFkIFNlY3Rpb25cblxuICAgICdBcnJvd0Rvd24nOiAgICAgICAgJ0Fycm93RG93bicsXG4gICAgJ0Fycm93TGVmdCc6ICAgICAgICAnQXJyb3dMZWZ0JyxcbiAgICAnQXJyb3dSaWdodCc6ICAgICAgICdBcnJvd1JpZ2h0JyxcbiAgICAnQXJyb3dVcCc6ICAgICAgICAgICdBcnJvd1VwJyxcblxuLy8gMy4xLjQuIE51bXBhZCBTZWN0aW9uXG5cbiAgICAnTnVtTG9jayc6ICAgICAgICAgICdOdW1Mb2NrJyxcbiAgICAnTnVtcGFkQmFja3NwYWNlJzogICdCYWNrc3BhY2UnLFxuICAgICdOdW1wYWRDbGVhcic6ICAgICAgJ0NsZWFyJyxcblxuLy8gMy4xLjUuIEZ1bmN0aW9uIFNlY3Rpb25cblxuICAgICdFc2NhcGUnOiAgICAgICAgICAgJ0VzY2FwZScsXG4gICAgJ0YxJzogICAgICAgICAgICAgICAnRjEnLFxuICAgICdGMic6ICAgICAgICAgICAgICAgJ0YyJyxcbiAgICAnRjMnOiAgICAgICAgICAgICAgICdGMycsXG4gICAgJ0Y0JzogICAgICAgICAgICAgICAnRjQnLFxuICAgICdGNSc6ICAgICAgICAgICAgICAgJ0Y1JyxcbiAgICAnRjYnOiAgICAgICAgICAgICAgICdGNicsXG4gICAgJ0Y3JzogICAgICAgICAgICAgICAnRjcnLFxuICAgICdGOCc6ICAgICAgICAgICAgICAgJ0Y4JyxcbiAgICAnRjknOiAgICAgICAgICAgICAgICdGOScsXG4gICAgJ0YxMCc6ICAgICAgICAgICAgICAnRjEwJyxcbiAgICAnRjExJzogICAgICAgICAgICAgICdGMTEnLFxuICAgICdGMTInOiAgICAgICAgICAgICAgJ0YxMicsXG4gICAgJ0YxMyc6ICAgICAgICAgICAgICAnRjEzJyxcbiAgICAnRjE0JzogICAgICAgICAgICAgICdGMTQnLFxuICAgICdGMTUnOiAgICAgICAgICAgICAgJ0YxNScsXG4gICAgJ0YxNic6ICAgICAgICAgICAgICAnRjE2JyxcbiAgICAnRjE3JzogICAgICAgICAgICAgICdGMTcnLFxuICAgICdGMTgnOiAgICAgICAgICAgICAgJ0YxOCcsXG4gICAgJ0YxOSc6ICAgICAgICAgICAgICAnRjE5JyxcbiAgICAnRjIwJzogICAgICAgICAgICAgICdGMjAnLFxuICAgICdGMjEnOiAgICAgICAgICAgICAgJ0YyMScsXG4gICAgJ0YyMic6ICAgICAgICAgICAgICAnRjIyJyxcbiAgICAnRjIzJzogICAgICAgICAgICAgICdGMjMnLFxuICAgICdGMjQnOiAgICAgICAgICAgICAgJ0YyNCcsXG4gICAgJ0YyNSc6ICAgICAgICAgICAgICAnRjI1JyxcbiAgICAnRjI2JzogICAgICAgICAgICAgICdGMjYnLFxuICAgICdGMjcnOiAgICAgICAgICAgICAgJ0YyNycsXG4gICAgJ0YyOCc6ICAgICAgICAgICAgICAnRjI4JyxcbiAgICAnRjI5JzogICAgICAgICAgICAgICdGMjknLFxuICAgICdGMzAnOiAgICAgICAgICAgICAgJ0YzMCcsXG4gICAgJ0YzMSc6ICAgICAgICAgICAgICAnRjMxJyxcbiAgICAnRjMyJzogICAgICAgICAgICAgICdGMzInLFxuICAgICdGMzMnOiAgICAgICAgICAgICAgJ0YzMycsXG4gICAgJ0YzNCc6ICAgICAgICAgICAgICAnRjM0JyxcbiAgICAnRjM1JzogICAgICAgICAgICAgICdGMzUnLFxuICAgICdQcmludFNjcmVlbic6ICAgICAgJ1ByaW50U2NyZWVuJyxcbiAgICAnU2Nyb2xsTG9jayc6ICAgICAgICdTY3JvbGxMb2NrJyxcbiAgICAnUGF1c2UnOiAgICAgICAgICAgICdQYXVzZScsXG5cbi8vIDMuMS42LiBNZWRpYSBLZXlzXG5cbiAgICAnQnJvd3NlckJhY2snOiAgICAgICdCcm93c2VyQmFjaycsXG4gICAgJ0Jyb3dzZXJGYXZvcml0ZXMnOiAnQnJvd3NlckZhdm9yaXRlcycsXG4gICAgJ0Jyb3dzZXJGb3J3YXJkJzogICAnQnJvd3NlckZvcndhcmQnLFxuICAgICdCcm93c2VySG9tZSc6ICAgICAgJ0Jyb3dzZXJIb21lJyxcbiAgICAnQnJvd3NlclJlZnJlc2gnOiAgICdCcm93c2VyUmVmcmVzaCcsXG4gICAgJ0Jyb3dzZXJTZWFyY2gnOiAgICAnQnJvd3NlclNlYXJjaCcsXG4gICAgJ0Jyb3dzZXJTdG9wJzogICAgICAnQnJvd3NlclN0b3AnLFxuICAgICdFamVjdCc6ICAgICAgICAgICAgJ0VqZWN0JyxcbiAgICAnTGF1bmNoQXBwMSc6ICAgICAgICdMYXVuY2hNeUNvbXB1dGVyJyxcbiAgICAnTGF1bmNoQXBwMic6ICAgICAgICdMYXVuY2hDYWxlbmRhcicsXG4gICAgJ0xhdW5jaE1haWwnOiAgICAgICAnTGF1bmNoTWFpbCcsXG4gICAgJ01lZGlhUGxheVBhdXNlJzogICAnTWVkaWFQbGF5JyxcbiAgICAnTWVkaWFTdG9wJzogICAgICAgICdNZWRpYVN0b3AnLFxuICAgICdNZWRpYVRyYWNrTmV4dCc6ICAgJ01lZGlhVHJhY2tOZXh0JyxcbiAgICAnTWVkaWFUcmFja1ByZXZpb3VzJzogJ01lZGlhVHJhY2tQcmV2aW91cycsXG4gICAgJ1Bvd2VyJzogICAgICAgICAgICAnUG93ZXInLFxuICAgICdTbGVlcCc6ICAgICAgICAgICAgJ1NsZWVwJyxcbiAgICAnQXVkaW9Wb2x1bWVEb3duJzogICdBdWRpb1ZvbHVtZURvd24nLFxuICAgICdBdWRpb1ZvbHVtZU11dGUnOiAgJ0F1ZGlvVm9sdW1lTXV0ZScsXG4gICAgJ0F1ZGlvVm9sdW1lVXAnOiAgICAnQXVkaW9Wb2x1bWVVcCcsXG4gICAgJ1dha2VVcCc6ICAgICAgICAgICAnV2FrZVVwJyxcbn07XG4iLCIvKlxuICogbm9WTkM6IEhUTUw1IFZOQyBjbGllbnRcbiAqIENvcHlyaWdodCAoQykgMjAxOCBUaGUgbm9WTkMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgTVBMIDIuMCBvciBhbnkgbGF0ZXIgdmVyc2lvbiAoc2VlIExJQ0VOU0UudHh0KVxuICovXG5cbmltcG9ydCAqIGFzIExvZyBmcm9tICcuLi91dGlsL2xvZ2dpbmcuanMnO1xuaW1wb3J0IHsgc3RvcEV2ZW50IH0gZnJvbSAnLi4vdXRpbC9ldmVudHMuanMnO1xuaW1wb3J0ICogYXMgS2V5Ym9hcmRVdGlsIGZyb20gXCIuL3V0aWwuanNcIjtcbmltcG9ydCBLZXlUYWJsZSBmcm9tIFwiLi9rZXlzeW0uanNcIjtcbmltcG9ydCAqIGFzIGJyb3dzZXIgZnJvbSBcIi4uL3V0aWwvYnJvd3Nlci5qc1wiO1xuXG4vL1xuLy8gS2V5Ym9hcmQgZXZlbnQgaGFuZGxlclxuLy9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2V5Ym9hcmQge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCkge1xuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQgfHwgbnVsbDtcblxuICAgICAgICB0aGlzLl9rZXlEb3duTGlzdCA9IHt9OyAgICAgICAgIC8vIExpc3Qgb2YgZGVwcmVzc2VkIGtleXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyAoZXZlbiBpZiB0aGV5IGFyZSBoYXBweSlcbiAgICAgICAgdGhpcy5fcGVuZGluZ0tleSA9IG51bGw7ICAgICAgICAvLyBLZXkgd2FpdGluZyBmb3Iga2V5cHJlc3NcbiAgICAgICAgdGhpcy5fYWx0R3JBcm1lZCA9IGZhbHNlOyAgICAgICAvLyBXaW5kb3dzIEFsdEdyIGRldGVjdGlvblxuXG4gICAgICAgIC8vIGtlZXAgdGhlc2UgaGVyZSBzbyB3ZSBjYW4gcmVmZXIgdG8gdGhlbSBsYXRlclxuICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXJzID0ge1xuICAgICAgICAgICAgJ2tleXVwJzogdGhpcy5faGFuZGxlS2V5VXAuYmluZCh0aGlzKSxcbiAgICAgICAgICAgICdrZXlkb3duJzogdGhpcy5faGFuZGxlS2V5RG93bi5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgJ2tleXByZXNzJzogdGhpcy5faGFuZGxlS2V5UHJlc3MuYmluZCh0aGlzKSxcbiAgICAgICAgICAgICdibHVyJzogdGhpcy5fYWxsS2V5c1VwLmJpbmQodGhpcyksXG4gICAgICAgICAgICAnY2hlY2thbHQnOiB0aGlzLl9jaGVja0FsdC5iaW5kKHRoaXMpLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vID09PT09IEVWRU5UIEhBTkRMRVJTID09PT09XG5cbiAgICAgICAgdGhpcy5vbmtleWV2ZW50ID0gKCkgPT4ge307IC8vIEhhbmRsZXIgZm9yIGtleSBwcmVzcy9yZWxlYXNlXG4gICAgfVxuXG4gICAgLy8gPT09PT0gUFJJVkFURSBNRVRIT0RTID09PT09XG5cbiAgICBfc2VuZEtleUV2ZW50KGtleXN5bSwgY29kZSwgZG93bikge1xuICAgICAgICBpZiAoZG93bikge1xuICAgICAgICAgICAgdGhpcy5fa2V5RG93bkxpc3RbY29kZV0gPSBrZXlzeW07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBEbyB3ZSByZWFsbHkgdGhpbmsgdGhpcyBrZXkgaXMgZG93bj9cbiAgICAgICAgICAgIGlmICghKGNvZGUgaW4gdGhpcy5fa2V5RG93bkxpc3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2tleURvd25MaXN0W2NvZGVdO1xuICAgICAgICB9XG5cbiAgICAgICAgTG9nLkRlYnVnKFwib25rZXlldmVudCBcIiArIChkb3duID8gXCJkb3duXCIgOiBcInVwXCIpICtcbiAgICAgICAgICAgICAgICAgIFwiLCBrZXlzeW06IFwiICsga2V5c3ltLCBcIiwgY29kZTogXCIgKyBjb2RlKTtcbiAgICAgICAgdGhpcy5vbmtleWV2ZW50KGtleXN5bSwgY29kZSwgZG93bik7XG4gICAgfVxuXG4gICAgX2dldEtleUNvZGUoZSkge1xuICAgICAgICBjb25zdCBjb2RlID0gS2V5Ym9hcmRVdGlsLmdldEtleWNvZGUoZSk7XG4gICAgICAgIGlmIChjb2RlICE9PSAnVW5pZGVudGlmaWVkJykge1xuICAgICAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBVbnN0YWJsZSwgYnV0IHdlIGRvbid0IGhhdmUgYW55dGhpbmcgZWxzZSB0byBnbyBvblxuICAgICAgICAvLyAoZG9uJ3QgdXNlIGl0IGZvciAna2V5cHJlc3MnIGV2ZW50cyB0aG91Z2h0IHNpbmNlXG4gICAgICAgIC8vIFdlYktpdCBzZXRzIGl0IHRvIHRoZSBzYW1lIGFzIGNoYXJDb2RlKVxuICAgICAgICBpZiAoZS5rZXlDb2RlICYmIChlLnR5cGUgIT09ICdrZXlwcmVzcycpKSB7XG4gICAgICAgICAgICAvLyAyMjkgaXMgdXNlZCBmb3IgY29tcG9zaXRpb24gZXZlbnRzXG4gICAgICAgICAgICBpZiAoZS5rZXlDb2RlICE9PSAyMjkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gJ1BsYXRmb3JtJyArIGUua2V5Q29kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEEgcHJlY3Vyc29yIHRvIHRoZSBmaW5hbCBET00zIHN0YW5kYXJkLiBVbmZvcnR1bmF0ZWx5IGl0XG4gICAgICAgIC8vIGlzIG5vdCBsYXlvdXQgaW5kZXBlbmRlbnQsIHNvIGl0IGlzIGFzIGJhZCBhcyB1c2luZyBrZXlDb2RlXG4gICAgICAgIGlmIChlLmtleUlkZW50aWZpZXIpIHtcbiAgICAgICAgICAgIC8vIE5vbi1jaGFyYWN0ZXIga2V5P1xuICAgICAgICAgICAgaWYgKGUua2V5SWRlbnRpZmllci5zdWJzdHIoMCwgMikgIT09ICdVKycpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZS5rZXlJZGVudGlmaWVyO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBjb2RlcG9pbnQgPSBwYXJzZUludChlLmtleUlkZW50aWZpZXIuc3Vic3RyKDIpLCAxNik7XG4gICAgICAgICAgICBjb25zdCBjaGFyID0gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlcG9pbnQpLnRvVXBwZXJDYXNlKCk7XG5cbiAgICAgICAgICAgIHJldHVybiAnUGxhdGZvcm0nICsgY2hhci5jaGFyQ29kZUF0KCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gJ1VuaWRlbnRpZmllZCc7XG4gICAgfVxuXG4gICAgX2hhbmRsZUtleURvd24oZSkge1xuICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5fZ2V0S2V5Q29kZShlKTtcbiAgICAgICAgbGV0IGtleXN5bSA9IEtleWJvYXJkVXRpbC5nZXRLZXlzeW0oZSk7XG5cbiAgICAgICAgLy8gV2luZG93cyBkb2Vzbid0IGhhdmUgYSBwcm9wZXIgQWx0R3IsIGJ1dCBoYW5kbGVzIGl0IHVzaW5nXG4gICAgICAgIC8vIGZha2UgQ3RybCtBbHQuIEhvd2V2ZXIgdGhlIHJlbW90ZSBlbmQgbWlnaHQgbm90IGJlIFdpbmRvd3MsXG4gICAgICAgIC8vIHNvIHdlIG5lZWQgdG8gbWVyZ2UgdGhvc2UgaW4gdG8gYSBzaW5nbGUgQWx0R3IgZXZlbnQuIFdlXG4gICAgICAgIC8vIGRldGVjdCB0aGlzIGNhc2UgYnkgc2VlaW5nIHRoZSB0d28ga2V5IGV2ZW50cyBkaXJlY3RseSBhZnRlclxuICAgICAgICAvLyBlYWNoIG90aGVyIHdpdGggYSB2ZXJ5IHNob3J0IHRpbWUgYmV0d2VlbiB0aGVtICg8NTBtcykuXG4gICAgICAgIGlmICh0aGlzLl9hbHRHckFybWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9hbHRHckFybWVkID0gZmFsc2U7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fYWx0R3JUaW1lb3V0KTtcblxuICAgICAgICAgICAgaWYgKChjb2RlID09PSBcIkFsdFJpZ2h0XCIpICYmXG4gICAgICAgICAgICAgICAgKChlLnRpbWVTdGFtcCAtIHRoaXMuX2FsdEdyQ3RybFRpbWUpIDwgNTApKSB7XG4gICAgICAgICAgICAgICAgLy8gRklYTUU6IFdlIGZhaWwgdG8gZGV0ZWN0IHRoaXMgaWYgZWl0aGVyIEN0cmwga2V5IGlzXG4gICAgICAgICAgICAgICAgLy8gICAgICAgIGZpcnN0IG1hbnVhbGx5IHByZXNzZWQgYXMgV2luZG93cyB0aGVuIG5vXG4gICAgICAgICAgICAgICAgLy8gICAgICAgIGxvbmdlciBzZW5kcyB0aGUgZmFrZSBDdHJsIGRvd24gZXZlbnQuIEl0XG4gICAgICAgICAgICAgICAgLy8gICAgICAgIGRvZXMgaG93ZXZlciBoYXBwaWx5IHNlbmQgcmVhbCBDdHJsIGV2ZW50c1xuICAgICAgICAgICAgICAgIC8vICAgICAgICBldmVuIHdoZW4gQWx0R3IgaXMgYWxyZWFkeSBkb3duLiBTb21lXG4gICAgICAgICAgICAgICAgLy8gICAgICAgIGJyb3dzZXJzIGRldGVjdCB0aGlzIGZvciB1cyB0aG91Z2ggYW5kIHNldCB0aGVcbiAgICAgICAgICAgICAgICAvLyAgICAgICAga2V5IHRvIFwiQWx0R3JhcGhcIi5cbiAgICAgICAgICAgICAgICBrZXlzeW0gPSBLZXlUYWJsZS5YS19JU09fTGV2ZWwzX1NoaWZ0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZW5kS2V5RXZlbnQoS2V5VGFibGUuWEtfQ29udHJvbF9MLCBcIkNvbnRyb2xMZWZ0XCIsIHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gV2UgY2Fubm90IGhhbmRsZSBrZXlzIHdlIGNhbm5vdCB0cmFjaywgYnV0IHdlIGFsc28gbmVlZFxuICAgICAgICAvLyB0byBkZWFsIHdpdGggdmlydHVhbCBrZXlib2FyZHMgd2hpY2ggb21pdCBrZXkgaW5mb1xuICAgICAgICAvLyAoaU9TIG9taXRzIHRyYWNraW5nIGluZm8gb24ga2V5dXAgZXZlbnRzLCB3aGljaCBmb3JjZXMgdXMgdG9cbiAgICAgICAgLy8gc3BlY2lhbCB0cmVhdCB0aGF0IHBsYXRmb3JtIGhlcmUpXG4gICAgICAgIGlmICgoY29kZSA9PT0gJ1VuaWRlbnRpZmllZCcpIHx8IGJyb3dzZXIuaXNJT1MoKSkge1xuICAgICAgICAgICAgaWYgKGtleXN5bSkge1xuICAgICAgICAgICAgICAgIC8vIElmIGl0J3MgYSB2aXJ0dWFsIGtleWJvYXJkIHRoZW4gaXQgc2hvdWxkIGJlXG4gICAgICAgICAgICAgICAgLy8gc3VmZmljaWVudCB0byBqdXN0IHNlbmQgcHJlc3MgYW5kIHJlbGVhc2UgcmlnaHRcbiAgICAgICAgICAgICAgICAvLyBhZnRlciBlYWNoIG90aGVyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2VuZEtleUV2ZW50KGtleXN5bSwgY29kZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VuZEtleUV2ZW50KGtleXN5bSwgY29kZSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzdG9wRXZlbnQoZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBbHQgYmVoYXZlcyBtb3JlIGxpa2UgQWx0R3JhcGggb24gbWFjT1MsIHNvIHNodWZmbGUgdGhlXG4gICAgICAgIC8vIGtleXMgYXJvdW5kIGEgYml0IHRvIG1ha2UgdGhpbmdzIG1vcmUgc2FuZSBmb3IgdGhlIHJlbW90ZVxuICAgICAgICAvLyBzZXJ2ZXIuIFRoaXMgbWV0aG9kIGlzIHVzZWQgYnkgUmVhbFZOQyBhbmQgVGlnZXJWTkMgKGFuZFxuICAgICAgICAvLyBwb3NzaWJseSBvdGhlcnMpLlxuICAgICAgICBpZiAoYnJvd3Nlci5pc01hYygpKSB7XG4gICAgICAgICAgICBzd2l0Y2ggKGtleXN5bSkge1xuICAgICAgICAgICAgICAgIGNhc2UgS2V5VGFibGUuWEtfU3VwZXJfTDpcbiAgICAgICAgICAgICAgICAgICAga2V5c3ltID0gS2V5VGFibGUuWEtfQWx0X0w7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgS2V5VGFibGUuWEtfU3VwZXJfUjpcbiAgICAgICAgICAgICAgICAgICAga2V5c3ltID0gS2V5VGFibGUuWEtfU3VwZXJfTDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBLZXlUYWJsZS5YS19BbHRfTDpcbiAgICAgICAgICAgICAgICAgICAga2V5c3ltID0gS2V5VGFibGUuWEtfTW9kZV9zd2l0Y2g7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgS2V5VGFibGUuWEtfQWx0X1I6XG4gICAgICAgICAgICAgICAgICAgIGtleXN5bSA9IEtleVRhYmxlLlhLX0lTT19MZXZlbDNfU2hpZnQ7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gSXMgdGhpcyBrZXkgYWxyZWFkeSBwcmVzc2VkPyBJZiBzbywgdGhlbiB3ZSBtdXN0IHVzZSB0aGVcbiAgICAgICAgLy8gc2FtZSBrZXlzeW0gb3Igd2UnbGwgY29uZnVzZSB0aGUgc2VydmVyXG4gICAgICAgIGlmIChjb2RlIGluIHRoaXMuX2tleURvd25MaXN0KSB7XG4gICAgICAgICAgICBrZXlzeW0gPSB0aGlzLl9rZXlEb3duTGlzdFtjb2RlXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIG1hY09TIGRvZXNuJ3Qgc2VuZCBwcm9wZXIga2V5IGV2ZW50cyBmb3IgbW9kaWZpZXJzLCBvbmx5XG4gICAgICAgIC8vIHN0YXRlIGNoYW5nZSBldmVudHMuIFRoYXQgZ2V0cyBleHRyYSBjb25mdXNpbmcgZm9yIENhcHNMb2NrXG4gICAgICAgIC8vIHdoaWNoIHRvZ2dsZXMgb24gZWFjaCBwcmVzcywgYnV0IG5vdCBvbiByZWxlYXNlLiBTbyBwcmV0ZW5kXG4gICAgICAgIC8vIGl0IHdhcyBhIHF1aWNrIHByZXNzIGFuZCByZWxlYXNlIG9mIHRoZSBidXR0b24uXG4gICAgICAgIGlmIChicm93c2VyLmlzTWFjKCkgJiYgKGNvZGUgPT09ICdDYXBzTG9jaycpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZW5kS2V5RXZlbnQoS2V5VGFibGUuWEtfQ2Fwc19Mb2NrLCAnQ2Fwc0xvY2snLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRLZXlFdmVudChLZXlUYWJsZS5YS19DYXBzX0xvY2ssICdDYXBzTG9jaycsIGZhbHNlKTtcbiAgICAgICAgICAgIHN0b3BFdmVudChlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElmIHRoaXMgaXMgYSBsZWdhY3kgYnJvd3NlciB0aGVuIHdlJ2xsIG5lZWQgdG8gd2FpdCBmb3JcbiAgICAgICAgLy8gYSBrZXlwcmVzcyBldmVudCBhcyB3ZWxsXG4gICAgICAgIC8vIChJRSBhbmQgRWRnZSBoYXMgYSBicm9rZW4gS2V5Ym9hcmRFdmVudC5rZXksIHNvIHdlIGNhbid0XG4gICAgICAgIC8vIGp1c3QgY2hlY2sgZm9yIHRoZSBwcmVzZW5jZSBvZiB0aGF0IGZpZWxkKVxuICAgICAgICBpZiAoIWtleXN5bSAmJiAoIWUua2V5IHx8IGJyb3dzZXIuaXNJRSgpIHx8IGJyb3dzZXIuaXNFZGdlKCkpKSB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nS2V5ID0gY29kZTtcbiAgICAgICAgICAgIC8vIEhvd2V2ZXIgd2UgbWlnaHQgbm90IGdldCBhIGtleXByZXNzIGV2ZW50IGlmIHRoZSBrZXlcbiAgICAgICAgICAgIC8vIGlzIG5vbi1wcmludGFibGUsIHdoaWNoIG5lZWRzIHNvbWUgc3BlY2lhbCBmYWxsYmFja1xuICAgICAgICAgICAgLy8gaGFuZGxpbmdcbiAgICAgICAgICAgIHNldFRpbWVvdXQodGhpcy5faGFuZGxlS2V5UHJlc3NUaW1lb3V0LmJpbmQodGhpcyksIDEwLCBlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3BlbmRpbmdLZXkgPSBudWxsO1xuICAgICAgICBzdG9wRXZlbnQoZSk7XG5cbiAgICAgICAgLy8gUG9zc2libGUgc3RhcnQgb2YgQWx0R3Igc2VxdWVuY2U/IChzZWUgYWJvdmUpXG4gICAgICAgIGlmICgoY29kZSA9PT0gXCJDb250cm9sTGVmdFwiKSAmJiBicm93c2VyLmlzV2luZG93cygpICYmXG4gICAgICAgICAgICAhKFwiQ29udHJvbExlZnRcIiBpbiB0aGlzLl9rZXlEb3duTGlzdCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2FsdEdyQXJtZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fYWx0R3JUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl9oYW5kbGVBbHRHclRpbWVvdXQuYmluZCh0aGlzKSwgMTAwKTtcbiAgICAgICAgICAgIHRoaXMuX2FsdEdyQ3RybFRpbWUgPSBlLnRpbWVTdGFtcDtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NlbmRLZXlFdmVudChrZXlzeW0sIGNvZGUsIHRydWUpO1xuICAgIH1cblxuICAgIC8vIExlZ2FjeSBldmVudCBmb3IgYnJvd3NlcnMgd2l0aG91dCBjb2RlL2tleVxuICAgIF9oYW5kbGVLZXlQcmVzcyhlKSB7XG4gICAgICAgIHN0b3BFdmVudChlKTtcblxuICAgICAgICAvLyBBcmUgd2UgZXhwZWN0aW5nIGEga2V5cHJlc3M/XG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nS2V5ID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgY29kZSA9IHRoaXMuX2dldEtleUNvZGUoZSk7XG4gICAgICAgIGNvbnN0IGtleXN5bSA9IEtleWJvYXJkVXRpbC5nZXRLZXlzeW0oZSk7XG5cbiAgICAgICAgLy8gVGhlIGtleSB3ZSB3ZXJlIHdhaXRpbmcgZm9yP1xuICAgICAgICBpZiAoKGNvZGUgIT09ICdVbmlkZW50aWZpZWQnKSAmJiAoY29kZSAhPSB0aGlzLl9wZW5kaW5nS2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29kZSA9IHRoaXMuX3BlbmRpbmdLZXk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdLZXkgPSBudWxsO1xuXG4gICAgICAgIGlmICgha2V5c3ltKSB7XG4gICAgICAgICAgICBMb2cuSW5mbygna2V5cHJlc3Mgd2l0aCBubyBrZXlzeW06JywgZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9zZW5kS2V5RXZlbnQoa2V5c3ltLCBjb2RlLCB0cnVlKTtcbiAgICB9XG5cbiAgICBfaGFuZGxlS2V5UHJlc3NUaW1lb3V0KGUpIHtcbiAgICAgICAgLy8gRGlkIHNvbWVvbmUgbWFuYWdlIHRvIHNvcnQgb3V0IHRoZSBrZXkgYWxyZWFkeT9cbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdLZXkgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIGxldCBrZXlzeW07XG5cbiAgICAgICAgY29uc3QgY29kZSA9IHRoaXMuX3BlbmRpbmdLZXk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdLZXkgPSBudWxsO1xuXG4gICAgICAgIC8vIFdlIGhhdmUgbm8gd2F5IG9mIGtub3dpbmcgdGhlIHByb3BlciBrZXlzeW0gd2l0aCB0aGVcbiAgICAgICAgLy8gaW5mb3JtYXRpb24gZ2l2ZW4sIGJ1dCB0aGUgZm9sbG93aW5nIGFyZSB0cnVlIGZvciBtb3N0XG4gICAgICAgIC8vIGxheW91dHNcbiAgICAgICAgaWYgKChlLmtleUNvZGUgPj0gMHgzMCkgJiYgKGUua2V5Q29kZSA8PSAweDM5KSkge1xuICAgICAgICAgICAgLy8gRGlnaXRcbiAgICAgICAgICAgIGtleXN5bSA9IGUua2V5Q29kZTtcbiAgICAgICAgfSBlbHNlIGlmICgoZS5rZXlDb2RlID49IDB4NDEpICYmIChlLmtleUNvZGUgPD0gMHg1YSkpIHtcbiAgICAgICAgICAgIC8vIENoYXJhY3RlciAoQS1aKVxuICAgICAgICAgICAgbGV0IGNoYXIgPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGUua2V5Q29kZSk7XG4gICAgICAgICAgICAvLyBBIGZlZWJsZSBhdHRlbXB0IGF0IHRoZSBjb3JyZWN0IGNhc2VcbiAgICAgICAgICAgIGlmIChlLnNoaWZ0S2V5KSB7XG4gICAgICAgICAgICAgICAgY2hhciA9IGNoYXIudG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2hhciA9IGNoYXIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGtleXN5bSA9IGNoYXIuY2hhckNvZGVBdCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gVW5rbm93biwgZ2l2ZSB1cFxuICAgICAgICAgICAga2V5c3ltID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NlbmRLZXlFdmVudChrZXlzeW0sIGNvZGUsIHRydWUpO1xuICAgIH1cblxuICAgIF9oYW5kbGVLZXlVcChlKSB7XG4gICAgICAgIHN0b3BFdmVudChlKTtcblxuICAgICAgICBjb25zdCBjb2RlID0gdGhpcy5fZ2V0S2V5Q29kZShlKTtcblxuICAgICAgICAvLyBXZSBjYW4ndCBnZXQgYSByZWxlYXNlIGluIHRoZSBtaWRkbGUgb2YgYW4gQWx0R3Igc2VxdWVuY2UsIHNvXG4gICAgICAgIC8vIGFib3J0IHRoYXQgZGV0ZWN0aW9uXG4gICAgICAgIGlmICh0aGlzLl9hbHRHckFybWVkKSB7XG4gICAgICAgICAgICB0aGlzLl9hbHRHckFybWVkID0gZmFsc2U7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fYWx0R3JUaW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRLZXlFdmVudChLZXlUYWJsZS5YS19Db250cm9sX0wsIFwiQ29udHJvbExlZnRcIiwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTZWUgY29tbWVudCBpbiBfaGFuZGxlS2V5RG93bigpXG4gICAgICAgIGlmIChicm93c2VyLmlzTWFjKCkgJiYgKGNvZGUgPT09ICdDYXBzTG9jaycpKSB7XG4gICAgICAgICAgICB0aGlzLl9zZW5kS2V5RXZlbnQoS2V5VGFibGUuWEtfQ2Fwc19Mb2NrLCAnQ2Fwc0xvY2snLCB0cnVlKTtcbiAgICAgICAgICAgIHRoaXMuX3NlbmRLZXlFdmVudChLZXlUYWJsZS5YS19DYXBzX0xvY2ssICdDYXBzTG9jaycsIGZhbHNlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3NlbmRLZXlFdmVudCh0aGlzLl9rZXlEb3duTGlzdFtjb2RlXSwgY29kZSwgZmFsc2UpO1xuICAgIH1cblxuICAgIF9oYW5kbGVBbHRHclRpbWVvdXQoKSB7XG4gICAgICAgIHRoaXMuX2FsdEdyQXJtZWQgPSBmYWxzZTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2FsdEdyVGltZW91dCk7XG4gICAgICAgIHRoaXMuX3NlbmRLZXlFdmVudChLZXlUYWJsZS5YS19Db250cm9sX0wsIFwiQ29udHJvbExlZnRcIiwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgX2FsbEtleXNVcCgpIHtcbiAgICAgICAgTG9nLkRlYnVnKFwiPj4gS2V5Ym9hcmQuYWxsS2V5c1VwXCIpO1xuICAgICAgICBmb3IgKGxldCBjb2RlIGluIHRoaXMuX2tleURvd25MaXN0KSB7XG4gICAgICAgICAgICB0aGlzLl9zZW5kS2V5RXZlbnQodGhpcy5fa2V5RG93bkxpc3RbY29kZV0sIGNvZGUsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBMb2cuRGVidWcoXCI8PCBLZXlib2FyZC5hbGxLZXlzVXBcIik7XG4gICAgfVxuXG4gICAgLy8gRmlyZWZveCBBbHQgd29ya2Fyb3VuZCwgc2VlIGJlbG93XG4gICAgX2NoZWNrQWx0KGUpIHtcbiAgICAgICAgaWYgKGUuYWx0S2V5KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl90YXJnZXQ7XG4gICAgICAgIGNvbnN0IGRvd25MaXN0ID0gdGhpcy5fa2V5RG93bkxpc3Q7XG4gICAgICAgIFsnQWx0TGVmdCcsICdBbHRSaWdodCddLmZvckVhY2goKGNvZGUpID0+IHtcbiAgICAgICAgICAgIGlmICghKGNvZGUgaW4gZG93bkxpc3QpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb25zdCBldmVudCA9IG5ldyBLZXlib2FyZEV2ZW50KCdrZXl1cCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsga2V5OiBkb3duTGlzdFtjb2RlXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb2RlIH0pO1xuICAgICAgICAgICAgdGFyZ2V0LmRpc3BhdGNoRXZlbnQoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyA9PT09PSBQVUJMSUMgTUVUSE9EUyA9PT09PVxuXG4gICAgZ3JhYigpIHtcbiAgICAgICAgLy9Mb2cuRGVidWcoXCI+PiBLZXlib2FyZC5ncmFiXCIpO1xuXG4gICAgICAgIHRoaXMuX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fZXZlbnRIYW5kbGVycy5rZXlkb3duKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5fZXZlbnRIYW5kbGVycy5rZXl1cCk7XG4gICAgICAgIHRoaXMuX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIHRoaXMuX2V2ZW50SGFuZGxlcnMua2V5cHJlc3MpO1xuXG4gICAgICAgIC8vIFJlbGVhc2UgKGtleSB1cCkgaWYgd2luZG93IGxvc2VzIGZvY3VzXG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdibHVyJywgdGhpcy5fZXZlbnRIYW5kbGVycy5ibHVyKTtcblxuICAgICAgICAvLyBGaXJlZm94IGhhcyBicm9rZW4gaGFuZGxpbmcgb2YgQWx0LCBzbyB3ZSBuZWVkIHRvIHBvbGwgYXNcbiAgICAgICAgLy8gYmVzdCB3ZSBjYW4gZm9yIHJlbGVhc2VzIChzdGlsbCBkb2Vzbid0IHByZXZlbnQgdGhlIG1lbnVcbiAgICAgICAgLy8gZnJvbSBwb3BwaW5nIHVwIHRob3VnaCBhcyB3ZSBjYW4ndCBjYWxsIHByZXZlbnREZWZhdWx0KCkpXG4gICAgICAgIGlmIChicm93c2VyLmlzV2luZG93cygpICYmIGJyb3dzZXIuaXNGaXJlZm94KCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLl9ldmVudEhhbmRsZXJzLmNoZWNrYWx0O1xuICAgICAgICAgICAgWydtb3VzZWRvd24nLCAnbW91c2V1cCcsICdtb3VzZW1vdmUnLCAnd2hlZWwnLFxuICAgICAgICAgICAgICd0b3VjaHN0YXJ0JywgJ3RvdWNoZW5kJywgJ3RvdWNobW92ZScsXG4gICAgICAgICAgICAgJ2tleWRvd24nLCAna2V5dXAnXS5mb3JFYWNoKHR5cGUgPT5cbiAgICAgICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGNhcHR1cmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhc3NpdmU6IHRydWUgfSkpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy9Mb2cuRGVidWcoXCI8PCBLZXlib2FyZC5ncmFiXCIpO1xuICAgIH1cblxuICAgIHVuZ3JhYigpIHtcbiAgICAgICAgLy9Mb2cuRGVidWcoXCI+PiBLZXlib2FyZC51bmdyYWJcIik7XG5cbiAgICAgICAgaWYgKGJyb3dzZXIuaXNXaW5kb3dzKCkgJiYgYnJvd3Nlci5pc0ZpcmVmb3goKSkge1xuICAgICAgICAgICAgY29uc3QgaGFuZGxlciA9IHRoaXMuX2V2ZW50SGFuZGxlcnMuY2hlY2thbHQ7XG4gICAgICAgICAgICBbJ21vdXNlZG93bicsICdtb3VzZXVwJywgJ21vdXNlbW92ZScsICd3aGVlbCcsXG4gICAgICAgICAgICAgJ3RvdWNoc3RhcnQnLCAndG91Y2hlbmQnLCAndG91Y2htb3ZlJyxcbiAgICAgICAgICAgICAna2V5ZG93bicsICdrZXl1cCddLmZvckVhY2godHlwZSA9PiBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlkb3duJywgdGhpcy5fZXZlbnRIYW5kbGVycy5rZXlkb3duKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleXVwJywgdGhpcy5fZXZlbnRIYW5kbGVycy5rZXl1cCk7XG4gICAgICAgIHRoaXMuX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIHRoaXMuX2V2ZW50SGFuZGxlcnMua2V5cHJlc3MpO1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignYmx1cicsIHRoaXMuX2V2ZW50SGFuZGxlcnMuYmx1cik7XG5cbiAgICAgICAgLy8gUmVsZWFzZSAoa2V5IHVwKSBhbGwga2V5cyB0aGF0IGFyZSBpbiBhIGRvd24gc3RhdGVcbiAgICAgICAgdGhpcy5fYWxsS2V5c1VwKCk7XG5cbiAgICAgICAgLy9Mb2cuRGVidWcoXCI+PiBLZXlib2FyZC51bmdyYWJcIik7XG4gICAgfVxufVxuIiwiLyogZXNsaW50LWRpc2FibGUga2V5LXNwYWNpbmcgKi9cblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIFhLX1ZvaWRTeW1ib2w6ICAgICAgICAgICAgICAgICAgMHhmZmZmZmYsIC8qIFZvaWQgc3ltYm9sICovXG5cbiAgICBYS19CYWNrU3BhY2U6ICAgICAgICAgICAgICAgICAgIDB4ZmYwOCwgLyogQmFjayBzcGFjZSwgYmFjayBjaGFyICovXG4gICAgWEtfVGFiOiAgICAgICAgICAgICAgICAgICAgICAgICAweGZmMDksXG4gICAgWEtfTGluZWZlZWQ6ICAgICAgICAgICAgICAgICAgICAweGZmMGEsIC8qIExpbmVmZWVkLCBMRiAqL1xuICAgIFhLX0NsZWFyOiAgICAgICAgICAgICAgICAgICAgICAgMHhmZjBiLFxuICAgIFhLX1JldHVybjogICAgICAgICAgICAgICAgICAgICAgMHhmZjBkLCAvKiBSZXR1cm4sIGVudGVyICovXG4gICAgWEtfUGF1c2U6ICAgICAgICAgICAgICAgICAgICAgICAweGZmMTMsIC8qIFBhdXNlLCBob2xkICovXG4gICAgWEtfU2Nyb2xsX0xvY2s6ICAgICAgICAgICAgICAgICAweGZmMTQsXG4gICAgWEtfU3lzX1JlcTogICAgICAgICAgICAgICAgICAgICAweGZmMTUsXG4gICAgWEtfRXNjYXBlOiAgICAgICAgICAgICAgICAgICAgICAweGZmMWIsXG4gICAgWEtfRGVsZXRlOiAgICAgICAgICAgICAgICAgICAgICAweGZmZmYsIC8qIERlbGV0ZSwgcnVib3V0ICovXG5cbiAgICAvKiBJbnRlcm5hdGlvbmFsICYgbXVsdGkta2V5IGNoYXJhY3RlciBjb21wb3NpdGlvbiAqL1xuXG4gICAgWEtfTXVsdGlfa2V5OiAgICAgICAgICAgICAgICAgICAweGZmMjAsIC8qIE11bHRpLWtleSBjaGFyYWN0ZXIgY29tcG9zZSAqL1xuICAgIFhLX0NvZGVpbnB1dDogICAgICAgICAgICAgICAgICAgMHhmZjM3LFxuICAgIFhLX1NpbmdsZUNhbmRpZGF0ZTogICAgICAgICAgICAgMHhmZjNjLFxuICAgIFhLX011bHRpcGxlQ2FuZGlkYXRlOiAgICAgICAgICAgMHhmZjNkLFxuICAgIFhLX1ByZXZpb3VzQ2FuZGlkYXRlOiAgICAgICAgICAgMHhmZjNlLFxuXG4gICAgLyogSmFwYW5lc2Uga2V5Ym9hcmQgc3VwcG9ydCAqL1xuXG4gICAgWEtfS2Fuamk6ICAgICAgICAgICAgICAgICAgICAgICAweGZmMjEsIC8qIEthbmppLCBLYW5qaSBjb252ZXJ0ICovXG4gICAgWEtfTXVoZW5rYW46ICAgICAgICAgICAgICAgICAgICAweGZmMjIsIC8qIENhbmNlbCBDb252ZXJzaW9uICovXG4gICAgWEtfSGVua2FuX01vZGU6ICAgICAgICAgICAgICAgICAweGZmMjMsIC8qIFN0YXJ0L1N0b3AgQ29udmVyc2lvbiAqL1xuICAgIFhLX0hlbmthbjogICAgICAgICAgICAgICAgICAgICAgMHhmZjIzLCAvKiBBbGlhcyBmb3IgSGVua2FuX01vZGUgKi9cbiAgICBYS19Sb21hamk6ICAgICAgICAgICAgICAgICAgICAgIDB4ZmYyNCwgLyogdG8gUm9tYWppICovXG4gICAgWEtfSGlyYWdhbmE6ICAgICAgICAgICAgICAgICAgICAweGZmMjUsIC8qIHRvIEhpcmFnYW5hICovXG4gICAgWEtfS2F0YWthbmE6ICAgICAgICAgICAgICAgICAgICAweGZmMjYsIC8qIHRvIEthdGFrYW5hICovXG4gICAgWEtfSGlyYWdhbmFfS2F0YWthbmE6ICAgICAgICAgICAweGZmMjcsIC8qIEhpcmFnYW5hL0thdGFrYW5hIHRvZ2dsZSAqL1xuICAgIFhLX1plbmtha3U6ICAgICAgICAgICAgICAgICAgICAgMHhmZjI4LCAvKiB0byBaZW5rYWt1ICovXG4gICAgWEtfSGFua2FrdTogICAgICAgICAgICAgICAgICAgICAweGZmMjksIC8qIHRvIEhhbmtha3UgKi9cbiAgICBYS19aZW5rYWt1X0hhbmtha3U6ICAgICAgICAgICAgIDB4ZmYyYSwgLyogWmVua2FrdS9IYW5rYWt1IHRvZ2dsZSAqL1xuICAgIFhLX1RvdXJva3U6ICAgICAgICAgICAgICAgICAgICAgMHhmZjJiLCAvKiBBZGQgdG8gRGljdGlvbmFyeSAqL1xuICAgIFhLX01hc3N5bzogICAgICAgICAgICAgICAgICAgICAgMHhmZjJjLCAvKiBEZWxldGUgZnJvbSBEaWN0aW9uYXJ5ICovXG4gICAgWEtfS2FuYV9Mb2NrOiAgICAgICAgICAgICAgICAgICAweGZmMmQsIC8qIEthbmEgTG9jayAqL1xuICAgIFhLX0thbmFfU2hpZnQ6ICAgICAgICAgICAgICAgICAgMHhmZjJlLCAvKiBLYW5hIFNoaWZ0ICovXG4gICAgWEtfRWlzdV9TaGlmdDogICAgICAgICAgICAgICAgICAweGZmMmYsIC8qIEFscGhhbnVtZXJpYyBTaGlmdCAqL1xuICAgIFhLX0Vpc3VfdG9nZ2xlOiAgICAgICAgICAgICAgICAgMHhmZjMwLCAvKiBBbHBoYW51bWVyaWMgdG9nZ2xlICovXG4gICAgWEtfS2FuamlfQmFuZ291OiAgICAgICAgICAgICAgICAweGZmMzcsIC8qIENvZGVpbnB1dCAqL1xuICAgIFhLX1plbl9Lb2hvOiAgICAgICAgICAgICAgICAgICAgMHhmZjNkLCAvKiBNdWx0aXBsZS9BbGwgQ2FuZGlkYXRlKHMpICovXG4gICAgWEtfTWFlX0tvaG86ICAgICAgICAgICAgICAgICAgICAweGZmM2UsIC8qIFByZXZpb3VzIENhbmRpZGF0ZSAqL1xuXG4gICAgLyogQ3Vyc29yIGNvbnRyb2wgJiBtb3Rpb24gKi9cblxuICAgIFhLX0hvbWU6ICAgICAgICAgICAgICAgICAgICAgICAgMHhmZjUwLFxuICAgIFhLX0xlZnQ6ICAgICAgICAgICAgICAgICAgICAgICAgMHhmZjUxLCAvKiBNb3ZlIGxlZnQsIGxlZnQgYXJyb3cgKi9cbiAgICBYS19VcDogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmY1MiwgLyogTW92ZSB1cCwgdXAgYXJyb3cgKi9cbiAgICBYS19SaWdodDogICAgICAgICAgICAgICAgICAgICAgIDB4ZmY1MywgLyogTW92ZSByaWdodCwgcmlnaHQgYXJyb3cgKi9cbiAgICBYS19Eb3duOiAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmY1NCwgLyogTW92ZSBkb3duLCBkb3duIGFycm93ICovXG4gICAgWEtfUHJpb3I6ICAgICAgICAgICAgICAgICAgICAgICAweGZmNTUsIC8qIFByaW9yLCBwcmV2aW91cyAqL1xuICAgIFhLX1BhZ2VfVXA6ICAgICAgICAgICAgICAgICAgICAgMHhmZjU1LFxuICAgIFhLX05leHQ6ICAgICAgICAgICAgICAgICAgICAgICAgMHhmZjU2LCAvKiBOZXh0ICovXG4gICAgWEtfUGFnZV9Eb3duOiAgICAgICAgICAgICAgICAgICAweGZmNTYsXG4gICAgWEtfRW5kOiAgICAgICAgICAgICAgICAgICAgICAgICAweGZmNTcsIC8qIEVPTCAqL1xuICAgIFhLX0JlZ2luOiAgICAgICAgICAgICAgICAgICAgICAgMHhmZjU4LCAvKiBCT0wgKi9cblxuXG4gICAgLyogTWlzYyBmdW5jdGlvbnMgKi9cblxuICAgIFhLX1NlbGVjdDogICAgICAgICAgICAgICAgICAgICAgMHhmZjYwLCAvKiBTZWxlY3QsIG1hcmsgKi9cbiAgICBYS19QcmludDogICAgICAgICAgICAgICAgICAgICAgIDB4ZmY2MSxcbiAgICBYS19FeGVjdXRlOiAgICAgICAgICAgICAgICAgICAgIDB4ZmY2MiwgLyogRXhlY3V0ZSwgcnVuLCBkbyAqL1xuICAgIFhLX0luc2VydDogICAgICAgICAgICAgICAgICAgICAgMHhmZjYzLCAvKiBJbnNlcnQsIGluc2VydCBoZXJlICovXG4gICAgWEtfVW5kbzogICAgICAgICAgICAgICAgICAgICAgICAweGZmNjUsXG4gICAgWEtfUmVkbzogICAgICAgICAgICAgICAgICAgICAgICAweGZmNjYsIC8qIFJlZG8sIGFnYWluICovXG4gICAgWEtfTWVudTogICAgICAgICAgICAgICAgICAgICAgICAweGZmNjcsXG4gICAgWEtfRmluZDogICAgICAgICAgICAgICAgICAgICAgICAweGZmNjgsIC8qIEZpbmQsIHNlYXJjaCAqL1xuICAgIFhLX0NhbmNlbDogICAgICAgICAgICAgICAgICAgICAgMHhmZjY5LCAvKiBDYW5jZWwsIHN0b3AsIGFib3J0LCBleGl0ICovXG4gICAgWEtfSGVscDogICAgICAgICAgICAgICAgICAgICAgICAweGZmNmEsIC8qIEhlbHAgKi9cbiAgICBYS19CcmVhazogICAgICAgICAgICAgICAgICAgICAgIDB4ZmY2YixcbiAgICBYS19Nb2RlX3N3aXRjaDogICAgICAgICAgICAgICAgIDB4ZmY3ZSwgLyogQ2hhcmFjdGVyIHNldCBzd2l0Y2ggKi9cbiAgICBYS19zY3JpcHRfc3dpdGNoOiAgICAgICAgICAgICAgIDB4ZmY3ZSwgLyogQWxpYXMgZm9yIG1vZGVfc3dpdGNoICovXG4gICAgWEtfTnVtX0xvY2s6ICAgICAgICAgICAgICAgICAgICAweGZmN2YsXG5cbiAgICAvKiBLZXlwYWQgZnVuY3Rpb25zLCBrZXlwYWQgbnVtYmVycyBjbGV2ZXJseSBjaG9zZW4gdG8gbWFwIHRvIEFTQ0lJICovXG5cbiAgICBYS19LUF9TcGFjZTogICAgICAgICAgICAgICAgICAgIDB4ZmY4MCwgLyogU3BhY2UgKi9cbiAgICBYS19LUF9UYWI6ICAgICAgICAgICAgICAgICAgICAgIDB4ZmY4OSxcbiAgICBYS19LUF9FbnRlcjogICAgICAgICAgICAgICAgICAgIDB4ZmY4ZCwgLyogRW50ZXIgKi9cbiAgICBYS19LUF9GMTogICAgICAgICAgICAgICAgICAgICAgIDB4ZmY5MSwgLyogUEYxLCBLUF9BLCAuLi4gKi9cbiAgICBYS19LUF9GMjogICAgICAgICAgICAgICAgICAgICAgIDB4ZmY5MixcbiAgICBYS19LUF9GMzogICAgICAgICAgICAgICAgICAgICAgIDB4ZmY5MyxcbiAgICBYS19LUF9GNDogICAgICAgICAgICAgICAgICAgICAgIDB4ZmY5NCxcbiAgICBYS19LUF9Ib21lOiAgICAgICAgICAgICAgICAgICAgIDB4ZmY5NSxcbiAgICBYS19LUF9MZWZ0OiAgICAgICAgICAgICAgICAgICAgIDB4ZmY5NixcbiAgICBYS19LUF9VcDogICAgICAgICAgICAgICAgICAgICAgIDB4ZmY5NyxcbiAgICBYS19LUF9SaWdodDogICAgICAgICAgICAgICAgICAgIDB4ZmY5OCxcbiAgICBYS19LUF9Eb3duOiAgICAgICAgICAgICAgICAgICAgIDB4ZmY5OSxcbiAgICBYS19LUF9QcmlvcjogICAgICAgICAgICAgICAgICAgIDB4ZmY5YSxcbiAgICBYS19LUF9QYWdlX1VwOiAgICAgICAgICAgICAgICAgIDB4ZmY5YSxcbiAgICBYS19LUF9OZXh0OiAgICAgICAgICAgICAgICAgICAgIDB4ZmY5YixcbiAgICBYS19LUF9QYWdlX0Rvd246ICAgICAgICAgICAgICAgIDB4ZmY5YixcbiAgICBYS19LUF9FbmQ6ICAgICAgICAgICAgICAgICAgICAgIDB4ZmY5YyxcbiAgICBYS19LUF9CZWdpbjogICAgICAgICAgICAgICAgICAgIDB4ZmY5ZCxcbiAgICBYS19LUF9JbnNlcnQ6ICAgICAgICAgICAgICAgICAgIDB4ZmY5ZSxcbiAgICBYS19LUF9EZWxldGU6ICAgICAgICAgICAgICAgICAgIDB4ZmY5ZixcbiAgICBYS19LUF9FcXVhbDogICAgICAgICAgICAgICAgICAgIDB4ZmZiZCwgLyogRXF1YWxzICovXG4gICAgWEtfS1BfTXVsdGlwbHk6ICAgICAgICAgICAgICAgICAweGZmYWEsXG4gICAgWEtfS1BfQWRkOiAgICAgICAgICAgICAgICAgICAgICAweGZmYWIsXG4gICAgWEtfS1BfU2VwYXJhdG9yOiAgICAgICAgICAgICAgICAweGZmYWMsIC8qIFNlcGFyYXRvciwgb2Z0ZW4gY29tbWEgKi9cbiAgICBYS19LUF9TdWJ0cmFjdDogICAgICAgICAgICAgICAgIDB4ZmZhZCxcbiAgICBYS19LUF9EZWNpbWFsOiAgICAgICAgICAgICAgICAgIDB4ZmZhZSxcbiAgICBYS19LUF9EaXZpZGU6ICAgICAgICAgICAgICAgICAgIDB4ZmZhZixcblxuICAgIFhLX0tQXzA6ICAgICAgICAgICAgICAgICAgICAgICAgMHhmZmIwLFxuICAgIFhLX0tQXzE6ICAgICAgICAgICAgICAgICAgICAgICAgMHhmZmIxLFxuICAgIFhLX0tQXzI6ICAgICAgICAgICAgICAgICAgICAgICAgMHhmZmIyLFxuICAgIFhLX0tQXzM6ICAgICAgICAgICAgICAgICAgICAgICAgMHhmZmIzLFxuICAgIFhLX0tQXzQ6ICAgICAgICAgICAgICAgICAgICAgICAgMHhmZmI0LFxuICAgIFhLX0tQXzU6ICAgICAgICAgICAgICAgICAgICAgICAgMHhmZmI1LFxuICAgIFhLX0tQXzY6ICAgICAgICAgICAgICAgICAgICAgICAgMHhmZmI2LFxuICAgIFhLX0tQXzc6ICAgICAgICAgICAgICAgICAgICAgICAgMHhmZmI3LFxuICAgIFhLX0tQXzg6ICAgICAgICAgICAgICAgICAgICAgICAgMHhmZmI4LFxuICAgIFhLX0tQXzk6ICAgICAgICAgICAgICAgICAgICAgICAgMHhmZmI5LFxuXG4gICAgLypcbiAgICAgKiBBdXhpbGlhcnkgZnVuY3Rpb25zOyBub3RlIHRoZSBkdXBsaWNhdGUgZGVmaW5pdGlvbnMgZm9yIGxlZnQgYW5kIHJpZ2h0XG4gICAgICogZnVuY3Rpb24ga2V5czsgIFN1biBrZXlib2FyZHMgYW5kIGEgZmV3IG90aGVyIG1hbnVmYWN0dXJlcnMgaGF2ZSBzdWNoXG4gICAgICogZnVuY3Rpb24ga2V5IGdyb3VwcyBvbiB0aGUgbGVmdCBhbmQvb3IgcmlnaHQgc2lkZXMgb2YgdGhlIGtleWJvYXJkLlxuICAgICAqIFdlJ3ZlIG5vdCBmb3VuZCBhIGtleWJvYXJkIHdpdGggbW9yZSB0aGFuIDM1IGZ1bmN0aW9uIGtleXMgdG90YWwuXG4gICAgICovXG5cbiAgICBYS19GMTogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZiZSxcbiAgICBYS19GMjogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZiZixcbiAgICBYS19GMzogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjMCxcbiAgICBYS19GNDogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjMSxcbiAgICBYS19GNTogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjMixcbiAgICBYS19GNjogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjMyxcbiAgICBYS19GNzogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjNCxcbiAgICBYS19GODogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjNSxcbiAgICBYS19GOTogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjNixcbiAgICBYS19GMTA6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjNyxcbiAgICBYS19GMTE6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjOCxcbiAgICBYS19MMTogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjOCxcbiAgICBYS19GMTI6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjOSxcbiAgICBYS19MMjogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjOSxcbiAgICBYS19GMTM6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjYSxcbiAgICBYS19MMzogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjYSxcbiAgICBYS19GMTQ6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjYixcbiAgICBYS19MNDogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjYixcbiAgICBYS19GMTU6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjYyxcbiAgICBYS19MNTogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjYyxcbiAgICBYS19GMTY6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjZCxcbiAgICBYS19MNjogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjZCxcbiAgICBYS19GMTc6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjZSxcbiAgICBYS19MNzogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjZSxcbiAgICBYS19GMTg6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjZixcbiAgICBYS19MODogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZjZixcbiAgICBYS19GMTk6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkMCxcbiAgICBYS19MOTogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkMCxcbiAgICBYS19GMjA6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkMSxcbiAgICBYS19MMTA6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkMSxcbiAgICBYS19GMjE6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkMixcbiAgICBYS19SMTogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkMixcbiAgICBYS19GMjI6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkMyxcbiAgICBYS19SMjogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkMyxcbiAgICBYS19GMjM6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkNCxcbiAgICBYS19SMzogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkNCxcbiAgICBYS19GMjQ6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkNSxcbiAgICBYS19SNDogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkNSxcbiAgICBYS19GMjU6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkNixcbiAgICBYS19SNTogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkNixcbiAgICBYS19GMjY6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkNyxcbiAgICBYS19SNjogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkNyxcbiAgICBYS19GMjc6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkOCxcbiAgICBYS19SNzogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkOCxcbiAgICBYS19GMjg6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkOSxcbiAgICBYS19SODogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkOSxcbiAgICBYS19GMjk6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkYSxcbiAgICBYS19SOTogICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkYSxcbiAgICBYS19GMzA6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkYixcbiAgICBYS19SMTA6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkYixcbiAgICBYS19GMzE6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkYyxcbiAgICBYS19SMTE6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkYyxcbiAgICBYS19GMzI6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkZCxcbiAgICBYS19SMTI6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkZCxcbiAgICBYS19GMzM6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkZSxcbiAgICBYS19SMTM6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkZSxcbiAgICBYS19GMzQ6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkZixcbiAgICBYS19SMTQ6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZkZixcbiAgICBYS19GMzU6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZlMCxcbiAgICBYS19SMTU6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4ZmZlMCxcblxuICAgIC8qIE1vZGlmaWVycyAqL1xuXG4gICAgWEtfU2hpZnRfTDogICAgICAgICAgICAgICAgICAgICAweGZmZTEsIC8qIExlZnQgc2hpZnQgKi9cbiAgICBYS19TaGlmdF9SOiAgICAgICAgICAgICAgICAgICAgIDB4ZmZlMiwgLyogUmlnaHQgc2hpZnQgKi9cbiAgICBYS19Db250cm9sX0w6ICAgICAgICAgICAgICAgICAgIDB4ZmZlMywgLyogTGVmdCBjb250cm9sICovXG4gICAgWEtfQ29udHJvbF9SOiAgICAgICAgICAgICAgICAgICAweGZmZTQsIC8qIFJpZ2h0IGNvbnRyb2wgKi9cbiAgICBYS19DYXBzX0xvY2s6ICAgICAgICAgICAgICAgICAgIDB4ZmZlNSwgLyogQ2FwcyBsb2NrICovXG4gICAgWEtfU2hpZnRfTG9jazogICAgICAgICAgICAgICAgICAweGZmZTYsIC8qIFNoaWZ0IGxvY2sgKi9cblxuICAgIFhLX01ldGFfTDogICAgICAgICAgICAgICAgICAgICAgMHhmZmU3LCAvKiBMZWZ0IG1ldGEgKi9cbiAgICBYS19NZXRhX1I6ICAgICAgICAgICAgICAgICAgICAgIDB4ZmZlOCwgLyogUmlnaHQgbWV0YSAqL1xuICAgIFhLX0FsdF9MOiAgICAgICAgICAgICAgICAgICAgICAgMHhmZmU5LCAvKiBMZWZ0IGFsdCAqL1xuICAgIFhLX0FsdF9SOiAgICAgICAgICAgICAgICAgICAgICAgMHhmZmVhLCAvKiBSaWdodCBhbHQgKi9cbiAgICBYS19TdXBlcl9MOiAgICAgICAgICAgICAgICAgICAgIDB4ZmZlYiwgLyogTGVmdCBzdXBlciAqL1xuICAgIFhLX1N1cGVyX1I6ICAgICAgICAgICAgICAgICAgICAgMHhmZmVjLCAvKiBSaWdodCBzdXBlciAqL1xuICAgIFhLX0h5cGVyX0w6ICAgICAgICAgICAgICAgICAgICAgMHhmZmVkLCAvKiBMZWZ0IGh5cGVyICovXG4gICAgWEtfSHlwZXJfUjogICAgICAgICAgICAgICAgICAgICAweGZmZWUsIC8qIFJpZ2h0IGh5cGVyICovXG5cbiAgICAvKlxuICAgICAqIEtleWJvYXJkIChYS0IpIEV4dGVuc2lvbiBmdW5jdGlvbiBhbmQgbW9kaWZpZXIga2V5c1xuICAgICAqIChmcm9tIEFwcGVuZGl4IEMgb2YgXCJUaGUgWCBLZXlib2FyZCBFeHRlbnNpb246IFByb3RvY29sIFNwZWNpZmljYXRpb25cIilcbiAgICAgKiBCeXRlIDMgPSAweGZlXG4gICAgICovXG5cbiAgICBYS19JU09fTGV2ZWwzX1NoaWZ0OiAgICAgICAgICAgIDB4ZmUwMywgLyogQWx0R3IgKi9cbiAgICBYS19JU09fTmV4dF9Hcm91cDogICAgICAgICAgICAgIDB4ZmUwOCxcbiAgICBYS19JU09fUHJldl9Hcm91cDogICAgICAgICAgICAgIDB4ZmUwYSxcbiAgICBYS19JU09fRmlyc3RfR3JvdXA6ICAgICAgICAgICAgIDB4ZmUwYyxcbiAgICBYS19JU09fTGFzdF9Hcm91cDogICAgICAgICAgICAgIDB4ZmUwZSxcblxuICAgIC8qXG4gICAgICogTGF0aW4gMVxuICAgICAqIChJU08vSUVDIDg4NTktMTogVW5pY29kZSBVKzAwMjAuLlUrMDBGRilcbiAgICAgKiBCeXRlIDM6IDBcbiAgICAgKi9cblxuICAgIFhLX3NwYWNlOiAgICAgICAgICAgICAgICAgICAgICAgMHgwMDIwLCAvKiBVKzAwMjAgU1BBQ0UgKi9cbiAgICBYS19leGNsYW06ICAgICAgICAgICAgICAgICAgICAgIDB4MDAyMSwgLyogVSswMDIxIEVYQ0xBTUFUSU9OIE1BUksgKi9cbiAgICBYS19xdW90ZWRibDogICAgICAgICAgICAgICAgICAgIDB4MDAyMiwgLyogVSswMDIyIFFVT1RBVElPTiBNQVJLICovXG4gICAgWEtfbnVtYmVyc2lnbjogICAgICAgICAgICAgICAgICAweDAwMjMsIC8qIFUrMDAyMyBOVU1CRVIgU0lHTiAqL1xuICAgIFhLX2RvbGxhcjogICAgICAgICAgICAgICAgICAgICAgMHgwMDI0LCAvKiBVKzAwMjQgRE9MTEFSIFNJR04gKi9cbiAgICBYS19wZXJjZW50OiAgICAgICAgICAgICAgICAgICAgIDB4MDAyNSwgLyogVSswMDI1IFBFUkNFTlQgU0lHTiAqL1xuICAgIFhLX2FtcGVyc2FuZDogICAgICAgICAgICAgICAgICAgMHgwMDI2LCAvKiBVKzAwMjYgQU1QRVJTQU5EICovXG4gICAgWEtfYXBvc3Ryb3BoZTogICAgICAgICAgICAgICAgICAweDAwMjcsIC8qIFUrMDAyNyBBUE9TVFJPUEhFICovXG4gICAgWEtfcXVvdGVyaWdodDogICAgICAgICAgICAgICAgICAweDAwMjcsIC8qIGRlcHJlY2F0ZWQgKi9cbiAgICBYS19wYXJlbmxlZnQ6ICAgICAgICAgICAgICAgICAgIDB4MDAyOCwgLyogVSswMDI4IExFRlQgUEFSRU5USEVTSVMgKi9cbiAgICBYS19wYXJlbnJpZ2h0OiAgICAgICAgICAgICAgICAgIDB4MDAyOSwgLyogVSswMDI5IFJJR0hUIFBBUkVOVEhFU0lTICovXG4gICAgWEtfYXN0ZXJpc2s6ICAgICAgICAgICAgICAgICAgICAweDAwMmEsIC8qIFUrMDAyQSBBU1RFUklTSyAqL1xuICAgIFhLX3BsdXM6ICAgICAgICAgICAgICAgICAgICAgICAgMHgwMDJiLCAvKiBVKzAwMkIgUExVUyBTSUdOICovXG4gICAgWEtfY29tbWE6ICAgICAgICAgICAgICAgICAgICAgICAweDAwMmMsIC8qIFUrMDAyQyBDT01NQSAqL1xuICAgIFhLX21pbnVzOiAgICAgICAgICAgICAgICAgICAgICAgMHgwMDJkLCAvKiBVKzAwMkQgSFlQSEVOLU1JTlVTICovXG4gICAgWEtfcGVyaW9kOiAgICAgICAgICAgICAgICAgICAgICAweDAwMmUsIC8qIFUrMDAyRSBGVUxMIFNUT1AgKi9cbiAgICBYS19zbGFzaDogICAgICAgICAgICAgICAgICAgICAgIDB4MDAyZiwgLyogVSswMDJGIFNPTElEVVMgKi9cbiAgICBYS18wOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDAzMCwgLyogVSswMDMwIERJR0lUIFpFUk8gKi9cbiAgICBYS18xOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDAzMSwgLyogVSswMDMxIERJR0lUIE9ORSAqL1xuICAgIFhLXzI6ICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgwMDMyLCAvKiBVKzAwMzIgRElHSVQgVFdPICovXG4gICAgWEtfMzogICAgICAgICAgICAgICAgICAgICAgICAgICAweDAwMzMsIC8qIFUrMDAzMyBESUdJVCBUSFJFRSAqL1xuICAgIFhLXzQ6ICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgwMDM0LCAvKiBVKzAwMzQgRElHSVQgRk9VUiAqL1xuICAgIFhLXzU6ICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgwMDM1LCAvKiBVKzAwMzUgRElHSVQgRklWRSAqL1xuICAgIFhLXzY6ICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgwMDM2LCAvKiBVKzAwMzYgRElHSVQgU0lYICovXG4gICAgWEtfNzogICAgICAgICAgICAgICAgICAgICAgICAgICAweDAwMzcsIC8qIFUrMDAzNyBESUdJVCBTRVZFTiAqL1xuICAgIFhLXzg6ICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgwMDM4LCAvKiBVKzAwMzggRElHSVQgRUlHSFQgKi9cbiAgICBYS185OiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDAzOSwgLyogVSswMDM5IERJR0lUIE5JTkUgKi9cbiAgICBYS19jb2xvbjogICAgICAgICAgICAgICAgICAgICAgIDB4MDAzYSwgLyogVSswMDNBIENPTE9OICovXG4gICAgWEtfc2VtaWNvbG9uOiAgICAgICAgICAgICAgICAgICAweDAwM2IsIC8qIFUrMDAzQiBTRU1JQ09MT04gKi9cbiAgICBYS19sZXNzOiAgICAgICAgICAgICAgICAgICAgICAgIDB4MDAzYywgLyogVSswMDNDIExFU1MtVEhBTiBTSUdOICovXG4gICAgWEtfZXF1YWw6ICAgICAgICAgICAgICAgICAgICAgICAweDAwM2QsIC8qIFUrMDAzRCBFUVVBTFMgU0lHTiAqL1xuICAgIFhLX2dyZWF0ZXI6ICAgICAgICAgICAgICAgICAgICAgMHgwMDNlLCAvKiBVKzAwM0UgR1JFQVRFUi1USEFOIFNJR04gKi9cbiAgICBYS19xdWVzdGlvbjogICAgICAgICAgICAgICAgICAgIDB4MDAzZiwgLyogVSswMDNGIFFVRVNUSU9OIE1BUksgKi9cbiAgICBYS19hdDogICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA0MCwgLyogVSswMDQwIENPTU1FUkNJQUwgQVQgKi9cbiAgICBYS19BOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA0MSwgLyogVSswMDQxIExBVElOIENBUElUQUwgTEVUVEVSIEEgKi9cbiAgICBYS19COiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA0MiwgLyogVSswMDQyIExBVElOIENBUElUQUwgTEVUVEVSIEIgKi9cbiAgICBYS19DOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA0MywgLyogVSswMDQzIExBVElOIENBUElUQUwgTEVUVEVSIEMgKi9cbiAgICBYS19EOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA0NCwgLyogVSswMDQ0IExBVElOIENBUElUQUwgTEVUVEVSIEQgKi9cbiAgICBYS19FOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA0NSwgLyogVSswMDQ1IExBVElOIENBUElUQUwgTEVUVEVSIEUgKi9cbiAgICBYS19GOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA0NiwgLyogVSswMDQ2IExBVElOIENBUElUQUwgTEVUVEVSIEYgKi9cbiAgICBYS19HOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA0NywgLyogVSswMDQ3IExBVElOIENBUElUQUwgTEVUVEVSIEcgKi9cbiAgICBYS19IOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA0OCwgLyogVSswMDQ4IExBVElOIENBUElUQUwgTEVUVEVSIEggKi9cbiAgICBYS19JOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA0OSwgLyogVSswMDQ5IExBVElOIENBUElUQUwgTEVUVEVSIEkgKi9cbiAgICBYS19KOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA0YSwgLyogVSswMDRBIExBVElOIENBUElUQUwgTEVUVEVSIEogKi9cbiAgICBYS19LOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA0YiwgLyogVSswMDRCIExBVElOIENBUElUQUwgTEVUVEVSIEsgKi9cbiAgICBYS19MOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA0YywgLyogVSswMDRDIExBVElOIENBUElUQUwgTEVUVEVSIEwgKi9cbiAgICBYS19NOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA0ZCwgLyogVSswMDREIExBVElOIENBUElUQUwgTEVUVEVSIE0gKi9cbiAgICBYS19OOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA0ZSwgLyogVSswMDRFIExBVElOIENBUElUQUwgTEVUVEVSIE4gKi9cbiAgICBYS19POiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA0ZiwgLyogVSswMDRGIExBVElOIENBUElUQUwgTEVUVEVSIE8gKi9cbiAgICBYS19QOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA1MCwgLyogVSswMDUwIExBVElOIENBUElUQUwgTEVUVEVSIFAgKi9cbiAgICBYS19ROiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA1MSwgLyogVSswMDUxIExBVElOIENBUElUQUwgTEVUVEVSIFEgKi9cbiAgICBYS19SOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA1MiwgLyogVSswMDUyIExBVElOIENBUElUQUwgTEVUVEVSIFIgKi9cbiAgICBYS19TOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA1MywgLyogVSswMDUzIExBVElOIENBUElUQUwgTEVUVEVSIFMgKi9cbiAgICBYS19UOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA1NCwgLyogVSswMDU0IExBVElOIENBUElUQUwgTEVUVEVSIFQgKi9cbiAgICBYS19VOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA1NSwgLyogVSswMDU1IExBVElOIENBUElUQUwgTEVUVEVSIFUgKi9cbiAgICBYS19WOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA1NiwgLyogVSswMDU2IExBVElOIENBUElUQUwgTEVUVEVSIFYgKi9cbiAgICBYS19XOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA1NywgLyogVSswMDU3IExBVElOIENBUElUQUwgTEVUVEVSIFcgKi9cbiAgICBYS19YOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA1OCwgLyogVSswMDU4IExBVElOIENBUElUQUwgTEVUVEVSIFggKi9cbiAgICBYS19ZOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA1OSwgLyogVSswMDU5IExBVElOIENBUElUQUwgTEVUVEVSIFkgKi9cbiAgICBYS19aOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA1YSwgLyogVSswMDVBIExBVElOIENBUElUQUwgTEVUVEVSIFogKi9cbiAgICBYS19icmFja2V0bGVmdDogICAgICAgICAgICAgICAgIDB4MDA1YiwgLyogVSswMDVCIExFRlQgU1FVQVJFIEJSQUNLRVQgKi9cbiAgICBYS19iYWNrc2xhc2g6ICAgICAgICAgICAgICAgICAgIDB4MDA1YywgLyogVSswMDVDIFJFVkVSU0UgU09MSURVUyAqL1xuICAgIFhLX2JyYWNrZXRyaWdodDogICAgICAgICAgICAgICAgMHgwMDVkLCAvKiBVKzAwNUQgUklHSFQgU1FVQVJFIEJSQUNLRVQgKi9cbiAgICBYS19hc2NpaWNpcmN1bTogICAgICAgICAgICAgICAgIDB4MDA1ZSwgLyogVSswMDVFIENJUkNVTUZMRVggQUNDRU5UICovXG4gICAgWEtfdW5kZXJzY29yZTogICAgICAgICAgICAgICAgICAweDAwNWYsIC8qIFUrMDA1RiBMT1cgTElORSAqL1xuICAgIFhLX2dyYXZlOiAgICAgICAgICAgICAgICAgICAgICAgMHgwMDYwLCAvKiBVKzAwNjAgR1JBVkUgQUNDRU5UICovXG4gICAgWEtfcXVvdGVsZWZ0OiAgICAgICAgICAgICAgICAgICAweDAwNjAsIC8qIGRlcHJlY2F0ZWQgKi9cbiAgICBYS19hOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA2MSwgLyogVSswMDYxIExBVElOIFNNQUxMIExFVFRFUiBBICovXG4gICAgWEtfYjogICAgICAgICAgICAgICAgICAgICAgICAgICAweDAwNjIsIC8qIFUrMDA2MiBMQVRJTiBTTUFMTCBMRVRURVIgQiAqL1xuICAgIFhLX2M6ICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgwMDYzLCAvKiBVKzAwNjMgTEFUSU4gU01BTEwgTEVUVEVSIEMgKi9cbiAgICBYS19kOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA2NCwgLyogVSswMDY0IExBVElOIFNNQUxMIExFVFRFUiBEICovXG4gICAgWEtfZTogICAgICAgICAgICAgICAgICAgICAgICAgICAweDAwNjUsIC8qIFUrMDA2NSBMQVRJTiBTTUFMTCBMRVRURVIgRSAqL1xuICAgIFhLX2Y6ICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgwMDY2LCAvKiBVKzAwNjYgTEFUSU4gU01BTEwgTEVUVEVSIEYgKi9cbiAgICBYS19nOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA2NywgLyogVSswMDY3IExBVElOIFNNQUxMIExFVFRFUiBHICovXG4gICAgWEtfaDogICAgICAgICAgICAgICAgICAgICAgICAgICAweDAwNjgsIC8qIFUrMDA2OCBMQVRJTiBTTUFMTCBMRVRURVIgSCAqL1xuICAgIFhLX2k6ICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgwMDY5LCAvKiBVKzAwNjkgTEFUSU4gU01BTEwgTEVUVEVSIEkgKi9cbiAgICBYS19qOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA2YSwgLyogVSswMDZBIExBVElOIFNNQUxMIExFVFRFUiBKICovXG4gICAgWEtfazogICAgICAgICAgICAgICAgICAgICAgICAgICAweDAwNmIsIC8qIFUrMDA2QiBMQVRJTiBTTUFMTCBMRVRURVIgSyAqL1xuICAgIFhLX2w6ICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgwMDZjLCAvKiBVKzAwNkMgTEFUSU4gU01BTEwgTEVUVEVSIEwgKi9cbiAgICBYS19tOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA2ZCwgLyogVSswMDZEIExBVElOIFNNQUxMIExFVFRFUiBNICovXG4gICAgWEtfbjogICAgICAgICAgICAgICAgICAgICAgICAgICAweDAwNmUsIC8qIFUrMDA2RSBMQVRJTiBTTUFMTCBMRVRURVIgTiAqL1xuICAgIFhLX286ICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgwMDZmLCAvKiBVKzAwNkYgTEFUSU4gU01BTEwgTEVUVEVSIE8gKi9cbiAgICBYS19wOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA3MCwgLyogVSswMDcwIExBVElOIFNNQUxMIExFVFRFUiBQICovXG4gICAgWEtfcTogICAgICAgICAgICAgICAgICAgICAgICAgICAweDAwNzEsIC8qIFUrMDA3MSBMQVRJTiBTTUFMTCBMRVRURVIgUSAqL1xuICAgIFhLX3I6ICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgwMDcyLCAvKiBVKzAwNzIgTEFUSU4gU01BTEwgTEVUVEVSIFIgKi9cbiAgICBYS19zOiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA3MywgLyogVSswMDczIExBVElOIFNNQUxMIExFVFRFUiBTICovXG4gICAgWEtfdDogICAgICAgICAgICAgICAgICAgICAgICAgICAweDAwNzQsIC8qIFUrMDA3NCBMQVRJTiBTTUFMTCBMRVRURVIgVCAqL1xuICAgIFhLX3U6ICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgwMDc1LCAvKiBVKzAwNzUgTEFUSU4gU01BTEwgTEVUVEVSIFUgKi9cbiAgICBYS192OiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA3NiwgLyogVSswMDc2IExBVElOIFNNQUxMIExFVFRFUiBWICovXG4gICAgWEtfdzogICAgICAgICAgICAgICAgICAgICAgICAgICAweDAwNzcsIC8qIFUrMDA3NyBMQVRJTiBTTUFMTCBMRVRURVIgVyAqL1xuICAgIFhLX3g6ICAgICAgICAgICAgICAgICAgICAgICAgICAgMHgwMDc4LCAvKiBVKzAwNzggTEFUSU4gU01BTEwgTEVUVEVSIFggKi9cbiAgICBYS195OiAgICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDA3OSwgLyogVSswMDc5IExBVElOIFNNQUxMIExFVFRFUiBZICovXG4gICAgWEtfejogICAgICAgICAgICAgICAgICAgICAgICAgICAweDAwN2EsIC8qIFUrMDA3QSBMQVRJTiBTTUFMTCBMRVRURVIgWiAqL1xuICAgIFhLX2JyYWNlbGVmdDogICAgICAgICAgICAgICAgICAgMHgwMDdiLCAvKiBVKzAwN0IgTEVGVCBDVVJMWSBCUkFDS0VUICovXG4gICAgWEtfYmFyOiAgICAgICAgICAgICAgICAgICAgICAgICAweDAwN2MsIC8qIFUrMDA3QyBWRVJUSUNBTCBMSU5FICovXG4gICAgWEtfYnJhY2VyaWdodDogICAgICAgICAgICAgICAgICAweDAwN2QsIC8qIFUrMDA3RCBSSUdIVCBDVVJMWSBCUkFDS0VUICovXG4gICAgWEtfYXNjaWl0aWxkZTogICAgICAgICAgICAgICAgICAweDAwN2UsIC8qIFUrMDA3RSBUSUxERSAqL1xuXG4gICAgWEtfbm9icmVha3NwYWNlOiAgICAgICAgICAgICAgICAweDAwYTAsIC8qIFUrMDBBMCBOTy1CUkVBSyBTUEFDRSAqL1xuICAgIFhLX2V4Y2xhbWRvd246ICAgICAgICAgICAgICAgICAgMHgwMGExLCAvKiBVKzAwQTEgSU5WRVJURUQgRVhDTEFNQVRJT04gTUFSSyAqL1xuICAgIFhLX2NlbnQ6ICAgICAgICAgICAgICAgICAgICAgICAgMHgwMGEyLCAvKiBVKzAwQTIgQ0VOVCBTSUdOICovXG4gICAgWEtfc3Rlcmxpbmc6ICAgICAgICAgICAgICAgICAgICAweDAwYTMsIC8qIFUrMDBBMyBQT1VORCBTSUdOICovXG4gICAgWEtfY3VycmVuY3k6ICAgICAgICAgICAgICAgICAgICAweDAwYTQsIC8qIFUrMDBBNCBDVVJSRU5DWSBTSUdOICovXG4gICAgWEtfeWVuOiAgICAgICAgICAgICAgICAgICAgICAgICAweDAwYTUsIC8qIFUrMDBBNSBZRU4gU0lHTiAqL1xuICAgIFhLX2Jyb2tlbmJhcjogICAgICAgICAgICAgICAgICAgMHgwMGE2LCAvKiBVKzAwQTYgQlJPS0VOIEJBUiAqL1xuICAgIFhLX3NlY3Rpb246ICAgICAgICAgICAgICAgICAgICAgMHgwMGE3LCAvKiBVKzAwQTcgU0VDVElPTiBTSUdOICovXG4gICAgWEtfZGlhZXJlc2lzOiAgICAgICAgICAgICAgICAgICAweDAwYTgsIC8qIFUrMDBBOCBESUFFUkVTSVMgKi9cbiAgICBYS19jb3B5cmlnaHQ6ICAgICAgICAgICAgICAgICAgIDB4MDBhOSwgLyogVSswMEE5IENPUFlSSUdIVCBTSUdOICovXG4gICAgWEtfb3JkZmVtaW5pbmU6ICAgICAgICAgICAgICAgICAweDAwYWEsIC8qIFUrMDBBQSBGRU1JTklORSBPUkRJTkFMIElORElDQVRPUiAqL1xuICAgIFhLX2d1aWxsZW1vdGxlZnQ6ICAgICAgICAgICAgICAgMHgwMGFiLCAvKiBVKzAwQUIgTEVGVC1QT0lOVElORyBET1VCTEUgQU5HTEUgUVVPVEFUSU9OIE1BUksgKi9cbiAgICBYS19ub3RzaWduOiAgICAgICAgICAgICAgICAgICAgIDB4MDBhYywgLyogVSswMEFDIE5PVCBTSUdOICovXG4gICAgWEtfaHlwaGVuOiAgICAgICAgICAgICAgICAgICAgICAweDAwYWQsIC8qIFUrMDBBRCBTT0ZUIEhZUEhFTiAqL1xuICAgIFhLX3JlZ2lzdGVyZWQ6ICAgICAgICAgICAgICAgICAgMHgwMGFlLCAvKiBVKzAwQUUgUkVHSVNURVJFRCBTSUdOICovXG4gICAgWEtfbWFjcm9uOiAgICAgICAgICAgICAgICAgICAgICAweDAwYWYsIC8qIFUrMDBBRiBNQUNST04gKi9cbiAgICBYS19kZWdyZWU6ICAgICAgICAgICAgICAgICAgICAgIDB4MDBiMCwgLyogVSswMEIwIERFR1JFRSBTSUdOICovXG4gICAgWEtfcGx1c21pbnVzOiAgICAgICAgICAgICAgICAgICAweDAwYjEsIC8qIFUrMDBCMSBQTFVTLU1JTlVTIFNJR04gKi9cbiAgICBYS190d29zdXBlcmlvcjogICAgICAgICAgICAgICAgIDB4MDBiMiwgLyogVSswMEIyIFNVUEVSU0NSSVBUIFRXTyAqL1xuICAgIFhLX3RocmVlc3VwZXJpb3I6ICAgICAgICAgICAgICAgMHgwMGIzLCAvKiBVKzAwQjMgU1VQRVJTQ1JJUFQgVEhSRUUgKi9cbiAgICBYS19hY3V0ZTogICAgICAgICAgICAgICAgICAgICAgIDB4MDBiNCwgLyogVSswMEI0IEFDVVRFIEFDQ0VOVCAqL1xuICAgIFhLX211OiAgICAgICAgICAgICAgICAgICAgICAgICAgMHgwMGI1LCAvKiBVKzAwQjUgTUlDUk8gU0lHTiAqL1xuICAgIFhLX3BhcmFncmFwaDogICAgICAgICAgICAgICAgICAgMHgwMGI2LCAvKiBVKzAwQjYgUElMQ1JPVyBTSUdOICovXG4gICAgWEtfcGVyaW9kY2VudGVyZWQ6ICAgICAgICAgICAgICAweDAwYjcsIC8qIFUrMDBCNyBNSURETEUgRE9UICovXG4gICAgWEtfY2VkaWxsYTogICAgICAgICAgICAgICAgICAgICAweDAwYjgsIC8qIFUrMDBCOCBDRURJTExBICovXG4gICAgWEtfb25lc3VwZXJpb3I6ICAgICAgICAgICAgICAgICAweDAwYjksIC8qIFUrMDBCOSBTVVBFUlNDUklQVCBPTkUgKi9cbiAgICBYS19tYXNjdWxpbmU6ICAgICAgICAgICAgICAgICAgIDB4MDBiYSwgLyogVSswMEJBIE1BU0NVTElORSBPUkRJTkFMIElORElDQVRPUiAqL1xuICAgIFhLX2d1aWxsZW1vdHJpZ2h0OiAgICAgICAgICAgICAgMHgwMGJiLCAvKiBVKzAwQkIgUklHSFQtUE9JTlRJTkcgRE9VQkxFIEFOR0xFIFFVT1RBVElPTiBNQVJLICovXG4gICAgWEtfb25lcXVhcnRlcjogICAgICAgICAgICAgICAgICAweDAwYmMsIC8qIFUrMDBCQyBWVUxHQVIgRlJBQ1RJT04gT05FIFFVQVJURVIgKi9cbiAgICBYS19vbmVoYWxmOiAgICAgICAgICAgICAgICAgICAgIDB4MDBiZCwgLyogVSswMEJEIFZVTEdBUiBGUkFDVElPTiBPTkUgSEFMRiAqL1xuICAgIFhLX3RocmVlcXVhcnRlcnM6ICAgICAgICAgICAgICAgMHgwMGJlLCAvKiBVKzAwQkUgVlVMR0FSIEZSQUNUSU9OIFRIUkVFIFFVQVJURVJTICovXG4gICAgWEtfcXVlc3Rpb25kb3duOiAgICAgICAgICAgICAgICAweDAwYmYsIC8qIFUrMDBCRiBJTlZFUlRFRCBRVUVTVElPTiBNQVJLICovXG4gICAgWEtfQWdyYXZlOiAgICAgICAgICAgICAgICAgICAgICAweDAwYzAsIC8qIFUrMDBDMCBMQVRJTiBDQVBJVEFMIExFVFRFUiBBIFdJVEggR1JBVkUgKi9cbiAgICBYS19BYWN1dGU6ICAgICAgICAgICAgICAgICAgICAgIDB4MDBjMSwgLyogVSswMEMxIExBVElOIENBUElUQUwgTEVUVEVSIEEgV0lUSCBBQ1VURSAqL1xuICAgIFhLX0FjaXJjdW1mbGV4OiAgICAgICAgICAgICAgICAgMHgwMGMyLCAvKiBVKzAwQzIgTEFUSU4gQ0FQSVRBTCBMRVRURVIgQSBXSVRIIENJUkNVTUZMRVggKi9cbiAgICBYS19BdGlsZGU6ICAgICAgICAgICAgICAgICAgICAgIDB4MDBjMywgLyogVSswMEMzIExBVElOIENBUElUQUwgTEVUVEVSIEEgV0lUSCBUSUxERSAqL1xuICAgIFhLX0FkaWFlcmVzaXM6ICAgICAgICAgICAgICAgICAgMHgwMGM0LCAvKiBVKzAwQzQgTEFUSU4gQ0FQSVRBTCBMRVRURVIgQSBXSVRIIERJQUVSRVNJUyAqL1xuICAgIFhLX0FyaW5nOiAgICAgICAgICAgICAgICAgICAgICAgMHgwMGM1LCAvKiBVKzAwQzUgTEFUSU4gQ0FQSVRBTCBMRVRURVIgQSBXSVRIIFJJTkcgQUJPVkUgKi9cbiAgICBYS19BRTogICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDBjNiwgLyogVSswMEM2IExBVElOIENBUElUQUwgTEVUVEVSIEFFICovXG4gICAgWEtfQ2NlZGlsbGE6ICAgICAgICAgICAgICAgICAgICAweDAwYzcsIC8qIFUrMDBDNyBMQVRJTiBDQVBJVEFMIExFVFRFUiBDIFdJVEggQ0VESUxMQSAqL1xuICAgIFhLX0VncmF2ZTogICAgICAgICAgICAgICAgICAgICAgMHgwMGM4LCAvKiBVKzAwQzggTEFUSU4gQ0FQSVRBTCBMRVRURVIgRSBXSVRIIEdSQVZFICovXG4gICAgWEtfRWFjdXRlOiAgICAgICAgICAgICAgICAgICAgICAweDAwYzksIC8qIFUrMDBDOSBMQVRJTiBDQVBJVEFMIExFVFRFUiBFIFdJVEggQUNVVEUgKi9cbiAgICBYS19FY2lyY3VtZmxleDogICAgICAgICAgICAgICAgIDB4MDBjYSwgLyogVSswMENBIExBVElOIENBUElUQUwgTEVUVEVSIEUgV0lUSCBDSVJDVU1GTEVYICovXG4gICAgWEtfRWRpYWVyZXNpczogICAgICAgICAgICAgICAgICAweDAwY2IsIC8qIFUrMDBDQiBMQVRJTiBDQVBJVEFMIExFVFRFUiBFIFdJVEggRElBRVJFU0lTICovXG4gICAgWEtfSWdyYXZlOiAgICAgICAgICAgICAgICAgICAgICAweDAwY2MsIC8qIFUrMDBDQyBMQVRJTiBDQVBJVEFMIExFVFRFUiBJIFdJVEggR1JBVkUgKi9cbiAgICBYS19JYWN1dGU6ICAgICAgICAgICAgICAgICAgICAgIDB4MDBjZCwgLyogVSswMENEIExBVElOIENBUElUQUwgTEVUVEVSIEkgV0lUSCBBQ1VURSAqL1xuICAgIFhLX0ljaXJjdW1mbGV4OiAgICAgICAgICAgICAgICAgMHgwMGNlLCAvKiBVKzAwQ0UgTEFUSU4gQ0FQSVRBTCBMRVRURVIgSSBXSVRIIENJUkNVTUZMRVggKi9cbiAgICBYS19JZGlhZXJlc2lzOiAgICAgICAgICAgICAgICAgIDB4MDBjZiwgLyogVSswMENGIExBVElOIENBUElUQUwgTEVUVEVSIEkgV0lUSCBESUFFUkVTSVMgKi9cbiAgICBYS19FVEg6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDBkMCwgLyogVSswMEQwIExBVElOIENBUElUQUwgTEVUVEVSIEVUSCAqL1xuICAgIFhLX0V0aDogICAgICAgICAgICAgICAgICAgICAgICAgMHgwMGQwLCAvKiBkZXByZWNhdGVkICovXG4gICAgWEtfTnRpbGRlOiAgICAgICAgICAgICAgICAgICAgICAweDAwZDEsIC8qIFUrMDBEMSBMQVRJTiBDQVBJVEFMIExFVFRFUiBOIFdJVEggVElMREUgKi9cbiAgICBYS19PZ3JhdmU6ICAgICAgICAgICAgICAgICAgICAgIDB4MDBkMiwgLyogVSswMEQyIExBVElOIENBUElUQUwgTEVUVEVSIE8gV0lUSCBHUkFWRSAqL1xuICAgIFhLX09hY3V0ZTogICAgICAgICAgICAgICAgICAgICAgMHgwMGQzLCAvKiBVKzAwRDMgTEFUSU4gQ0FQSVRBTCBMRVRURVIgTyBXSVRIIEFDVVRFICovXG4gICAgWEtfT2NpcmN1bWZsZXg6ICAgICAgICAgICAgICAgICAweDAwZDQsIC8qIFUrMDBENCBMQVRJTiBDQVBJVEFMIExFVFRFUiBPIFdJVEggQ0lSQ1VNRkxFWCAqL1xuICAgIFhLX090aWxkZTogICAgICAgICAgICAgICAgICAgICAgMHgwMGQ1LCAvKiBVKzAwRDUgTEFUSU4gQ0FQSVRBTCBMRVRURVIgTyBXSVRIIFRJTERFICovXG4gICAgWEtfT2RpYWVyZXNpczogICAgICAgICAgICAgICAgICAweDAwZDYsIC8qIFUrMDBENiBMQVRJTiBDQVBJVEFMIExFVFRFUiBPIFdJVEggRElBRVJFU0lTICovXG4gICAgWEtfbXVsdGlwbHk6ICAgICAgICAgICAgICAgICAgICAweDAwZDcsIC8qIFUrMDBENyBNVUxUSVBMSUNBVElPTiBTSUdOICovXG4gICAgWEtfT3NsYXNoOiAgICAgICAgICAgICAgICAgICAgICAweDAwZDgsIC8qIFUrMDBEOCBMQVRJTiBDQVBJVEFMIExFVFRFUiBPIFdJVEggU1RST0tFICovXG4gICAgWEtfT29ibGlxdWU6ICAgICAgICAgICAgICAgICAgICAweDAwZDgsIC8qIFUrMDBEOCBMQVRJTiBDQVBJVEFMIExFVFRFUiBPIFdJVEggU1RST0tFICovXG4gICAgWEtfVWdyYXZlOiAgICAgICAgICAgICAgICAgICAgICAweDAwZDksIC8qIFUrMDBEOSBMQVRJTiBDQVBJVEFMIExFVFRFUiBVIFdJVEggR1JBVkUgKi9cbiAgICBYS19VYWN1dGU6ICAgICAgICAgICAgICAgICAgICAgIDB4MDBkYSwgLyogVSswMERBIExBVElOIENBUElUQUwgTEVUVEVSIFUgV0lUSCBBQ1VURSAqL1xuICAgIFhLX1VjaXJjdW1mbGV4OiAgICAgICAgICAgICAgICAgMHgwMGRiLCAvKiBVKzAwREIgTEFUSU4gQ0FQSVRBTCBMRVRURVIgVSBXSVRIIENJUkNVTUZMRVggKi9cbiAgICBYS19VZGlhZXJlc2lzOiAgICAgICAgICAgICAgICAgIDB4MDBkYywgLyogVSswMERDIExBVElOIENBUElUQUwgTEVUVEVSIFUgV0lUSCBESUFFUkVTSVMgKi9cbiAgICBYS19ZYWN1dGU6ICAgICAgICAgICAgICAgICAgICAgIDB4MDBkZCwgLyogVSswMEREIExBVElOIENBUElUQUwgTEVUVEVSIFkgV0lUSCBBQ1VURSAqL1xuICAgIFhLX1RIT1JOOiAgICAgICAgICAgICAgICAgICAgICAgMHgwMGRlLCAvKiBVKzAwREUgTEFUSU4gQ0FQSVRBTCBMRVRURVIgVEhPUk4gKi9cbiAgICBYS19UaG9ybjogICAgICAgICAgICAgICAgICAgICAgIDB4MDBkZSwgLyogZGVwcmVjYXRlZCAqL1xuICAgIFhLX3NzaGFycDogICAgICAgICAgICAgICAgICAgICAgMHgwMGRmLCAvKiBVKzAwREYgTEFUSU4gU01BTEwgTEVUVEVSIFNIQVJQIFMgKi9cbiAgICBYS19hZ3JhdmU6ICAgICAgICAgICAgICAgICAgICAgIDB4MDBlMCwgLyogVSswMEUwIExBVElOIFNNQUxMIExFVFRFUiBBIFdJVEggR1JBVkUgKi9cbiAgICBYS19hYWN1dGU6ICAgICAgICAgICAgICAgICAgICAgIDB4MDBlMSwgLyogVSswMEUxIExBVElOIFNNQUxMIExFVFRFUiBBIFdJVEggQUNVVEUgKi9cbiAgICBYS19hY2lyY3VtZmxleDogICAgICAgICAgICAgICAgIDB4MDBlMiwgLyogVSswMEUyIExBVElOIFNNQUxMIExFVFRFUiBBIFdJVEggQ0lSQ1VNRkxFWCAqL1xuICAgIFhLX2F0aWxkZTogICAgICAgICAgICAgICAgICAgICAgMHgwMGUzLCAvKiBVKzAwRTMgTEFUSU4gU01BTEwgTEVUVEVSIEEgV0lUSCBUSUxERSAqL1xuICAgIFhLX2FkaWFlcmVzaXM6ICAgICAgICAgICAgICAgICAgMHgwMGU0LCAvKiBVKzAwRTQgTEFUSU4gU01BTEwgTEVUVEVSIEEgV0lUSCBESUFFUkVTSVMgKi9cbiAgICBYS19hcmluZzogICAgICAgICAgICAgICAgICAgICAgIDB4MDBlNSwgLyogVSswMEU1IExBVElOIFNNQUxMIExFVFRFUiBBIFdJVEggUklORyBBQk9WRSAqL1xuICAgIFhLX2FlOiAgICAgICAgICAgICAgICAgICAgICAgICAgMHgwMGU2LCAvKiBVKzAwRTYgTEFUSU4gU01BTEwgTEVUVEVSIEFFICovXG4gICAgWEtfY2NlZGlsbGE6ICAgICAgICAgICAgICAgICAgICAweDAwZTcsIC8qIFUrMDBFNyBMQVRJTiBTTUFMTCBMRVRURVIgQyBXSVRIIENFRElMTEEgKi9cbiAgICBYS19lZ3JhdmU6ICAgICAgICAgICAgICAgICAgICAgIDB4MDBlOCwgLyogVSswMEU4IExBVElOIFNNQUxMIExFVFRFUiBFIFdJVEggR1JBVkUgKi9cbiAgICBYS19lYWN1dGU6ICAgICAgICAgICAgICAgICAgICAgIDB4MDBlOSwgLyogVSswMEU5IExBVElOIFNNQUxMIExFVFRFUiBFIFdJVEggQUNVVEUgKi9cbiAgICBYS19lY2lyY3VtZmxleDogICAgICAgICAgICAgICAgIDB4MDBlYSwgLyogVSswMEVBIExBVElOIFNNQUxMIExFVFRFUiBFIFdJVEggQ0lSQ1VNRkxFWCAqL1xuICAgIFhLX2VkaWFlcmVzaXM6ICAgICAgICAgICAgICAgICAgMHgwMGViLCAvKiBVKzAwRUIgTEFUSU4gU01BTEwgTEVUVEVSIEUgV0lUSCBESUFFUkVTSVMgKi9cbiAgICBYS19pZ3JhdmU6ICAgICAgICAgICAgICAgICAgICAgIDB4MDBlYywgLyogVSswMEVDIExBVElOIFNNQUxMIExFVFRFUiBJIFdJVEggR1JBVkUgKi9cbiAgICBYS19pYWN1dGU6ICAgICAgICAgICAgICAgICAgICAgIDB4MDBlZCwgLyogVSswMEVEIExBVElOIFNNQUxMIExFVFRFUiBJIFdJVEggQUNVVEUgKi9cbiAgICBYS19pY2lyY3VtZmxleDogICAgICAgICAgICAgICAgIDB4MDBlZSwgLyogVSswMEVFIExBVElOIFNNQUxMIExFVFRFUiBJIFdJVEggQ0lSQ1VNRkxFWCAqL1xuICAgIFhLX2lkaWFlcmVzaXM6ICAgICAgICAgICAgICAgICAgMHgwMGVmLCAvKiBVKzAwRUYgTEFUSU4gU01BTEwgTEVUVEVSIEkgV0lUSCBESUFFUkVTSVMgKi9cbiAgICBYS19ldGg6ICAgICAgICAgICAgICAgICAgICAgICAgIDB4MDBmMCwgLyogVSswMEYwIExBVElOIFNNQUxMIExFVFRFUiBFVEggKi9cbiAgICBYS19udGlsZGU6ICAgICAgICAgICAgICAgICAgICAgIDB4MDBmMSwgLyogVSswMEYxIExBVElOIFNNQUxMIExFVFRFUiBOIFdJVEggVElMREUgKi9cbiAgICBYS19vZ3JhdmU6ICAgICAgICAgICAgICAgICAgICAgIDB4MDBmMiwgLyogVSswMEYyIExBVElOIFNNQUxMIExFVFRFUiBPIFdJVEggR1JBVkUgKi9cbiAgICBYS19vYWN1dGU6ICAgICAgICAgICAgICAgICAgICAgIDB4MDBmMywgLyogVSswMEYzIExBVElOIFNNQUxMIExFVFRFUiBPIFdJVEggQUNVVEUgKi9cbiAgICBYS19vY2lyY3VtZmxleDogICAgICAgICAgICAgICAgIDB4MDBmNCwgLyogVSswMEY0IExBVElOIFNNQUxMIExFVFRFUiBPIFdJVEggQ0lSQ1VNRkxFWCAqL1xuICAgIFhLX290aWxkZTogICAgICAgICAgICAgICAgICAgICAgMHgwMGY1LCAvKiBVKzAwRjUgTEFUSU4gU01BTEwgTEVUVEVSIE8gV0lUSCBUSUxERSAqL1xuICAgIFhLX29kaWFlcmVzaXM6ICAgICAgICAgICAgICAgICAgMHgwMGY2LCAvKiBVKzAwRjYgTEFUSU4gU01BTEwgTEVUVEVSIE8gV0lUSCBESUFFUkVTSVMgKi9cbiAgICBYS19kaXZpc2lvbjogICAgICAgICAgICAgICAgICAgIDB4MDBmNywgLyogVSswMEY3IERJVklTSU9OIFNJR04gKi9cbiAgICBYS19vc2xhc2g6ICAgICAgICAgICAgICAgICAgICAgIDB4MDBmOCwgLyogVSswMEY4IExBVElOIFNNQUxMIExFVFRFUiBPIFdJVEggU1RST0tFICovXG4gICAgWEtfb29ibGlxdWU6ICAgICAgICAgICAgICAgICAgICAweDAwZjgsIC8qIFUrMDBGOCBMQVRJTiBTTUFMTCBMRVRURVIgTyBXSVRIIFNUUk9LRSAqL1xuICAgIFhLX3VncmF2ZTogICAgICAgICAgICAgICAgICAgICAgMHgwMGY5LCAvKiBVKzAwRjkgTEFUSU4gU01BTEwgTEVUVEVSIFUgV0lUSCBHUkFWRSAqL1xuICAgIFhLX3VhY3V0ZTogICAgICAgICAgICAgICAgICAgICAgMHgwMGZhLCAvKiBVKzAwRkEgTEFUSU4gU01BTEwgTEVUVEVSIFUgV0lUSCBBQ1VURSAqL1xuICAgIFhLX3VjaXJjdW1mbGV4OiAgICAgICAgICAgICAgICAgMHgwMGZiLCAvKiBVKzAwRkIgTEFUSU4gU01BTEwgTEVUVEVSIFUgV0lUSCBDSVJDVU1GTEVYICovXG4gICAgWEtfdWRpYWVyZXNpczogICAgICAgICAgICAgICAgICAweDAwZmMsIC8qIFUrMDBGQyBMQVRJTiBTTUFMTCBMRVRURVIgVSBXSVRIIERJQUVSRVNJUyAqL1xuICAgIFhLX3lhY3V0ZTogICAgICAgICAgICAgICAgICAgICAgMHgwMGZkLCAvKiBVKzAwRkQgTEFUSU4gU01BTEwgTEVUVEVSIFkgV0lUSCBBQ1VURSAqL1xuICAgIFhLX3Rob3JuOiAgICAgICAgICAgICAgICAgICAgICAgMHgwMGZlLCAvKiBVKzAwRkUgTEFUSU4gU01BTEwgTEVUVEVSIFRIT1JOICovXG4gICAgWEtfeWRpYWVyZXNpczogICAgICAgICAgICAgICAgICAweDAwZmYsIC8qIFUrMDBGRiBMQVRJTiBTTUFMTCBMRVRURVIgWSBXSVRIIERJQUVSRVNJUyAqL1xuXG4gICAgLypcbiAgICAgKiBLb3JlYW5cbiAgICAgKiBCeXRlIDMgPSAweDBlXG4gICAgICovXG5cbiAgICBYS19IYW5ndWw6ICAgICAgICAgICAgICAgICAgICAgIDB4ZmYzMSwgLyogSGFuZ3VsIHN0YXJ0L3N0b3AodG9nZ2xlKSAqL1xuICAgIFhLX0hhbmd1bF9IYW5qYTogICAgICAgICAgICAgICAgMHhmZjM0LCAvKiBTdGFydCBIYW5ndWwtPkhhbmphIENvbnZlcnNpb24gKi9cbiAgICBYS19IYW5ndWxfSmVvbmphOiAgICAgICAgICAgICAgIDB4ZmYzOCwgLyogSmVvbmphIG1vZGUgKi9cblxuICAgIC8qXG4gICAgICogWEZyZWU4NiB2ZW5kb3Igc3BlY2lmaWMga2V5c3ltcy5cbiAgICAgKlxuICAgICAqIFRoZSBYRnJlZTg2IGtleXN5bSByYW5nZSBpcyAweDEwMDgwMDAxIC0gMHgxMDA4RkZGRi5cbiAgICAgKi9cblxuICAgIFhGODZYS19Nb2RlTG9jazogICAgICAgICAgICAgICAgMHgxMDA4RkYwMSxcbiAgICBYRjg2WEtfTW9uQnJpZ2h0bmVzc1VwOiAgICAgICAgIDB4MTAwOEZGMDIsXG4gICAgWEY4NlhLX01vbkJyaWdodG5lc3NEb3duOiAgICAgICAweDEwMDhGRjAzLFxuICAgIFhGODZYS19LYmRMaWdodE9uT2ZmOiAgICAgICAgICAgMHgxMDA4RkYwNCxcbiAgICBYRjg2WEtfS2JkQnJpZ2h0bmVzc1VwOiAgICAgICAgIDB4MTAwOEZGMDUsXG4gICAgWEY4NlhLX0tiZEJyaWdodG5lc3NEb3duOiAgICAgICAweDEwMDhGRjA2LFxuICAgIFhGODZYS19TdGFuZGJ5OiAgICAgICAgICAgICAgICAgMHgxMDA4RkYxMCxcbiAgICBYRjg2WEtfQXVkaW9Mb3dlclZvbHVtZTogICAgICAgIDB4MTAwOEZGMTEsXG4gICAgWEY4NlhLX0F1ZGlvTXV0ZTogICAgICAgICAgICAgICAweDEwMDhGRjEyLFxuICAgIFhGODZYS19BdWRpb1JhaXNlVm9sdW1lOiAgICAgICAgMHgxMDA4RkYxMyxcbiAgICBYRjg2WEtfQXVkaW9QbGF5OiAgICAgICAgICAgICAgIDB4MTAwOEZGMTQsXG4gICAgWEY4NlhLX0F1ZGlvU3RvcDogICAgICAgICAgICAgICAweDEwMDhGRjE1LFxuICAgIFhGODZYS19BdWRpb1ByZXY6ICAgICAgICAgICAgICAgMHgxMDA4RkYxNixcbiAgICBYRjg2WEtfQXVkaW9OZXh0OiAgICAgICAgICAgICAgIDB4MTAwOEZGMTcsXG4gICAgWEY4NlhLX0hvbWVQYWdlOiAgICAgICAgICAgICAgICAweDEwMDhGRjE4LFxuICAgIFhGODZYS19NYWlsOiAgICAgICAgICAgICAgICAgICAgMHgxMDA4RkYxOSxcbiAgICBYRjg2WEtfU3RhcnQ6ICAgICAgICAgICAgICAgICAgIDB4MTAwOEZGMUEsXG4gICAgWEY4NlhLX1NlYXJjaDogICAgICAgICAgICAgICAgICAweDEwMDhGRjFCLFxuICAgIFhGODZYS19BdWRpb1JlY29yZDogICAgICAgICAgICAgMHgxMDA4RkYxQyxcbiAgICBYRjg2WEtfQ2FsY3VsYXRvcjogICAgICAgICAgICAgIDB4MTAwOEZGMUQsXG4gICAgWEY4NlhLX01lbW86ICAgICAgICAgICAgICAgICAgICAweDEwMDhGRjFFLFxuICAgIFhGODZYS19Ub0RvTGlzdDogICAgICAgICAgICAgICAgMHgxMDA4RkYxRixcbiAgICBYRjg2WEtfQ2FsZW5kYXI6ICAgICAgICAgICAgICAgIDB4MTAwOEZGMjAsXG4gICAgWEY4NlhLX1Bvd2VyRG93bjogICAgICAgICAgICAgICAweDEwMDhGRjIxLFxuICAgIFhGODZYS19Db250cmFzdEFkanVzdDogICAgICAgICAgMHgxMDA4RkYyMixcbiAgICBYRjg2WEtfUm9ja2VyVXA6ICAgICAgICAgICAgICAgIDB4MTAwOEZGMjMsXG4gICAgWEY4NlhLX1JvY2tlckRvd246ICAgICAgICAgICAgICAweDEwMDhGRjI0LFxuICAgIFhGODZYS19Sb2NrZXJFbnRlcjogICAgICAgICAgICAgMHgxMDA4RkYyNSxcbiAgICBYRjg2WEtfQmFjazogICAgICAgICAgICAgICAgICAgIDB4MTAwOEZGMjYsXG4gICAgWEY4NlhLX0ZvcndhcmQ6ICAgICAgICAgICAgICAgICAweDEwMDhGRjI3LFxuICAgIFhGODZYS19TdG9wOiAgICAgICAgICAgICAgICAgICAgMHgxMDA4RkYyOCxcbiAgICBYRjg2WEtfUmVmcmVzaDogICAgICAgICAgICAgICAgIDB4MTAwOEZGMjksXG4gICAgWEY4NlhLX1Bvd2VyT2ZmOiAgICAgICAgICAgICAgICAweDEwMDhGRjJBLFxuICAgIFhGODZYS19XYWtlVXA6ICAgICAgICAgICAgICAgICAgMHgxMDA4RkYyQixcbiAgICBYRjg2WEtfRWplY3Q6ICAgICAgICAgICAgICAgICAgIDB4MTAwOEZGMkMsXG4gICAgWEY4NlhLX1NjcmVlblNhdmVyOiAgICAgICAgICAgICAweDEwMDhGRjJELFxuICAgIFhGODZYS19XV1c6ICAgICAgICAgICAgICAgICAgICAgMHgxMDA4RkYyRSxcbiAgICBYRjg2WEtfU2xlZXA6ICAgICAgICAgICAgICAgICAgIDB4MTAwOEZGMkYsXG4gICAgWEY4NlhLX0Zhdm9yaXRlczogICAgICAgICAgICAgICAweDEwMDhGRjMwLFxuICAgIFhGODZYS19BdWRpb1BhdXNlOiAgICAgICAgICAgICAgMHgxMDA4RkYzMSxcbiAgICBYRjg2WEtfQXVkaW9NZWRpYTogICAgICAgICAgICAgIDB4MTAwOEZGMzIsXG4gICAgWEY4NlhLX015Q29tcHV0ZXI6ICAgICAgICAgICAgICAweDEwMDhGRjMzLFxuICAgIFhGODZYS19WZW5kb3JIb21lOiAgICAgICAgICAgICAgMHgxMDA4RkYzNCxcbiAgICBYRjg2WEtfTGlnaHRCdWxiOiAgICAgICAgICAgICAgIDB4MTAwOEZGMzUsXG4gICAgWEY4NlhLX1Nob3A6ICAgICAgICAgICAgICAgICAgICAweDEwMDhGRjM2LFxuICAgIFhGODZYS19IaXN0b3J5OiAgICAgICAgICAgICAgICAgMHgxMDA4RkYzNyxcbiAgICBYRjg2WEtfT3BlblVSTDogICAgICAgICAgICAgICAgIDB4MTAwOEZGMzgsXG4gICAgWEY4NlhLX0FkZEZhdm9yaXRlOiAgICAgICAgICAgICAweDEwMDhGRjM5LFxuICAgIFhGODZYS19Ib3RMaW5rczogICAgICAgICAgICAgICAgMHgxMDA4RkYzQSxcbiAgICBYRjg2WEtfQnJpZ2h0bmVzc0FkanVzdDogICAgICAgIDB4MTAwOEZGM0IsXG4gICAgWEY4NlhLX0ZpbmFuY2U6ICAgICAgICAgICAgICAgICAweDEwMDhGRjNDLFxuICAgIFhGODZYS19Db21tdW5pdHk6ICAgICAgICAgICAgICAgMHgxMDA4RkYzRCxcbiAgICBYRjg2WEtfQXVkaW9SZXdpbmQ6ICAgICAgICAgICAgIDB4MTAwOEZGM0UsXG4gICAgWEY4NlhLX0JhY2tGb3J3YXJkOiAgICAgICAgICAgICAweDEwMDhGRjNGLFxuICAgIFhGODZYS19MYXVuY2gwOiAgICAgICAgICAgICAgICAgMHgxMDA4RkY0MCxcbiAgICBYRjg2WEtfTGF1bmNoMTogICAgICAgICAgICAgICAgIDB4MTAwOEZGNDEsXG4gICAgWEY4NlhLX0xhdW5jaDI6ICAgICAgICAgICAgICAgICAweDEwMDhGRjQyLFxuICAgIFhGODZYS19MYXVuY2gzOiAgICAgICAgICAgICAgICAgMHgxMDA4RkY0MyxcbiAgICBYRjg2WEtfTGF1bmNoNDogICAgICAgICAgICAgICAgIDB4MTAwOEZGNDQsXG4gICAgWEY4NlhLX0xhdW5jaDU6ICAgICAgICAgICAgICAgICAweDEwMDhGRjQ1LFxuICAgIFhGODZYS19MYXVuY2g2OiAgICAgICAgICAgICAgICAgMHgxMDA4RkY0NixcbiAgICBYRjg2WEtfTGF1bmNoNzogICAgICAgICAgICAgICAgIDB4MTAwOEZGNDcsXG4gICAgWEY4NlhLX0xhdW5jaDg6ICAgICAgICAgICAgICAgICAweDEwMDhGRjQ4LFxuICAgIFhGODZYS19MYXVuY2g5OiAgICAgICAgICAgICAgICAgMHgxMDA4RkY0OSxcbiAgICBYRjg2WEtfTGF1bmNoQTogICAgICAgICAgICAgICAgIDB4MTAwOEZGNEEsXG4gICAgWEY4NlhLX0xhdW5jaEI6ICAgICAgICAgICAgICAgICAweDEwMDhGRjRCLFxuICAgIFhGODZYS19MYXVuY2hDOiAgICAgICAgICAgICAgICAgMHgxMDA4RkY0QyxcbiAgICBYRjg2WEtfTGF1bmNoRDogICAgICAgICAgICAgICAgIDB4MTAwOEZGNEQsXG4gICAgWEY4NlhLX0xhdW5jaEU6ICAgICAgICAgICAgICAgICAweDEwMDhGRjRFLFxuICAgIFhGODZYS19MYXVuY2hGOiAgICAgICAgICAgICAgICAgMHgxMDA4RkY0RixcbiAgICBYRjg2WEtfQXBwbGljYXRpb25MZWZ0OiAgICAgICAgIDB4MTAwOEZGNTAsXG4gICAgWEY4NlhLX0FwcGxpY2F0aW9uUmlnaHQ6ICAgICAgICAweDEwMDhGRjUxLFxuICAgIFhGODZYS19Cb29rOiAgICAgICAgICAgICAgICAgICAgMHgxMDA4RkY1MixcbiAgICBYRjg2WEtfQ0Q6ICAgICAgICAgICAgICAgICAgICAgIDB4MTAwOEZGNTMsXG4gICAgWEY4NlhLX0NhbGN1bGF0ZXI6ICAgICAgICAgICAgICAweDEwMDhGRjU0LFxuICAgIFhGODZYS19DbGVhcjogICAgICAgICAgICAgICAgICAgMHgxMDA4RkY1NSxcbiAgICBYRjg2WEtfQ2xvc2U6ICAgICAgICAgICAgICAgICAgIDB4MTAwOEZGNTYsXG4gICAgWEY4NlhLX0NvcHk6ICAgICAgICAgICAgICAgICAgICAweDEwMDhGRjU3LFxuICAgIFhGODZYS19DdXQ6ICAgICAgICAgICAgICAgICAgICAgMHgxMDA4RkY1OCxcbiAgICBYRjg2WEtfRGlzcGxheTogICAgICAgICAgICAgICAgIDB4MTAwOEZGNTksXG4gICAgWEY4NlhLX0RPUzogICAgICAgICAgICAgICAgICAgICAweDEwMDhGRjVBLFxuICAgIFhGODZYS19Eb2N1bWVudHM6ICAgICAgICAgICAgICAgMHgxMDA4RkY1QixcbiAgICBYRjg2WEtfRXhjZWw6ICAgICAgICAgICAgICAgICAgIDB4MTAwOEZGNUMsXG4gICAgWEY4NlhLX0V4cGxvcmVyOiAgICAgICAgICAgICAgICAweDEwMDhGRjVELFxuICAgIFhGODZYS19HYW1lOiAgICAgICAgICAgICAgICAgICAgMHgxMDA4RkY1RSxcbiAgICBYRjg2WEtfR286ICAgICAgICAgICAgICAgICAgICAgIDB4MTAwOEZGNUYsXG4gICAgWEY4NlhLX2lUb3VjaDogICAgICAgICAgICAgICAgICAweDEwMDhGRjYwLFxuICAgIFhGODZYS19Mb2dPZmY6ICAgICAgICAgICAgICAgICAgMHgxMDA4RkY2MSxcbiAgICBYRjg2WEtfTWFya2V0OiAgICAgICAgICAgICAgICAgIDB4MTAwOEZGNjIsXG4gICAgWEY4NlhLX01lZXRpbmc6ICAgICAgICAgICAgICAgICAweDEwMDhGRjYzLFxuICAgIFhGODZYS19NZW51S0I6ICAgICAgICAgICAgICAgICAgMHgxMDA4RkY2NSxcbiAgICBYRjg2WEtfTWVudVBCOiAgICAgICAgICAgICAgICAgIDB4MTAwOEZGNjYsXG4gICAgWEY4NlhLX015U2l0ZXM6ICAgICAgICAgICAgICAgICAweDEwMDhGRjY3LFxuICAgIFhGODZYS19OZXc6ICAgICAgICAgICAgICAgICAgICAgMHgxMDA4RkY2OCxcbiAgICBYRjg2WEtfTmV3czogICAgICAgICAgICAgICAgICAgIDB4MTAwOEZGNjksXG4gICAgWEY4NlhLX09mZmljZUhvbWU6ICAgICAgICAgICAgICAweDEwMDhGRjZBLFxuICAgIFhGODZYS19PcGVuOiAgICAgICAgICAgICAgICAgICAgMHgxMDA4RkY2QixcbiAgICBYRjg2WEtfT3B0aW9uOiAgICAgICAgICAgICAgICAgIDB4MTAwOEZGNkMsXG4gICAgWEY4NlhLX1Bhc3RlOiAgICAgICAgICAgICAgICAgICAweDEwMDhGRjZELFxuICAgIFhGODZYS19QaG9uZTogICAgICAgICAgICAgICAgICAgMHgxMDA4RkY2RSxcbiAgICBYRjg2WEtfUTogICAgICAgICAgICAgICAgICAgICAgIDB4MTAwOEZGNzAsXG4gICAgWEY4NlhLX1JlcGx5OiAgICAgICAgICAgICAgICAgICAweDEwMDhGRjcyLFxuICAgIFhGODZYS19SZWxvYWQ6ICAgICAgICAgICAgICAgICAgMHgxMDA4RkY3MyxcbiAgICBYRjg2WEtfUm90YXRlV2luZG93czogICAgICAgICAgIDB4MTAwOEZGNzQsXG4gICAgWEY4NlhLX1JvdGF0aW9uUEI6ICAgICAgICAgICAgICAweDEwMDhGRjc1LFxuICAgIFhGODZYS19Sb3RhdGlvbktCOiAgICAgICAgICAgICAgMHgxMDA4RkY3NixcbiAgICBYRjg2WEtfU2F2ZTogICAgICAgICAgICAgICAgICAgIDB4MTAwOEZGNzcsXG4gICAgWEY4NlhLX1Njcm9sbFVwOiAgICAgICAgICAgICAgICAweDEwMDhGRjc4LFxuICAgIFhGODZYS19TY3JvbGxEb3duOiAgICAgICAgICAgICAgMHgxMDA4RkY3OSxcbiAgICBYRjg2WEtfU2Nyb2xsQ2xpY2s6ICAgICAgICAgICAgIDB4MTAwOEZGN0EsXG4gICAgWEY4NlhLX1NlbmQ6ICAgICAgICAgICAgICAgICAgICAweDEwMDhGRjdCLFxuICAgIFhGODZYS19TcGVsbDogICAgICAgICAgICAgICAgICAgMHgxMDA4RkY3QyxcbiAgICBYRjg2WEtfU3BsaXRTY3JlZW46ICAgICAgICAgICAgIDB4MTAwOEZGN0QsXG4gICAgWEY4NlhLX1N1cHBvcnQ6ICAgICAgICAgICAgICAgICAweDEwMDhGRjdFLFxuICAgIFhGODZYS19UYXNrUGFuZTogICAgICAgICAgICAgICAgMHgxMDA4RkY3RixcbiAgICBYRjg2WEtfVGVybWluYWw6ICAgICAgICAgICAgICAgIDB4MTAwOEZGODAsXG4gICAgWEY4NlhLX1Rvb2xzOiAgICAgICAgICAgICAgICAgICAweDEwMDhGRjgxLFxuICAgIFhGODZYS19UcmF2ZWw6ICAgICAgICAgICAgICAgICAgMHgxMDA4RkY4MixcbiAgICBYRjg2WEtfVXNlclBCOiAgICAgICAgICAgICAgICAgIDB4MTAwOEZGODQsXG4gICAgWEY4NlhLX1VzZXIxS0I6ICAgICAgICAgICAgICAgICAweDEwMDhGRjg1LFxuICAgIFhGODZYS19Vc2VyMktCOiAgICAgICAgICAgICAgICAgMHgxMDA4RkY4NixcbiAgICBYRjg2WEtfVmlkZW86ICAgICAgICAgICAgICAgICAgIDB4MTAwOEZGODcsXG4gICAgWEY4NlhLX1doZWVsQnV0dG9uOiAgICAgICAgICAgICAweDEwMDhGRjg4LFxuICAgIFhGODZYS19Xb3JkOiAgICAgICAgICAgICAgICAgICAgMHgxMDA4RkY4OSxcbiAgICBYRjg2WEtfWGZlcjogICAgICAgICAgICAgICAgICAgIDB4MTAwOEZGOEEsXG4gICAgWEY4NlhLX1pvb21JbjogICAgICAgICAgICAgICAgICAweDEwMDhGRjhCLFxuICAgIFhGODZYS19ab29tT3V0OiAgICAgICAgICAgICAgICAgMHgxMDA4RkY4QyxcbiAgICBYRjg2WEtfQXdheTogICAgICAgICAgICAgICAgICAgIDB4MTAwOEZGOEQsXG4gICAgWEY4NlhLX01lc3NlbmdlcjogICAgICAgICAgICAgICAweDEwMDhGRjhFLFxuICAgIFhGODZYS19XZWJDYW06ICAgICAgICAgICAgICAgICAgMHgxMDA4RkY4RixcbiAgICBYRjg2WEtfTWFpbEZvcndhcmQ6ICAgICAgICAgICAgIDB4MTAwOEZGOTAsXG4gICAgWEY4NlhLX1BpY3R1cmVzOiAgICAgICAgICAgICAgICAweDEwMDhGRjkxLFxuICAgIFhGODZYS19NdXNpYzogICAgICAgICAgICAgICAgICAgMHgxMDA4RkY5MixcbiAgICBYRjg2WEtfQmF0dGVyeTogICAgICAgICAgICAgICAgIDB4MTAwOEZGOTMsXG4gICAgWEY4NlhLX0JsdWV0b290aDogICAgICAgICAgICAgICAweDEwMDhGRjk0LFxuICAgIFhGODZYS19XTEFOOiAgICAgICAgICAgICAgICAgICAgMHgxMDA4RkY5NSxcbiAgICBYRjg2WEtfVVdCOiAgICAgICAgICAgICAgICAgICAgIDB4MTAwOEZGOTYsXG4gICAgWEY4NlhLX0F1ZGlvRm9yd2FyZDogICAgICAgICAgICAweDEwMDhGRjk3LFxuICAgIFhGODZYS19BdWRpb1JlcGVhdDogICAgICAgICAgICAgMHgxMDA4RkY5OCxcbiAgICBYRjg2WEtfQXVkaW9SYW5kb21QbGF5OiAgICAgICAgIDB4MTAwOEZGOTksXG4gICAgWEY4NlhLX1N1YnRpdGxlOiAgICAgICAgICAgICAgICAweDEwMDhGRjlBLFxuICAgIFhGODZYS19BdWRpb0N5Y2xlVHJhY2s6ICAgICAgICAgMHgxMDA4RkY5QixcbiAgICBYRjg2WEtfQ3ljbGVBbmdsZTogICAgICAgICAgICAgIDB4MTAwOEZGOUMsXG4gICAgWEY4NlhLX0ZyYW1lQmFjazogICAgICAgICAgICAgICAweDEwMDhGRjlELFxuICAgIFhGODZYS19GcmFtZUZvcndhcmQ6ICAgICAgICAgICAgMHgxMDA4RkY5RSxcbiAgICBYRjg2WEtfVGltZTogICAgICAgICAgICAgICAgICAgIDB4MTAwOEZGOUYsXG4gICAgWEY4NlhLX1NlbGVjdDogICAgICAgICAgICAgICAgICAweDEwMDhGRkEwLFxuICAgIFhGODZYS19WaWV3OiAgICAgICAgICAgICAgICAgICAgMHgxMDA4RkZBMSxcbiAgICBYRjg2WEtfVG9wTWVudTogICAgICAgICAgICAgICAgIDB4MTAwOEZGQTIsXG4gICAgWEY4NlhLX1JlZDogICAgICAgICAgICAgICAgICAgICAweDEwMDhGRkEzLFxuICAgIFhGODZYS19HcmVlbjogICAgICAgICAgICAgICAgICAgMHgxMDA4RkZBNCxcbiAgICBYRjg2WEtfWWVsbG93OiAgICAgICAgICAgICAgICAgIDB4MTAwOEZGQTUsXG4gICAgWEY4NlhLX0JsdWU6ICAgICAgICAgICAgICAgICAgICAweDEwMDhGRkE2LFxuICAgIFhGODZYS19TdXNwZW5kOiAgICAgICAgICAgICAgICAgMHgxMDA4RkZBNyxcbiAgICBYRjg2WEtfSGliZXJuYXRlOiAgICAgICAgICAgICAgIDB4MTAwOEZGQTgsXG4gICAgWEY4NlhLX1RvdWNocGFkVG9nZ2xlOiAgICAgICAgICAweDEwMDhGRkE5LFxuICAgIFhGODZYS19Ub3VjaHBhZE9uOiAgICAgICAgICAgICAgMHgxMDA4RkZCMCxcbiAgICBYRjg2WEtfVG91Y2hwYWRPZmY6ICAgICAgICAgICAgIDB4MTAwOEZGQjEsXG4gICAgWEY4NlhLX0F1ZGlvTWljTXV0ZTogICAgICAgICAgICAweDEwMDhGRkIyLFxuICAgIFhGODZYS19Td2l0Y2hfVlRfMTogICAgICAgICAgICAgMHgxMDA4RkUwMSxcbiAgICBYRjg2WEtfU3dpdGNoX1ZUXzI6ICAgICAgICAgICAgIDB4MTAwOEZFMDIsXG4gICAgWEY4NlhLX1N3aXRjaF9WVF8zOiAgICAgICAgICAgICAweDEwMDhGRTAzLFxuICAgIFhGODZYS19Td2l0Y2hfVlRfNDogICAgICAgICAgICAgMHgxMDA4RkUwNCxcbiAgICBYRjg2WEtfU3dpdGNoX1ZUXzU6ICAgICAgICAgICAgIDB4MTAwOEZFMDUsXG4gICAgWEY4NlhLX1N3aXRjaF9WVF82OiAgICAgICAgICAgICAweDEwMDhGRTA2LFxuICAgIFhGODZYS19Td2l0Y2hfVlRfNzogICAgICAgICAgICAgMHgxMDA4RkUwNyxcbiAgICBYRjg2WEtfU3dpdGNoX1ZUXzg6ICAgICAgICAgICAgIDB4MTAwOEZFMDgsXG4gICAgWEY4NlhLX1N3aXRjaF9WVF85OiAgICAgICAgICAgICAweDEwMDhGRTA5LFxuICAgIFhGODZYS19Td2l0Y2hfVlRfMTA6ICAgICAgICAgICAgMHgxMDA4RkUwQSxcbiAgICBYRjg2WEtfU3dpdGNoX1ZUXzExOiAgICAgICAgICAgIDB4MTAwOEZFMEIsXG4gICAgWEY4NlhLX1N3aXRjaF9WVF8xMjogICAgICAgICAgICAweDEwMDhGRTBDLFxuICAgIFhGODZYS19VbmdyYWI6ICAgICAgICAgICAgICAgICAgMHgxMDA4RkUyMCxcbiAgICBYRjg2WEtfQ2xlYXJHcmFiOiAgICAgICAgICAgICAgIDB4MTAwOEZFMjEsXG4gICAgWEY4NlhLX05leHRfVk1vZGU6ICAgICAgICAgICAgICAweDEwMDhGRTIyLFxuICAgIFhGODZYS19QcmV2X1ZNb2RlOiAgICAgICAgICAgICAgMHgxMDA4RkUyMyxcbiAgICBYRjg2WEtfTG9nV2luZG93VHJlZTogICAgICAgICAgIDB4MTAwOEZFMjQsXG4gICAgWEY4NlhLX0xvZ0dyYWJJbmZvOiAgICAgICAgICAgICAweDEwMDhGRTI1LFxufTtcbiIsIi8qXG4gKiBNYXBwaW5nIGZyb20gVW5pY29kZSBjb2RlcG9pbnRzIHRvIFgxMS9SRkIga2V5c3ltc1xuICpcbiAqIFRoaXMgZmlsZSB3YXMgYXV0b21hdGljYWxseSBnZW5lcmF0ZWQgZnJvbSBrZXlzeW1kZWYuaFxuICogRE8gTk9UIEVESVQhXG4gKi9cblxuLyogRnVuY3Rpb25zIGF0IHRoZSBib3R0b20gKi9cblxuY29uc3QgY29kZXBvaW50cyA9IHtcbiAgICAweDAxMDA6IDB4MDNjMCwgLy8gWEtfQW1hY3JvblxuICAgIDB4MDEwMTogMHgwM2UwLCAvLyBYS19hbWFjcm9uXG4gICAgMHgwMTAyOiAweDAxYzMsIC8vIFhLX0FicmV2ZVxuICAgIDB4MDEwMzogMHgwMWUzLCAvLyBYS19hYnJldmVcbiAgICAweDAxMDQ6IDB4MDFhMSwgLy8gWEtfQW9nb25la1xuICAgIDB4MDEwNTogMHgwMWIxLCAvLyBYS19hb2dvbmVrXG4gICAgMHgwMTA2OiAweDAxYzYsIC8vIFhLX0NhY3V0ZVxuICAgIDB4MDEwNzogMHgwMWU2LCAvLyBYS19jYWN1dGVcbiAgICAweDAxMDg6IDB4MDJjNiwgLy8gWEtfQ2NpcmN1bWZsZXhcbiAgICAweDAxMDk6IDB4MDJlNiwgLy8gWEtfY2NpcmN1bWZsZXhcbiAgICAweDAxMGE6IDB4MDJjNSwgLy8gWEtfQ2Fib3ZlZG90XG4gICAgMHgwMTBiOiAweDAyZTUsIC8vIFhLX2NhYm92ZWRvdFxuICAgIDB4MDEwYzogMHgwMWM4LCAvLyBYS19DY2Fyb25cbiAgICAweDAxMGQ6IDB4MDFlOCwgLy8gWEtfY2Nhcm9uXG4gICAgMHgwMTBlOiAweDAxY2YsIC8vIFhLX0RjYXJvblxuICAgIDB4MDEwZjogMHgwMWVmLCAvLyBYS19kY2Fyb25cbiAgICAweDAxMTA6IDB4MDFkMCwgLy8gWEtfRHN0cm9rZVxuICAgIDB4MDExMTogMHgwMWYwLCAvLyBYS19kc3Ryb2tlXG4gICAgMHgwMTEyOiAweDAzYWEsIC8vIFhLX0VtYWNyb25cbiAgICAweDAxMTM6IDB4MDNiYSwgLy8gWEtfZW1hY3JvblxuICAgIDB4MDExNjogMHgwM2NjLCAvLyBYS19FYWJvdmVkb3RcbiAgICAweDAxMTc6IDB4MDNlYywgLy8gWEtfZWFib3ZlZG90XG4gICAgMHgwMTE4OiAweDAxY2EsIC8vIFhLX0VvZ29uZWtcbiAgICAweDAxMTk6IDB4MDFlYSwgLy8gWEtfZW9nb25la1xuICAgIDB4MDExYTogMHgwMWNjLCAvLyBYS19FY2Fyb25cbiAgICAweDAxMWI6IDB4MDFlYywgLy8gWEtfZWNhcm9uXG4gICAgMHgwMTFjOiAweDAyZDgsIC8vIFhLX0djaXJjdW1mbGV4XG4gICAgMHgwMTFkOiAweDAyZjgsIC8vIFhLX2djaXJjdW1mbGV4XG4gICAgMHgwMTFlOiAweDAyYWIsIC8vIFhLX0dicmV2ZVxuICAgIDB4MDExZjogMHgwMmJiLCAvLyBYS19nYnJldmVcbiAgICAweDAxMjA6IDB4MDJkNSwgLy8gWEtfR2Fib3ZlZG90XG4gICAgMHgwMTIxOiAweDAyZjUsIC8vIFhLX2dhYm92ZWRvdFxuICAgIDB4MDEyMjogMHgwM2FiLCAvLyBYS19HY2VkaWxsYVxuICAgIDB4MDEyMzogMHgwM2JiLCAvLyBYS19nY2VkaWxsYVxuICAgIDB4MDEyNDogMHgwMmE2LCAvLyBYS19IY2lyY3VtZmxleFxuICAgIDB4MDEyNTogMHgwMmI2LCAvLyBYS19oY2lyY3VtZmxleFxuICAgIDB4MDEyNjogMHgwMmExLCAvLyBYS19Ic3Ryb2tlXG4gICAgMHgwMTI3OiAweDAyYjEsIC8vIFhLX2hzdHJva2VcbiAgICAweDAxMjg6IDB4MDNhNSwgLy8gWEtfSXRpbGRlXG4gICAgMHgwMTI5OiAweDAzYjUsIC8vIFhLX2l0aWxkZVxuICAgIDB4MDEyYTogMHgwM2NmLCAvLyBYS19JbWFjcm9uXG4gICAgMHgwMTJiOiAweDAzZWYsIC8vIFhLX2ltYWNyb25cbiAgICAweDAxMmU6IDB4MDNjNywgLy8gWEtfSW9nb25la1xuICAgIDB4MDEyZjogMHgwM2U3LCAvLyBYS19pb2dvbmVrXG4gICAgMHgwMTMwOiAweDAyYTksIC8vIFhLX0lhYm92ZWRvdFxuICAgIDB4MDEzMTogMHgwMmI5LCAvLyBYS19pZG90bGVzc1xuICAgIDB4MDEzNDogMHgwMmFjLCAvLyBYS19KY2lyY3VtZmxleFxuICAgIDB4MDEzNTogMHgwMmJjLCAvLyBYS19qY2lyY3VtZmxleFxuICAgIDB4MDEzNjogMHgwM2QzLCAvLyBYS19LY2VkaWxsYVxuICAgIDB4MDEzNzogMHgwM2YzLCAvLyBYS19rY2VkaWxsYVxuICAgIDB4MDEzODogMHgwM2EyLCAvLyBYS19rcmFcbiAgICAweDAxMzk6IDB4MDFjNSwgLy8gWEtfTGFjdXRlXG4gICAgMHgwMTNhOiAweDAxZTUsIC8vIFhLX2xhY3V0ZVxuICAgIDB4MDEzYjogMHgwM2E2LCAvLyBYS19MY2VkaWxsYVxuICAgIDB4MDEzYzogMHgwM2I2LCAvLyBYS19sY2VkaWxsYVxuICAgIDB4MDEzZDogMHgwMWE1LCAvLyBYS19MY2Fyb25cbiAgICAweDAxM2U6IDB4MDFiNSwgLy8gWEtfbGNhcm9uXG4gICAgMHgwMTQxOiAweDAxYTMsIC8vIFhLX0xzdHJva2VcbiAgICAweDAxNDI6IDB4MDFiMywgLy8gWEtfbHN0cm9rZVxuICAgIDB4MDE0MzogMHgwMWQxLCAvLyBYS19OYWN1dGVcbiAgICAweDAxNDQ6IDB4MDFmMSwgLy8gWEtfbmFjdXRlXG4gICAgMHgwMTQ1OiAweDAzZDEsIC8vIFhLX05jZWRpbGxhXG4gICAgMHgwMTQ2OiAweDAzZjEsIC8vIFhLX25jZWRpbGxhXG4gICAgMHgwMTQ3OiAweDAxZDIsIC8vIFhLX05jYXJvblxuICAgIDB4MDE0ODogMHgwMWYyLCAvLyBYS19uY2Fyb25cbiAgICAweDAxNGE6IDB4MDNiZCwgLy8gWEtfRU5HXG4gICAgMHgwMTRiOiAweDAzYmYsIC8vIFhLX2VuZ1xuICAgIDB4MDE0YzogMHgwM2QyLCAvLyBYS19PbWFjcm9uXG4gICAgMHgwMTRkOiAweDAzZjIsIC8vIFhLX29tYWNyb25cbiAgICAweDAxNTA6IDB4MDFkNSwgLy8gWEtfT2RvdWJsZWFjdXRlXG4gICAgMHgwMTUxOiAweDAxZjUsIC8vIFhLX29kb3VibGVhY3V0ZVxuICAgIDB4MDE1MjogMHgxM2JjLCAvLyBYS19PRVxuICAgIDB4MDE1MzogMHgxM2JkLCAvLyBYS19vZVxuICAgIDB4MDE1NDogMHgwMWMwLCAvLyBYS19SYWN1dGVcbiAgICAweDAxNTU6IDB4MDFlMCwgLy8gWEtfcmFjdXRlXG4gICAgMHgwMTU2OiAweDAzYTMsIC8vIFhLX1JjZWRpbGxhXG4gICAgMHgwMTU3OiAweDAzYjMsIC8vIFhLX3JjZWRpbGxhXG4gICAgMHgwMTU4OiAweDAxZDgsIC8vIFhLX1JjYXJvblxuICAgIDB4MDE1OTogMHgwMWY4LCAvLyBYS19yY2Fyb25cbiAgICAweDAxNWE6IDB4MDFhNiwgLy8gWEtfU2FjdXRlXG4gICAgMHgwMTViOiAweDAxYjYsIC8vIFhLX3NhY3V0ZVxuICAgIDB4MDE1YzogMHgwMmRlLCAvLyBYS19TY2lyY3VtZmxleFxuICAgIDB4MDE1ZDogMHgwMmZlLCAvLyBYS19zY2lyY3VtZmxleFxuICAgIDB4MDE1ZTogMHgwMWFhLCAvLyBYS19TY2VkaWxsYVxuICAgIDB4MDE1ZjogMHgwMWJhLCAvLyBYS19zY2VkaWxsYVxuICAgIDB4MDE2MDogMHgwMWE5LCAvLyBYS19TY2Fyb25cbiAgICAweDAxNjE6IDB4MDFiOSwgLy8gWEtfc2Nhcm9uXG4gICAgMHgwMTYyOiAweDAxZGUsIC8vIFhLX1RjZWRpbGxhXG4gICAgMHgwMTYzOiAweDAxZmUsIC8vIFhLX3RjZWRpbGxhXG4gICAgMHgwMTY0OiAweDAxYWIsIC8vIFhLX1RjYXJvblxuICAgIDB4MDE2NTogMHgwMWJiLCAvLyBYS190Y2Fyb25cbiAgICAweDAxNjY6IDB4MDNhYywgLy8gWEtfVHNsYXNoXG4gICAgMHgwMTY3OiAweDAzYmMsIC8vIFhLX3RzbGFzaFxuICAgIDB4MDE2ODogMHgwM2RkLCAvLyBYS19VdGlsZGVcbiAgICAweDAxNjk6IDB4MDNmZCwgLy8gWEtfdXRpbGRlXG4gICAgMHgwMTZhOiAweDAzZGUsIC8vIFhLX1VtYWNyb25cbiAgICAweDAxNmI6IDB4MDNmZSwgLy8gWEtfdW1hY3JvblxuICAgIDB4MDE2YzogMHgwMmRkLCAvLyBYS19VYnJldmVcbiAgICAweDAxNmQ6IDB4MDJmZCwgLy8gWEtfdWJyZXZlXG4gICAgMHgwMTZlOiAweDAxZDksIC8vIFhLX1VyaW5nXG4gICAgMHgwMTZmOiAweDAxZjksIC8vIFhLX3VyaW5nXG4gICAgMHgwMTcwOiAweDAxZGIsIC8vIFhLX1Vkb3VibGVhY3V0ZVxuICAgIDB4MDE3MTogMHgwMWZiLCAvLyBYS191ZG91YmxlYWN1dGVcbiAgICAweDAxNzI6IDB4MDNkOSwgLy8gWEtfVW9nb25la1xuICAgIDB4MDE3MzogMHgwM2Y5LCAvLyBYS191b2dvbmVrXG4gICAgMHgwMTc4OiAweDEzYmUsIC8vIFhLX1lkaWFlcmVzaXNcbiAgICAweDAxNzk6IDB4MDFhYywgLy8gWEtfWmFjdXRlXG4gICAgMHgwMTdhOiAweDAxYmMsIC8vIFhLX3phY3V0ZVxuICAgIDB4MDE3YjogMHgwMWFmLCAvLyBYS19aYWJvdmVkb3RcbiAgICAweDAxN2M6IDB4MDFiZiwgLy8gWEtfemFib3ZlZG90XG4gICAgMHgwMTdkOiAweDAxYWUsIC8vIFhLX1pjYXJvblxuICAgIDB4MDE3ZTogMHgwMWJlLCAvLyBYS196Y2Fyb25cbiAgICAweDAxOTI6IDB4MDhmNiwgLy8gWEtfZnVuY3Rpb25cbiAgICAweDAxZDI6IDB4MTAwMDFkMSwgLy8gWEtfT2Nhcm9uXG4gICAgMHgwMmM3OiAweDAxYjcsIC8vIFhLX2Nhcm9uXG4gICAgMHgwMmQ4OiAweDAxYTIsIC8vIFhLX2JyZXZlXG4gICAgMHgwMmQ5OiAweDAxZmYsIC8vIFhLX2Fib3ZlZG90XG4gICAgMHgwMmRiOiAweDAxYjIsIC8vIFhLX29nb25la1xuICAgIDB4MDJkZDogMHgwMWJkLCAvLyBYS19kb3VibGVhY3V0ZVxuICAgIDB4MDM4NTogMHgwN2FlLCAvLyBYS19HcmVla19hY2NlbnRkaWVyZXNpc1xuICAgIDB4MDM4NjogMHgwN2ExLCAvLyBYS19HcmVla19BTFBIQWFjY2VudFxuICAgIDB4MDM4ODogMHgwN2EyLCAvLyBYS19HcmVla19FUFNJTE9OYWNjZW50XG4gICAgMHgwMzg5OiAweDA3YTMsIC8vIFhLX0dyZWVrX0VUQWFjY2VudFxuICAgIDB4MDM4YTogMHgwN2E0LCAvLyBYS19HcmVla19JT1RBYWNjZW50XG4gICAgMHgwMzhjOiAweDA3YTcsIC8vIFhLX0dyZWVrX09NSUNST05hY2NlbnRcbiAgICAweDAzOGU6IDB4MDdhOCwgLy8gWEtfR3JlZWtfVVBTSUxPTmFjY2VudFxuICAgIDB4MDM4ZjogMHgwN2FiLCAvLyBYS19HcmVla19PTUVHQWFjY2VudFxuICAgIDB4MDM5MDogMHgwN2I2LCAvLyBYS19HcmVla19pb3RhYWNjZW50ZGllcmVzaXNcbiAgICAweDAzOTE6IDB4MDdjMSwgLy8gWEtfR3JlZWtfQUxQSEFcbiAgICAweDAzOTI6IDB4MDdjMiwgLy8gWEtfR3JlZWtfQkVUQVxuICAgIDB4MDM5MzogMHgwN2MzLCAvLyBYS19HcmVla19HQU1NQVxuICAgIDB4MDM5NDogMHgwN2M0LCAvLyBYS19HcmVla19ERUxUQVxuICAgIDB4MDM5NTogMHgwN2M1LCAvLyBYS19HcmVla19FUFNJTE9OXG4gICAgMHgwMzk2OiAweDA3YzYsIC8vIFhLX0dyZWVrX1pFVEFcbiAgICAweDAzOTc6IDB4MDdjNywgLy8gWEtfR3JlZWtfRVRBXG4gICAgMHgwMzk4OiAweDA3YzgsIC8vIFhLX0dyZWVrX1RIRVRBXG4gICAgMHgwMzk5OiAweDA3YzksIC8vIFhLX0dyZWVrX0lPVEFcbiAgICAweDAzOWE6IDB4MDdjYSwgLy8gWEtfR3JlZWtfS0FQUEFcbiAgICAweDAzOWI6IDB4MDdjYiwgLy8gWEtfR3JlZWtfTEFNREFcbiAgICAweDAzOWM6IDB4MDdjYywgLy8gWEtfR3JlZWtfTVVcbiAgICAweDAzOWQ6IDB4MDdjZCwgLy8gWEtfR3JlZWtfTlVcbiAgICAweDAzOWU6IDB4MDdjZSwgLy8gWEtfR3JlZWtfWElcbiAgICAweDAzOWY6IDB4MDdjZiwgLy8gWEtfR3JlZWtfT01JQ1JPTlxuICAgIDB4MDNhMDogMHgwN2QwLCAvLyBYS19HcmVla19QSVxuICAgIDB4MDNhMTogMHgwN2QxLCAvLyBYS19HcmVla19SSE9cbiAgICAweDAzYTM6IDB4MDdkMiwgLy8gWEtfR3JlZWtfU0lHTUFcbiAgICAweDAzYTQ6IDB4MDdkNCwgLy8gWEtfR3JlZWtfVEFVXG4gICAgMHgwM2E1OiAweDA3ZDUsIC8vIFhLX0dyZWVrX1VQU0lMT05cbiAgICAweDAzYTY6IDB4MDdkNiwgLy8gWEtfR3JlZWtfUEhJXG4gICAgMHgwM2E3OiAweDA3ZDcsIC8vIFhLX0dyZWVrX0NISVxuICAgIDB4MDNhODogMHgwN2Q4LCAvLyBYS19HcmVla19QU0lcbiAgICAweDAzYTk6IDB4MDdkOSwgLy8gWEtfR3JlZWtfT01FR0FcbiAgICAweDAzYWE6IDB4MDdhNSwgLy8gWEtfR3JlZWtfSU9UQWRpZXJlc2lzXG4gICAgMHgwM2FiOiAweDA3YTksIC8vIFhLX0dyZWVrX1VQU0lMT05kaWVyZXNpc1xuICAgIDB4MDNhYzogMHgwN2IxLCAvLyBYS19HcmVla19hbHBoYWFjY2VudFxuICAgIDB4MDNhZDogMHgwN2IyLCAvLyBYS19HcmVla19lcHNpbG9uYWNjZW50XG4gICAgMHgwM2FlOiAweDA3YjMsIC8vIFhLX0dyZWVrX2V0YWFjY2VudFxuICAgIDB4MDNhZjogMHgwN2I0LCAvLyBYS19HcmVla19pb3RhYWNjZW50XG4gICAgMHgwM2IwOiAweDA3YmEsIC8vIFhLX0dyZWVrX3Vwc2lsb25hY2NlbnRkaWVyZXNpc1xuICAgIDB4MDNiMTogMHgwN2UxLCAvLyBYS19HcmVla19hbHBoYVxuICAgIDB4MDNiMjogMHgwN2UyLCAvLyBYS19HcmVla19iZXRhXG4gICAgMHgwM2IzOiAweDA3ZTMsIC8vIFhLX0dyZWVrX2dhbW1hXG4gICAgMHgwM2I0OiAweDA3ZTQsIC8vIFhLX0dyZWVrX2RlbHRhXG4gICAgMHgwM2I1OiAweDA3ZTUsIC8vIFhLX0dyZWVrX2Vwc2lsb25cbiAgICAweDAzYjY6IDB4MDdlNiwgLy8gWEtfR3JlZWtfemV0YVxuICAgIDB4MDNiNzogMHgwN2U3LCAvLyBYS19HcmVla19ldGFcbiAgICAweDAzYjg6IDB4MDdlOCwgLy8gWEtfR3JlZWtfdGhldGFcbiAgICAweDAzYjk6IDB4MDdlOSwgLy8gWEtfR3JlZWtfaW90YVxuICAgIDB4MDNiYTogMHgwN2VhLCAvLyBYS19HcmVla19rYXBwYVxuICAgIDB4MDNiYjogMHgwN2ViLCAvLyBYS19HcmVla19sYW1kYVxuICAgIDB4MDNiYzogMHgwN2VjLCAvLyBYS19HcmVla19tdVxuICAgIDB4MDNiZDogMHgwN2VkLCAvLyBYS19HcmVla19udVxuICAgIDB4MDNiZTogMHgwN2VlLCAvLyBYS19HcmVla194aVxuICAgIDB4MDNiZjogMHgwN2VmLCAvLyBYS19HcmVla19vbWljcm9uXG4gICAgMHgwM2MwOiAweDA3ZjAsIC8vIFhLX0dyZWVrX3BpXG4gICAgMHgwM2MxOiAweDA3ZjEsIC8vIFhLX0dyZWVrX3Job1xuICAgIDB4MDNjMjogMHgwN2YzLCAvLyBYS19HcmVla19maW5hbHNtYWxsc2lnbWFcbiAgICAweDAzYzM6IDB4MDdmMiwgLy8gWEtfR3JlZWtfc2lnbWFcbiAgICAweDAzYzQ6IDB4MDdmNCwgLy8gWEtfR3JlZWtfdGF1XG4gICAgMHgwM2M1OiAweDA3ZjUsIC8vIFhLX0dyZWVrX3Vwc2lsb25cbiAgICAweDAzYzY6IDB4MDdmNiwgLy8gWEtfR3JlZWtfcGhpXG4gICAgMHgwM2M3OiAweDA3ZjcsIC8vIFhLX0dyZWVrX2NoaVxuICAgIDB4MDNjODogMHgwN2Y4LCAvLyBYS19HcmVla19wc2lcbiAgICAweDAzYzk6IDB4MDdmOSwgLy8gWEtfR3JlZWtfb21lZ2FcbiAgICAweDAzY2E6IDB4MDdiNSwgLy8gWEtfR3JlZWtfaW90YWRpZXJlc2lzXG4gICAgMHgwM2NiOiAweDA3YjksIC8vIFhLX0dyZWVrX3Vwc2lsb25kaWVyZXNpc1xuICAgIDB4MDNjYzogMHgwN2I3LCAvLyBYS19HcmVla19vbWljcm9uYWNjZW50XG4gICAgMHgwM2NkOiAweDA3YjgsIC8vIFhLX0dyZWVrX3Vwc2lsb25hY2NlbnRcbiAgICAweDAzY2U6IDB4MDdiYiwgLy8gWEtfR3JlZWtfb21lZ2FhY2NlbnRcbiAgICAweDA0MDE6IDB4MDZiMywgLy8gWEtfQ3lyaWxsaWNfSU9cbiAgICAweDA0MDI6IDB4MDZiMSwgLy8gWEtfU2VyYmlhbl9ESkVcbiAgICAweDA0MDM6IDB4MDZiMiwgLy8gWEtfTWFjZWRvbmlhX0dKRVxuICAgIDB4MDQwNDogMHgwNmI0LCAvLyBYS19Va3JhaW5pYW5fSUVcbiAgICAweDA0MDU6IDB4MDZiNSwgLy8gWEtfTWFjZWRvbmlhX0RTRVxuICAgIDB4MDQwNjogMHgwNmI2LCAvLyBYS19Va3JhaW5pYW5fSVxuICAgIDB4MDQwNzogMHgwNmI3LCAvLyBYS19Va3JhaW5pYW5fWUlcbiAgICAweDA0MDg6IDB4MDZiOCwgLy8gWEtfQ3lyaWxsaWNfSkVcbiAgICAweDA0MDk6IDB4MDZiOSwgLy8gWEtfQ3lyaWxsaWNfTEpFXG4gICAgMHgwNDBhOiAweDA2YmEsIC8vIFhLX0N5cmlsbGljX05KRVxuICAgIDB4MDQwYjogMHgwNmJiLCAvLyBYS19TZXJiaWFuX1RTSEVcbiAgICAweDA0MGM6IDB4MDZiYywgLy8gWEtfTWFjZWRvbmlhX0tKRVxuICAgIDB4MDQwZTogMHgwNmJlLCAvLyBYS19CeWVsb3J1c3NpYW5fU0hPUlRVXG4gICAgMHgwNDBmOiAweDA2YmYsIC8vIFhLX0N5cmlsbGljX0RaSEVcbiAgICAweDA0MTA6IDB4MDZlMSwgLy8gWEtfQ3lyaWxsaWNfQVxuICAgIDB4MDQxMTogMHgwNmUyLCAvLyBYS19DeXJpbGxpY19CRVxuICAgIDB4MDQxMjogMHgwNmY3LCAvLyBYS19DeXJpbGxpY19WRVxuICAgIDB4MDQxMzogMHgwNmU3LCAvLyBYS19DeXJpbGxpY19HSEVcbiAgICAweDA0MTQ6IDB4MDZlNCwgLy8gWEtfQ3lyaWxsaWNfREVcbiAgICAweDA0MTU6IDB4MDZlNSwgLy8gWEtfQ3lyaWxsaWNfSUVcbiAgICAweDA0MTY6IDB4MDZmNiwgLy8gWEtfQ3lyaWxsaWNfWkhFXG4gICAgMHgwNDE3OiAweDA2ZmEsIC8vIFhLX0N5cmlsbGljX1pFXG4gICAgMHgwNDE4OiAweDA2ZTksIC8vIFhLX0N5cmlsbGljX0lcbiAgICAweDA0MTk6IDB4MDZlYSwgLy8gWEtfQ3lyaWxsaWNfU0hPUlRJXG4gICAgMHgwNDFhOiAweDA2ZWIsIC8vIFhLX0N5cmlsbGljX0tBXG4gICAgMHgwNDFiOiAweDA2ZWMsIC8vIFhLX0N5cmlsbGljX0VMXG4gICAgMHgwNDFjOiAweDA2ZWQsIC8vIFhLX0N5cmlsbGljX0VNXG4gICAgMHgwNDFkOiAweDA2ZWUsIC8vIFhLX0N5cmlsbGljX0VOXG4gICAgMHgwNDFlOiAweDA2ZWYsIC8vIFhLX0N5cmlsbGljX09cbiAgICAweDA0MWY6IDB4MDZmMCwgLy8gWEtfQ3lyaWxsaWNfUEVcbiAgICAweDA0MjA6IDB4MDZmMiwgLy8gWEtfQ3lyaWxsaWNfRVJcbiAgICAweDA0MjE6IDB4MDZmMywgLy8gWEtfQ3lyaWxsaWNfRVNcbiAgICAweDA0MjI6IDB4MDZmNCwgLy8gWEtfQ3lyaWxsaWNfVEVcbiAgICAweDA0MjM6IDB4MDZmNSwgLy8gWEtfQ3lyaWxsaWNfVVxuICAgIDB4MDQyNDogMHgwNmU2LCAvLyBYS19DeXJpbGxpY19FRlxuICAgIDB4MDQyNTogMHgwNmU4LCAvLyBYS19DeXJpbGxpY19IQVxuICAgIDB4MDQyNjogMHgwNmUzLCAvLyBYS19DeXJpbGxpY19UU0VcbiAgICAweDA0Mjc6IDB4MDZmZSwgLy8gWEtfQ3lyaWxsaWNfQ0hFXG4gICAgMHgwNDI4OiAweDA2ZmIsIC8vIFhLX0N5cmlsbGljX1NIQVxuICAgIDB4MDQyOTogMHgwNmZkLCAvLyBYS19DeXJpbGxpY19TSENIQVxuICAgIDB4MDQyYTogMHgwNmZmLCAvLyBYS19DeXJpbGxpY19IQVJEU0lHTlxuICAgIDB4MDQyYjogMHgwNmY5LCAvLyBYS19DeXJpbGxpY19ZRVJVXG4gICAgMHgwNDJjOiAweDA2ZjgsIC8vIFhLX0N5cmlsbGljX1NPRlRTSUdOXG4gICAgMHgwNDJkOiAweDA2ZmMsIC8vIFhLX0N5cmlsbGljX0VcbiAgICAweDA0MmU6IDB4MDZlMCwgLy8gWEtfQ3lyaWxsaWNfWVVcbiAgICAweDA0MmY6IDB4MDZmMSwgLy8gWEtfQ3lyaWxsaWNfWUFcbiAgICAweDA0MzA6IDB4MDZjMSwgLy8gWEtfQ3lyaWxsaWNfYVxuICAgIDB4MDQzMTogMHgwNmMyLCAvLyBYS19DeXJpbGxpY19iZVxuICAgIDB4MDQzMjogMHgwNmQ3LCAvLyBYS19DeXJpbGxpY192ZVxuICAgIDB4MDQzMzogMHgwNmM3LCAvLyBYS19DeXJpbGxpY19naGVcbiAgICAweDA0MzQ6IDB4MDZjNCwgLy8gWEtfQ3lyaWxsaWNfZGVcbiAgICAweDA0MzU6IDB4MDZjNSwgLy8gWEtfQ3lyaWxsaWNfaWVcbiAgICAweDA0MzY6IDB4MDZkNiwgLy8gWEtfQ3lyaWxsaWNfemhlXG4gICAgMHgwNDM3OiAweDA2ZGEsIC8vIFhLX0N5cmlsbGljX3plXG4gICAgMHgwNDM4OiAweDA2YzksIC8vIFhLX0N5cmlsbGljX2lcbiAgICAweDA0Mzk6IDB4MDZjYSwgLy8gWEtfQ3lyaWxsaWNfc2hvcnRpXG4gICAgMHgwNDNhOiAweDA2Y2IsIC8vIFhLX0N5cmlsbGljX2thXG4gICAgMHgwNDNiOiAweDA2Y2MsIC8vIFhLX0N5cmlsbGljX2VsXG4gICAgMHgwNDNjOiAweDA2Y2QsIC8vIFhLX0N5cmlsbGljX2VtXG4gICAgMHgwNDNkOiAweDA2Y2UsIC8vIFhLX0N5cmlsbGljX2VuXG4gICAgMHgwNDNlOiAweDA2Y2YsIC8vIFhLX0N5cmlsbGljX29cbiAgICAweDA0M2Y6IDB4MDZkMCwgLy8gWEtfQ3lyaWxsaWNfcGVcbiAgICAweDA0NDA6IDB4MDZkMiwgLy8gWEtfQ3lyaWxsaWNfZXJcbiAgICAweDA0NDE6IDB4MDZkMywgLy8gWEtfQ3lyaWxsaWNfZXNcbiAgICAweDA0NDI6IDB4MDZkNCwgLy8gWEtfQ3lyaWxsaWNfdGVcbiAgICAweDA0NDM6IDB4MDZkNSwgLy8gWEtfQ3lyaWxsaWNfdVxuICAgIDB4MDQ0NDogMHgwNmM2LCAvLyBYS19DeXJpbGxpY19lZlxuICAgIDB4MDQ0NTogMHgwNmM4LCAvLyBYS19DeXJpbGxpY19oYVxuICAgIDB4MDQ0NjogMHgwNmMzLCAvLyBYS19DeXJpbGxpY190c2VcbiAgICAweDA0NDc6IDB4MDZkZSwgLy8gWEtfQ3lyaWxsaWNfY2hlXG4gICAgMHgwNDQ4OiAweDA2ZGIsIC8vIFhLX0N5cmlsbGljX3NoYVxuICAgIDB4MDQ0OTogMHgwNmRkLCAvLyBYS19DeXJpbGxpY19zaGNoYVxuICAgIDB4MDQ0YTogMHgwNmRmLCAvLyBYS19DeXJpbGxpY19oYXJkc2lnblxuICAgIDB4MDQ0YjogMHgwNmQ5LCAvLyBYS19DeXJpbGxpY195ZXJ1XG4gICAgMHgwNDRjOiAweDA2ZDgsIC8vIFhLX0N5cmlsbGljX3NvZnRzaWduXG4gICAgMHgwNDRkOiAweDA2ZGMsIC8vIFhLX0N5cmlsbGljX2VcbiAgICAweDA0NGU6IDB4MDZjMCwgLy8gWEtfQ3lyaWxsaWNfeXVcbiAgICAweDA0NGY6IDB4MDZkMSwgLy8gWEtfQ3lyaWxsaWNfeWFcbiAgICAweDA0NTE6IDB4MDZhMywgLy8gWEtfQ3lyaWxsaWNfaW9cbiAgICAweDA0NTI6IDB4MDZhMSwgLy8gWEtfU2VyYmlhbl9kamVcbiAgICAweDA0NTM6IDB4MDZhMiwgLy8gWEtfTWFjZWRvbmlhX2dqZVxuICAgIDB4MDQ1NDogMHgwNmE0LCAvLyBYS19Va3JhaW5pYW5faWVcbiAgICAweDA0NTU6IDB4MDZhNSwgLy8gWEtfTWFjZWRvbmlhX2RzZVxuICAgIDB4MDQ1NjogMHgwNmE2LCAvLyBYS19Va3JhaW5pYW5faVxuICAgIDB4MDQ1NzogMHgwNmE3LCAvLyBYS19Va3JhaW5pYW5feWlcbiAgICAweDA0NTg6IDB4MDZhOCwgLy8gWEtfQ3lyaWxsaWNfamVcbiAgICAweDA0NTk6IDB4MDZhOSwgLy8gWEtfQ3lyaWxsaWNfbGplXG4gICAgMHgwNDVhOiAweDA2YWEsIC8vIFhLX0N5cmlsbGljX25qZVxuICAgIDB4MDQ1YjogMHgwNmFiLCAvLyBYS19TZXJiaWFuX3RzaGVcbiAgICAweDA0NWM6IDB4MDZhYywgLy8gWEtfTWFjZWRvbmlhX2tqZVxuICAgIDB4MDQ1ZTogMHgwNmFlLCAvLyBYS19CeWVsb3J1c3NpYW5fc2hvcnR1XG4gICAgMHgwNDVmOiAweDA2YWYsIC8vIFhLX0N5cmlsbGljX2R6aGVcbiAgICAweDA0OTA6IDB4MDZiZCwgLy8gWEtfVWtyYWluaWFuX0dIRV9XSVRIX1VQVFVSTlxuICAgIDB4MDQ5MTogMHgwNmFkLCAvLyBYS19Va3JhaW5pYW5fZ2hlX3dpdGhfdXB0dXJuXG4gICAgMHgwNWQwOiAweDBjZTAsIC8vIFhLX2hlYnJld19hbGVwaFxuICAgIDB4MDVkMTogMHgwY2UxLCAvLyBYS19oZWJyZXdfYmV0XG4gICAgMHgwNWQyOiAweDBjZTIsIC8vIFhLX2hlYnJld19naW1lbFxuICAgIDB4MDVkMzogMHgwY2UzLCAvLyBYS19oZWJyZXdfZGFsZXRcbiAgICAweDA1ZDQ6IDB4MGNlNCwgLy8gWEtfaGVicmV3X2hlXG4gICAgMHgwNWQ1OiAweDBjZTUsIC8vIFhLX2hlYnJld193YXdcbiAgICAweDA1ZDY6IDB4MGNlNiwgLy8gWEtfaGVicmV3X3phaW5cbiAgICAweDA1ZDc6IDB4MGNlNywgLy8gWEtfaGVicmV3X2NoZXRcbiAgICAweDA1ZDg6IDB4MGNlOCwgLy8gWEtfaGVicmV3X3RldFxuICAgIDB4MDVkOTogMHgwY2U5LCAvLyBYS19oZWJyZXdfeW9kXG4gICAgMHgwNWRhOiAweDBjZWEsIC8vIFhLX2hlYnJld19maW5hbGthcGhcbiAgICAweDA1ZGI6IDB4MGNlYiwgLy8gWEtfaGVicmV3X2thcGhcbiAgICAweDA1ZGM6IDB4MGNlYywgLy8gWEtfaGVicmV3X2xhbWVkXG4gICAgMHgwNWRkOiAweDBjZWQsIC8vIFhLX2hlYnJld19maW5hbG1lbVxuICAgIDB4MDVkZTogMHgwY2VlLCAvLyBYS19oZWJyZXdfbWVtXG4gICAgMHgwNWRmOiAweDBjZWYsIC8vIFhLX2hlYnJld19maW5hbG51blxuICAgIDB4MDVlMDogMHgwY2YwLCAvLyBYS19oZWJyZXdfbnVuXG4gICAgMHgwNWUxOiAweDBjZjEsIC8vIFhLX2hlYnJld19zYW1lY2hcbiAgICAweDA1ZTI6IDB4MGNmMiwgLy8gWEtfaGVicmV3X2F5aW5cbiAgICAweDA1ZTM6IDB4MGNmMywgLy8gWEtfaGVicmV3X2ZpbmFscGVcbiAgICAweDA1ZTQ6IDB4MGNmNCwgLy8gWEtfaGVicmV3X3BlXG4gICAgMHgwNWU1OiAweDBjZjUsIC8vIFhLX2hlYnJld19maW5hbHphZGVcbiAgICAweDA1ZTY6IDB4MGNmNiwgLy8gWEtfaGVicmV3X3phZGVcbiAgICAweDA1ZTc6IDB4MGNmNywgLy8gWEtfaGVicmV3X3FvcGhcbiAgICAweDA1ZTg6IDB4MGNmOCwgLy8gWEtfaGVicmV3X3Jlc2hcbiAgICAweDA1ZTk6IDB4MGNmOSwgLy8gWEtfaGVicmV3X3NoaW5cbiAgICAweDA1ZWE6IDB4MGNmYSwgLy8gWEtfaGVicmV3X3Rhd1xuICAgIDB4MDYwYzogMHgwNWFjLCAvLyBYS19BcmFiaWNfY29tbWFcbiAgICAweDA2MWI6IDB4MDViYiwgLy8gWEtfQXJhYmljX3NlbWljb2xvblxuICAgIDB4MDYxZjogMHgwNWJmLCAvLyBYS19BcmFiaWNfcXVlc3Rpb25fbWFya1xuICAgIDB4MDYyMTogMHgwNWMxLCAvLyBYS19BcmFiaWNfaGFtemFcbiAgICAweDA2MjI6IDB4MDVjMiwgLy8gWEtfQXJhYmljX21hZGRhb25hbGVmXG4gICAgMHgwNjIzOiAweDA1YzMsIC8vIFhLX0FyYWJpY19oYW16YW9uYWxlZlxuICAgIDB4MDYyNDogMHgwNWM0LCAvLyBYS19BcmFiaWNfaGFtemFvbndhd1xuICAgIDB4MDYyNTogMHgwNWM1LCAvLyBYS19BcmFiaWNfaGFtemF1bmRlcmFsZWZcbiAgICAweDA2MjY6IDB4MDVjNiwgLy8gWEtfQXJhYmljX2hhbXphb255ZWhcbiAgICAweDA2Mjc6IDB4MDVjNywgLy8gWEtfQXJhYmljX2FsZWZcbiAgICAweDA2Mjg6IDB4MDVjOCwgLy8gWEtfQXJhYmljX2JlaFxuICAgIDB4MDYyOTogMHgwNWM5LCAvLyBYS19BcmFiaWNfdGVobWFyYnV0YVxuICAgIDB4MDYyYTogMHgwNWNhLCAvLyBYS19BcmFiaWNfdGVoXG4gICAgMHgwNjJiOiAweDA1Y2IsIC8vIFhLX0FyYWJpY190aGVoXG4gICAgMHgwNjJjOiAweDA1Y2MsIC8vIFhLX0FyYWJpY19qZWVtXG4gICAgMHgwNjJkOiAweDA1Y2QsIC8vIFhLX0FyYWJpY19oYWhcbiAgICAweDA2MmU6IDB4MDVjZSwgLy8gWEtfQXJhYmljX2toYWhcbiAgICAweDA2MmY6IDB4MDVjZiwgLy8gWEtfQXJhYmljX2RhbFxuICAgIDB4MDYzMDogMHgwNWQwLCAvLyBYS19BcmFiaWNfdGhhbFxuICAgIDB4MDYzMTogMHgwNWQxLCAvLyBYS19BcmFiaWNfcmFcbiAgICAweDA2MzI6IDB4MDVkMiwgLy8gWEtfQXJhYmljX3phaW5cbiAgICAweDA2MzM6IDB4MDVkMywgLy8gWEtfQXJhYmljX3NlZW5cbiAgICAweDA2MzQ6IDB4MDVkNCwgLy8gWEtfQXJhYmljX3NoZWVuXG4gICAgMHgwNjM1OiAweDA1ZDUsIC8vIFhLX0FyYWJpY19zYWRcbiAgICAweDA2MzY6IDB4MDVkNiwgLy8gWEtfQXJhYmljX2RhZFxuICAgIDB4MDYzNzogMHgwNWQ3LCAvLyBYS19BcmFiaWNfdGFoXG4gICAgMHgwNjM4OiAweDA1ZDgsIC8vIFhLX0FyYWJpY196YWhcbiAgICAweDA2Mzk6IDB4MDVkOSwgLy8gWEtfQXJhYmljX2FpblxuICAgIDB4MDYzYTogMHgwNWRhLCAvLyBYS19BcmFiaWNfZ2hhaW5cbiAgICAweDA2NDA6IDB4MDVlMCwgLy8gWEtfQXJhYmljX3RhdHdlZWxcbiAgICAweDA2NDE6IDB4MDVlMSwgLy8gWEtfQXJhYmljX2ZlaFxuICAgIDB4MDY0MjogMHgwNWUyLCAvLyBYS19BcmFiaWNfcWFmXG4gICAgMHgwNjQzOiAweDA1ZTMsIC8vIFhLX0FyYWJpY19rYWZcbiAgICAweDA2NDQ6IDB4MDVlNCwgLy8gWEtfQXJhYmljX2xhbVxuICAgIDB4MDY0NTogMHgwNWU1LCAvLyBYS19BcmFiaWNfbWVlbVxuICAgIDB4MDY0NjogMHgwNWU2LCAvLyBYS19BcmFiaWNfbm9vblxuICAgIDB4MDY0NzogMHgwNWU3LCAvLyBYS19BcmFiaWNfaGFcbiAgICAweDA2NDg6IDB4MDVlOCwgLy8gWEtfQXJhYmljX3dhd1xuICAgIDB4MDY0OTogMHgwNWU5LCAvLyBYS19BcmFiaWNfYWxlZm1ha3N1cmFcbiAgICAweDA2NGE6IDB4MDVlYSwgLy8gWEtfQXJhYmljX3llaFxuICAgIDB4MDY0YjogMHgwNWViLCAvLyBYS19BcmFiaWNfZmF0aGF0YW5cbiAgICAweDA2NGM6IDB4MDVlYywgLy8gWEtfQXJhYmljX2RhbW1hdGFuXG4gICAgMHgwNjRkOiAweDA1ZWQsIC8vIFhLX0FyYWJpY19rYXNyYXRhblxuICAgIDB4MDY0ZTogMHgwNWVlLCAvLyBYS19BcmFiaWNfZmF0aGFcbiAgICAweDA2NGY6IDB4MDVlZiwgLy8gWEtfQXJhYmljX2RhbW1hXG4gICAgMHgwNjUwOiAweDA1ZjAsIC8vIFhLX0FyYWJpY19rYXNyYVxuICAgIDB4MDY1MTogMHgwNWYxLCAvLyBYS19BcmFiaWNfc2hhZGRhXG4gICAgMHgwNjUyOiAweDA1ZjIsIC8vIFhLX0FyYWJpY19zdWt1blxuICAgIDB4MGUwMTogMHgwZGExLCAvLyBYS19UaGFpX2tva2FpXG4gICAgMHgwZTAyOiAweDBkYTIsIC8vIFhLX1RoYWlfa2hva2hhaVxuICAgIDB4MGUwMzogMHgwZGEzLCAvLyBYS19UaGFpX2tob2todWF0XG4gICAgMHgwZTA0OiAweDBkYTQsIC8vIFhLX1RoYWlfa2hva2h3YWlcbiAgICAweDBlMDU6IDB4MGRhNSwgLy8gWEtfVGhhaV9raG9raG9uXG4gICAgMHgwZTA2OiAweDBkYTYsIC8vIFhLX1RoYWlfa2hvcmFraGFuZ1xuICAgIDB4MGUwNzogMHgwZGE3LCAvLyBYS19UaGFpX25nb25ndVxuICAgIDB4MGUwODogMHgwZGE4LCAvLyBYS19UaGFpX2Nob2NoYW5cbiAgICAweDBlMDk6IDB4MGRhOSwgLy8gWEtfVGhhaV9jaG9jaGluZ1xuICAgIDB4MGUwYTogMHgwZGFhLCAvLyBYS19UaGFpX2Nob2NoYW5nXG4gICAgMHgwZTBiOiAweDBkYWIsIC8vIFhLX1RoYWlfc29zb1xuICAgIDB4MGUwYzogMHgwZGFjLCAvLyBYS19UaGFpX2Nob2Nob2VcbiAgICAweDBlMGQ6IDB4MGRhZCwgLy8gWEtfVGhhaV95b3lpbmdcbiAgICAweDBlMGU6IDB4MGRhZSwgLy8gWEtfVGhhaV9kb2NoYWRhXG4gICAgMHgwZTBmOiAweDBkYWYsIC8vIFhLX1RoYWlfdG9wYXRha1xuICAgIDB4MGUxMDogMHgwZGIwLCAvLyBYS19UaGFpX3Rob3RoYW5cbiAgICAweDBlMTE6IDB4MGRiMSwgLy8gWEtfVGhhaV90aG9uYW5nbW9udGhvXG4gICAgMHgwZTEyOiAweDBkYjIsIC8vIFhLX1RoYWlfdGhvcGh1dGhhb1xuICAgIDB4MGUxMzogMHgwZGIzLCAvLyBYS19UaGFpX25vbmVuXG4gICAgMHgwZTE0OiAweDBkYjQsIC8vIFhLX1RoYWlfZG9kZWtcbiAgICAweDBlMTU6IDB4MGRiNSwgLy8gWEtfVGhhaV90b3Rhb1xuICAgIDB4MGUxNjogMHgwZGI2LCAvLyBYS19UaGFpX3Rob3RodW5nXG4gICAgMHgwZTE3OiAweDBkYjcsIC8vIFhLX1RoYWlfdGhvdGhhaGFuXG4gICAgMHgwZTE4OiAweDBkYjgsIC8vIFhLX1RoYWlfdGhvdGhvbmdcbiAgICAweDBlMTk6IDB4MGRiOSwgLy8gWEtfVGhhaV9ub251XG4gICAgMHgwZTFhOiAweDBkYmEsIC8vIFhLX1RoYWlfYm9iYWltYWlcbiAgICAweDBlMWI6IDB4MGRiYiwgLy8gWEtfVGhhaV9wb3BsYVxuICAgIDB4MGUxYzogMHgwZGJjLCAvLyBYS19UaGFpX3Bob3BodW5nXG4gICAgMHgwZTFkOiAweDBkYmQsIC8vIFhLX1RoYWlfZm9mYVxuICAgIDB4MGUxZTogMHgwZGJlLCAvLyBYS19UaGFpX3Bob3BoYW5cbiAgICAweDBlMWY6IDB4MGRiZiwgLy8gWEtfVGhhaV9mb2ZhblxuICAgIDB4MGUyMDogMHgwZGMwLCAvLyBYS19UaGFpX3Bob3NhbXBoYW9cbiAgICAweDBlMjE6IDB4MGRjMSwgLy8gWEtfVGhhaV9tb21hXG4gICAgMHgwZTIyOiAweDBkYzIsIC8vIFhLX1RoYWlfeW95YWtcbiAgICAweDBlMjM6IDB4MGRjMywgLy8gWEtfVGhhaV9yb3J1YVxuICAgIDB4MGUyNDogMHgwZGM0LCAvLyBYS19UaGFpX3J1XG4gICAgMHgwZTI1OiAweDBkYzUsIC8vIFhLX1RoYWlfbG9saW5nXG4gICAgMHgwZTI2OiAweDBkYzYsIC8vIFhLX1RoYWlfbHVcbiAgICAweDBlMjc6IDB4MGRjNywgLy8gWEtfVGhhaV93b3dhZW5cbiAgICAweDBlMjg6IDB4MGRjOCwgLy8gWEtfVGhhaV9zb3NhbGFcbiAgICAweDBlMjk6IDB4MGRjOSwgLy8gWEtfVGhhaV9zb3J1c2lcbiAgICAweDBlMmE6IDB4MGRjYSwgLy8gWEtfVGhhaV9zb3N1YVxuICAgIDB4MGUyYjogMHgwZGNiLCAvLyBYS19UaGFpX2hvaGlwXG4gICAgMHgwZTJjOiAweDBkY2MsIC8vIFhLX1RoYWlfbG9jaHVsYVxuICAgIDB4MGUyZDogMHgwZGNkLCAvLyBYS19UaGFpX29hbmdcbiAgICAweDBlMmU6IDB4MGRjZSwgLy8gWEtfVGhhaV9ob25va2h1a1xuICAgIDB4MGUyZjogMHgwZGNmLCAvLyBYS19UaGFpX3BhaXlhbm5vaVxuICAgIDB4MGUzMDogMHgwZGQwLCAvLyBYS19UaGFpX3NhcmFhXG4gICAgMHgwZTMxOiAweDBkZDEsIC8vIFhLX1RoYWlfbWFpaGFuYWthdFxuICAgIDB4MGUzMjogMHgwZGQyLCAvLyBYS19UaGFpX3NhcmFhYVxuICAgIDB4MGUzMzogMHgwZGQzLCAvLyBYS19UaGFpX3NhcmFhbVxuICAgIDB4MGUzNDogMHgwZGQ0LCAvLyBYS19UaGFpX3NhcmFpXG4gICAgMHgwZTM1OiAweDBkZDUsIC8vIFhLX1RoYWlfc2FyYWlpXG4gICAgMHgwZTM2OiAweDBkZDYsIC8vIFhLX1RoYWlfc2FyYXVlXG4gICAgMHgwZTM3OiAweDBkZDcsIC8vIFhLX1RoYWlfc2FyYXVlZVxuICAgIDB4MGUzODogMHgwZGQ4LCAvLyBYS19UaGFpX3NhcmF1XG4gICAgMHgwZTM5OiAweDBkZDksIC8vIFhLX1RoYWlfc2FyYXV1XG4gICAgMHgwZTNhOiAweDBkZGEsIC8vIFhLX1RoYWlfcGhpbnRodVxuICAgIDB4MGUzZjogMHgwZGRmLCAvLyBYS19UaGFpX2JhaHRcbiAgICAweDBlNDA6IDB4MGRlMCwgLy8gWEtfVGhhaV9zYXJhZVxuICAgIDB4MGU0MTogMHgwZGUxLCAvLyBYS19UaGFpX3NhcmFhZVxuICAgIDB4MGU0MjogMHgwZGUyLCAvLyBYS19UaGFpX3NhcmFvXG4gICAgMHgwZTQzOiAweDBkZTMsIC8vIFhLX1RoYWlfc2FyYWFpbWFpbXVhblxuICAgIDB4MGU0NDogMHgwZGU0LCAvLyBYS19UaGFpX3NhcmFhaW1haW1hbGFpXG4gICAgMHgwZTQ1OiAweDBkZTUsIC8vIFhLX1RoYWlfbGFra2hhbmd5YW9cbiAgICAweDBlNDY6IDB4MGRlNiwgLy8gWEtfVGhhaV9tYWl5YW1va1xuICAgIDB4MGU0NzogMHgwZGU3LCAvLyBYS19UaGFpX21haXRhaWtodVxuICAgIDB4MGU0ODogMHgwZGU4LCAvLyBYS19UaGFpX21haWVrXG4gICAgMHgwZTQ5OiAweDBkZTksIC8vIFhLX1RoYWlfbWFpdGhvXG4gICAgMHgwZTRhOiAweDBkZWEsIC8vIFhLX1RoYWlfbWFpdHJpXG4gICAgMHgwZTRiOiAweDBkZWIsIC8vIFhLX1RoYWlfbWFpY2hhdHRhd2FcbiAgICAweDBlNGM6IDB4MGRlYywgLy8gWEtfVGhhaV90aGFudGhha2hhdFxuICAgIDB4MGU0ZDogMHgwZGVkLCAvLyBYS19UaGFpX25pa2hhaGl0XG4gICAgMHgwZTUwOiAweDBkZjAsIC8vIFhLX1RoYWlfbGVrc3VuXG4gICAgMHgwZTUxOiAweDBkZjEsIC8vIFhLX1RoYWlfbGVrbnVuZ1xuICAgIDB4MGU1MjogMHgwZGYyLCAvLyBYS19UaGFpX2xla3NvbmdcbiAgICAweDBlNTM6IDB4MGRmMywgLy8gWEtfVGhhaV9sZWtzYW1cbiAgICAweDBlNTQ6IDB4MGRmNCwgLy8gWEtfVGhhaV9sZWtzaVxuICAgIDB4MGU1NTogMHgwZGY1LCAvLyBYS19UaGFpX2xla2hhXG4gICAgMHgwZTU2OiAweDBkZjYsIC8vIFhLX1RoYWlfbGVraG9rXG4gICAgMHgwZTU3OiAweDBkZjcsIC8vIFhLX1RoYWlfbGVrY2hldFxuICAgIDB4MGU1ODogMHgwZGY4LCAvLyBYS19UaGFpX2xla3BhZXRcbiAgICAweDBlNTk6IDB4MGRmOSwgLy8gWEtfVGhhaV9sZWtrYW9cbiAgICAweDIwMDI6IDB4MGFhMiwgLy8gWEtfZW5zcGFjZVxuICAgIDB4MjAwMzogMHgwYWExLCAvLyBYS19lbXNwYWNlXG4gICAgMHgyMDA0OiAweDBhYTMsIC8vIFhLX2VtM3NwYWNlXG4gICAgMHgyMDA1OiAweDBhYTQsIC8vIFhLX2VtNHNwYWNlXG4gICAgMHgyMDA3OiAweDBhYTUsIC8vIFhLX2RpZ2l0c3BhY2VcbiAgICAweDIwMDg6IDB4MGFhNiwgLy8gWEtfcHVuY3RzcGFjZVxuICAgIDB4MjAwOTogMHgwYWE3LCAvLyBYS190aGluc3BhY2VcbiAgICAweDIwMGE6IDB4MGFhOCwgLy8gWEtfaGFpcnNwYWNlXG4gICAgMHgyMDEyOiAweDBhYmIsIC8vIFhLX2ZpZ2Rhc2hcbiAgICAweDIwMTM6IDB4MGFhYSwgLy8gWEtfZW5kYXNoXG4gICAgMHgyMDE0OiAweDBhYTksIC8vIFhLX2VtZGFzaFxuICAgIDB4MjAxNTogMHgwN2FmLCAvLyBYS19HcmVla19ob3JpemJhclxuICAgIDB4MjAxNzogMHgwY2RmLCAvLyBYS19oZWJyZXdfZG91YmxlbG93bGluZVxuICAgIDB4MjAxODogMHgwYWQwLCAvLyBYS19sZWZ0c2luZ2xlcXVvdGVtYXJrXG4gICAgMHgyMDE5OiAweDBhZDEsIC8vIFhLX3JpZ2h0c2luZ2xlcXVvdGVtYXJrXG4gICAgMHgyMDFhOiAweDBhZmQsIC8vIFhLX3NpbmdsZWxvd3F1b3RlbWFya1xuICAgIDB4MjAxYzogMHgwYWQyLCAvLyBYS19sZWZ0ZG91YmxlcXVvdGVtYXJrXG4gICAgMHgyMDFkOiAweDBhZDMsIC8vIFhLX3JpZ2h0ZG91YmxlcXVvdGVtYXJrXG4gICAgMHgyMDFlOiAweDBhZmUsIC8vIFhLX2RvdWJsZWxvd3F1b3RlbWFya1xuICAgIDB4MjAyMDogMHgwYWYxLCAvLyBYS19kYWdnZXJcbiAgICAweDIwMjE6IDB4MGFmMiwgLy8gWEtfZG91YmxlZGFnZ2VyXG4gICAgMHgyMDIyOiAweDBhZTYsIC8vIFhLX2VuZmlsbGVkY2lyY2J1bGxldFxuICAgIDB4MjAyNTogMHgwYWFmLCAvLyBYS19kb3ViYmFzZWxpbmVkb3RcbiAgICAweDIwMjY6IDB4MGFhZSwgLy8gWEtfZWxsaXBzaXNcbiAgICAweDIwMzA6IDB4MGFkNSwgLy8gWEtfcGVybWlsbGVcbiAgICAweDIwMzI6IDB4MGFkNiwgLy8gWEtfbWludXRlc1xuICAgIDB4MjAzMzogMHgwYWQ3LCAvLyBYS19zZWNvbmRzXG4gICAgMHgyMDM4OiAweDBhZmMsIC8vIFhLX2NhcmV0XG4gICAgMHgyMDNlOiAweDA0N2UsIC8vIFhLX292ZXJsaW5lXG4gICAgMHgyMGE5OiAweDBlZmYsIC8vIFhLX0tvcmVhbl9Xb25cbiAgICAweDIwYWM6IDB4MjBhYywgLy8gWEtfRXVyb1NpZ25cbiAgICAweDIxMDU6IDB4MGFiOCwgLy8gWEtfY2FyZW9mXG4gICAgMHgyMTE2OiAweDA2YjAsIC8vIFhLX251bWVyb3NpZ25cbiAgICAweDIxMTc6IDB4MGFmYiwgLy8gWEtfcGhvbm9ncmFwaGNvcHlyaWdodFxuICAgIDB4MjExZTogMHgwYWQ0LCAvLyBYS19wcmVzY3JpcHRpb25cbiAgICAweDIxMjI6IDB4MGFjOSwgLy8gWEtfdHJhZGVtYXJrXG4gICAgMHgyMTUzOiAweDBhYjAsIC8vIFhLX29uZXRoaXJkXG4gICAgMHgyMTU0OiAweDBhYjEsIC8vIFhLX3R3b3RoaXJkc1xuICAgIDB4MjE1NTogMHgwYWIyLCAvLyBYS19vbmVmaWZ0aFxuICAgIDB4MjE1NjogMHgwYWIzLCAvLyBYS190d29maWZ0aHNcbiAgICAweDIxNTc6IDB4MGFiNCwgLy8gWEtfdGhyZWVmaWZ0aHNcbiAgICAweDIxNTg6IDB4MGFiNSwgLy8gWEtfZm91cmZpZnRoc1xuICAgIDB4MjE1OTogMHgwYWI2LCAvLyBYS19vbmVzaXh0aFxuICAgIDB4MjE1YTogMHgwYWI3LCAvLyBYS19maXZlc2l4dGhzXG4gICAgMHgyMTViOiAweDBhYzMsIC8vIFhLX29uZWVpZ2h0aFxuICAgIDB4MjE1YzogMHgwYWM0LCAvLyBYS190aHJlZWVpZ2h0aHNcbiAgICAweDIxNWQ6IDB4MGFjNSwgLy8gWEtfZml2ZWVpZ2h0aHNcbiAgICAweDIxNWU6IDB4MGFjNiwgLy8gWEtfc2V2ZW5laWdodGhzXG4gICAgMHgyMTkwOiAweDA4ZmIsIC8vIFhLX2xlZnRhcnJvd1xuICAgIDB4MjE5MTogMHgwOGZjLCAvLyBYS191cGFycm93XG4gICAgMHgyMTkyOiAweDA4ZmQsIC8vIFhLX3JpZ2h0YXJyb3dcbiAgICAweDIxOTM6IDB4MDhmZSwgLy8gWEtfZG93bmFycm93XG4gICAgMHgyMWQyOiAweDA4Y2UsIC8vIFhLX2ltcGxpZXNcbiAgICAweDIxZDQ6IDB4MDhjZCwgLy8gWEtfaWZvbmx5aWZcbiAgICAweDIyMDI6IDB4MDhlZiwgLy8gWEtfcGFydGlhbGRlcml2YXRpdmVcbiAgICAweDIyMDc6IDB4MDhjNSwgLy8gWEtfbmFibGFcbiAgICAweDIyMTg6IDB4MGJjYSwgLy8gWEtfam90XG4gICAgMHgyMjFhOiAweDA4ZDYsIC8vIFhLX3JhZGljYWxcbiAgICAweDIyMWQ6IDB4MDhjMSwgLy8gWEtfdmFyaWF0aW9uXG4gICAgMHgyMjFlOiAweDA4YzIsIC8vIFhLX2luZmluaXR5XG4gICAgMHgyMjI3OiAweDA4ZGUsIC8vIFhLX2xvZ2ljYWxhbmRcbiAgICAweDIyMjg6IDB4MDhkZiwgLy8gWEtfbG9naWNhbG9yXG4gICAgMHgyMjI5OiAweDA4ZGMsIC8vIFhLX2ludGVyc2VjdGlvblxuICAgIDB4MjIyYTogMHgwOGRkLCAvLyBYS191bmlvblxuICAgIDB4MjIyYjogMHgwOGJmLCAvLyBYS19pbnRlZ3JhbFxuICAgIDB4MjIzNDogMHgwOGMwLCAvLyBYS190aGVyZWZvcmVcbiAgICAweDIyM2M6IDB4MDhjOCwgLy8gWEtfYXBwcm94aW1hdGVcbiAgICAweDIyNDM6IDB4MDhjOSwgLy8gWEtfc2ltaWxhcmVxdWFsXG4gICAgMHgyMjQ1OiAweDEwMDIyNDgsIC8vIFhLX2FwcHJveGVxXG4gICAgMHgyMjYwOiAweDA4YmQsIC8vIFhLX25vdGVxdWFsXG4gICAgMHgyMjYxOiAweDA4Y2YsIC8vIFhLX2lkZW50aWNhbFxuICAgIDB4MjI2NDogMHgwOGJjLCAvLyBYS19sZXNzdGhhbmVxdWFsXG4gICAgMHgyMjY1OiAweDA4YmUsIC8vIFhLX2dyZWF0ZXJ0aGFuZXF1YWxcbiAgICAweDIyODI6IDB4MDhkYSwgLy8gWEtfaW5jbHVkZWRpblxuICAgIDB4MjI4MzogMHgwOGRiLCAvLyBYS19pbmNsdWRlc1xuICAgIDB4MjJhMjogMHgwYmZjLCAvLyBYS19yaWdodHRhY2tcbiAgICAweDIyYTM6IDB4MGJkYywgLy8gWEtfbGVmdHRhY2tcbiAgICAweDIyYTQ6IDB4MGJjMiwgLy8gWEtfZG93bnRhY2tcbiAgICAweDIyYTU6IDB4MGJjZSwgLy8gWEtfdXB0YWNrXG4gICAgMHgyMzA4OiAweDBiZDMsIC8vIFhLX3Vwc3RpbGVcbiAgICAweDIzMGE6IDB4MGJjNCwgLy8gWEtfZG93bnN0aWxlXG4gICAgMHgyMzE1OiAweDBhZmEsIC8vIFhLX3RlbGVwaG9uZXJlY29yZGVyXG4gICAgMHgyMzIwOiAweDA4YTQsIC8vIFhLX3RvcGludGVncmFsXG4gICAgMHgyMzIxOiAweDA4YTUsIC8vIFhLX2JvdGludGVncmFsXG4gICAgMHgyMzk1OiAweDBiY2MsIC8vIFhLX3F1YWRcbiAgICAweDIzOWI6IDB4MDhhYiwgLy8gWEtfdG9wbGVmdHBhcmVuc1xuICAgIDB4MjM5ZDogMHgwOGFjLCAvLyBYS19ib3RsZWZ0cGFyZW5zXG4gICAgMHgyMzllOiAweDA4YWQsIC8vIFhLX3RvcHJpZ2h0cGFyZW5zXG4gICAgMHgyM2EwOiAweDA4YWUsIC8vIFhLX2JvdHJpZ2h0cGFyZW5zXG4gICAgMHgyM2ExOiAweDA4YTcsIC8vIFhLX3RvcGxlZnRzcWJyYWNrZXRcbiAgICAweDIzYTM6IDB4MDhhOCwgLy8gWEtfYm90bGVmdHNxYnJhY2tldFxuICAgIDB4MjNhNDogMHgwOGE5LCAvLyBYS190b3ByaWdodHNxYnJhY2tldFxuICAgIDB4MjNhNjogMHgwOGFhLCAvLyBYS19ib3RyaWdodHNxYnJhY2tldFxuICAgIDB4MjNhODogMHgwOGFmLCAvLyBYS19sZWZ0bWlkZGxlY3VybHlicmFjZVxuICAgIDB4MjNhYzogMHgwOGIwLCAvLyBYS19yaWdodG1pZGRsZWN1cmx5YnJhY2VcbiAgICAweDIzYjc6IDB4MDhhMSwgLy8gWEtfbGVmdHJhZGljYWxcbiAgICAweDIzYmE6IDB4MDllZiwgLy8gWEtfaG9yaXpsaW5lc2NhbjFcbiAgICAweDIzYmI6IDB4MDlmMCwgLy8gWEtfaG9yaXpsaW5lc2NhbjNcbiAgICAweDIzYmM6IDB4MDlmMiwgLy8gWEtfaG9yaXpsaW5lc2NhbjdcbiAgICAweDIzYmQ6IDB4MDlmMywgLy8gWEtfaG9yaXpsaW5lc2NhbjlcbiAgICAweDI0MDk6IDB4MDllMiwgLy8gWEtfaHRcbiAgICAweDI0MGE6IDB4MDllNSwgLy8gWEtfbGZcbiAgICAweDI0MGI6IDB4MDllOSwgLy8gWEtfdnRcbiAgICAweDI0MGM6IDB4MDllMywgLy8gWEtfZmZcbiAgICAweDI0MGQ6IDB4MDllNCwgLy8gWEtfY3JcbiAgICAweDI0MjM6IDB4MGFhYywgLy8gWEtfc2lnbmlmYmxhbmtcbiAgICAweDI0MjQ6IDB4MDllOCwgLy8gWEtfbmxcbiAgICAweDI1MDA6IDB4MDhhMywgLy8gWEtfaG9yaXpjb25uZWN0b3JcbiAgICAweDI1MDI6IDB4MDhhNiwgLy8gWEtfdmVydGNvbm5lY3RvclxuICAgIDB4MjUwYzogMHgwOGEyLCAvLyBYS190b3BsZWZ0cmFkaWNhbFxuICAgIDB4MjUxMDogMHgwOWViLCAvLyBYS191cHJpZ2h0Y29ybmVyXG4gICAgMHgyNTE0OiAweDA5ZWQsIC8vIFhLX2xvd2xlZnRjb3JuZXJcbiAgICAweDI1MTg6IDB4MDllYSwgLy8gWEtfbG93cmlnaHRjb3JuZXJcbiAgICAweDI1MWM6IDB4MDlmNCwgLy8gWEtfbGVmdHRcbiAgICAweDI1MjQ6IDB4MDlmNSwgLy8gWEtfcmlnaHR0XG4gICAgMHgyNTJjOiAweDA5ZjcsIC8vIFhLX3RvcHRcbiAgICAweDI1MzQ6IDB4MDlmNiwgLy8gWEtfYm90dFxuICAgIDB4MjUzYzogMHgwOWVlLCAvLyBYS19jcm9zc2luZ2xpbmVzXG4gICAgMHgyNTkyOiAweDA5ZTEsIC8vIFhLX2NoZWNrZXJib2FyZFxuICAgIDB4MjVhYTogMHgwYWU3LCAvLyBYS19lbmZpbGxlZHNxYnVsbGV0XG4gICAgMHgyNWFiOiAweDBhZTEsIC8vIFhLX2Vub3BlbnNxdWFyZWJ1bGxldFxuICAgIDB4MjVhYzogMHgwYWRiLCAvLyBYS19maWxsZWRyZWN0YnVsbGV0XG4gICAgMHgyNWFkOiAweDBhZTIsIC8vIFhLX29wZW5yZWN0YnVsbGV0XG4gICAgMHgyNWFlOiAweDBhZGYsIC8vIFhLX2VtZmlsbGVkcmVjdFxuICAgIDB4MjVhZjogMHgwYWNmLCAvLyBYS19lbW9wZW5yZWN0YW5nbGVcbiAgICAweDI1YjI6IDB4MGFlOCwgLy8gWEtfZmlsbGVkdHJpYnVsbGV0dXBcbiAgICAweDI1YjM6IDB4MGFlMywgLy8gWEtfb3BlbnRyaWJ1bGxldHVwXG4gICAgMHgyNWI2OiAweDBhZGQsIC8vIFhLX2ZpbGxlZHJpZ2h0dHJpYnVsbGV0XG4gICAgMHgyNWI3OiAweDBhY2QsIC8vIFhLX3JpZ2h0b3BlbnRyaWFuZ2xlXG4gICAgMHgyNWJjOiAweDBhZTksIC8vIFhLX2ZpbGxlZHRyaWJ1bGxldGRvd25cbiAgICAweDI1YmQ6IDB4MGFlNCwgLy8gWEtfb3BlbnRyaWJ1bGxldGRvd25cbiAgICAweDI1YzA6IDB4MGFkYywgLy8gWEtfZmlsbGVkbGVmdHRyaWJ1bGxldFxuICAgIDB4MjVjMTogMHgwYWNjLCAvLyBYS19sZWZ0b3BlbnRyaWFuZ2xlXG4gICAgMHgyNWM2OiAweDA5ZTAsIC8vIFhLX3NvbGlkZGlhbW9uZFxuICAgIDB4MjVjYjogMHgwYWNlLCAvLyBYS19lbW9wZW5jaXJjbGVcbiAgICAweDI1Y2Y6IDB4MGFkZSwgLy8gWEtfZW1maWxsZWRjaXJjbGVcbiAgICAweDI1ZTY6IDB4MGFlMCwgLy8gWEtfZW5vcGVuY2lyY2J1bGxldFxuICAgIDB4MjYwNjogMHgwYWU1LCAvLyBYS19vcGVuc3RhclxuICAgIDB4MjYwZTogMHgwYWY5LCAvLyBYS190ZWxlcGhvbmVcbiAgICAweDI2MTM6IDB4MGFjYSwgLy8gWEtfc2lnbmF0dXJlbWFya1xuICAgIDB4MjYxYzogMHgwYWVhLCAvLyBYS19sZWZ0cG9pbnRlclxuICAgIDB4MjYxZTogMHgwYWViLCAvLyBYS19yaWdodHBvaW50ZXJcbiAgICAweDI2NDA6IDB4MGFmOCwgLy8gWEtfZmVtYWxlc3ltYm9sXG4gICAgMHgyNjQyOiAweDBhZjcsIC8vIFhLX21hbGVzeW1ib2xcbiAgICAweDI2NjM6IDB4MGFlYywgLy8gWEtfY2x1YlxuICAgIDB4MjY2NTogMHgwYWVlLCAvLyBYS19oZWFydFxuICAgIDB4MjY2NjogMHgwYWVkLCAvLyBYS19kaWFtb25kXG4gICAgMHgyNjZkOiAweDBhZjYsIC8vIFhLX211c2ljYWxmbGF0XG4gICAgMHgyNjZmOiAweDBhZjUsIC8vIFhLX211c2ljYWxzaGFycFxuICAgIDB4MjcxMzogMHgwYWYzLCAvLyBYS19jaGVja21hcmtcbiAgICAweDI3MTc6IDB4MGFmNCwgLy8gWEtfYmFsbG90Y3Jvc3NcbiAgICAweDI3MWQ6IDB4MGFkOSwgLy8gWEtfbGF0aW5jcm9zc1xuICAgIDB4MjcyMDogMHgwYWYwLCAvLyBYS19tYWx0ZXNlY3Jvc3NcbiAgICAweDI3ZTg6IDB4MGFiYywgLy8gWEtfbGVmdGFuZ2xlYnJhY2tldFxuICAgIDB4MjdlOTogMHgwYWJlLCAvLyBYS19yaWdodGFuZ2xlYnJhY2tldFxuICAgIDB4MzAwMTogMHgwNGE0LCAvLyBYS19rYW5hX2NvbW1hXG4gICAgMHgzMDAyOiAweDA0YTEsIC8vIFhLX2thbmFfZnVsbHN0b3BcbiAgICAweDMwMGM6IDB4MDRhMiwgLy8gWEtfa2FuYV9vcGVuaW5nYnJhY2tldFxuICAgIDB4MzAwZDogMHgwNGEzLCAvLyBYS19rYW5hX2Nsb3NpbmdicmFja2V0XG4gICAgMHgzMDliOiAweDA0ZGUsIC8vIFhLX3ZvaWNlZHNvdW5kXG4gICAgMHgzMDljOiAweDA0ZGYsIC8vIFhLX3NlbWl2b2ljZWRzb3VuZFxuICAgIDB4MzBhMTogMHgwNGE3LCAvLyBYS19rYW5hX2FcbiAgICAweDMwYTI6IDB4MDRiMSwgLy8gWEtfa2FuYV9BXG4gICAgMHgzMGEzOiAweDA0YTgsIC8vIFhLX2thbmFfaVxuICAgIDB4MzBhNDogMHgwNGIyLCAvLyBYS19rYW5hX0lcbiAgICAweDMwYTU6IDB4MDRhOSwgLy8gWEtfa2FuYV91XG4gICAgMHgzMGE2OiAweDA0YjMsIC8vIFhLX2thbmFfVVxuICAgIDB4MzBhNzogMHgwNGFhLCAvLyBYS19rYW5hX2VcbiAgICAweDMwYTg6IDB4MDRiNCwgLy8gWEtfa2FuYV9FXG4gICAgMHgzMGE5OiAweDA0YWIsIC8vIFhLX2thbmFfb1xuICAgIDB4MzBhYTogMHgwNGI1LCAvLyBYS19rYW5hX09cbiAgICAweDMwYWI6IDB4MDRiNiwgLy8gWEtfa2FuYV9LQVxuICAgIDB4MzBhZDogMHgwNGI3LCAvLyBYS19rYW5hX0tJXG4gICAgMHgzMGFmOiAweDA0YjgsIC8vIFhLX2thbmFfS1VcbiAgICAweDMwYjE6IDB4MDRiOSwgLy8gWEtfa2FuYV9LRVxuICAgIDB4MzBiMzogMHgwNGJhLCAvLyBYS19rYW5hX0tPXG4gICAgMHgzMGI1OiAweDA0YmIsIC8vIFhLX2thbmFfU0FcbiAgICAweDMwYjc6IDB4MDRiYywgLy8gWEtfa2FuYV9TSElcbiAgICAweDMwYjk6IDB4MDRiZCwgLy8gWEtfa2FuYV9TVVxuICAgIDB4MzBiYjogMHgwNGJlLCAvLyBYS19rYW5hX1NFXG4gICAgMHgzMGJkOiAweDA0YmYsIC8vIFhLX2thbmFfU09cbiAgICAweDMwYmY6IDB4MDRjMCwgLy8gWEtfa2FuYV9UQVxuICAgIDB4MzBjMTogMHgwNGMxLCAvLyBYS19rYW5hX0NISVxuICAgIDB4MzBjMzogMHgwNGFmLCAvLyBYS19rYW5hX3RzdVxuICAgIDB4MzBjNDogMHgwNGMyLCAvLyBYS19rYW5hX1RTVVxuICAgIDB4MzBjNjogMHgwNGMzLCAvLyBYS19rYW5hX1RFXG4gICAgMHgzMGM4OiAweDA0YzQsIC8vIFhLX2thbmFfVE9cbiAgICAweDMwY2E6IDB4MDRjNSwgLy8gWEtfa2FuYV9OQVxuICAgIDB4MzBjYjogMHgwNGM2LCAvLyBYS19rYW5hX05JXG4gICAgMHgzMGNjOiAweDA0YzcsIC8vIFhLX2thbmFfTlVcbiAgICAweDMwY2Q6IDB4MDRjOCwgLy8gWEtfa2FuYV9ORVxuICAgIDB4MzBjZTogMHgwNGM5LCAvLyBYS19rYW5hX05PXG4gICAgMHgzMGNmOiAweDA0Y2EsIC8vIFhLX2thbmFfSEFcbiAgICAweDMwZDI6IDB4MDRjYiwgLy8gWEtfa2FuYV9ISVxuICAgIDB4MzBkNTogMHgwNGNjLCAvLyBYS19rYW5hX0ZVXG4gICAgMHgzMGQ4OiAweDA0Y2QsIC8vIFhLX2thbmFfSEVcbiAgICAweDMwZGI6IDB4MDRjZSwgLy8gWEtfa2FuYV9IT1xuICAgIDB4MzBkZTogMHgwNGNmLCAvLyBYS19rYW5hX01BXG4gICAgMHgzMGRmOiAweDA0ZDAsIC8vIFhLX2thbmFfTUlcbiAgICAweDMwZTA6IDB4MDRkMSwgLy8gWEtfa2FuYV9NVVxuICAgIDB4MzBlMTogMHgwNGQyLCAvLyBYS19rYW5hX01FXG4gICAgMHgzMGUyOiAweDA0ZDMsIC8vIFhLX2thbmFfTU9cbiAgICAweDMwZTM6IDB4MDRhYywgLy8gWEtfa2FuYV95YVxuICAgIDB4MzBlNDogMHgwNGQ0LCAvLyBYS19rYW5hX1lBXG4gICAgMHgzMGU1OiAweDA0YWQsIC8vIFhLX2thbmFfeXVcbiAgICAweDMwZTY6IDB4MDRkNSwgLy8gWEtfa2FuYV9ZVVxuICAgIDB4MzBlNzogMHgwNGFlLCAvLyBYS19rYW5hX3lvXG4gICAgMHgzMGU4OiAweDA0ZDYsIC8vIFhLX2thbmFfWU9cbiAgICAweDMwZTk6IDB4MDRkNywgLy8gWEtfa2FuYV9SQVxuICAgIDB4MzBlYTogMHgwNGQ4LCAvLyBYS19rYW5hX1JJXG4gICAgMHgzMGViOiAweDA0ZDksIC8vIFhLX2thbmFfUlVcbiAgICAweDMwZWM6IDB4MDRkYSwgLy8gWEtfa2FuYV9SRVxuICAgIDB4MzBlZDogMHgwNGRiLCAvLyBYS19rYW5hX1JPXG4gICAgMHgzMGVmOiAweDA0ZGMsIC8vIFhLX2thbmFfV0FcbiAgICAweDMwZjI6IDB4MDRhNiwgLy8gWEtfa2FuYV9XT1xuICAgIDB4MzBmMzogMHgwNGRkLCAvLyBYS19rYW5hX05cbiAgICAweDMwZmI6IDB4MDRhNSwgLy8gWEtfa2FuYV9jb25qdW5jdGl2ZVxuICAgIDB4MzBmYzogMHgwNGIwLCAvLyBYS19wcm9sb25nZWRzb3VuZFxufTtcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGxvb2t1cCh1KSB7XG4gICAgICAgIC8vIExhdGluLTEgaXMgb25lLXRvLW9uZSBtYXBwaW5nXG4gICAgICAgIGlmICgodSA+PSAweDIwKSAmJiAodSA8PSAweGZmKSkge1xuICAgICAgICAgICAgcmV0dXJuIHU7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBMb29rdXAgdGFibGUgKGZhaXJseSByYW5kb20pXG4gICAgICAgIGNvbnN0IGtleXN5bSA9IGNvZGVwb2ludHNbdV07XG4gICAgICAgIGlmIChrZXlzeW0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGtleXN5bTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEdlbmVyYWwgbWFwcGluZyBhcyBmaW5hbCBmYWxsYmFja1xuICAgICAgICByZXR1cm4gMHgwMTAwMDAwMCB8IHU7XG4gICAgfSxcbn07XG4iLCIvKlxuICogbm9WTkM6IEhUTUw1IFZOQyBjbGllbnRcbiAqIENvcHlyaWdodCAoQykgMjAxOCBUaGUgbm9WTkMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgTVBMIDIuMCBvciBhbnkgbGF0ZXIgdmVyc2lvbiAoc2VlIExJQ0VOU0UudHh0KVxuICovXG5cbmltcG9ydCAqIGFzIExvZyBmcm9tICcuLi91dGlsL2xvZ2dpbmcuanMnO1xuaW1wb3J0IHsgaXNUb3VjaERldmljZSB9IGZyb20gJy4uL3V0aWwvYnJvd3Nlci5qcyc7XG5pbXBvcnQgeyBzZXRDYXB0dXJlLCBzdG9wRXZlbnQsIGdldFBvaW50ZXJFdmVudCB9IGZyb20gJy4uL3V0aWwvZXZlbnRzLmpzJztcblxuY29uc3QgV0hFRUxfU1RFUCA9IDEwOyAvLyBEZWx0YSB0aHJlc2hvbGQgZm9yIGEgbW91c2Ugd2hlZWwgc3RlcFxuY29uc3QgV0hFRUxfU1RFUF9USU1FT1VUID0gNTA7IC8vIG1zXG5jb25zdCBXSEVFTF9MSU5FX0hFSUdIVCA9IDE5O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNb3VzZSB7XG4gICAgY29uc3RydWN0b3IodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldCB8fCBkb2N1bWVudDtcblxuICAgICAgICB0aGlzLl9kb3VibGVDbGlja1RpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fbGFzdFRvdWNoUG9zID0gbnVsbDtcblxuICAgICAgICB0aGlzLl9wb3MgPSBudWxsO1xuICAgICAgICB0aGlzLl93aGVlbFN0ZXBYVGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl93aGVlbFN0ZXBZVGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9hY2N1bXVsYXRlZFdoZWVsRGVsdGFYID0gMDtcbiAgICAgICAgdGhpcy5fYWNjdW11bGF0ZWRXaGVlbERlbHRhWSA9IDA7XG5cbiAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVycyA9IHtcbiAgICAgICAgICAgICdtb3VzZWRvd24nOiB0aGlzLl9oYW5kbGVNb3VzZURvd24uYmluZCh0aGlzKSxcbiAgICAgICAgICAgICdtb3VzZXVwJzogdGhpcy5faGFuZGxlTW91c2VVcC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgJ21vdXNlbW92ZSc6IHRoaXMuX2hhbmRsZU1vdXNlTW92ZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgJ21vdXNld2hlZWwnOiB0aGlzLl9oYW5kbGVNb3VzZVdoZWVsLmJpbmQodGhpcyksXG4gICAgICAgICAgICAnbW91c2VkaXNhYmxlJzogdGhpcy5faGFuZGxlTW91c2VEaXNhYmxlLmJpbmQodGhpcylcbiAgICAgICAgfTtcblxuICAgICAgICAvLyA9PT09PSBQUk9QRVJUSUVTID09PT09XG5cbiAgICAgICAgdGhpcy50b3VjaEJ1dHRvbiA9IDE7ICAgICAgICAgICAgICAgICAvLyBCdXR0b24gbWFzayAoMSwgMiwgNCkgZm9yIHRvdWNoIGRldmljZXMgKDAgbWVhbnMgaWdub3JlIGNsaWNrcylcblxuICAgICAgICAvLyA9PT09PSBFVkVOVCBIQU5ETEVSUyA9PT09PVxuXG4gICAgICAgIHRoaXMub25tb3VzZWJ1dHRvbiA9ICgpID0+IHt9OyAvLyBIYW5kbGVyIGZvciBtb3VzZSBidXR0b24gY2xpY2svcmVsZWFzZVxuICAgICAgICB0aGlzLm9ubW91c2Vtb3ZlID0gKCkgPT4ge307IC8vIEhhbmRsZXIgZm9yIG1vdXNlIG1vdmVtZW50XG4gICAgfVxuXG4gICAgLy8gPT09PT0gUFJJVkFURSBNRVRIT0RTID09PT09XG5cbiAgICBfcmVzZXREb3VibGVDbGlja1RpbWVyKCkge1xuICAgICAgICB0aGlzLl9kb3VibGVDbGlja1RpbWVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBfaGFuZGxlTW91c2VCdXR0b24oZSwgZG93bikge1xuICAgICAgICB0aGlzLl91cGRhdGVNb3VzZVBvc2l0aW9uKGUpO1xuICAgICAgICBsZXQgcG9zID0gdGhpcy5fcG9zO1xuXG4gICAgICAgIGxldCBibWFzaztcbiAgICAgICAgaWYgKGUudG91Y2hlcyB8fCBlLmNoYW5nZWRUb3VjaGVzKSB7XG4gICAgICAgICAgICAvLyBUb3VjaCBkZXZpY2VcblxuICAgICAgICAgICAgLy8gV2hlbiB0d28gdG91Y2hlcyBvY2N1ciB3aXRoaW4gNTAwIG1zIG9mIGVhY2ggb3RoZXIgYW5kIGFyZVxuICAgICAgICAgICAgLy8gY2xvc2UgZW5vdWdoIHRvZ2V0aGVyIGEgZG91YmxlIGNsaWNrIGlzIHRyaWdnZXJlZC5cbiAgICAgICAgICAgIGlmIChkb3duID09IDEpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZG91YmxlQ2xpY2tUaW1lciA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9sYXN0VG91Y2hQb3MgPSBwb3M7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX2RvdWJsZUNsaWNrVGltZXIpO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFdoZW4gdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byB0b3VjaGVzIGlzIHNtYWxsIGVub3VnaFxuICAgICAgICAgICAgICAgICAgICAvLyBmb3JjZSB0aGUgcG9zaXRpb24gb2YgdGhlIGxhdHRlciB0b3VjaCB0byB0aGUgcG9zaXRpb24gb2ZcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIGZpcnN0LlxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHhzID0gdGhpcy5fbGFzdFRvdWNoUG9zLnggLSBwb3MueDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgeXMgPSB0aGlzLl9sYXN0VG91Y2hQb3MueSAtIHBvcy55O1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBkID0gTWF0aC5zcXJ0KCh4cyAqIHhzKSArICh5cyAqIHlzKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGdvYWwgaXMgdG8gdHJpZ2dlciBvbiBhIGNlcnRhaW4gcGh5c2ljYWwgd2lkdGgsIHRoZVxuICAgICAgICAgICAgICAgICAgICAvLyBkZXZpY2VQaXhlbFJhdGlvIGJyaW5ncyB1cyBhIGJpdCBjbG9zZXIgYnV0IGlzIG5vdCBvcHRpbWFsLlxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aHJlc2hvbGQgPSAyMCAqICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGQgPCB0aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHRoaXMuX2xhc3RUb3VjaFBvcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9kb3VibGVDbGlja1RpbWVyID0gc2V0VGltZW91dCh0aGlzLl9yZXNldERvdWJsZUNsaWNrVGltZXIuYmluZCh0aGlzKSwgNTAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJtYXNrID0gdGhpcy50b3VjaEJ1dHRvbjtcbiAgICAgICAgICAgIC8vIElmIGJtYXNrIGlzIHNldFxuICAgICAgICB9IGVsc2UgaWYgKGUud2hpY2gpIHtcbiAgICAgICAgICAgIC8qIGV2ZXJ5dGhpbmcgZXhjZXB0IElFICovXG4gICAgICAgICAgICBibWFzayA9IDEgPDwgZS5idXR0b247XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvKiBJRSBpbmNsdWRpbmcgOSAqL1xuICAgICAgICAgICAgYm1hc2sgPSAoZS5idXR0b24gJiAweDEpICsgICAgICAvLyBMZWZ0XG4gICAgICAgICAgICAgICAgICAgIChlLmJ1dHRvbiAmIDB4MikgKiAyICsgIC8vIFJpZ2h0XG4gICAgICAgICAgICAgICAgICAgIChlLmJ1dHRvbiAmIDB4NCkgLyAyOyAgIC8vIE1pZGRsZVxuICAgICAgICB9XG5cbiAgICAgICAgTG9nLkRlYnVnKFwib25tb3VzZWJ1dHRvbiBcIiArIChkb3duID8gXCJkb3duXCIgOiBcInVwXCIpICtcbiAgICAgICAgICAgICAgICAgIFwiLCB4OiBcIiArIHBvcy54ICsgXCIsIHk6IFwiICsgcG9zLnkgKyBcIiwgYm1hc2s6IFwiICsgYm1hc2spO1xuICAgICAgICB0aGlzLm9ubW91c2VidXR0b24ocG9zLngsIHBvcy55LCBkb3duLCBibWFzayk7XG5cbiAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgIH1cblxuICAgIF9oYW5kbGVNb3VzZURvd24oZSkge1xuICAgICAgICAvLyBUb3VjaCBldmVudHMgaGF2ZSBpbXBsaWNpdCBjYXB0dXJlXG4gICAgICAgIGlmIChlLnR5cGUgPT09IFwibW91c2Vkb3duXCIpIHtcbiAgICAgICAgICAgIHNldENhcHR1cmUodGhpcy5fdGFyZ2V0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2hhbmRsZU1vdXNlQnV0dG9uKGUsIDEpO1xuICAgIH1cblxuICAgIF9oYW5kbGVNb3VzZVVwKGUpIHtcbiAgICAgICAgdGhpcy5faGFuZGxlTW91c2VCdXR0b24oZSwgMCk7XG4gICAgfVxuXG4gICAgLy8gTW91c2Ugd2hlZWwgZXZlbnRzIGFyZSBzZW50IGluIHN0ZXBzIG92ZXIgVk5DLiBUaGlzIG1lYW5zIHRoYXQgdGhlIFZOQ1xuICAgIC8vIHByb3RvY29sIGNhbid0IGhhbmRsZSBhIHdoZWVsIGV2ZW50IHdpdGggc3BlY2lmaWMgZGlzdGFuY2Ugb3Igc3BlZWQuXG4gICAgLy8gVGhlcmVmb3IsIGlmIHdlIGdldCBhIGxvdCBvZiBzbWFsbCBtb3VzZSB3aGVlbCBldmVudHMgd2UgY29tYmluZSB0aGVtLlxuICAgIF9nZW5lcmF0ZVdoZWVsU3RlcFgoKSB7XG5cbiAgICAgICAgaWYgKHRoaXMuX2FjY3VtdWxhdGVkV2hlZWxEZWx0YVggPCAwKSB7XG4gICAgICAgICAgICB0aGlzLm9ubW91c2VidXR0b24odGhpcy5fcG9zLngsIHRoaXMuX3Bvcy55LCAxLCAxIDw8IDUpO1xuICAgICAgICAgICAgdGhpcy5vbm1vdXNlYnV0dG9uKHRoaXMuX3Bvcy54LCB0aGlzLl9wb3MueSwgMCwgMSA8PCA1KTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9hY2N1bXVsYXRlZFdoZWVsRGVsdGFYID4gMCkge1xuICAgICAgICAgICAgdGhpcy5vbm1vdXNlYnV0dG9uKHRoaXMuX3Bvcy54LCB0aGlzLl9wb3MueSwgMSwgMSA8PCA2KTtcbiAgICAgICAgICAgIHRoaXMub25tb3VzZWJ1dHRvbih0aGlzLl9wb3MueCwgdGhpcy5fcG9zLnksIDAsIDEgPDwgNik7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9hY2N1bXVsYXRlZFdoZWVsRGVsdGFYID0gMDtcbiAgICB9XG5cbiAgICBfZ2VuZXJhdGVXaGVlbFN0ZXBZKCkge1xuXG4gICAgICAgIGlmICh0aGlzLl9hY2N1bXVsYXRlZFdoZWVsRGVsdGFZIDwgMCkge1xuICAgICAgICAgICAgdGhpcy5vbm1vdXNlYnV0dG9uKHRoaXMuX3Bvcy54LCB0aGlzLl9wb3MueSwgMSwgMSA8PCAzKTtcbiAgICAgICAgICAgIHRoaXMub25tb3VzZWJ1dHRvbih0aGlzLl9wb3MueCwgdGhpcy5fcG9zLnksIDAsIDEgPDwgMyk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYWNjdW11bGF0ZWRXaGVlbERlbHRhWSA+IDApIHtcbiAgICAgICAgICAgIHRoaXMub25tb3VzZWJ1dHRvbih0aGlzLl9wb3MueCwgdGhpcy5fcG9zLnksIDEsIDEgPDwgNCk7XG4gICAgICAgICAgICB0aGlzLm9ubW91c2VidXR0b24odGhpcy5fcG9zLngsIHRoaXMuX3Bvcy55LCAwLCAxIDw8IDQpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYWNjdW11bGF0ZWRXaGVlbERlbHRhWSA9IDA7XG4gICAgfVxuXG4gICAgX3Jlc2V0V2hlZWxTdGVwVGltZXJzKCkge1xuICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMuX3doZWVsU3RlcFhUaW1lcik7XG4gICAgICAgIHdpbmRvdy5jbGVhclRpbWVvdXQodGhpcy5fd2hlZWxTdGVwWVRpbWVyKTtcbiAgICAgICAgdGhpcy5fd2hlZWxTdGVwWFRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5fd2hlZWxTdGVwWVRpbWVyID0gbnVsbDtcbiAgICB9XG5cbiAgICBfaGFuZGxlTW91c2VXaGVlbChlKSB7XG4gICAgICAgIHRoaXMuX3Jlc2V0V2hlZWxTdGVwVGltZXJzKCk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlTW91c2VQb3NpdGlvbihlKTtcblxuICAgICAgICBsZXQgZFggPSBlLmRlbHRhWDtcbiAgICAgICAgbGV0IGRZID0gZS5kZWx0YVk7XG5cbiAgICAgICAgLy8gUGl4ZWwgdW5pdHMgdW5sZXNzIGl0J3Mgbm9uLXplcm8uXG4gICAgICAgIC8vIE5vdGUgdGhhdCBpZiBkZWx0YW1vZGUgaXMgbGluZSBvciBwYWdlIHdvbid0IG1hdHRlciBzaW5jZSB3ZSBhcmVuJ3RcbiAgICAgICAgLy8gc2VuZGluZyB0aGUgbW91c2Ugd2hlZWwgZGVsdGEgdG8gdGhlIHNlcnZlciBhbnl3YXkuXG4gICAgICAgIC8vIFRoZSBkaWZmZXJlbmNlIGJldHdlZW4gcGl4ZWwgYW5kIGxpbmUgY2FuIGJlIGltcG9ydGFudCBob3dldmVyIHNpbmNlXG4gICAgICAgIC8vIHdlIGhhdmUgYSB0aHJlc2hvbGQgdGhhdCBjYW4gYmUgc21hbGxlciB0aGFuIHRoZSBsaW5lIGhlaWdodC5cbiAgICAgICAgaWYgKGUuZGVsdGFNb2RlICE9PSAwKSB7XG4gICAgICAgICAgICBkWCAqPSBXSEVFTF9MSU5FX0hFSUdIVDtcbiAgICAgICAgICAgIGRZICo9IFdIRUVMX0xJTkVfSEVJR0hUO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fYWNjdW11bGF0ZWRXaGVlbERlbHRhWCArPSBkWDtcbiAgICAgICAgdGhpcy5fYWNjdW11bGF0ZWRXaGVlbERlbHRhWSArPSBkWTtcblxuICAgICAgICAvLyBHZW5lcmF0ZSBhIG1vdXNlIHdoZWVsIHN0ZXAgZXZlbnQgd2hlbiB0aGUgYWNjdW11bGF0ZWQgZGVsdGFcbiAgICAgICAgLy8gZm9yIG9uZSBvZiB0aGUgYXhlcyBpcyBsYXJnZSBlbm91Z2guXG4gICAgICAgIC8vIFNtYWxsIGRlbHRhIGV2ZW50cyB0aGF0IGRvIG5vdCBwYXNzIHRoZSB0aHJlc2hvbGQgZ2V0IHNlbnRcbiAgICAgICAgLy8gYWZ0ZXIgYSB0aW1lb3V0LlxuICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5fYWNjdW11bGF0ZWRXaGVlbERlbHRhWCkgPiBXSEVFTF9TVEVQKSB7XG4gICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZVdoZWVsU3RlcFgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3doZWVsU3RlcFhUaW1lciA9XG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQodGhpcy5fZ2VuZXJhdGVXaGVlbFN0ZXBYLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV0hFRUxfU1RFUF9USU1FT1VUKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoTWF0aC5hYnModGhpcy5fYWNjdW11bGF0ZWRXaGVlbERlbHRhWSkgPiBXSEVFTF9TVEVQKSB7XG4gICAgICAgICAgICB0aGlzLl9nZW5lcmF0ZVdoZWVsU3RlcFkoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3doZWVsU3RlcFlUaW1lciA9XG4gICAgICAgICAgICAgICAgd2luZG93LnNldFRpbWVvdXQodGhpcy5fZ2VuZXJhdGVXaGVlbFN0ZXBZLmJpbmQodGhpcyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgV0hFRUxfU1RFUF9USU1FT1VUKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0b3BFdmVudChlKTtcbiAgICB9XG5cbiAgICBfaGFuZGxlTW91c2VNb3ZlKGUpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlTW91c2VQb3NpdGlvbihlKTtcbiAgICAgICAgdGhpcy5vbm1vdXNlbW92ZSh0aGlzLl9wb3MueCwgdGhpcy5fcG9zLnkpO1xuICAgICAgICBzdG9wRXZlbnQoZSk7XG4gICAgfVxuXG4gICAgX2hhbmRsZU1vdXNlRGlzYWJsZShlKSB7XG4gICAgICAgIC8qXG4gICAgICAgICAqIFN0b3AgcHJvcGFnYXRpb24gaWYgaW5zaWRlIGNhbnZhcyBhcmVhXG4gICAgICAgICAqIE5vdGU6IFRoaXMgaXMgb25seSBuZWVkZWQgZm9yIHRoZSAnY2xpY2snIGV2ZW50IGFzIGl0IGZhaWxzXG4gICAgICAgICAqICAgICAgIHRvIGZpcmUgcHJvcGVybHkgZm9yIHRoZSB0YXJnZXQgZWxlbWVudCBzbyB3ZSBoYXZlXG4gICAgICAgICAqICAgICAgIHRvIGxpc3RlbiBvbiB0aGUgZG9jdW1lbnQgZWxlbWVudCBpbnN0ZWFkLlxuICAgICAgICAgKi9cbiAgICAgICAgaWYgKGUudGFyZ2V0ID09IHRoaXMuX3RhcmdldCkge1xuICAgICAgICAgICAgc3RvcEV2ZW50KGUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIGNvb3JkaW5hdGVzIHJlbGF0aXZlIHRvIHRhcmdldFxuICAgIF91cGRhdGVNb3VzZVBvc2l0aW9uKGUpIHtcbiAgICAgICAgZSA9IGdldFBvaW50ZXJFdmVudChlKTtcbiAgICAgICAgY29uc3QgYm91bmRzID0gdGhpcy5fdGFyZ2V0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBsZXQgeDtcbiAgICAgICAgbGV0IHk7XG4gICAgICAgIC8vIENsaXAgdG8gdGFyZ2V0IGJvdW5kc1xuICAgICAgICBpZiAoZS5jbGllbnRYIDwgYm91bmRzLmxlZnQpIHtcbiAgICAgICAgICAgIHggPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGUuY2xpZW50WCA+PSBib3VuZHMucmlnaHQpIHtcbiAgICAgICAgICAgIHggPSBib3VuZHMud2lkdGggLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeCA9IGUuY2xpZW50WCAtIGJvdW5kcy5sZWZ0O1xuICAgICAgICB9XG4gICAgICAgIGlmIChlLmNsaWVudFkgPCBib3VuZHMudG9wKSB7XG4gICAgICAgICAgICB5ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChlLmNsaWVudFkgPj0gYm91bmRzLmJvdHRvbSkge1xuICAgICAgICAgICAgeSA9IGJvdW5kcy5oZWlnaHQgLSAxO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgeSA9IGUuY2xpZW50WSAtIGJvdW5kcy50b3A7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcG9zID0ge3g6IHgsIHk6IHl9O1xuICAgIH1cblxuICAgIC8vID09PT09IFBVQkxJQyBNRVRIT0RTID09PT09XG5cbiAgICBncmFiKCkge1xuICAgICAgICBpZiAoaXNUb3VjaERldmljZSkge1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLl9ldmVudEhhbmRsZXJzLm1vdXNlZG93bik7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCB0aGlzLl9ldmVudEhhbmRsZXJzLm1vdXNldXApO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNobW92ZScsIHRoaXMuX2V2ZW50SGFuZGxlcnMubW91c2Vtb3ZlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgdGhpcy5fZXZlbnRIYW5kbGVycy5tb3VzZWRvd24pO1xuICAgICAgICB0aGlzLl90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMuX2V2ZW50SGFuZGxlcnMubW91c2V1cCk7XG4gICAgICAgIHRoaXMuX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCB0aGlzLl9ldmVudEhhbmRsZXJzLm1vdXNlbW92ZSk7XG4gICAgICAgIHRoaXMuX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCd3aGVlbCcsIHRoaXMuX2V2ZW50SGFuZGxlcnMubW91c2V3aGVlbCk7XG5cbiAgICAgICAgLyogUHJldmVudCBtaWRkbGUtY2xpY2sgcGFzdGluZyAoc2VlIGFib3ZlIGZvciB3aHkgd2UgYmluZCB0byBkb2N1bWVudCkgKi9cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCB0aGlzLl9ldmVudEhhbmRsZXJzLm1vdXNlZGlzYWJsZSk7XG5cbiAgICAgICAgLyogcHJldmVudERlZmF1bHQoKSBvbiBtb3VzZWRvd24gZG9lc24ndCBzdG9wIHRoaXMgZXZlbnQgZm9yIHNvbWVcbiAgICAgICAgICAgcmVhc29uIHNvIHdlIGhhdmUgdG8gZXhwbGljaXRseSBibG9jayBpdCAqL1xuICAgICAgICB0aGlzLl90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLl9ldmVudEhhbmRsZXJzLm1vdXNlZGlzYWJsZSk7XG4gICAgfVxuXG4gICAgdW5ncmFiKCkge1xuICAgICAgICB0aGlzLl9yZXNldFdoZWVsU3RlcFRpbWVycygpO1xuXG4gICAgICAgIGlmIChpc1RvdWNoRGV2aWNlKSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2V2ZW50SGFuZGxlcnMubW91c2Vkb3duKTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIHRoaXMuX2V2ZW50SGFuZGxlcnMubW91c2V1cCk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fZXZlbnRIYW5kbGVycy5tb3VzZW1vdmUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCB0aGlzLl9ldmVudEhhbmRsZXJzLm1vdXNlZG93bik7XG4gICAgICAgIHRoaXMuX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fZXZlbnRIYW5kbGVycy5tb3VzZXVwKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX2V2ZW50SGFuZGxlcnMubW91c2Vtb3ZlKTtcbiAgICAgICAgdGhpcy5fdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3doZWVsJywgdGhpcy5fZXZlbnRIYW5kbGVycy5tb3VzZXdoZWVsKTtcblxuICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdjbGljaycsIHRoaXMuX2V2ZW50SGFuZGxlcnMubW91c2VkaXNhYmxlKTtcblxuICAgICAgICB0aGlzLl90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignY29udGV4dG1lbnUnLCB0aGlzLl9ldmVudEhhbmRsZXJzLm1vdXNlZGlzYWJsZSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IGtleXN5bXMgZnJvbSBcIi4va2V5c3ltZGVmLmpzXCI7XG5pbXBvcnQgdmtleXMgZnJvbSBcIi4vdmtleXMuanNcIjtcbmltcG9ydCBmaXhlZGtleXMgZnJvbSBcIi4vZml4ZWRrZXlzLmpzXCI7XG5pbXBvcnQgRE9NS2V5VGFibGUgZnJvbSBcIi4vZG9ta2V5dGFibGUuanNcIjtcbmltcG9ydCAqIGFzIGJyb3dzZXIgZnJvbSBcIi4uL3V0aWwvYnJvd3Nlci5qc1wiO1xuXG4vLyBHZXQgJ0tleWJvYXJkRXZlbnQuY29kZScsIGhhbmRsaW5nIGxlZ2FjeSBicm93c2Vyc1xuZXhwb3J0IGZ1bmN0aW9uIGdldEtleWNvZGUoZXZ0KSB7XG4gICAgLy8gQXJlIHdlIGdldHRpbmcgcHJvcGVyIGtleSBpZGVudGlmaWVycz9cbiAgICAvLyAodW5mb3J0dW5hdGVseSBGaXJlZm94IGFuZCBDaHJvbWUgYXJlIGNyYXBweSBoZXJlIGFuZCBnaXZlc1xuICAgIC8vIHVzIGFuIGVtcHR5IHN0cmluZyBvbiBzb21lIHBsYXRmb3JtcywgcmF0aGVyIHRoYW4gbGVhdmluZyBpdFxuICAgIC8vIHVuZGVmaW5lZClcbiAgICBpZiAoZXZ0LmNvZGUpIHtcbiAgICAgICAgLy8gTW96aWxsYSBpc24ndCBmdWxseSBpbiBzeW5jIHdpdGggdGhlIHNwZWMgeWV0XG4gICAgICAgIHN3aXRjaCAoZXZ0LmNvZGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ09TTGVmdCc6IHJldHVybiAnTWV0YUxlZnQnO1xuICAgICAgICAgICAgY2FzZSAnT1NSaWdodCc6IHJldHVybiAnTWV0YVJpZ2h0JztcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBldnQuY29kZTtcbiAgICB9XG5cbiAgICAvLyBUaGUgZGUtZmFjdG8gc3RhbmRhcmQgaXMgdG8gdXNlIFdpbmRvd3MgVmlydHVhbC1LZXkgY29kZXNcbiAgICAvLyBpbiB0aGUgJ2tleUNvZGUnIGZpZWxkIGZvciBub24tcHJpbnRhYmxlIGNoYXJhY3RlcnMuIEhvd2V2ZXJcbiAgICAvLyBXZWJraXQgc2V0cyBpdCB0byB0aGUgc2FtZSBhcyBjaGFyQ29kZSBpbiAna2V5cHJlc3MnIGV2ZW50cy5cbiAgICBpZiAoKGV2dC50eXBlICE9PSAna2V5cHJlc3MnKSAmJiAoZXZ0LmtleUNvZGUgaW4gdmtleXMpKSB7XG4gICAgICAgIGxldCBjb2RlID0gdmtleXNbZXZ0LmtleUNvZGVdO1xuXG4gICAgICAgIC8vIG1hY09TIGhhcyBtZXNzZWQgdXAgdGhpcyBjb2RlIGZvciBzb21lIHJlYXNvblxuICAgICAgICBpZiAoYnJvd3Nlci5pc01hYygpICYmIChjb2RlID09PSAnQ29udGV4dE1lbnUnKSkge1xuICAgICAgICAgICAgY29kZSA9ICdNZXRhUmlnaHQnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIGtleUNvZGUgZG9lc24ndCBkaXN0aW5ndWlzaCBiZXR3ZWVuIGxlZnQgYW5kIHJpZ2h0XG4gICAgICAgIC8vIGZvciB0aGUgc3RhbmRhcmQgbW9kaWZpZXJzXG4gICAgICAgIGlmIChldnQubG9jYXRpb24gPT09IDIpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ1NoaWZ0TGVmdCc6IHJldHVybiAnU2hpZnRSaWdodCc7XG4gICAgICAgICAgICAgICAgY2FzZSAnQ29udHJvbExlZnQnOiByZXR1cm4gJ0NvbnRyb2xSaWdodCc7XG4gICAgICAgICAgICAgICAgY2FzZSAnQWx0TGVmdCc6IHJldHVybiAnQWx0UmlnaHQnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gTm9yIGEgYnVuY2ggb2YgdGhlIG51bXBhZCBrZXlzXG4gICAgICAgIGlmIChldnQubG9jYXRpb24gPT09IDMpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29kZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0RlbGV0ZSc6IHJldHVybiAnTnVtcGFkRGVjaW1hbCc7XG4gICAgICAgICAgICAgICAgY2FzZSAnSW5zZXJ0JzogcmV0dXJuICdOdW1wYWQwJztcbiAgICAgICAgICAgICAgICBjYXNlICdFbmQnOiByZXR1cm4gJ051bXBhZDEnO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0Fycm93RG93bic6IHJldHVybiAnTnVtcGFkMic7XG4gICAgICAgICAgICAgICAgY2FzZSAnUGFnZURvd24nOiByZXR1cm4gJ051bXBhZDMnO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0Fycm93TGVmdCc6IHJldHVybiAnTnVtcGFkNCc7XG4gICAgICAgICAgICAgICAgY2FzZSAnQXJyb3dSaWdodCc6IHJldHVybiAnTnVtcGFkNic7XG4gICAgICAgICAgICAgICAgY2FzZSAnSG9tZSc6IHJldHVybiAnTnVtcGFkNyc7XG4gICAgICAgICAgICAgICAgY2FzZSAnQXJyb3dVcCc6IHJldHVybiAnTnVtcGFkOCc7XG4gICAgICAgICAgICAgICAgY2FzZSAnUGFnZVVwJzogcmV0dXJuICdOdW1wYWQ5JztcbiAgICAgICAgICAgICAgICBjYXNlICdFbnRlcic6IHJldHVybiAnTnVtcGFkRW50ZXInO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNvZGU7XG4gICAgfVxuXG4gICAgcmV0dXJuICdVbmlkZW50aWZpZWQnO1xufVxuXG4vLyBHZXQgJ0tleWJvYXJkRXZlbnQua2V5JywgaGFuZGxpbmcgbGVnYWN5IGJyb3dzZXJzXG5leHBvcnQgZnVuY3Rpb24gZ2V0S2V5KGV2dCkge1xuICAgIC8vIEFyZSB3ZSBnZXR0aW5nIGEgcHJvcGVyIGtleSB2YWx1ZT9cbiAgICBpZiAoZXZ0LmtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIElFIGFuZCBFZGdlIHVzZSBzb21lIGFuY2llbnQgdmVyc2lvbiBvZiB0aGUgc3BlY1xuICAgICAgICAvLyBodHRwczovL2RldmVsb3Blci5taWNyb3NvZnQuY29tL2VuLXVzL21pY3Jvc29mdC1lZGdlL3BsYXRmb3JtL2lzc3Vlcy84ODYwNTcxL1xuICAgICAgICBzd2l0Y2ggKGV2dC5rZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ1NwYWNlYmFyJzogcmV0dXJuICcgJztcbiAgICAgICAgICAgIGNhc2UgJ0VzYyc6IHJldHVybiAnRXNjYXBlJztcbiAgICAgICAgICAgIGNhc2UgJ1Njcm9sbCc6IHJldHVybiAnU2Nyb2xsTG9jayc7XG4gICAgICAgICAgICBjYXNlICdXaW4nOiByZXR1cm4gJ01ldGEnO1xuICAgICAgICAgICAgY2FzZSAnQXBwcyc6IHJldHVybiAnQ29udGV4dE1lbnUnO1xuICAgICAgICAgICAgY2FzZSAnVXAnOiByZXR1cm4gJ0Fycm93VXAnO1xuICAgICAgICAgICAgY2FzZSAnTGVmdCc6IHJldHVybiAnQXJyb3dMZWZ0JztcbiAgICAgICAgICAgIGNhc2UgJ1JpZ2h0JzogcmV0dXJuICdBcnJvd1JpZ2h0JztcbiAgICAgICAgICAgIGNhc2UgJ0Rvd24nOiByZXR1cm4gJ0Fycm93RG93bic7XG4gICAgICAgICAgICBjYXNlICdEZWwnOiByZXR1cm4gJ0RlbGV0ZSc7XG4gICAgICAgICAgICBjYXNlICdEaXZpZGUnOiByZXR1cm4gJy8nO1xuICAgICAgICAgICAgY2FzZSAnTXVsdGlwbHknOiByZXR1cm4gJyonO1xuICAgICAgICAgICAgY2FzZSAnU3VidHJhY3QnOiByZXR1cm4gJy0nO1xuICAgICAgICAgICAgY2FzZSAnQWRkJzogcmV0dXJuICcrJztcbiAgICAgICAgICAgIGNhc2UgJ0RlY2ltYWwnOiByZXR1cm4gZXZ0LmNoYXI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBNb3ppbGxhIGlzbid0IGZ1bGx5IGluIHN5bmMgd2l0aCB0aGUgc3BlYyB5ZXRcbiAgICAgICAgc3dpdGNoIChldnQua2V5KSB7XG4gICAgICAgICAgICBjYXNlICdPUyc6IHJldHVybiAnTWV0YSc7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpT1MgbGVha3Mgc29tZSBPUyBuYW1lc1xuICAgICAgICBzd2l0Y2ggKGV2dC5rZXkpIHtcbiAgICAgICAgICAgIGNhc2UgJ1VJS2V5SW5wdXRVcEFycm93JzogcmV0dXJuICdBcnJvd1VwJztcbiAgICAgICAgICAgIGNhc2UgJ1VJS2V5SW5wdXREb3duQXJyb3cnOiByZXR1cm4gJ0Fycm93RG93bic7XG4gICAgICAgICAgICBjYXNlICdVSUtleUlucHV0TGVmdEFycm93JzogcmV0dXJuICdBcnJvd0xlZnQnO1xuICAgICAgICAgICAgY2FzZSAnVUlLZXlJbnB1dFJpZ2h0QXJyb3cnOiByZXR1cm4gJ0Fycm93UmlnaHQnO1xuICAgICAgICAgICAgY2FzZSAnVUlLZXlJbnB1dEVzY2FwZSc6IHJldHVybiAnRXNjYXBlJztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIElFIGFuZCBFZGdlIGhhdmUgYnJva2VuIGhhbmRsaW5nIG9mIEFsdEdyYXBoIHNvIHdlIGNhbm5vdFxuICAgICAgICAvLyB0cnVzdCB0aGVtIGZvciBwcmludGFibGUgY2hhcmFjdGVyc1xuICAgICAgICBpZiAoKGV2dC5rZXkubGVuZ3RoICE9PSAxKSB8fCAoIWJyb3dzZXIuaXNJRSgpICYmICFicm93c2VyLmlzRWRnZSgpKSkge1xuICAgICAgICAgICAgcmV0dXJuIGV2dC5rZXk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBUcnkgdG8gZGVkdWNlIGl0IGJhc2VkIG9uIHRoZSBwaHlzaWNhbCBrZXlcbiAgICBjb25zdCBjb2RlID0gZ2V0S2V5Y29kZShldnQpO1xuICAgIGlmIChjb2RlIGluIGZpeGVka2V5cykge1xuICAgICAgICByZXR1cm4gZml4ZWRrZXlzW2NvZGVdO1xuICAgIH1cblxuICAgIC8vIElmIHRoYXQgZmFpbGVkLCB0aGVuIHNlZSBpZiB3ZSBoYXZlIGEgcHJpbnRhYmxlIGNoYXJhY3RlclxuICAgIGlmIChldnQuY2hhckNvZGUpIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoZXZ0LmNoYXJDb2RlKTtcbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50IHdlIGhhdmUgbm90aGluZyBsZWZ0IHRvIGdvIG9uXG4gICAgcmV0dXJuICdVbmlkZW50aWZpZWQnO1xufVxuXG4vLyBHZXQgdGhlIG1vc3QgcmVsaWFibGUga2V5c3ltIHZhbHVlIHdlIGNhbiBnZXQgZnJvbSBhIGtleSBldmVudFxuZXhwb3J0IGZ1bmN0aW9uIGdldEtleXN5bShldnQpIHtcbiAgICBjb25zdCBrZXkgPSBnZXRLZXkoZXZ0KTtcblxuICAgIGlmIChrZXkgPT09ICdVbmlkZW50aWZpZWQnKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIEZpcnN0IGxvb2sgdXAgc3BlY2lhbCBrZXlzXG4gICAgaWYgKGtleSBpbiBET01LZXlUYWJsZSkge1xuICAgICAgICBsZXQgbG9jYXRpb24gPSBldnQubG9jYXRpb247XG5cbiAgICAgICAgLy8gU2FmYXJpIHNjcmV3cyB1cCBsb2NhdGlvbiBmb3IgdGhlIHJpZ2h0IGNtZCBrZXlcbiAgICAgICAgaWYgKChrZXkgPT09ICdNZXRhJykgJiYgKGxvY2F0aW9uID09PSAwKSkge1xuICAgICAgICAgICAgbG9jYXRpb24gPSAyO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKChsb2NhdGlvbiA9PT0gdW5kZWZpbmVkKSB8fCAobG9jYXRpb24gPiAzKSkge1xuICAgICAgICAgICAgbG9jYXRpb24gPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIERPTUtleVRhYmxlW2tleV1bbG9jYXRpb25dO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBuZWVkIHRvIGxvb2sgYXQgdGhlIFVuaWNvZGUgc3ltYm9sIGluc3RlYWRcblxuICAgIC8vIFNwZWNpYWwga2V5PyAoRklYTUU6IFNob3VsZCBoYXZlIGJlZW4gY2F1Z2h0IGVhcmxpZXIpXG4gICAgaWYgKGtleS5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgY29kZXBvaW50ID0ga2V5LmNoYXJDb2RlQXQoKTtcbiAgICBpZiAoY29kZXBvaW50KSB7XG4gICAgICAgIHJldHVybiBrZXlzeW1zLmxvb2t1cChjb2RlcG9pbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBudWxsO1xufVxuIiwiLypcbiAqIG5vVk5DOiBIVE1MNSBWTkMgY2xpZW50XG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggVGhlIG5vVk5DIEF1dGhvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIE1QTCAyLjAgb3IgYW55IGxhdGVyIHZlcnNpb24gKHNlZSBMSUNFTlNFLnR4dClcbiAqL1xuXG4vKlxuICogTWFwcGluZyBiZXR3ZWVuIE1pY3Jvc29mdMKuIFdpbmRvd3PCriBWaXJ0dWFsLUtleSBjb2RlcyBhbmRcbiAqIEhUTUwga2V5IGNvZGVzLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICAweDA4OiAnQmFja3NwYWNlJyxcbiAgICAweDA5OiAnVGFiJyxcbiAgICAweDBhOiAnTnVtcGFkQ2xlYXInLFxuICAgIDB4MGM6ICdOdW1wYWQ1JywgLy8gSUUxMSBzZW5kcyBldnQua2V5Q29kZTogMTIgd2hlbiBudW1sb2NrIGlzIG9mZlxuICAgIDB4MGQ6ICdFbnRlcicsXG4gICAgMHgxMDogJ1NoaWZ0TGVmdCcsXG4gICAgMHgxMTogJ0NvbnRyb2xMZWZ0JyxcbiAgICAweDEyOiAnQWx0TGVmdCcsXG4gICAgMHgxMzogJ1BhdXNlJyxcbiAgICAweDE0OiAnQ2Fwc0xvY2snLFxuICAgIDB4MTU6ICdMYW5nMScsXG4gICAgMHgxOTogJ0xhbmcyJyxcbiAgICAweDFiOiAnRXNjYXBlJyxcbiAgICAweDFjOiAnQ29udmVydCcsXG4gICAgMHgxZDogJ05vbkNvbnZlcnQnLFxuICAgIDB4MjA6ICdTcGFjZScsXG4gICAgMHgyMTogJ1BhZ2VVcCcsXG4gICAgMHgyMjogJ1BhZ2VEb3duJyxcbiAgICAweDIzOiAnRW5kJyxcbiAgICAweDI0OiAnSG9tZScsXG4gICAgMHgyNTogJ0Fycm93TGVmdCcsXG4gICAgMHgyNjogJ0Fycm93VXAnLFxuICAgIDB4Mjc6ICdBcnJvd1JpZ2h0JyxcbiAgICAweDI4OiAnQXJyb3dEb3duJyxcbiAgICAweDI5OiAnU2VsZWN0JyxcbiAgICAweDJjOiAnUHJpbnRTY3JlZW4nLFxuICAgIDB4MmQ6ICdJbnNlcnQnLFxuICAgIDB4MmU6ICdEZWxldGUnLFxuICAgIDB4MmY6ICdIZWxwJyxcbiAgICAweDMwOiAnRGlnaXQwJyxcbiAgICAweDMxOiAnRGlnaXQxJyxcbiAgICAweDMyOiAnRGlnaXQyJyxcbiAgICAweDMzOiAnRGlnaXQzJyxcbiAgICAweDM0OiAnRGlnaXQ0JyxcbiAgICAweDM1OiAnRGlnaXQ1JyxcbiAgICAweDM2OiAnRGlnaXQ2JyxcbiAgICAweDM3OiAnRGlnaXQ3JyxcbiAgICAweDM4OiAnRGlnaXQ4JyxcbiAgICAweDM5OiAnRGlnaXQ5JyxcbiAgICAweDViOiAnTWV0YUxlZnQnLFxuICAgIDB4NWM6ICdNZXRhUmlnaHQnLFxuICAgIDB4NWQ6ICdDb250ZXh0TWVudScsXG4gICAgMHg1ZjogJ1NsZWVwJyxcbiAgICAweDYwOiAnTnVtcGFkMCcsXG4gICAgMHg2MTogJ051bXBhZDEnLFxuICAgIDB4NjI6ICdOdW1wYWQyJyxcbiAgICAweDYzOiAnTnVtcGFkMycsXG4gICAgMHg2NDogJ051bXBhZDQnLFxuICAgIDB4NjU6ICdOdW1wYWQ1JyxcbiAgICAweDY2OiAnTnVtcGFkNicsXG4gICAgMHg2NzogJ051bXBhZDcnLFxuICAgIDB4Njg6ICdOdW1wYWQ4JyxcbiAgICAweDY5OiAnTnVtcGFkOScsXG4gICAgMHg2YTogJ051bXBhZE11bHRpcGx5JyxcbiAgICAweDZiOiAnTnVtcGFkQWRkJyxcbiAgICAweDZjOiAnTnVtcGFkRGVjaW1hbCcsXG4gICAgMHg2ZDogJ051bXBhZFN1YnRyYWN0JyxcbiAgICAweDZlOiAnTnVtcGFkRGVjaW1hbCcsIC8vIER1cGxpY2F0ZSwgYmVjYXVzZSBidWdneSBvbiBXaW5kb3dzXG4gICAgMHg2ZjogJ051bXBhZERpdmlkZScsXG4gICAgMHg3MDogJ0YxJyxcbiAgICAweDcxOiAnRjInLFxuICAgIDB4NzI6ICdGMycsXG4gICAgMHg3MzogJ0Y0JyxcbiAgICAweDc0OiAnRjUnLFxuICAgIDB4NzU6ICdGNicsXG4gICAgMHg3NjogJ0Y3JyxcbiAgICAweDc3OiAnRjgnLFxuICAgIDB4Nzg6ICdGOScsXG4gICAgMHg3OTogJ0YxMCcsXG4gICAgMHg3YTogJ0YxMScsXG4gICAgMHg3YjogJ0YxMicsXG4gICAgMHg3YzogJ0YxMycsXG4gICAgMHg3ZDogJ0YxNCcsXG4gICAgMHg3ZTogJ0YxNScsXG4gICAgMHg3ZjogJ0YxNicsXG4gICAgMHg4MDogJ0YxNycsXG4gICAgMHg4MTogJ0YxOCcsXG4gICAgMHg4MjogJ0YxOScsXG4gICAgMHg4MzogJ0YyMCcsXG4gICAgMHg4NDogJ0YyMScsXG4gICAgMHg4NTogJ0YyMicsXG4gICAgMHg4NjogJ0YyMycsXG4gICAgMHg4NzogJ0YyNCcsXG4gICAgMHg5MDogJ051bUxvY2snLFxuICAgIDB4OTE6ICdTY3JvbGxMb2NrJyxcbiAgICAweGE2OiAnQnJvd3NlckJhY2snLFxuICAgIDB4YTc6ICdCcm93c2VyRm9yd2FyZCcsXG4gICAgMHhhODogJ0Jyb3dzZXJSZWZyZXNoJyxcbiAgICAweGE5OiAnQnJvd3NlclN0b3AnLFxuICAgIDB4YWE6ICdCcm93c2VyU2VhcmNoJyxcbiAgICAweGFiOiAnQnJvd3NlckZhdm9yaXRlcycsXG4gICAgMHhhYzogJ0Jyb3dzZXJIb21lJyxcbiAgICAweGFkOiAnQXVkaW9Wb2x1bWVNdXRlJyxcbiAgICAweGFlOiAnQXVkaW9Wb2x1bWVEb3duJyxcbiAgICAweGFmOiAnQXVkaW9Wb2x1bWVVcCcsXG4gICAgMHhiMDogJ01lZGlhVHJhY2tOZXh0JyxcbiAgICAweGIxOiAnTWVkaWFUcmFja1ByZXZpb3VzJyxcbiAgICAweGIyOiAnTWVkaWFTdG9wJyxcbiAgICAweGIzOiAnTWVkaWFQbGF5UGF1c2UnLFxuICAgIDB4YjQ6ICdMYXVuY2hNYWlsJyxcbiAgICAweGI1OiAnTWVkaWFTZWxlY3QnLFxuICAgIDB4YjY6ICdMYXVuY2hBcHAxJyxcbiAgICAweGI3OiAnTGF1bmNoQXBwMicsXG4gICAgMHhlMTogJ0FsdFJpZ2h0JywgLy8gT25seSB3aGVuIGl0IGlzIEFsdEdyYXBoXG59O1xuIiwiLypcbiAqIFRoaXMgZmlsZSBpcyBhdXRvLWdlbmVyYXRlZCBmcm9tIGtleW1hcHMuY3N2IG9uIDIwMTctMDUtMzEgMTY6MjBcbiAqIERhdGFiYXNlIGNoZWNrc3VtIHNoYTI1Nig5MmZkMTY1NTA3ZjJhM2I4YzViM2ZhNTZlNDI1ZDQ1Nzg4ZGJjYjk4Y2YwNjdhMzA3NTI3ZDkxY2UyMmNhYjk0KVxuICogVG8gcmUtZ2VuZXJhdGUsIHJ1bjpcbiAqICAga2V5bWFwLWdlbiAtLWxhbmc9anMgY29kZS1tYXAga2V5bWFwcy5jc3YgaHRtbCBhdHNldDFcbiovXG5leHBvcnQgZGVmYXVsdCB7XG4gIFwiQWdhaW5cIjogMHhlMDA1LCAvKiBodG1sOkFnYWluIChBZ2FpbikgLT4gbGludXg6MTI5IChLRVlfQUdBSU4pIC0+IGF0c2V0MTo1NzM0OSAqL1xuICBcIkFsdExlZnRcIjogMHgzOCwgLyogaHRtbDpBbHRMZWZ0IChBbHRMZWZ0KSAtPiBsaW51eDo1NiAoS0VZX0xFRlRBTFQpIC0+IGF0c2V0MTo1NiAqL1xuICBcIkFsdFJpZ2h0XCI6IDB4ZTAzOCwgLyogaHRtbDpBbHRSaWdodCAoQWx0UmlnaHQpIC0+IGxpbnV4OjEwMCAoS0VZX1JJR0hUQUxUKSAtPiBhdHNldDE6NTc0MDAgKi9cbiAgXCJBcnJvd0Rvd25cIjogMHhlMDUwLCAvKiBodG1sOkFycm93RG93biAoQXJyb3dEb3duKSAtPiBsaW51eDoxMDggKEtFWV9ET1dOKSAtPiBhdHNldDE6NTc0MjQgKi9cbiAgXCJBcnJvd0xlZnRcIjogMHhlMDRiLCAvKiBodG1sOkFycm93TGVmdCAoQXJyb3dMZWZ0KSAtPiBsaW51eDoxMDUgKEtFWV9MRUZUKSAtPiBhdHNldDE6NTc0MTkgKi9cbiAgXCJBcnJvd1JpZ2h0XCI6IDB4ZTA0ZCwgLyogaHRtbDpBcnJvd1JpZ2h0IChBcnJvd1JpZ2h0KSAtPiBsaW51eDoxMDYgKEtFWV9SSUdIVCkgLT4gYXRzZXQxOjU3NDIxICovXG4gIFwiQXJyb3dVcFwiOiAweGUwNDgsIC8qIGh0bWw6QXJyb3dVcCAoQXJyb3dVcCkgLT4gbGludXg6MTAzIChLRVlfVVApIC0+IGF0c2V0MTo1NzQxNiAqL1xuICBcIkF1ZGlvVm9sdW1lRG93blwiOiAweGUwMmUsIC8qIGh0bWw6QXVkaW9Wb2x1bWVEb3duIChBdWRpb1ZvbHVtZURvd24pIC0+IGxpbnV4OjExNCAoS0VZX1ZPTFVNRURPV04pIC0+IGF0c2V0MTo1NzM5MCAqL1xuICBcIkF1ZGlvVm9sdW1lTXV0ZVwiOiAweGUwMjAsIC8qIGh0bWw6QXVkaW9Wb2x1bWVNdXRlIChBdWRpb1ZvbHVtZU11dGUpIC0+IGxpbnV4OjExMyAoS0VZX01VVEUpIC0+IGF0c2V0MTo1NzM3NiAqL1xuICBcIkF1ZGlvVm9sdW1lVXBcIjogMHhlMDMwLCAvKiBodG1sOkF1ZGlvVm9sdW1lVXAgKEF1ZGlvVm9sdW1lVXApIC0+IGxpbnV4OjExNSAoS0VZX1ZPTFVNRVVQKSAtPiBhdHNldDE6NTczOTIgKi9cbiAgXCJCYWNrcXVvdGVcIjogMHgyOSwgLyogaHRtbDpCYWNrcXVvdGUgKEJhY2txdW90ZSkgLT4gbGludXg6NDEgKEtFWV9HUkFWRSkgLT4gYXRzZXQxOjQxICovXG4gIFwiQmFja3NsYXNoXCI6IDB4MmIsIC8qIGh0bWw6QmFja3NsYXNoIChCYWNrc2xhc2gpIC0+IGxpbnV4OjQzIChLRVlfQkFDS1NMQVNIKSAtPiBhdHNldDE6NDMgKi9cbiAgXCJCYWNrc3BhY2VcIjogMHhlLCAvKiBodG1sOkJhY2tzcGFjZSAoQmFja3NwYWNlKSAtPiBsaW51eDoxNCAoS0VZX0JBQ0tTUEFDRSkgLT4gYXRzZXQxOjE0ICovXG4gIFwiQnJhY2tldExlZnRcIjogMHgxYSwgLyogaHRtbDpCcmFja2V0TGVmdCAoQnJhY2tldExlZnQpIC0+IGxpbnV4OjI2IChLRVlfTEVGVEJSQUNFKSAtPiBhdHNldDE6MjYgKi9cbiAgXCJCcmFja2V0UmlnaHRcIjogMHgxYiwgLyogaHRtbDpCcmFja2V0UmlnaHQgKEJyYWNrZXRSaWdodCkgLT4gbGludXg6MjcgKEtFWV9SSUdIVEJSQUNFKSAtPiBhdHNldDE6MjcgKi9cbiAgXCJCcm93c2VyQmFja1wiOiAweGUwNmEsIC8qIGh0bWw6QnJvd3NlckJhY2sgKEJyb3dzZXJCYWNrKSAtPiBsaW51eDoxNTggKEtFWV9CQUNLKSAtPiBhdHNldDE6NTc0NTAgKi9cbiAgXCJCcm93c2VyRmF2b3JpdGVzXCI6IDB4ZTA2NiwgLyogaHRtbDpCcm93c2VyRmF2b3JpdGVzIChCcm93c2VyRmF2b3JpdGVzKSAtPiBsaW51eDoxNTYgKEtFWV9CT09LTUFSS1MpIC0+IGF0c2V0MTo1NzQ0NiAqL1xuICBcIkJyb3dzZXJGb3J3YXJkXCI6IDB4ZTA2OSwgLyogaHRtbDpCcm93c2VyRm9yd2FyZCAoQnJvd3NlckZvcndhcmQpIC0+IGxpbnV4OjE1OSAoS0VZX0ZPUldBUkQpIC0+IGF0c2V0MTo1NzQ0OSAqL1xuICBcIkJyb3dzZXJIb21lXCI6IDB4ZTAzMiwgLyogaHRtbDpCcm93c2VySG9tZSAoQnJvd3NlckhvbWUpIC0+IGxpbnV4OjE3MiAoS0VZX0hPTUVQQUdFKSAtPiBhdHNldDE6NTczOTQgKi9cbiAgXCJCcm93c2VyUmVmcmVzaFwiOiAweGUwNjcsIC8qIGh0bWw6QnJvd3NlclJlZnJlc2ggKEJyb3dzZXJSZWZyZXNoKSAtPiBsaW51eDoxNzMgKEtFWV9SRUZSRVNIKSAtPiBhdHNldDE6NTc0NDcgKi9cbiAgXCJCcm93c2VyU2VhcmNoXCI6IDB4ZTA2NSwgLyogaHRtbDpCcm93c2VyU2VhcmNoIChCcm93c2VyU2VhcmNoKSAtPiBsaW51eDoyMTcgKEtFWV9TRUFSQ0gpIC0+IGF0c2V0MTo1NzQ0NSAqL1xuICBcIkJyb3dzZXJTdG9wXCI6IDB4ZTA2OCwgLyogaHRtbDpCcm93c2VyU3RvcCAoQnJvd3NlclN0b3ApIC0+IGxpbnV4OjEyOCAoS0VZX1NUT1ApIC0+IGF0c2V0MTo1NzQ0OCAqL1xuICBcIkNhcHNMb2NrXCI6IDB4M2EsIC8qIGh0bWw6Q2Fwc0xvY2sgKENhcHNMb2NrKSAtPiBsaW51eDo1OCAoS0VZX0NBUFNMT0NLKSAtPiBhdHNldDE6NTggKi9cbiAgXCJDb21tYVwiOiAweDMzLCAvKiBodG1sOkNvbW1hIChDb21tYSkgLT4gbGludXg6NTEgKEtFWV9DT01NQSkgLT4gYXRzZXQxOjUxICovXG4gIFwiQ29udGV4dE1lbnVcIjogMHhlMDVkLCAvKiBodG1sOkNvbnRleHRNZW51IChDb250ZXh0TWVudSkgLT4gbGludXg6MTI3IChLRVlfQ09NUE9TRSkgLT4gYXRzZXQxOjU3NDM3ICovXG4gIFwiQ29udHJvbExlZnRcIjogMHgxZCwgLyogaHRtbDpDb250cm9sTGVmdCAoQ29udHJvbExlZnQpIC0+IGxpbnV4OjI5IChLRVlfTEVGVENUUkwpIC0+IGF0c2V0MToyOSAqL1xuICBcIkNvbnRyb2xSaWdodFwiOiAweGUwMWQsIC8qIGh0bWw6Q29udHJvbFJpZ2h0IChDb250cm9sUmlnaHQpIC0+IGxpbnV4Ojk3IChLRVlfUklHSFRDVFJMKSAtPiBhdHNldDE6NTczNzMgKi9cbiAgXCJDb252ZXJ0XCI6IDB4NzksIC8qIGh0bWw6Q29udmVydCAoQ29udmVydCkgLT4gbGludXg6OTIgKEtFWV9IRU5LQU4pIC0+IGF0c2V0MToxMjEgKi9cbiAgXCJDb3B5XCI6IDB4ZTA3OCwgLyogaHRtbDpDb3B5IChDb3B5KSAtPiBsaW51eDoxMzMgKEtFWV9DT1BZKSAtPiBhdHNldDE6NTc0NjQgKi9cbiAgXCJDdXRcIjogMHhlMDNjLCAvKiBodG1sOkN1dCAoQ3V0KSAtPiBsaW51eDoxMzcgKEtFWV9DVVQpIC0+IGF0c2V0MTo1NzQwNCAqL1xuICBcIkRlbGV0ZVwiOiAweGUwNTMsIC8qIGh0bWw6RGVsZXRlIChEZWxldGUpIC0+IGxpbnV4OjExMSAoS0VZX0RFTEVURSkgLT4gYXRzZXQxOjU3NDI3ICovXG4gIFwiRGlnaXQwXCI6IDB4YiwgLyogaHRtbDpEaWdpdDAgKERpZ2l0MCkgLT4gbGludXg6MTEgKEtFWV8wKSAtPiBhdHNldDE6MTEgKi9cbiAgXCJEaWdpdDFcIjogMHgyLCAvKiBodG1sOkRpZ2l0MSAoRGlnaXQxKSAtPiBsaW51eDoyIChLRVlfMSkgLT4gYXRzZXQxOjIgKi9cbiAgXCJEaWdpdDJcIjogMHgzLCAvKiBodG1sOkRpZ2l0MiAoRGlnaXQyKSAtPiBsaW51eDozIChLRVlfMikgLT4gYXRzZXQxOjMgKi9cbiAgXCJEaWdpdDNcIjogMHg0LCAvKiBodG1sOkRpZ2l0MyAoRGlnaXQzKSAtPiBsaW51eDo0IChLRVlfMykgLT4gYXRzZXQxOjQgKi9cbiAgXCJEaWdpdDRcIjogMHg1LCAvKiBodG1sOkRpZ2l0NCAoRGlnaXQ0KSAtPiBsaW51eDo1IChLRVlfNCkgLT4gYXRzZXQxOjUgKi9cbiAgXCJEaWdpdDVcIjogMHg2LCAvKiBodG1sOkRpZ2l0NSAoRGlnaXQ1KSAtPiBsaW51eDo2IChLRVlfNSkgLT4gYXRzZXQxOjYgKi9cbiAgXCJEaWdpdDZcIjogMHg3LCAvKiBodG1sOkRpZ2l0NiAoRGlnaXQ2KSAtPiBsaW51eDo3IChLRVlfNikgLT4gYXRzZXQxOjcgKi9cbiAgXCJEaWdpdDdcIjogMHg4LCAvKiBodG1sOkRpZ2l0NyAoRGlnaXQ3KSAtPiBsaW51eDo4IChLRVlfNykgLT4gYXRzZXQxOjggKi9cbiAgXCJEaWdpdDhcIjogMHg5LCAvKiBodG1sOkRpZ2l0OCAoRGlnaXQ4KSAtPiBsaW51eDo5IChLRVlfOCkgLT4gYXRzZXQxOjkgKi9cbiAgXCJEaWdpdDlcIjogMHhhLCAvKiBodG1sOkRpZ2l0OSAoRGlnaXQ5KSAtPiBsaW51eDoxMCAoS0VZXzkpIC0+IGF0c2V0MToxMCAqL1xuICBcIkVqZWN0XCI6IDB4ZTA3ZCwgLyogaHRtbDpFamVjdCAoRWplY3QpIC0+IGxpbnV4OjE2MiAoS0VZX0VKRUNUQ0xPU0VDRCkgLT4gYXRzZXQxOjU3NDY5ICovXG4gIFwiRW5kXCI6IDB4ZTA0ZiwgLyogaHRtbDpFbmQgKEVuZCkgLT4gbGludXg6MTA3IChLRVlfRU5EKSAtPiBhdHNldDE6NTc0MjMgKi9cbiAgXCJFbnRlclwiOiAweDFjLCAvKiBodG1sOkVudGVyIChFbnRlcikgLT4gbGludXg6MjggKEtFWV9FTlRFUikgLT4gYXRzZXQxOjI4ICovXG4gIFwiRXF1YWxcIjogMHhkLCAvKiBodG1sOkVxdWFsIChFcXVhbCkgLT4gbGludXg6MTMgKEtFWV9FUVVBTCkgLT4gYXRzZXQxOjEzICovXG4gIFwiRXNjYXBlXCI6IDB4MSwgLyogaHRtbDpFc2NhcGUgKEVzY2FwZSkgLT4gbGludXg6MSAoS0VZX0VTQykgLT4gYXRzZXQxOjEgKi9cbiAgXCJGMVwiOiAweDNiLCAvKiBodG1sOkYxIChGMSkgLT4gbGludXg6NTkgKEtFWV9GMSkgLT4gYXRzZXQxOjU5ICovXG4gIFwiRjEwXCI6IDB4NDQsIC8qIGh0bWw6RjEwIChGMTApIC0+IGxpbnV4OjY4IChLRVlfRjEwKSAtPiBhdHNldDE6NjggKi9cbiAgXCJGMTFcIjogMHg1NywgLyogaHRtbDpGMTEgKEYxMSkgLT4gbGludXg6ODcgKEtFWV9GMTEpIC0+IGF0c2V0MTo4NyAqL1xuICBcIkYxMlwiOiAweDU4LCAvKiBodG1sOkYxMiAoRjEyKSAtPiBsaW51eDo4OCAoS0VZX0YxMikgLT4gYXRzZXQxOjg4ICovXG4gIFwiRjEzXCI6IDB4NWQsIC8qIGh0bWw6RjEzIChGMTMpIC0+IGxpbnV4OjE4MyAoS0VZX0YxMykgLT4gYXRzZXQxOjkzICovXG4gIFwiRjE0XCI6IDB4NWUsIC8qIGh0bWw6RjE0IChGMTQpIC0+IGxpbnV4OjE4NCAoS0VZX0YxNCkgLT4gYXRzZXQxOjk0ICovXG4gIFwiRjE1XCI6IDB4NWYsIC8qIGh0bWw6RjE1IChGMTUpIC0+IGxpbnV4OjE4NSAoS0VZX0YxNSkgLT4gYXRzZXQxOjk1ICovXG4gIFwiRjE2XCI6IDB4NTUsIC8qIGh0bWw6RjE2IChGMTYpIC0+IGxpbnV4OjE4NiAoS0VZX0YxNikgLT4gYXRzZXQxOjg1ICovXG4gIFwiRjE3XCI6IDB4ZTAwMywgLyogaHRtbDpGMTcgKEYxNykgLT4gbGludXg6MTg3IChLRVlfRjE3KSAtPiBhdHNldDE6NTczNDcgKi9cbiAgXCJGMThcIjogMHhlMDc3LCAvKiBodG1sOkYxOCAoRjE4KSAtPiBsaW51eDoxODggKEtFWV9GMTgpIC0+IGF0c2V0MTo1NzQ2MyAqL1xuICBcIkYxOVwiOiAweGUwMDQsIC8qIGh0bWw6RjE5IChGMTkpIC0+IGxpbnV4OjE4OSAoS0VZX0YxOSkgLT4gYXRzZXQxOjU3MzQ4ICovXG4gIFwiRjJcIjogMHgzYywgLyogaHRtbDpGMiAoRjIpIC0+IGxpbnV4OjYwIChLRVlfRjIpIC0+IGF0c2V0MTo2MCAqL1xuICBcIkYyMFwiOiAweDVhLCAvKiBodG1sOkYyMCAoRjIwKSAtPiBsaW51eDoxOTAgKEtFWV9GMjApIC0+IGF0c2V0MTo5MCAqL1xuICBcIkYyMVwiOiAweDc0LCAvKiBodG1sOkYyMSAoRjIxKSAtPiBsaW51eDoxOTEgKEtFWV9GMjEpIC0+IGF0c2V0MToxMTYgKi9cbiAgXCJGMjJcIjogMHhlMDc5LCAvKiBodG1sOkYyMiAoRjIyKSAtPiBsaW51eDoxOTIgKEtFWV9GMjIpIC0+IGF0c2V0MTo1NzQ2NSAqL1xuICBcIkYyM1wiOiAweDZkLCAvKiBodG1sOkYyMyAoRjIzKSAtPiBsaW51eDoxOTMgKEtFWV9GMjMpIC0+IGF0c2V0MToxMDkgKi9cbiAgXCJGMjRcIjogMHg2ZiwgLyogaHRtbDpGMjQgKEYyNCkgLT4gbGludXg6MTk0IChLRVlfRjI0KSAtPiBhdHNldDE6MTExICovXG4gIFwiRjNcIjogMHgzZCwgLyogaHRtbDpGMyAoRjMpIC0+IGxpbnV4OjYxIChLRVlfRjMpIC0+IGF0c2V0MTo2MSAqL1xuICBcIkY0XCI6IDB4M2UsIC8qIGh0bWw6RjQgKEY0KSAtPiBsaW51eDo2MiAoS0VZX0Y0KSAtPiBhdHNldDE6NjIgKi9cbiAgXCJGNVwiOiAweDNmLCAvKiBodG1sOkY1IChGNSkgLT4gbGludXg6NjMgKEtFWV9GNSkgLT4gYXRzZXQxOjYzICovXG4gIFwiRjZcIjogMHg0MCwgLyogaHRtbDpGNiAoRjYpIC0+IGxpbnV4OjY0IChLRVlfRjYpIC0+IGF0c2V0MTo2NCAqL1xuICBcIkY3XCI6IDB4NDEsIC8qIGh0bWw6RjcgKEY3KSAtPiBsaW51eDo2NSAoS0VZX0Y3KSAtPiBhdHNldDE6NjUgKi9cbiAgXCJGOFwiOiAweDQyLCAvKiBodG1sOkY4IChGOCkgLT4gbGludXg6NjYgKEtFWV9GOCkgLT4gYXRzZXQxOjY2ICovXG4gIFwiRjlcIjogMHg0MywgLyogaHRtbDpGOSAoRjkpIC0+IGxpbnV4OjY3IChLRVlfRjkpIC0+IGF0c2V0MTo2NyAqL1xuICBcIkZpbmRcIjogMHhlMDQxLCAvKiBodG1sOkZpbmQgKEZpbmQpIC0+IGxpbnV4OjEzNiAoS0VZX0ZJTkQpIC0+IGF0c2V0MTo1NzQwOSAqL1xuICBcIkhlbHBcIjogMHhlMDc1LCAvKiBodG1sOkhlbHAgKEhlbHApIC0+IGxpbnV4OjEzOCAoS0VZX0hFTFApIC0+IGF0c2V0MTo1NzQ2MSAqL1xuICBcIkhpcmFnYW5hXCI6IDB4NzcsIC8qIGh0bWw6SGlyYWdhbmEgKExhbmc0KSAtPiBsaW51eDo5MSAoS0VZX0hJUkFHQU5BKSAtPiBhdHNldDE6MTE5ICovXG4gIFwiSG9tZVwiOiAweGUwNDcsIC8qIGh0bWw6SG9tZSAoSG9tZSkgLT4gbGludXg6MTAyIChLRVlfSE9NRSkgLT4gYXRzZXQxOjU3NDE1ICovXG4gIFwiSW5zZXJ0XCI6IDB4ZTA1MiwgLyogaHRtbDpJbnNlcnQgKEluc2VydCkgLT4gbGludXg6MTEwIChLRVlfSU5TRVJUKSAtPiBhdHNldDE6NTc0MjYgKi9cbiAgXCJJbnRsQmFja3NsYXNoXCI6IDB4NTYsIC8qIGh0bWw6SW50bEJhY2tzbGFzaCAoSW50bEJhY2tzbGFzaCkgLT4gbGludXg6ODYgKEtFWV8xMDJORCkgLT4gYXRzZXQxOjg2ICovXG4gIFwiSW50bFJvXCI6IDB4NzMsIC8qIGh0bWw6SW50bFJvIChJbnRsUm8pIC0+IGxpbnV4Ojg5IChLRVlfUk8pIC0+IGF0c2V0MToxMTUgKi9cbiAgXCJJbnRsWWVuXCI6IDB4N2QsIC8qIGh0bWw6SW50bFllbiAoSW50bFllbikgLT4gbGludXg6MTI0IChLRVlfWUVOKSAtPiBhdHNldDE6MTI1ICovXG4gIFwiS2FuYU1vZGVcIjogMHg3MCwgLyogaHRtbDpLYW5hTW9kZSAoS2FuYU1vZGUpIC0+IGxpbnV4OjkzIChLRVlfS0FUQUtBTkFISVJBR0FOQSkgLT4gYXRzZXQxOjExMiAqL1xuICBcIkthdGFrYW5hXCI6IDB4NzgsIC8qIGh0bWw6S2F0YWthbmEgKExhbmczKSAtPiBsaW51eDo5MCAoS0VZX0tBVEFLQU5BKSAtPiBhdHNldDE6MTIwICovXG4gIFwiS2V5QVwiOiAweDFlLCAvKiBodG1sOktleUEgKEtleUEpIC0+IGxpbnV4OjMwIChLRVlfQSkgLT4gYXRzZXQxOjMwICovXG4gIFwiS2V5QlwiOiAweDMwLCAvKiBodG1sOktleUIgKEtleUIpIC0+IGxpbnV4OjQ4IChLRVlfQikgLT4gYXRzZXQxOjQ4ICovXG4gIFwiS2V5Q1wiOiAweDJlLCAvKiBodG1sOktleUMgKEtleUMpIC0+IGxpbnV4OjQ2IChLRVlfQykgLT4gYXRzZXQxOjQ2ICovXG4gIFwiS2V5RFwiOiAweDIwLCAvKiBodG1sOktleUQgKEtleUQpIC0+IGxpbnV4OjMyIChLRVlfRCkgLT4gYXRzZXQxOjMyICovXG4gIFwiS2V5RVwiOiAweDEyLCAvKiBodG1sOktleUUgKEtleUUpIC0+IGxpbnV4OjE4IChLRVlfRSkgLT4gYXRzZXQxOjE4ICovXG4gIFwiS2V5RlwiOiAweDIxLCAvKiBodG1sOktleUYgKEtleUYpIC0+IGxpbnV4OjMzIChLRVlfRikgLT4gYXRzZXQxOjMzICovXG4gIFwiS2V5R1wiOiAweDIyLCAvKiBodG1sOktleUcgKEtleUcpIC0+IGxpbnV4OjM0IChLRVlfRykgLT4gYXRzZXQxOjM0ICovXG4gIFwiS2V5SFwiOiAweDIzLCAvKiBodG1sOktleUggKEtleUgpIC0+IGxpbnV4OjM1IChLRVlfSCkgLT4gYXRzZXQxOjM1ICovXG4gIFwiS2V5SVwiOiAweDE3LCAvKiBodG1sOktleUkgKEtleUkpIC0+IGxpbnV4OjIzIChLRVlfSSkgLT4gYXRzZXQxOjIzICovXG4gIFwiS2V5SlwiOiAweDI0LCAvKiBodG1sOktleUogKEtleUopIC0+IGxpbnV4OjM2IChLRVlfSikgLT4gYXRzZXQxOjM2ICovXG4gIFwiS2V5S1wiOiAweDI1LCAvKiBodG1sOktleUsgKEtleUspIC0+IGxpbnV4OjM3IChLRVlfSykgLT4gYXRzZXQxOjM3ICovXG4gIFwiS2V5TFwiOiAweDI2LCAvKiBodG1sOktleUwgKEtleUwpIC0+IGxpbnV4OjM4IChLRVlfTCkgLT4gYXRzZXQxOjM4ICovXG4gIFwiS2V5TVwiOiAweDMyLCAvKiBodG1sOktleU0gKEtleU0pIC0+IGxpbnV4OjUwIChLRVlfTSkgLT4gYXRzZXQxOjUwICovXG4gIFwiS2V5TlwiOiAweDMxLCAvKiBodG1sOktleU4gKEtleU4pIC0+IGxpbnV4OjQ5IChLRVlfTikgLT4gYXRzZXQxOjQ5ICovXG4gIFwiS2V5T1wiOiAweDE4LCAvKiBodG1sOktleU8gKEtleU8pIC0+IGxpbnV4OjI0IChLRVlfTykgLT4gYXRzZXQxOjI0ICovXG4gIFwiS2V5UFwiOiAweDE5LCAvKiBodG1sOktleVAgKEtleVApIC0+IGxpbnV4OjI1IChLRVlfUCkgLT4gYXRzZXQxOjI1ICovXG4gIFwiS2V5UVwiOiAweDEwLCAvKiBodG1sOktleVEgKEtleVEpIC0+IGxpbnV4OjE2IChLRVlfUSkgLT4gYXRzZXQxOjE2ICovXG4gIFwiS2V5UlwiOiAweDEzLCAvKiBodG1sOktleVIgKEtleVIpIC0+IGxpbnV4OjE5IChLRVlfUikgLT4gYXRzZXQxOjE5ICovXG4gIFwiS2V5U1wiOiAweDFmLCAvKiBodG1sOktleVMgKEtleVMpIC0+IGxpbnV4OjMxIChLRVlfUykgLT4gYXRzZXQxOjMxICovXG4gIFwiS2V5VFwiOiAweDE0LCAvKiBodG1sOktleVQgKEtleVQpIC0+IGxpbnV4OjIwIChLRVlfVCkgLT4gYXRzZXQxOjIwICovXG4gIFwiS2V5VVwiOiAweDE2LCAvKiBodG1sOktleVUgKEtleVUpIC0+IGxpbnV4OjIyIChLRVlfVSkgLT4gYXRzZXQxOjIyICovXG4gIFwiS2V5VlwiOiAweDJmLCAvKiBodG1sOktleVYgKEtleVYpIC0+IGxpbnV4OjQ3IChLRVlfVikgLT4gYXRzZXQxOjQ3ICovXG4gIFwiS2V5V1wiOiAweDExLCAvKiBodG1sOktleVcgKEtleVcpIC0+IGxpbnV4OjE3IChLRVlfVykgLT4gYXRzZXQxOjE3ICovXG4gIFwiS2V5WFwiOiAweDJkLCAvKiBodG1sOktleVggKEtleVgpIC0+IGxpbnV4OjQ1IChLRVlfWCkgLT4gYXRzZXQxOjQ1ICovXG4gIFwiS2V5WVwiOiAweDE1LCAvKiBodG1sOktleVkgKEtleVkpIC0+IGxpbnV4OjIxIChLRVlfWSkgLT4gYXRzZXQxOjIxICovXG4gIFwiS2V5WlwiOiAweDJjLCAvKiBodG1sOktleVogKEtleVopIC0+IGxpbnV4OjQ0IChLRVlfWikgLT4gYXRzZXQxOjQ0ICovXG4gIFwiTGFuZzNcIjogMHg3OCwgLyogaHRtbDpMYW5nMyAoTGFuZzMpIC0+IGxpbnV4OjkwIChLRVlfS0FUQUtBTkEpIC0+IGF0c2V0MToxMjAgKi9cbiAgXCJMYW5nNFwiOiAweDc3LCAvKiBodG1sOkxhbmc0IChMYW5nNCkgLT4gbGludXg6OTEgKEtFWV9ISVJBR0FOQSkgLT4gYXRzZXQxOjExOSAqL1xuICBcIkxhbmc1XCI6IDB4NzYsIC8qIGh0bWw6TGFuZzUgKExhbmc1KSAtPiBsaW51eDo4NSAoS0VZX1pFTktBS1VIQU5LQUtVKSAtPiBhdHNldDE6MTE4ICovXG4gIFwiTGF1bmNoQXBwMVwiOiAweGUwNmIsIC8qIGh0bWw6TGF1bmNoQXBwMSAoTGF1bmNoQXBwMSkgLT4gbGludXg6MTU3IChLRVlfQ09NUFVURVIpIC0+IGF0c2V0MTo1NzQ1MSAqL1xuICBcIkxhdW5jaEFwcDJcIjogMHhlMDIxLCAvKiBodG1sOkxhdW5jaEFwcDIgKExhdW5jaEFwcDIpIC0+IGxpbnV4OjE0MCAoS0VZX0NBTEMpIC0+IGF0c2V0MTo1NzM3NyAqL1xuICBcIkxhdW5jaE1haWxcIjogMHhlMDZjLCAvKiBodG1sOkxhdW5jaE1haWwgKExhdW5jaE1haWwpIC0+IGxpbnV4OjE1NSAoS0VZX01BSUwpIC0+IGF0c2V0MTo1NzQ1MiAqL1xuICBcIk1lZGlhUGxheVBhdXNlXCI6IDB4ZTAyMiwgLyogaHRtbDpNZWRpYVBsYXlQYXVzZSAoTWVkaWFQbGF5UGF1c2UpIC0+IGxpbnV4OjE2NCAoS0VZX1BMQVlQQVVTRSkgLT4gYXRzZXQxOjU3Mzc4ICovXG4gIFwiTWVkaWFTZWxlY3RcIjogMHhlMDZkLCAvKiBodG1sOk1lZGlhU2VsZWN0IChNZWRpYVNlbGVjdCkgLT4gbGludXg6MjI2IChLRVlfTUVESUEpIC0+IGF0c2V0MTo1NzQ1MyAqL1xuICBcIk1lZGlhU3RvcFwiOiAweGUwMjQsIC8qIGh0bWw6TWVkaWFTdG9wIChNZWRpYVN0b3ApIC0+IGxpbnV4OjE2NiAoS0VZX1NUT1BDRCkgLT4gYXRzZXQxOjU3MzgwICovXG4gIFwiTWVkaWFUcmFja05leHRcIjogMHhlMDE5LCAvKiBodG1sOk1lZGlhVHJhY2tOZXh0IChNZWRpYVRyYWNrTmV4dCkgLT4gbGludXg6MTYzIChLRVlfTkVYVFNPTkcpIC0+IGF0c2V0MTo1NzM2OSAqL1xuICBcIk1lZGlhVHJhY2tQcmV2aW91c1wiOiAweGUwMTAsIC8qIGh0bWw6TWVkaWFUcmFja1ByZXZpb3VzIChNZWRpYVRyYWNrUHJldmlvdXMpIC0+IGxpbnV4OjE2NSAoS0VZX1BSRVZJT1VTU09ORykgLT4gYXRzZXQxOjU3MzYwICovXG4gIFwiTWV0YUxlZnRcIjogMHhlMDViLCAvKiBodG1sOk1ldGFMZWZ0IChNZXRhTGVmdCkgLT4gbGludXg6MTI1IChLRVlfTEVGVE1FVEEpIC0+IGF0c2V0MTo1NzQzNSAqL1xuICBcIk1ldGFSaWdodFwiOiAweGUwNWMsIC8qIGh0bWw6TWV0YVJpZ2h0IChNZXRhUmlnaHQpIC0+IGxpbnV4OjEyNiAoS0VZX1JJR0hUTUVUQSkgLT4gYXRzZXQxOjU3NDM2ICovXG4gIFwiTWludXNcIjogMHhjLCAvKiBodG1sOk1pbnVzIChNaW51cykgLT4gbGludXg6MTIgKEtFWV9NSU5VUykgLT4gYXRzZXQxOjEyICovXG4gIFwiTm9uQ29udmVydFwiOiAweDdiLCAvKiBodG1sOk5vbkNvbnZlcnQgKE5vbkNvbnZlcnQpIC0+IGxpbnV4Ojk0IChLRVlfTVVIRU5LQU4pIC0+IGF0c2V0MToxMjMgKi9cbiAgXCJOdW1Mb2NrXCI6IDB4NDUsIC8qIGh0bWw6TnVtTG9jayAoTnVtTG9jaykgLT4gbGludXg6NjkgKEtFWV9OVU1MT0NLKSAtPiBhdHNldDE6NjkgKi9cbiAgXCJOdW1wYWQwXCI6IDB4NTIsIC8qIGh0bWw6TnVtcGFkMCAoTnVtcGFkMCkgLT4gbGludXg6ODIgKEtFWV9LUDApIC0+IGF0c2V0MTo4MiAqL1xuICBcIk51bXBhZDFcIjogMHg0ZiwgLyogaHRtbDpOdW1wYWQxIChOdW1wYWQxKSAtPiBsaW51eDo3OSAoS0VZX0tQMSkgLT4gYXRzZXQxOjc5ICovXG4gIFwiTnVtcGFkMlwiOiAweDUwLCAvKiBodG1sOk51bXBhZDIgKE51bXBhZDIpIC0+IGxpbnV4OjgwIChLRVlfS1AyKSAtPiBhdHNldDE6ODAgKi9cbiAgXCJOdW1wYWQzXCI6IDB4NTEsIC8qIGh0bWw6TnVtcGFkMyAoTnVtcGFkMykgLT4gbGludXg6ODEgKEtFWV9LUDMpIC0+IGF0c2V0MTo4MSAqL1xuICBcIk51bXBhZDRcIjogMHg0YiwgLyogaHRtbDpOdW1wYWQ0IChOdW1wYWQ0KSAtPiBsaW51eDo3NSAoS0VZX0tQNCkgLT4gYXRzZXQxOjc1ICovXG4gIFwiTnVtcGFkNVwiOiAweDRjLCAvKiBodG1sOk51bXBhZDUgKE51bXBhZDUpIC0+IGxpbnV4Ojc2IChLRVlfS1A1KSAtPiBhdHNldDE6NzYgKi9cbiAgXCJOdW1wYWQ2XCI6IDB4NGQsIC8qIGh0bWw6TnVtcGFkNiAoTnVtcGFkNikgLT4gbGludXg6NzcgKEtFWV9LUDYpIC0+IGF0c2V0MTo3NyAqL1xuICBcIk51bXBhZDdcIjogMHg0NywgLyogaHRtbDpOdW1wYWQ3IChOdW1wYWQ3KSAtPiBsaW51eDo3MSAoS0VZX0tQNykgLT4gYXRzZXQxOjcxICovXG4gIFwiTnVtcGFkOFwiOiAweDQ4LCAvKiBodG1sOk51bXBhZDggKE51bXBhZDgpIC0+IGxpbnV4OjcyIChLRVlfS1A4KSAtPiBhdHNldDE6NzIgKi9cbiAgXCJOdW1wYWQ5XCI6IDB4NDksIC8qIGh0bWw6TnVtcGFkOSAoTnVtcGFkOSkgLT4gbGludXg6NzMgKEtFWV9LUDkpIC0+IGF0c2V0MTo3MyAqL1xuICBcIk51bXBhZEFkZFwiOiAweDRlLCAvKiBodG1sOk51bXBhZEFkZCAoTnVtcGFkQWRkKSAtPiBsaW51eDo3OCAoS0VZX0tQUExVUykgLT4gYXRzZXQxOjc4ICovXG4gIFwiTnVtcGFkQ29tbWFcIjogMHg3ZSwgLyogaHRtbDpOdW1wYWRDb21tYSAoTnVtcGFkQ29tbWEpIC0+IGxpbnV4OjEyMSAoS0VZX0tQQ09NTUEpIC0+IGF0c2V0MToxMjYgKi9cbiAgXCJOdW1wYWREZWNpbWFsXCI6IDB4NTMsIC8qIGh0bWw6TnVtcGFkRGVjaW1hbCAoTnVtcGFkRGVjaW1hbCkgLT4gbGludXg6ODMgKEtFWV9LUERPVCkgLT4gYXRzZXQxOjgzICovXG4gIFwiTnVtcGFkRGl2aWRlXCI6IDB4ZTAzNSwgLyogaHRtbDpOdW1wYWREaXZpZGUgKE51bXBhZERpdmlkZSkgLT4gbGludXg6OTggKEtFWV9LUFNMQVNIKSAtPiBhdHNldDE6NTczOTcgKi9cbiAgXCJOdW1wYWRFbnRlclwiOiAweGUwMWMsIC8qIGh0bWw6TnVtcGFkRW50ZXIgKE51bXBhZEVudGVyKSAtPiBsaW51eDo5NiAoS0VZX0tQRU5URVIpIC0+IGF0c2V0MTo1NzM3MiAqL1xuICBcIk51bXBhZEVxdWFsXCI6IDB4NTksIC8qIGh0bWw6TnVtcGFkRXF1YWwgKE51bXBhZEVxdWFsKSAtPiBsaW51eDoxMTcgKEtFWV9LUEVRVUFMKSAtPiBhdHNldDE6ODkgKi9cbiAgXCJOdW1wYWRNdWx0aXBseVwiOiAweDM3LCAvKiBodG1sOk51bXBhZE11bHRpcGx5IChOdW1wYWRNdWx0aXBseSkgLT4gbGludXg6NTUgKEtFWV9LUEFTVEVSSVNLKSAtPiBhdHNldDE6NTUgKi9cbiAgXCJOdW1wYWRQYXJlbkxlZnRcIjogMHhlMDc2LCAvKiBodG1sOk51bXBhZFBhcmVuTGVmdCAoTnVtcGFkUGFyZW5MZWZ0KSAtPiBsaW51eDoxNzkgKEtFWV9LUExFRlRQQVJFTikgLT4gYXRzZXQxOjU3NDYyICovXG4gIFwiTnVtcGFkUGFyZW5SaWdodFwiOiAweGUwN2IsIC8qIGh0bWw6TnVtcGFkUGFyZW5SaWdodCAoTnVtcGFkUGFyZW5SaWdodCkgLT4gbGludXg6MTgwIChLRVlfS1BSSUdIVFBBUkVOKSAtPiBhdHNldDE6NTc0NjcgKi9cbiAgXCJOdW1wYWRTdWJ0cmFjdFwiOiAweDRhLCAvKiBodG1sOk51bXBhZFN1YnRyYWN0IChOdW1wYWRTdWJ0cmFjdCkgLT4gbGludXg6NzQgKEtFWV9LUE1JTlVTKSAtPiBhdHNldDE6NzQgKi9cbiAgXCJPcGVuXCI6IDB4NjQsIC8qIGh0bWw6T3BlbiAoT3BlbikgLT4gbGludXg6MTM0IChLRVlfT1BFTikgLT4gYXRzZXQxOjEwMCAqL1xuICBcIlBhZ2VEb3duXCI6IDB4ZTA1MSwgLyogaHRtbDpQYWdlRG93biAoUGFnZURvd24pIC0+IGxpbnV4OjEwOSAoS0VZX1BBR0VET1dOKSAtPiBhdHNldDE6NTc0MjUgKi9cbiAgXCJQYWdlVXBcIjogMHhlMDQ5LCAvKiBodG1sOlBhZ2VVcCAoUGFnZVVwKSAtPiBsaW51eDoxMDQgKEtFWV9QQUdFVVApIC0+IGF0c2V0MTo1NzQxNyAqL1xuICBcIlBhc3RlXCI6IDB4NjUsIC8qIGh0bWw6UGFzdGUgKFBhc3RlKSAtPiBsaW51eDoxMzUgKEtFWV9QQVNURSkgLT4gYXRzZXQxOjEwMSAqL1xuICBcIlBhdXNlXCI6IDB4ZTA0NiwgLyogaHRtbDpQYXVzZSAoUGF1c2UpIC0+IGxpbnV4OjExOSAoS0VZX1BBVVNFKSAtPiBhdHNldDE6NTc0MTQgKi9cbiAgXCJQZXJpb2RcIjogMHgzNCwgLyogaHRtbDpQZXJpb2QgKFBlcmlvZCkgLT4gbGludXg6NTIgKEtFWV9ET1QpIC0+IGF0c2V0MTo1MiAqL1xuICBcIlBvd2VyXCI6IDB4ZTA1ZSwgLyogaHRtbDpQb3dlciAoUG93ZXIpIC0+IGxpbnV4OjExNiAoS0VZX1BPV0VSKSAtPiBhdHNldDE6NTc0MzggKi9cbiAgXCJQcmludFNjcmVlblwiOiAweDU0LCAvKiBodG1sOlByaW50U2NyZWVuIChQcmludFNjcmVlbikgLT4gbGludXg6OTkgKEtFWV9TWVNSUSkgLT4gYXRzZXQxOjg0ICovXG4gIFwiUHJvcHNcIjogMHhlMDA2LCAvKiBodG1sOlByb3BzIChQcm9wcykgLT4gbGludXg6MTMwIChLRVlfUFJPUFMpIC0+IGF0c2V0MTo1NzM1MCAqL1xuICBcIlF1b3RlXCI6IDB4MjgsIC8qIGh0bWw6UXVvdGUgKFF1b3RlKSAtPiBsaW51eDo0MCAoS0VZX0FQT1NUUk9QSEUpIC0+IGF0c2V0MTo0MCAqL1xuICBcIlNjcm9sbExvY2tcIjogMHg0NiwgLyogaHRtbDpTY3JvbGxMb2NrIChTY3JvbGxMb2NrKSAtPiBsaW51eDo3MCAoS0VZX1NDUk9MTExPQ0spIC0+IGF0c2V0MTo3MCAqL1xuICBcIlNlbWljb2xvblwiOiAweDI3LCAvKiBodG1sOlNlbWljb2xvbiAoU2VtaWNvbG9uKSAtPiBsaW51eDozOSAoS0VZX1NFTUlDT0xPTikgLT4gYXRzZXQxOjM5ICovXG4gIFwiU2hpZnRMZWZ0XCI6IDB4MmEsIC8qIGh0bWw6U2hpZnRMZWZ0IChTaGlmdExlZnQpIC0+IGxpbnV4OjQyIChLRVlfTEVGVFNISUZUKSAtPiBhdHNldDE6NDIgKi9cbiAgXCJTaGlmdFJpZ2h0XCI6IDB4MzYsIC8qIGh0bWw6U2hpZnRSaWdodCAoU2hpZnRSaWdodCkgLT4gbGludXg6NTQgKEtFWV9SSUdIVFNISUZUKSAtPiBhdHNldDE6NTQgKi9cbiAgXCJTbGFzaFwiOiAweDM1LCAvKiBodG1sOlNsYXNoIChTbGFzaCkgLT4gbGludXg6NTMgKEtFWV9TTEFTSCkgLT4gYXRzZXQxOjUzICovXG4gIFwiU2xlZXBcIjogMHhlMDVmLCAvKiBodG1sOlNsZWVwIChTbGVlcCkgLT4gbGludXg6MTQyIChLRVlfU0xFRVApIC0+IGF0c2V0MTo1NzQzOSAqL1xuICBcIlNwYWNlXCI6IDB4MzksIC8qIGh0bWw6U3BhY2UgKFNwYWNlKSAtPiBsaW51eDo1NyAoS0VZX1NQQUNFKSAtPiBhdHNldDE6NTcgKi9cbiAgXCJTdXNwZW5kXCI6IDB4ZTAyNSwgLyogaHRtbDpTdXNwZW5kIChTdXNwZW5kKSAtPiBsaW51eDoyMDUgKEtFWV9TVVNQRU5EKSAtPiBhdHNldDE6NTczODEgKi9cbiAgXCJUYWJcIjogMHhmLCAvKiBodG1sOlRhYiAoVGFiKSAtPiBsaW51eDoxNSAoS0VZX1RBQikgLT4gYXRzZXQxOjE1ICovXG4gIFwiVW5kb1wiOiAweGUwMDcsIC8qIGh0bWw6VW5kbyAoVW5kbykgLT4gbGludXg6MTMxIChLRVlfVU5ETykgLT4gYXRzZXQxOjU3MzUxICovXG4gIFwiV2FrZVVwXCI6IDB4ZTA2MywgLyogaHRtbDpXYWtlVXAgKFdha2VVcCkgLT4gbGludXg6MTQzIChLRVlfV0FLRVVQKSAtPiBhdHNldDE6NTc0NDMgKi9cbn07XG4iLCIvKlxuICogbm9WTkM6IEhUTUw1IFZOQyBjbGllbnRcbiAqIENvcHlyaWdodCAoQykgMjAxOCBUaGUgbm9WTkMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgTVBMIDIuMCAoc2VlIExJQ0VOU0UudHh0KVxuICpcbiAqIFNlZSBSRUFETUUubWQgZm9yIHVzYWdlIGFuZCBpbnRlZ3JhdGlvbiBpbnN0cnVjdGlvbnMuXG4gKlxuICovXG5cbmltcG9ydCAqIGFzIExvZyBmcm9tICcuL3V0aWwvbG9nZ2luZy5qcyc7XG5pbXBvcnQgeyBkZWNvZGVVVEY4IH0gZnJvbSAnLi91dGlsL3N0cmluZ3MuanMnO1xuaW1wb3J0IHsgZHJhZ1RocmVzaG9sZCB9IGZyb20gJy4vdXRpbC9icm93c2VyLmpzJztcbmltcG9ydCBFdmVudFRhcmdldE1peGluIGZyb20gJy4vdXRpbC9ldmVudHRhcmdldC5qcyc7XG5pbXBvcnQgRGlzcGxheSBmcm9tIFwiLi9kaXNwbGF5LmpzXCI7XG5pbXBvcnQgS2V5Ym9hcmQgZnJvbSBcIi4vaW5wdXQva2V5Ym9hcmQuanNcIjtcbmltcG9ydCBNb3VzZSBmcm9tIFwiLi9pbnB1dC9tb3VzZS5qc1wiO1xuaW1wb3J0IEN1cnNvciBmcm9tIFwiLi91dGlsL2N1cnNvci5qc1wiO1xuaW1wb3J0IFdlYnNvY2sgZnJvbSBcIi4vd2Vic29jay5qc1wiO1xuaW1wb3J0IERFUyBmcm9tIFwiLi9kZXMuanNcIjtcbmltcG9ydCBLZXlUYWJsZSBmcm9tIFwiLi9pbnB1dC9rZXlzeW0uanNcIjtcbmltcG9ydCBYdFNjYW5jb2RlIGZyb20gXCIuL2lucHV0L3h0c2NhbmNvZGVzLmpzXCI7XG5pbXBvcnQgeyBlbmNvZGluZ3MgfSBmcm9tIFwiLi9lbmNvZGluZ3MuanNcIjtcbmltcG9ydCBcIi4vdXRpbC9wb2x5ZmlsbC5qc1wiO1xuXG5pbXBvcnQgUmF3RGVjb2RlciBmcm9tIFwiLi9kZWNvZGVycy9yYXcuanNcIjtcbmltcG9ydCBDb3B5UmVjdERlY29kZXIgZnJvbSBcIi4vZGVjb2RlcnMvY29weXJlY3QuanNcIjtcbmltcG9ydCBSUkVEZWNvZGVyIGZyb20gXCIuL2RlY29kZXJzL3JyZS5qc1wiO1xuaW1wb3J0IEhleHRpbGVEZWNvZGVyIGZyb20gXCIuL2RlY29kZXJzL2hleHRpbGUuanNcIjtcbmltcG9ydCBUaWdodERlY29kZXIgZnJvbSBcIi4vZGVjb2RlcnMvdGlnaHQuanNcIjtcbmltcG9ydCBUaWdodFBOR0RlY29kZXIgZnJvbSBcIi4vZGVjb2RlcnMvdGlnaHRwbmcuanNcIjtcblxuLy8gSG93IG1hbnkgc2Vjb25kcyB0byB3YWl0IGZvciBhIGRpc2Nvbm5lY3QgdG8gZmluaXNoXG5jb25zdCBESVNDT05ORUNUX1RJTUVPVVQgPSAzO1xuY29uc3QgREVGQVVMVF9CQUNLR1JPVU5EID0gJ3JnYig0MCwgNDAsIDQwKSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFJGQiBleHRlbmRzIEV2ZW50VGFyZ2V0TWl4aW4ge1xuICAgIGNvbnN0cnVjdG9yKHRhcmdldCwgdXJsLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICghdGFyZ2V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHNwZWNpZnkgdGFyZ2V0XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNdXN0IHNwZWNpZnkgVVJMXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3VwZXIoKTtcblxuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG4gICAgICAgIHRoaXMuX3VybCA9IHVybDtcblxuICAgICAgICAvLyBDb25uZWN0aW9uIGRldGFpbHNcbiAgICAgICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgIHRoaXMuX3JmYl9jcmVkZW50aWFscyA9IG9wdGlvbnMuY3JlZGVudGlhbHMgfHwge307XG4gICAgICAgIHRoaXMuX3NoYXJlZCA9ICdzaGFyZWQnIGluIG9wdGlvbnMgPyAhIW9wdGlvbnMuc2hhcmVkIDogdHJ1ZTtcbiAgICAgICAgdGhpcy5fcmVwZWF0ZXJJRCA9IG9wdGlvbnMucmVwZWF0ZXJJRCB8fCAnJztcbiAgICAgICAgdGhpcy5fc2hvd0RvdEN1cnNvciA9IG9wdGlvbnMuc2hvd0RvdEN1cnNvciB8fCBmYWxzZTtcblxuICAgICAgICAvLyBJbnRlcm5hbCBzdGF0ZVxuICAgICAgICB0aGlzLl9yZmJfY29ubmVjdGlvbl9zdGF0ZSA9ICcnO1xuICAgICAgICB0aGlzLl9yZmJfaW5pdF9zdGF0ZSA9ICcnO1xuICAgICAgICB0aGlzLl9yZmJfYXV0aF9zY2hlbWUgPSAtMTtcbiAgICAgICAgdGhpcy5fcmZiX2NsZWFuX2Rpc2Nvbm5lY3QgPSB0cnVlO1xuXG4gICAgICAgIC8vIFNlcnZlciBjYXBhYmlsaXRpZXNcbiAgICAgICAgdGhpcy5fcmZiX3ZlcnNpb24gPSAwO1xuICAgICAgICB0aGlzLl9yZmJfbWF4X3ZlcnNpb24gPSAzLjg7XG4gICAgICAgIHRoaXMuX3JmYl90aWdodHZuYyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9yZmJfeHZwX3ZlciA9IDA7XG5cbiAgICAgICAgdGhpcy5fZmJfd2lkdGggPSAwO1xuICAgICAgICB0aGlzLl9mYl9oZWlnaHQgPSAwO1xuXG4gICAgICAgIHRoaXMuX2ZiX25hbWUgPSBcIlwiO1xuXG4gICAgICAgIHRoaXMuX2NhcGFiaWxpdGllcyA9IHsgcG93ZXI6IGZhbHNlIH07XG5cbiAgICAgICAgdGhpcy5fc3VwcG9ydHNGZW5jZSA9IGZhbHNlO1xuXG4gICAgICAgIHRoaXMuX3N1cHBvcnRzQ29udGludW91c1VwZGF0ZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fZW5hYmxlZENvbnRpbnVvdXNVcGRhdGVzID0gZmFsc2U7XG5cbiAgICAgICAgdGhpcy5fc3VwcG9ydHNTZXREZXNrdG9wU2l6ZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zY3JlZW5faWQgPSAwO1xuICAgICAgICB0aGlzLl9zY3JlZW5fZmxhZ3MgPSAwO1xuXG4gICAgICAgIHRoaXMuX3FlbXVFeHRLZXlFdmVudFN1cHBvcnRlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEludGVybmFsIG9iamVjdHNcbiAgICAgICAgdGhpcy5fc29jayA9IG51bGw7ICAgICAgICAgICAgICAvLyBXZWJzb2NrIG9iamVjdFxuICAgICAgICB0aGlzLl9kaXNwbGF5ID0gbnVsbDsgICAgICAgICAgIC8vIERpc3BsYXkgb2JqZWN0XG4gICAgICAgIHRoaXMuX2ZsdXNoaW5nID0gZmFsc2U7ICAgICAgICAgLy8gRGlzcGxheSBmbHVzaGluZyBzdGF0ZVxuICAgICAgICB0aGlzLl9rZXlib2FyZCA9IG51bGw7ICAgICAgICAgIC8vIEtleWJvYXJkIGlucHV0IGhhbmRsZXIgb2JqZWN0XG4gICAgICAgIHRoaXMuX21vdXNlID0gbnVsbDsgICAgICAgICAgICAgLy8gTW91c2UgaW5wdXQgaGFuZGxlciBvYmplY3RcblxuICAgICAgICAvLyBUaW1lcnNcbiAgICAgICAgdGhpcy5fZGlzY29ublRpbWVyID0gbnVsbDsgICAgICAvLyBkaXNjb25uZWN0aW9uIHRpbWVyXG4gICAgICAgIHRoaXMuX3Jlc2l6ZVRpbWVvdXQgPSBudWxsOyAgICAgLy8gcmVzaXplIHJhdGUgbGltaXRpbmdcblxuICAgICAgICAvLyBEZWNvZGVyIHN0YXRlc1xuICAgICAgICB0aGlzLl9kZWNvZGVycyA9IHt9O1xuXG4gICAgICAgIHRoaXMuX0ZCVSA9IHtcbiAgICAgICAgICAgIHJlY3RzOiAwLFxuICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgIHk6IDAsXG4gICAgICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgICAgIGVuY29kaW5nOiBudWxsLFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIE1vdXNlIHN0YXRlXG4gICAgICAgIHRoaXMuX21vdXNlX2J1dHRvbk1hc2sgPSAwO1xuICAgICAgICB0aGlzLl9tb3VzZV9hcnIgPSBbXTtcbiAgICAgICAgdGhpcy5fdmlld3BvcnREcmFnZ2luZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLl92aWV3cG9ydERyYWdQb3MgPSB7fTtcbiAgICAgICAgdGhpcy5fdmlld3BvcnRIYXNNb3ZlZCA9IGZhbHNlO1xuXG4gICAgICAgIC8vIEJvdW5kIGV2ZW50IGhhbmRsZXJzXG4gICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcnMgPSB7XG4gICAgICAgICAgICBmb2N1c0NhbnZhczogdGhpcy5fZm9jdXNDYW52YXMuYmluZCh0aGlzKSxcbiAgICAgICAgICAgIHdpbmRvd1Jlc2l6ZTogdGhpcy5fd2luZG93UmVzaXplLmJpbmQodGhpcyksXG4gICAgICAgIH07XG5cbiAgICAgICAgLy8gbWFpbiBzZXR1cFxuICAgICAgICBMb2cuRGVidWcoXCI+PiBSRkIuY29uc3RydWN0b3JcIik7XG5cbiAgICAgICAgLy8gQ3JlYXRlIERPTSBlbGVtZW50c1xuICAgICAgICB0aGlzLl9zY3JlZW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdGhpcy5fc2NyZWVuLnN0eWxlLmRpc3BsYXkgPSAnZmxleCc7XG4gICAgICAgIHRoaXMuX3NjcmVlbi5zdHlsZS53aWR0aCA9ICcxMDAlJztcbiAgICAgICAgdGhpcy5fc2NyZWVuLnN0eWxlLmhlaWdodCA9ICcxMDAlJztcbiAgICAgICAgdGhpcy5fc2NyZWVuLnN0eWxlLm92ZXJmbG93ID0gJ2F1dG8nO1xuICAgICAgICB0aGlzLl9zY3JlZW4uc3R5bGUuYmFja2dyb3VuZCA9IERFRkFVTFRfQkFDS0dST1VORDtcbiAgICAgICAgdGhpcy5fY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5tYXJnaW4gPSAnYXV0byc7XG4gICAgICAgIC8vIFNvbWUgYnJvd3NlcnMgYWRkIGFuIG91dGxpbmUgb24gZm9jdXNcbiAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLm91dGxpbmUgPSAnbm9uZSc7XG4gICAgICAgIC8vIElFIG1pc2NhbGN1bGF0ZXMgd2lkdGggd2l0aG91dCB0aGlzIDooXG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS5mbGV4U2hyaW5rID0gJzAnO1xuICAgICAgICB0aGlzLl9jYW52YXMud2lkdGggPSAwO1xuICAgICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5fY2FudmFzLnRhYkluZGV4ID0gLTE7XG4gICAgICAgIHRoaXMuX3NjcmVlbi5hcHBlbmRDaGlsZCh0aGlzLl9jYW52YXMpO1xuXG4gICAgICAgIC8vIEN1cnNvclxuICAgICAgICB0aGlzLl9jdXJzb3IgPSBuZXcgQ3Vyc29yKCk7XG5cbiAgICAgICAgLy8gWFhYOiBUaWdodFZOQyAyLjguMTEgc2VuZHMgbm8gY3Vyc29yIGF0IGFsbCB1bnRpbCBXaW5kb3dzIGNoYW5nZXNcbiAgICAgICAgLy8gaXQuIFJlc3VsdDogbm8gY3Vyc29yIGF0IGFsbCB1bnRpbCBhIHdpbmRvdyBib3JkZXIgb3IgYW4gZWRpdCBmaWVsZFxuICAgICAgICAvLyBpcyBoaXQgYmxpbmRseS4gQnV0IHRoZXJlIGFyZSBhbHNvIFZOQyBzZXJ2ZXJzIHRoYXQgZHJhdyB0aGUgY3Vyc29yXG4gICAgICAgIC8vIGluIHRoZSBmcmFtZWJ1ZmZlciBhbmQgZG9uJ3Qgc2VuZCB0aGUgZW1wdHkgbG9jYWwgY3Vyc29yLiBUaGVyZSBpc1xuICAgICAgICAvLyBubyB3YXkgdG8gc2F0aXNmeSBib3RoIHNpZGVzLlxuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgc3BlYyBpcyB1bmNsZWFyIG9uIHRoaXMgXCJpbml0aWFsIGN1cnNvclwiIGlzc3VlLiBNYW55IG90aGVyXG4gICAgICAgIC8vIHZpZXdlcnMgKFRpZ2VyVk5DLCBSZWFsVk5DLCBSZW1taW5hKSBkaXNwbGF5IGFuIGFycm93IGFzIHRoZVxuICAgICAgICAvLyBpbml0aWFsIGN1cnNvciBpbnN0ZWFkLlxuICAgICAgICB0aGlzLl9jdXJzb3JJbWFnZSA9IFJGQi5jdXJzb3JzLm5vbmU7XG5cbiAgICAgICAgLy8gcG9wdWxhdGUgZGVjb2RlciBhcnJheSB3aXRoIG9iamVjdHNcbiAgICAgICAgdGhpcy5fZGVjb2RlcnNbZW5jb2RpbmdzLmVuY29kaW5nUmF3XSA9IG5ldyBSYXdEZWNvZGVyKCk7XG4gICAgICAgIHRoaXMuX2RlY29kZXJzW2VuY29kaW5ncy5lbmNvZGluZ0NvcHlSZWN0XSA9IG5ldyBDb3B5UmVjdERlY29kZXIoKTtcbiAgICAgICAgdGhpcy5fZGVjb2RlcnNbZW5jb2RpbmdzLmVuY29kaW5nUlJFXSA9IG5ldyBSUkVEZWNvZGVyKCk7XG4gICAgICAgIHRoaXMuX2RlY29kZXJzW2VuY29kaW5ncy5lbmNvZGluZ0hleHRpbGVdID0gbmV3IEhleHRpbGVEZWNvZGVyKCk7XG4gICAgICAgIHRoaXMuX2RlY29kZXJzW2VuY29kaW5ncy5lbmNvZGluZ1RpZ2h0XSA9IG5ldyBUaWdodERlY29kZXIoKTtcbiAgICAgICAgdGhpcy5fZGVjb2RlcnNbZW5jb2RpbmdzLmVuY29kaW5nVGlnaHRQTkddID0gbmV3IFRpZ2h0UE5HRGVjb2RlcigpO1xuXG4gICAgICAgIC8vIE5COiBub3RoaW5nIHRoYXQgbmVlZHMgZXhwbGljaXQgdGVhcmRvd24gc2hvdWxkIGJlIGRvbmVcbiAgICAgICAgLy8gYmVmb3JlIHRoaXMgcG9pbnQsIHNpbmNlIHRoaXMgY2FuIHRocm93IGFuIGV4Y2VwdGlvblxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5fZGlzcGxheSA9IG5ldyBEaXNwbGF5KHRoaXMuX2NhbnZhcyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4Yykge1xuICAgICAgICAgICAgTG9nLkVycm9yKFwiRGlzcGxheSBleGNlcHRpb246IFwiICsgZXhjKTtcbiAgICAgICAgICAgIHRocm93IGV4YztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9kaXNwbGF5Lm9uZmx1c2ggPSB0aGlzLl9vbkZsdXNoLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuX2Rpc3BsYXkuY2xlYXIoKTtcblxuICAgICAgICB0aGlzLl9rZXlib2FyZCA9IG5ldyBLZXlib2FyZCh0aGlzLl9jYW52YXMpO1xuICAgICAgICB0aGlzLl9rZXlib2FyZC5vbmtleWV2ZW50ID0gdGhpcy5faGFuZGxlS2V5RXZlbnQuYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLl9tb3VzZSA9IG5ldyBNb3VzZSh0aGlzLl9jYW52YXMpO1xuICAgICAgICB0aGlzLl9tb3VzZS5vbm1vdXNlYnV0dG9uID0gdGhpcy5faGFuZGxlTW91c2VCdXR0b24uYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fbW91c2Uub25tb3VzZW1vdmUgPSB0aGlzLl9oYW5kbGVNb3VzZU1vdmUuYmluZCh0aGlzKTtcblxuICAgICAgICB0aGlzLl9zb2NrID0gbmV3IFdlYnNvY2soKTtcbiAgICAgICAgdGhpcy5fc29jay5vbignbWVzc2FnZScsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZV9tZXNzYWdlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zb2NrLm9uKCdvcGVuJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCh0aGlzLl9yZmJfY29ubmVjdGlvbl9zdGF0ZSA9PT0gJ2Nvbm5lY3RpbmcnKSAmJlxuICAgICAgICAgICAgICAgICh0aGlzLl9yZmJfaW5pdF9zdGF0ZSA9PT0gJycpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmZiX2luaXRfc3RhdGUgPSAnUHJvdG9jb2xWZXJzaW9uJztcbiAgICAgICAgICAgICAgICBMb2cuRGVidWcoXCJTdGFydGluZyBWTkMgaGFuZHNoYWtlXCIpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mYWlsKFwiVW5leHBlY3RlZCBzZXJ2ZXIgY29ubmVjdGlvbiB3aGlsZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZmJfY29ubmVjdGlvbl9zdGF0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zb2NrLm9uKCdjbG9zZScsIChlKSA9PiB7XG4gICAgICAgICAgICBMb2cuRGVidWcoXCJXZWJTb2NrZXQgb24tY2xvc2UgZXZlbnRcIik7XG4gICAgICAgICAgICBsZXQgbXNnID0gXCJcIjtcbiAgICAgICAgICAgIGlmIChlLmNvZGUpIHtcbiAgICAgICAgICAgICAgICBtc2cgPSBcIihjb2RlOiBcIiArIGUuY29kZTtcbiAgICAgICAgICAgICAgICBpZiAoZS5yZWFzb24pIHtcbiAgICAgICAgICAgICAgICAgICAgbXNnICs9IFwiLCByZWFzb246IFwiICsgZS5yZWFzb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG1zZyArPSBcIilcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcmZiX2Nvbm5lY3Rpb25fc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0aW5nJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFpbChcIkNvbm5lY3Rpb24gY2xvc2VkIFwiICsgbXNnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgLy8gSGFuZGxlIGRpc2Nvbm5lY3RzIHRoYXQgd2VyZSBpbml0aWF0ZWQgc2VydmVyLXNpZGVcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbm5lY3Rpb25TdGF0ZSgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RpbmcnOlxuICAgICAgICAgICAgICAgICAgICAvLyBOb3JtYWwgZGlzY29ubmVjdGlvbiBwYXRoXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNvbm5lY3Rpb25TdGF0ZSgnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZhaWwoXCJVbmV4cGVjdGVkIHNlcnZlciBkaXNjb25uZWN0IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIndoZW4gYWxyZWFkeSBkaXNjb25uZWN0ZWQgXCIgKyBtc2cpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYWlsKFwiVW5leHBlY3RlZCBzZXJ2ZXIgZGlzY29ubmVjdCBiZWZvcmUgY29ubmVjdGluZyBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbXNnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zb2NrLm9mZignY2xvc2UnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NvY2sub24oJ2Vycm9yJywgZSA9PiBMb2cuV2FybihcIldlYlNvY2tldCBvbi1lcnJvciBldmVudFwiKSk7XG5cbiAgICAgICAgLy8gU2xpZ2h0IGRlbGF5IG9mIHRoZSBhY3R1YWwgY29ubmVjdGlvbiBzbyB0aGF0IHRoZSBjYWxsZXIgaGFzXG4gICAgICAgIC8vIHRpbWUgdG8gc2V0IHVwIGNhbGxiYWNrc1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuX3VwZGF0ZUNvbm5lY3Rpb25TdGF0ZS5iaW5kKHRoaXMsICdjb25uZWN0aW5nJykpO1xuXG4gICAgICAgIExvZy5EZWJ1ZyhcIjw8IFJGQi5jb25zdHJ1Y3RvclwiKTtcblxuICAgICAgICAvLyA9PT09PSBQUk9QRVJUSUVTID09PT09XG5cbiAgICAgICAgdGhpcy5kcmFnVmlld3BvcnQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mb2N1c09uQ2xpY2sgPSB0cnVlO1xuXG4gICAgICAgIHRoaXMuX3ZpZXdPbmx5ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2NsaXBWaWV3cG9ydCA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9zY2FsZVZpZXdwb3J0ID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3Jlc2l6ZVNlc3Npb24gPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyA9PT09PSBQUk9QRVJUSUVTID09PT09XG5cbiAgICBnZXQgdmlld09ubHkoKSB7IHJldHVybiB0aGlzLl92aWV3T25seTsgfVxuICAgIHNldCB2aWV3T25seSh2aWV3T25seSkge1xuICAgICAgICB0aGlzLl92aWV3T25seSA9IHZpZXdPbmx5O1xuXG4gICAgICAgIGlmICh0aGlzLl9yZmJfY29ubmVjdGlvbl9zdGF0ZSA9PT0gXCJjb25uZWN0aW5nXCIgfHxcbiAgICAgICAgICAgIHRoaXMuX3JmYl9jb25uZWN0aW9uX3N0YXRlID09PSBcImNvbm5lY3RlZFwiKSB7XG4gICAgICAgICAgICBpZiAodmlld09ubHkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXlib2FyZC51bmdyYWIoKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb3VzZS51bmdyYWIoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fa2V5Ym9hcmQuZ3JhYigpO1xuICAgICAgICAgICAgICAgIHRoaXMuX21vdXNlLmdyYWIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCBjYXBhYmlsaXRpZXMoKSB7IHJldHVybiB0aGlzLl9jYXBhYmlsaXRpZXM7IH1cblxuICAgIGdldCB0b3VjaEJ1dHRvbigpIHsgcmV0dXJuIHRoaXMuX21vdXNlLnRvdWNoQnV0dG9uOyB9XG4gICAgc2V0IHRvdWNoQnV0dG9uKGJ1dHRvbikgeyB0aGlzLl9tb3VzZS50b3VjaEJ1dHRvbiA9IGJ1dHRvbjsgfVxuXG4gICAgZ2V0IGNsaXBWaWV3cG9ydCgpIHsgcmV0dXJuIHRoaXMuX2NsaXBWaWV3cG9ydDsgfVxuICAgIHNldCBjbGlwVmlld3BvcnQodmlld3BvcnQpIHtcbiAgICAgICAgdGhpcy5fY2xpcFZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgICAgIHRoaXMuX3VwZGF0ZUNsaXAoKTtcbiAgICB9XG5cbiAgICBnZXQgc2NhbGVWaWV3cG9ydCgpIHsgcmV0dXJuIHRoaXMuX3NjYWxlVmlld3BvcnQ7IH1cbiAgICBzZXQgc2NhbGVWaWV3cG9ydChzY2FsZSkge1xuICAgICAgICB0aGlzLl9zY2FsZVZpZXdwb3J0ID0gc2NhbGU7XG4gICAgICAgIC8vIFNjYWxpbmcgdHJ1bXBzIGNsaXBwaW5nLCBzbyB3ZSBtYXkgbmVlZCB0byBhZGp1c3RcbiAgICAgICAgLy8gY2xpcHBpbmcgd2hlbiBlbmFibGluZyBvciBkaXNhYmxpbmcgc2NhbGluZ1xuICAgICAgICBpZiAoc2NhbGUgJiYgdGhpcy5fY2xpcFZpZXdwb3J0KSB7XG4gICAgICAgICAgICB0aGlzLl91cGRhdGVDbGlwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fdXBkYXRlU2NhbGUoKTtcbiAgICAgICAgaWYgKCFzY2FsZSAmJiB0aGlzLl9jbGlwVmlld3BvcnQpIHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNsaXAoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldCByZXNpemVTZXNzaW9uKCkgeyByZXR1cm4gdGhpcy5fcmVzaXplU2Vzc2lvbjsgfVxuICAgIHNldCByZXNpemVTZXNzaW9uKHJlc2l6ZSkge1xuICAgICAgICB0aGlzLl9yZXNpemVTZXNzaW9uID0gcmVzaXplO1xuICAgICAgICBpZiAocmVzaXplKSB7XG4gICAgICAgICAgICB0aGlzLl9yZXF1ZXN0UmVtb3RlUmVzaXplKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXQgc2hvd0RvdEN1cnNvcigpIHsgcmV0dXJuIHRoaXMuX3Nob3dEb3RDdXJzb3I7IH1cbiAgICBzZXQgc2hvd0RvdEN1cnNvcihzaG93KSB7XG4gICAgICAgIHRoaXMuX3Nob3dEb3RDdXJzb3IgPSBzaG93O1xuICAgICAgICB0aGlzLl9yZWZyZXNoQ3Vyc29yKCk7XG4gICAgfVxuXG4gICAgZ2V0IGJhY2tncm91bmQoKSB7IHJldHVybiB0aGlzLl9zY3JlZW4uc3R5bGUuYmFja2dyb3VuZDsgfVxuICAgIHNldCBiYWNrZ3JvdW5kKGNzc1ZhbHVlKSB7IHRoaXMuX3NjcmVlbi5zdHlsZS5iYWNrZ3JvdW5kID0gY3NzVmFsdWU7IH1cblxuICAgIC8vID09PT09IFBVQkxJQyBNRVRIT0RTID09PT09XG5cbiAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICB0aGlzLl91cGRhdGVDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgdGhpcy5fc29jay5vZmYoJ2Vycm9yJyk7XG4gICAgICAgIHRoaXMuX3NvY2sub2ZmKCdtZXNzYWdlJyk7XG4gICAgICAgIHRoaXMuX3NvY2sub2ZmKCdvcGVuJyk7XG4gICAgfVxuXG4gICAgc2VuZENyZWRlbnRpYWxzKGNyZWRzKSB7XG4gICAgICAgIHRoaXMuX3JmYl9jcmVkZW50aWFscyA9IGNyZWRzO1xuICAgICAgICBzZXRUaW1lb3V0KHRoaXMuX2luaXRfbXNnLmJpbmQodGhpcyksIDApO1xuICAgIH1cblxuICAgIHNlbmRDdHJsQWx0RGVsKCkge1xuICAgICAgICBpZiAodGhpcy5fcmZiX2Nvbm5lY3Rpb25fc3RhdGUgIT09ICdjb25uZWN0ZWQnIHx8IHRoaXMuX3ZpZXdPbmx5KSB7IHJldHVybjsgfVxuICAgICAgICBMb2cuSW5mbyhcIlNlbmRpbmcgQ3RybC1BbHQtRGVsXCIpO1xuXG4gICAgICAgIHRoaXMuc2VuZEtleShLZXlUYWJsZS5YS19Db250cm9sX0wsIFwiQ29udHJvbExlZnRcIiwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuc2VuZEtleShLZXlUYWJsZS5YS19BbHRfTCwgXCJBbHRMZWZ0XCIsIHRydWUpO1xuICAgICAgICB0aGlzLnNlbmRLZXkoS2V5VGFibGUuWEtfRGVsZXRlLCBcIkRlbGV0ZVwiLCB0cnVlKTtcbiAgICAgICAgdGhpcy5zZW5kS2V5KEtleVRhYmxlLlhLX0RlbGV0ZSwgXCJEZWxldGVcIiwgZmFsc2UpO1xuICAgICAgICB0aGlzLnNlbmRLZXkoS2V5VGFibGUuWEtfQWx0X0wsIFwiQWx0TGVmdFwiLCBmYWxzZSk7XG4gICAgICAgIHRoaXMuc2VuZEtleShLZXlUYWJsZS5YS19Db250cm9sX0wsIFwiQ29udHJvbExlZnRcIiwgZmFsc2UpO1xuICAgIH1cblxuICAgIG1hY2hpbmVTaHV0ZG93bigpIHtcbiAgICAgICAgdGhpcy5feHZwT3AoMSwgMik7XG4gICAgfVxuXG4gICAgbWFjaGluZVJlYm9vdCgpIHtcbiAgICAgICAgdGhpcy5feHZwT3AoMSwgMyk7XG4gICAgfVxuXG4gICAgbWFjaGluZVJlc2V0KCkge1xuICAgICAgICB0aGlzLl94dnBPcCgxLCA0KTtcbiAgICB9XG5cbiAgICAvLyBTZW5kIGEga2V5IHByZXNzLiBJZiAnZG93bicgaXMgbm90IHNwZWNpZmllZCB0aGVuIHNlbmQgYSBkb3duIGtleVxuICAgIC8vIGZvbGxvd2VkIGJ5IGFuIHVwIGtleS5cbiAgICBzZW5kS2V5KGtleXN5bSwgY29kZSwgZG93bikge1xuICAgICAgICBpZiAodGhpcy5fcmZiX2Nvbm5lY3Rpb25fc3RhdGUgIT09ICdjb25uZWN0ZWQnIHx8IHRoaXMuX3ZpZXdPbmx5KSB7IHJldHVybjsgfVxuXG4gICAgICAgIGlmIChkb3duID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZEtleShrZXlzeW0sIGNvZGUsIHRydWUpO1xuICAgICAgICAgICAgdGhpcy5zZW5kS2V5KGtleXN5bSwgY29kZSwgZmFsc2UpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2NhbmNvZGUgPSBYdFNjYW5jb2RlW2NvZGVdO1xuXG4gICAgICAgIGlmICh0aGlzLl9xZW11RXh0S2V5RXZlbnRTdXBwb3J0ZWQgJiYgc2NhbmNvZGUpIHtcbiAgICAgICAgICAgIC8vIDAgaXMgTm9TeW1ib2xcbiAgICAgICAgICAgIGtleXN5bSA9IGtleXN5bSB8fCAwO1xuXG4gICAgICAgICAgICBMb2cuSW5mbyhcIlNlbmRpbmcga2V5IChcIiArIChkb3duID8gXCJkb3duXCIgOiBcInVwXCIpICsgXCIpOiBrZXlzeW0gXCIgKyBrZXlzeW0gKyBcIiwgc2NhbmNvZGUgXCIgKyBzY2FuY29kZSk7XG5cbiAgICAgICAgICAgIFJGQi5tZXNzYWdlcy5RRU1VRXh0ZW5kZWRLZXlFdmVudCh0aGlzLl9zb2NrLCBrZXlzeW0sIGRvd24sIHNjYW5jb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICgha2V5c3ltKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTG9nLkluZm8oXCJTZW5kaW5nIGtleXN5bSAoXCIgKyAoZG93biA/IFwiZG93blwiIDogXCJ1cFwiKSArIFwiKTogXCIgKyBrZXlzeW0pO1xuICAgICAgICAgICAgUkZCLm1lc3NhZ2VzLmtleUV2ZW50KHRoaXMuX3NvY2ssIGtleXN5bSwgZG93biA/IDEgOiAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZvY3VzKCkge1xuICAgICAgICB0aGlzLl9jYW52YXMuZm9jdXMoKTtcbiAgICB9XG5cbiAgICBibHVyKCkge1xuICAgICAgICB0aGlzLl9jYW52YXMuYmx1cigpO1xuICAgIH1cblxuICAgIGNsaXBib2FyZFBhc3RlRnJvbSh0ZXh0KSB7XG4gICAgICAgIGlmICh0aGlzLl9yZmJfY29ubmVjdGlvbl9zdGF0ZSAhPT0gJ2Nvbm5lY3RlZCcgfHwgdGhpcy5fdmlld09ubHkpIHsgcmV0dXJuOyB9XG4gICAgICAgIFJGQi5tZXNzYWdlcy5jbGllbnRDdXRUZXh0KHRoaXMuX3NvY2ssIHRleHQpO1xuICAgIH1cblxuICAgIC8vID09PT09IFBSSVZBVEUgTUVUSE9EUyA9PT09PVxuXG4gICAgX2Nvbm5lY3QoKSB7XG4gICAgICAgIExvZy5EZWJ1ZyhcIj4+IFJGQi5jb25uZWN0XCIpO1xuXG4gICAgICAgIExvZy5JbmZvKFwiY29ubmVjdGluZyB0byBcIiArIHRoaXMuX3VybCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdlYlNvY2tldC5vbm9wZW4gdHJhbnNpdGlvbnMgdG8gdGhlIFJGQiBpbml0IHN0YXRlc1xuICAgICAgICAgICAgdGhpcy5fc29jay5vcGVuKHRoaXMuX3VybCwgWydiaW5hcnknXSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mYWlsKFwiSW52YWxpZCBob3N0IG9yIHBvcnQgKFwiICsgZSArIFwiKVwiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZmFpbChcIkVycm9yIHdoZW4gb3BlbmluZyBzb2NrZXQgKFwiICsgZSArIFwiKVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE1ha2Ugb3VyIGVsZW1lbnRzIHBhcnQgb2YgdGhlIHBhZ2VcbiAgICAgICAgdGhpcy5fdGFyZ2V0LmFwcGVuZENoaWxkKHRoaXMuX3NjcmVlbik7XG5cbiAgICAgICAgdGhpcy5fY3Vyc29yLmF0dGFjaCh0aGlzLl9jYW52YXMpO1xuICAgICAgICB0aGlzLl9yZWZyZXNoQ3Vyc29yKCk7XG5cbiAgICAgICAgLy8gTW9uaXRvciBzaXplIGNoYW5nZXMgb2YgdGhlIHNjcmVlblxuICAgICAgICAvLyBGSVhNRTogVXNlIFJlc2l6ZU9ic2VydmVyLCBvciBoaWRkZW4gb3ZlcmZsb3dcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2V2ZW50SGFuZGxlcnMud2luZG93UmVzaXplKTtcblxuICAgICAgICAvLyBBbHdheXMgZ3JhYiBmb2N1cyBvbiBzb21lIGtpbmQgb2YgY2xpY2sgZXZlbnRcbiAgICAgICAgdGhpcy5fY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5fZXZlbnRIYW5kbGVycy5mb2N1c0NhbnZhcyk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl9ldmVudEhhbmRsZXJzLmZvY3VzQ2FudmFzKTtcblxuICAgICAgICBMb2cuRGVidWcoXCI8PCBSRkIuY29ubmVjdFwiKTtcbiAgICB9XG5cbiAgICBfZGlzY29ubmVjdCgpIHtcbiAgICAgICAgTG9nLkRlYnVnKFwiPj4gUkZCLmRpc2Nvbm5lY3RcIik7XG4gICAgICAgIHRoaXMuX2N1cnNvci5kZXRhY2goKTtcbiAgICAgICAgdGhpcy5fY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtb3VzZWRvd25cIiwgdGhpcy5fZXZlbnRIYW5kbGVycy5mb2N1c0NhbnZhcyk7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hzdGFydFwiLCB0aGlzLl9ldmVudEhhbmRsZXJzLmZvY3VzQ2FudmFzKTtcbiAgICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHRoaXMuX2V2ZW50SGFuZGxlcnMud2luZG93UmVzaXplKTtcbiAgICAgICAgdGhpcy5fa2V5Ym9hcmQudW5ncmFiKCk7XG4gICAgICAgIHRoaXMuX21vdXNlLnVuZ3JhYigpO1xuICAgICAgICB0aGlzLl9zb2NrLmNsb3NlKCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQucmVtb3ZlQ2hpbGQodGhpcy5fc2NyZWVuKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ05vdEZvdW5kRXJyb3InKSB7XG4gICAgICAgICAgICAgICAgLy8gU29tZSBjYXNlcyB3aGVyZSB0aGUgaW5pdGlhbCBjb25uZWN0aW9uIGZhaWxzXG4gICAgICAgICAgICAgICAgLy8gY2FuIGRpc2Nvbm5lY3QgYmVmb3JlIHRoZSBfc2NyZWVuIGlzIGNyZWF0ZWRcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVzaXplVGltZW91dCk7XG4gICAgICAgIExvZy5EZWJ1ZyhcIjw8IFJGQi5kaXNjb25uZWN0XCIpO1xuICAgIH1cblxuICAgIF9mb2N1c0NhbnZhcyhldmVudCkge1xuICAgICAgICAvLyBSZXNwZWN0IGVhcmxpZXIgaGFuZGxlcnMnIHJlcXVlc3QgdG8gbm90IGRvIHNpZGUtZWZmZWN0c1xuICAgICAgICBpZiAoZXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCF0aGlzLmZvY3VzT25DbGljaykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5mb2N1cygpO1xuICAgIH1cblxuICAgIF93aW5kb3dSZXNpemUoZXZlbnQpIHtcbiAgICAgICAgLy8gSWYgdGhlIHdpbmRvdyByZXNpemVkIHRoZW4gb3VyIHNjcmVlbiBlbGVtZW50IG1pZ2h0IGhhdmVcbiAgICAgICAgLy8gYXMgd2VsbC4gVXBkYXRlIHRoZSB2aWV3cG9ydCBkaW1lbnNpb25zLlxuICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZUNsaXAoKTtcbiAgICAgICAgICAgIHRoaXMuX3VwZGF0ZVNjYWxlKCk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICh0aGlzLl9yZXNpemVTZXNzaW9uKSB7XG4gICAgICAgICAgICAvLyBSZXF1ZXN0IGNoYW5naW5nIHRoZSByZXNvbHV0aW9uIG9mIHRoZSByZW1vdGUgZGlzcGxheSB0b1xuICAgICAgICAgICAgLy8gdGhlIHNpemUgb2YgdGhlIGxvY2FsIGJyb3dzZXIgdmlld3BvcnQuXG5cbiAgICAgICAgICAgIC8vIEluIG9yZGVyIHRvIG5vdCBzZW5kIG11bHRpcGxlIHJlcXVlc3RzIGJlZm9yZSB0aGUgYnJvd3Nlci1yZXNpemVcbiAgICAgICAgICAgIC8vIGlzIGZpbmlzaGVkIHdlIHdhaXQgMC41IHNlY29uZHMgYmVmb3JlIHNlbmRpbmcgdGhlIHJlcXVlc3QuXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fcmVzaXplVGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemVUaW1lb3V0ID0gc2V0VGltZW91dCh0aGlzLl9yZXF1ZXN0UmVtb3RlUmVzaXplLmJpbmQodGhpcyksIDUwMCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgc3RhdGUgb2YgY2xpcHBpbmcgaW4gRGlzcGxheSBvYmplY3QsIGFuZCBtYWtlIHN1cmUgdGhlXG4gICAgLy8gY29uZmlndXJlZCB2aWV3cG9ydCBtYXRjaGVzIHRoZSBjdXJyZW50IHNjcmVlbiBzaXplXG4gICAgX3VwZGF0ZUNsaXAoKSB7XG4gICAgICAgIGNvbnN0IGN1cl9jbGlwID0gdGhpcy5fZGlzcGxheS5jbGlwVmlld3BvcnQ7XG4gICAgICAgIGxldCBuZXdfY2xpcCA9IHRoaXMuX2NsaXBWaWV3cG9ydDtcblxuICAgICAgICBpZiAodGhpcy5fc2NhbGVWaWV3cG9ydCkge1xuICAgICAgICAgICAgLy8gRGlzYWJsZSB2aWV3cG9ydCBjbGlwcGluZyBpZiB3ZSBhcmUgc2NhbGluZ1xuICAgICAgICAgICAgbmV3X2NsaXAgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChjdXJfY2xpcCAhPT0gbmV3X2NsaXApIHtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkuY2xpcFZpZXdwb3J0ID0gbmV3X2NsaXA7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobmV3X2NsaXApIHtcbiAgICAgICAgICAgIC8vIFdoZW4gY2xpcHBpbmcgaXMgZW5hYmxlZCwgdGhlIHNjcmVlbiBpcyBsaW1pdGVkIHRvXG4gICAgICAgICAgICAvLyB0aGUgc2l6ZSBvZiB0aGUgY29udGFpbmVyLlxuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NjcmVlblNpemUoKTtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkudmlld3BvcnRDaGFuZ2VTaXplKHNpemUudywgc2l6ZS5oKTtcbiAgICAgICAgICAgIHRoaXMuX2ZpeFNjcm9sbGJhcnMoKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF91cGRhdGVTY2FsZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9zY2FsZVZpZXdwb3J0KSB7XG4gICAgICAgICAgICB0aGlzLl9kaXNwbGF5LnNjYWxlID0gMS4wO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NjcmVlblNpemUoKTtcbiAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkuYXV0b3NjYWxlKHNpemUudywgc2l6ZS5oKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9maXhTY3JvbGxiYXJzKCk7XG4gICAgfVxuXG4gICAgLy8gUmVxdWVzdHMgYSBjaGFuZ2Ugb2YgcmVtb3RlIGRlc2t0b3Agc2l6ZS4gVGhpcyBtZXNzYWdlIGlzIGFuIGV4dGVuc2lvblxuICAgIC8vIGFuZCBtYXkgb25seSBiZSBzZW50IGlmIHdlIGhhdmUgcmVjZWl2ZWQgYW4gRXh0ZW5kZWREZXNrdG9wU2l6ZSBtZXNzYWdlXG4gICAgX3JlcXVlc3RSZW1vdGVSZXNpemUoKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9yZXNpemVUaW1lb3V0KTtcbiAgICAgICAgdGhpcy5fcmVzaXplVGltZW91dCA9IG51bGw7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9yZXNpemVTZXNzaW9uIHx8IHRoaXMuX3ZpZXdPbmx5IHx8XG4gICAgICAgICAgICAhdGhpcy5fc3VwcG9ydHNTZXREZXNrdG9wU2l6ZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3Qgc2l6ZSA9IHRoaXMuX3NjcmVlblNpemUoKTtcbiAgICAgICAgUkZCLm1lc3NhZ2VzLnNldERlc2t0b3BTaXplKHRoaXMuX3NvY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBNYXRoLmZsb29yKHNpemUudyksIE1hdGguZmxvb3Ioc2l6ZS5oKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NjcmVlbl9pZCwgdGhpcy5fc2NyZWVuX2ZsYWdzKTtcblxuICAgICAgICBMb2cuRGVidWcoJ1JlcXVlc3RlZCBuZXcgZGVza3RvcCBzaXplOiAnICtcbiAgICAgICAgICAgICAgICAgICBzaXplLncgKyAneCcgKyBzaXplLmgpO1xuICAgIH1cblxuICAgIC8vIEdldHMgdGhlIHRoZSBzaXplIG9mIHRoZSBhdmFpbGFibGUgc2NyZWVuXG4gICAgX3NjcmVlblNpemUoKSB7XG4gICAgICAgIGxldCByID0gdGhpcy5fc2NyZWVuLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICByZXR1cm4geyB3OiByLndpZHRoLCBoOiByLmhlaWdodCB9O1xuICAgIH1cblxuICAgIF9maXhTY3JvbGxiYXJzKCkge1xuICAgICAgICAvLyBUaGlzIGlzIGEgaGFjayBiZWNhdXNlIENocm9tZSBzY3Jld3MgdXAgdGhlIGNhbGN1bGF0aW9uXG4gICAgICAgIC8vIGZvciB3aGVuIHNjcm9sbGJhcnMgYXJlIG5lZWRlZC4gU28gdG8gZml4IGl0IHdlIHRlbXBvcmFyaWx5XG4gICAgICAgIC8vIHRvZ2dsZSB0aGVtIG9mZiBhbmQgb24uXG4gICAgICAgIGNvbnN0IG9yaWcgPSB0aGlzLl9zY3JlZW4uc3R5bGUub3ZlcmZsb3c7XG4gICAgICAgIHRoaXMuX3NjcmVlbi5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgICAgICAvLyBGb3JjZSBDaHJvbWUgdG8gcmVjYWxjdWxhdGUgdGhlIGxheW91dCBieSBhc2tpbmcgZm9yXG4gICAgICAgIC8vIGFuIGVsZW1lbnQncyBkaW1lbnNpb25zXG4gICAgICAgIHRoaXMuX3NjcmVlbi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdGhpcy5fc2NyZWVuLnN0eWxlLm92ZXJmbG93ID0gb3JpZztcbiAgICB9XG5cbiAgICAvKlxuICAgICAqIENvbm5lY3Rpb24gc3RhdGVzOlxuICAgICAqICAgY29ubmVjdGluZ1xuICAgICAqICAgY29ubmVjdGVkXG4gICAgICogICBkaXNjb25uZWN0aW5nXG4gICAgICogICBkaXNjb25uZWN0ZWQgLSBwZXJtYW5lbnQgc3RhdGVcbiAgICAgKi9cbiAgICBfdXBkYXRlQ29ubmVjdGlvblN0YXRlKHN0YXRlKSB7XG4gICAgICAgIGNvbnN0IG9sZHN0YXRlID0gdGhpcy5fcmZiX2Nvbm5lY3Rpb25fc3RhdGU7XG5cbiAgICAgICAgaWYgKHN0YXRlID09PSBvbGRzdGF0ZSkge1xuICAgICAgICAgICAgTG9nLkRlYnVnKFwiQWxyZWFkeSBpbiBzdGF0ZSAnXCIgKyBzdGF0ZSArIFwiJywgaWdub3JpbmdcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgJ2Rpc2Nvbm5lY3RlZCcgc3RhdGUgaXMgcGVybWFuZW50IGZvciBlYWNoIFJGQiBvYmplY3RcbiAgICAgICAgaWYgKG9sZHN0YXRlID09PSAnZGlzY29ubmVjdGVkJykge1xuICAgICAgICAgICAgTG9nLkVycm9yKFwiVHJpZWQgY2hhbmdpbmcgc3RhdGUgb2YgYSBkaXNjb25uZWN0ZWQgUkZCIG9iamVjdFwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEVuc3VyZSBwcm9wZXIgdHJhbnNpdGlvbnMgYmVmb3JlIGRvaW5nIGFueXRoaW5nXG4gICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgaWYgKG9sZHN0YXRlICE9PSAnY29ubmVjdGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nLkVycm9yKFwiQmFkIHRyYW5zaXRpb24gdG8gY29ubmVjdGVkIHN0YXRlLCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJwcmV2aW91cyBjb25uZWN0aW9uIHN0YXRlOiBcIiArIG9sZHN0YXRlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICBpZiAob2xkc3RhdGUgIT09ICdkaXNjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgICAgICAgICBMb2cuRXJyb3IoXCJCYWQgdHJhbnNpdGlvbiB0byBkaXNjb25uZWN0ZWQgc3RhdGUsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInByZXZpb3VzIGNvbm5lY3Rpb24gc3RhdGU6IFwiICsgb2xkc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdjb25uZWN0aW5nJzpcbiAgICAgICAgICAgICAgICBpZiAob2xkc3RhdGUgIT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIExvZy5FcnJvcihcIkJhZCB0cmFuc2l0aW9uIHRvIGNvbm5lY3Rpbmcgc3RhdGUsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInByZXZpb3VzIGNvbm5lY3Rpb24gc3RhdGU6IFwiICsgb2xkc3RhdGUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0aW5nJzpcbiAgICAgICAgICAgICAgICBpZiAob2xkc3RhdGUgIT09ICdjb25uZWN0ZWQnICYmIG9sZHN0YXRlICE9PSAnY29ubmVjdGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgTG9nLkVycm9yKFwiQmFkIHRyYW5zaXRpb24gdG8gZGlzY29ubmVjdGluZyBzdGF0ZSwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwicHJldmlvdXMgY29ubmVjdGlvbiBzdGF0ZTogXCIgKyBvbGRzdGF0ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgTG9nLkVycm9yKFwiVW5rbm93biBjb25uZWN0aW9uIHN0YXRlOiBcIiArIHN0YXRlKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdGF0ZSBjaGFuZ2UgYWN0aW9uc1xuXG4gICAgICAgIHRoaXMuX3JmYl9jb25uZWN0aW9uX3N0YXRlID0gc3RhdGU7XG5cbiAgICAgICAgTG9nLkRlYnVnKFwiTmV3IHN0YXRlICdcIiArIHN0YXRlICsgXCInLCB3YXMgJ1wiICsgb2xkc3RhdGUgKyBcIicuXCIpO1xuXG4gICAgICAgIGlmICh0aGlzLl9kaXNjb25uVGltZXIgJiYgc3RhdGUgIT09ICdkaXNjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgTG9nLkRlYnVnKFwiQ2xlYXJpbmcgZGlzY29ubmVjdCB0aW1lclwiKTtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9kaXNjb25uVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5fZGlzY29ublRpbWVyID0gbnVsbDtcblxuICAgICAgICAgICAgLy8gbWFrZSBzdXJlIHdlIGRvbid0IGdldCBhIGRvdWJsZSBldmVudFxuICAgICAgICAgICAgdGhpcy5fc29jay5vZmYoJ2Nsb3NlJyk7XG4gICAgICAgIH1cblxuICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdjb25uZWN0aW5nJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9jb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcImNvbm5lY3RcIiwgeyBkZXRhaWw6IHt9IH0pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGluZyc6XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzY29ubmVjdCgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzY29ublRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIExvZy5FcnJvcihcIkRpc2Nvbm5lY3Rpb24gdGltZWQgb3V0LlwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlQ29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICB9LCBESVNDT05ORUNUX1RJTUVPVVQgKiAxMDAwKTtcbiAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICB0aGlzLmRpc3BhdGNoRXZlbnQobmV3IEN1c3RvbUV2ZW50KFxuICAgICAgICAgICAgICAgICAgICBcImRpc2Nvbm5lY3RcIiwgeyBkZXRhaWw6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGNsZWFuOiB0aGlzLl9yZmJfY2xlYW5fZGlzY29ubmVjdCB9IH0pKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8qIFByaW50IGVycm9ycyBhbmQgZGlzY29ubmVjdFxuICAgICAqXG4gICAgICogVGhlIHBhcmFtZXRlciAnZGV0YWlscycgaXMgdXNlZCBmb3IgaW5mb3JtYXRpb24gdGhhdFxuICAgICAqIHNob3VsZCBiZSBsb2dnZWQgYnV0IG5vdCBzZW50IHRvIHRoZSB1c2VyIGludGVyZmFjZS5cbiAgICAgKi9cbiAgICBfZmFpbChkZXRhaWxzKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fcmZiX2Nvbm5lY3Rpb25fc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RpbmcnOlxuICAgICAgICAgICAgICAgIExvZy5FcnJvcihcIkZhaWxlZCB3aGVuIGRpc2Nvbm5lY3Rpbmc6IFwiICsgZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgIExvZy5FcnJvcihcIkZhaWxlZCB3aGlsZSBjb25uZWN0ZWQ6IFwiICsgZGV0YWlscyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb25uZWN0aW5nJzpcbiAgICAgICAgICAgICAgICBMb2cuRXJyb3IoXCJGYWlsZWQgd2hlbiBjb25uZWN0aW5nOiBcIiArIGRldGFpbHMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBMb2cuRXJyb3IoXCJSRkIgZmFpbHVyZTogXCIgKyBkZXRhaWxzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZmJfY2xlYW5fZGlzY29ubmVjdCA9IGZhbHNlOyAvL1RoaXMgaXMgc2VudCB0byB0aGUgVUlcblxuICAgICAgICAvLyBUcmFuc2l0aW9uIHRvIGRpc2Nvbm5lY3RlZCB3aXRob3V0IHdhaXRpbmcgZm9yIHNvY2tldCB0byBjbG9zZVxuICAgICAgICB0aGlzLl91cGRhdGVDb25uZWN0aW9uU3RhdGUoJ2Rpc2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlQ29ubmVjdGlvblN0YXRlKCdkaXNjb25uZWN0ZWQnKTtcblxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgX3NldENhcGFiaWxpdHkoY2FwLCB2YWwpIHtcbiAgICAgICAgdGhpcy5fY2FwYWJpbGl0aWVzW2NhcF0gPSB2YWw7XG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXCJjYXBhYmlsaXRpZXNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IGRldGFpbDogeyBjYXBhYmlsaXRpZXM6IHRoaXMuX2NhcGFiaWxpdGllcyB9IH0pKTtcbiAgICB9XG5cbiAgICBfaGFuZGxlX21lc3NhZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9zb2NrLnJRbGVuID09PSAwKSB7XG4gICAgICAgICAgICBMb2cuV2FybihcImhhbmRsZV9tZXNzYWdlIGNhbGxlZCBvbiBhbiBlbXB0eSByZWNlaXZlIHF1ZXVlXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgc3dpdGNoICh0aGlzLl9yZmJfY29ubmVjdGlvbl9zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICBMb2cuRXJyb3IoXCJHb3QgZGF0YSB3aGlsZSBkaXNjb25uZWN0ZWRcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9mbHVzaGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ub3JtYWxfbXNnKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9zb2NrLnJRbGVuID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhpcy5faW5pdF9tc2coKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9oYW5kbGVLZXlFdmVudChrZXlzeW0sIGNvZGUsIGRvd24pIHtcbiAgICAgICAgdGhpcy5zZW5kS2V5KGtleXN5bSwgY29kZSwgZG93bik7XG4gICAgfVxuXG4gICAgX2hhbmRsZU1vdXNlQnV0dG9uKHgsIHksIGRvd24sIGJtYXNrKSB7XG4gICAgICAgIGlmIChkb3duKSB7XG4gICAgICAgICAgICB0aGlzLl9tb3VzZV9idXR0b25NYXNrIHw9IGJtYXNrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbW91c2VfYnV0dG9uTWFzayAmPSB+Ym1hc2s7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5kcmFnVmlld3BvcnQpIHtcbiAgICAgICAgICAgIGlmIChkb3duICYmICF0aGlzLl92aWV3cG9ydERyYWdnaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld3BvcnREcmFnZ2luZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld3BvcnREcmFnUG9zID0geyd4JzogeCwgJ3knOiB5fTtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3cG9ydEhhc01vdmVkID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvLyBTa2lwIHNlbmRpbmcgbW91c2UgZXZlbnRzXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3cG9ydERyYWdnaW5nID0gZmFsc2U7XG5cbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBhY3R1YWxseSBwZXJmb3JtZWQgYSBkcmFnIHRoZW4gd2UgYXJlIGRvbmVcbiAgICAgICAgICAgICAgICAvLyBoZXJlIGFuZCBzaG91bGQgbm90IHNlbmQgYW55IG1vdXNlIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLl92aWV3cG9ydEhhc01vdmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2Ugd2UgdHJlYXQgdGhpcyBhcyBhIG1vdXNlIGNsaWNrIGV2ZW50LlxuICAgICAgICAgICAgICAgIC8vIFNlbmQgdGhlIGJ1dHRvbiBkb3duIGV2ZW50IGhlcmUsIGFzIHRoZSBidXR0b24gdXBcbiAgICAgICAgICAgICAgICAvLyBldmVudCBpcyBzZW50IGF0IHRoZSBlbmQgb2YgdGhpcyBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgICBSRkIubWVzc2FnZXMucG9pbnRlckV2ZW50KHRoaXMuX3NvY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5LmFic1goeCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9kaXNwbGF5LmFic1koeSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibWFzayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fdmlld09ubHkpIHsgcmV0dXJuOyB9IC8vIFZpZXcgb25seSwgc2tpcCBtb3VzZSBldmVudHNcblxuICAgICAgICBpZiAodGhpcy5fcmZiX2Nvbm5lY3Rpb25fc3RhdGUgIT09ICdjb25uZWN0ZWQnKSB7IHJldHVybjsgfVxuICAgICAgICBSRkIubWVzc2FnZXMucG9pbnRlckV2ZW50KHRoaXMuX3NvY2ssIHRoaXMuX2Rpc3BsYXkuYWJzWCh4KSwgdGhpcy5fZGlzcGxheS5hYnNZKHkpLCB0aGlzLl9tb3VzZV9idXR0b25NYXNrKTtcbiAgICB9XG5cbiAgICBfaGFuZGxlTW91c2VNb3ZlKHgsIHkpIHtcbiAgICAgICAgaWYgKHRoaXMuX3ZpZXdwb3J0RHJhZ2dpbmcpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhWCA9IHRoaXMuX3ZpZXdwb3J0RHJhZ1Bvcy54IC0geDtcbiAgICAgICAgICAgIGNvbnN0IGRlbHRhWSA9IHRoaXMuX3ZpZXdwb3J0RHJhZ1Bvcy55IC0geTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3ZpZXdwb3J0SGFzTW92ZWQgfHwgKE1hdGguYWJzKGRlbHRhWCkgPiBkcmFnVGhyZXNob2xkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgTWF0aC5hYnMoZGVsdGFZKSA+IGRyYWdUaHJlc2hvbGQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fdmlld3BvcnRIYXNNb3ZlZCA9IHRydWU7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl92aWV3cG9ydERyYWdQb3MgPSB7J3gnOiB4LCAneSc6IHl9O1xuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3BsYXkudmlld3BvcnRDaGFuZ2VQb3MoZGVsdGFYLCBkZWx0YVkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTa2lwIHNlbmRpbmcgbW91c2UgZXZlbnRzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fdmlld09ubHkpIHsgcmV0dXJuOyB9IC8vIFZpZXcgb25seSwgc2tpcCBtb3VzZSBldmVudHNcblxuICAgICAgICBpZiAodGhpcy5fcmZiX2Nvbm5lY3Rpb25fc3RhdGUgIT09ICdjb25uZWN0ZWQnKSB7IHJldHVybjsgfVxuICAgICAgICBSRkIubWVzc2FnZXMucG9pbnRlckV2ZW50KHRoaXMuX3NvY2ssIHRoaXMuX2Rpc3BsYXkuYWJzWCh4KSwgdGhpcy5fZGlzcGxheS5hYnNZKHkpLCB0aGlzLl9tb3VzZV9idXR0b25NYXNrKTtcbiAgICB9XG5cbiAgICAvLyBNZXNzYWdlIEhhbmRsZXJzXG5cbiAgICBfbmVnb3RpYXRlX3Byb3RvY29sX3ZlcnNpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9zb2NrLnJRd2FpdChcInZlcnNpb25cIiwgMTIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBzdmVyc2lvbiA9IHRoaXMuX3NvY2suclFzaGlmdFN0cigxMikuc3Vic3RyKDQsIDcpO1xuICAgICAgICBMb2cuSW5mbyhcIlNlcnZlciBQcm90b2NvbFZlcnNpb246IFwiICsgc3ZlcnNpb24pO1xuICAgICAgICBsZXQgaXNfcmVwZWF0ZXIgPSAwO1xuICAgICAgICBzd2l0Y2ggKHN2ZXJzaW9uKSB7XG4gICAgICAgICAgICBjYXNlIFwiMDAwLjAwMFwiOiAgLy8gVWx0cmFWTkMgcmVwZWF0ZXJcbiAgICAgICAgICAgICAgICBpc19yZXBlYXRlciA9IDE7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiMDAzLjAwM1wiOlxuICAgICAgICAgICAgY2FzZSBcIjAwMy4wMDZcIjogIC8vIFVsdHJhVk5DXG4gICAgICAgICAgICBjYXNlIFwiMDAzLjg4OVwiOiAgLy8gQXBwbGUgUmVtb3RlIERlc2t0b3BcbiAgICAgICAgICAgICAgICB0aGlzLl9yZmJfdmVyc2lvbiA9IDMuMztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCIwMDMuMDA3XCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fcmZiX3ZlcnNpb24gPSAzLjc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiMDAzLjAwOFwiOlxuICAgICAgICAgICAgY2FzZSBcIjAwNC4wMDBcIjogIC8vIEludGVsIEFNVCBLVk1cbiAgICAgICAgICAgIGNhc2UgXCIwMDQuMDAxXCI6ICAvLyBSZWFsVk5DIDQuNlxuICAgICAgICAgICAgY2FzZSBcIjAwNS4wMDBcIjogIC8vIFJlYWxWTkMgNS4zXG4gICAgICAgICAgICAgICAgdGhpcy5fcmZiX3ZlcnNpb24gPSAzLjg7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mYWlsKFwiSW52YWxpZCBzZXJ2ZXIgdmVyc2lvbiBcIiArIHN2ZXJzaW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc19yZXBlYXRlcikge1xuICAgICAgICAgICAgbGV0IHJlcGVhdGVySUQgPSBcIklEOlwiICsgdGhpcy5fcmVwZWF0ZXJJRDtcbiAgICAgICAgICAgIHdoaWxlIChyZXBlYXRlcklELmxlbmd0aCA8IDI1MCkge1xuICAgICAgICAgICAgICAgIHJlcGVhdGVySUQgKz0gXCJcXDBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX3NvY2suc2VuZF9zdHJpbmcocmVwZWF0ZXJJRCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9yZmJfdmVyc2lvbiA+IHRoaXMuX3JmYl9tYXhfdmVyc2lvbikge1xuICAgICAgICAgICAgdGhpcy5fcmZiX3ZlcnNpb24gPSB0aGlzLl9yZmJfbWF4X3ZlcnNpb247XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBjdmVyc2lvbiA9IFwiMDBcIiArIHBhcnNlSW50KHRoaXMuX3JmYl92ZXJzaW9uLCAxMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICBcIi4wMFwiICsgKCh0aGlzLl9yZmJfdmVyc2lvbiAqIDEwKSAlIDEwKTtcbiAgICAgICAgdGhpcy5fc29jay5zZW5kX3N0cmluZyhcIlJGQiBcIiArIGN2ZXJzaW9uICsgXCJcXG5cIik7XG4gICAgICAgIExvZy5EZWJ1ZygnU2VudCBQcm90b2NvbFZlcnNpb246ICcgKyBjdmVyc2lvbik7XG5cbiAgICAgICAgdGhpcy5fcmZiX2luaXRfc3RhdGUgPSAnU2VjdXJpdHknO1xuICAgIH1cblxuICAgIF9uZWdvdGlhdGVfc2VjdXJpdHkoKSB7XG4gICAgICAgIC8vIFBvbHlmaWxsIHNpbmNlIElFIGFuZCBQaGFudG9tSlMgZG9lc24ndCBoYXZlXG4gICAgICAgIC8vIFR5cGVkQXJyYXkuaW5jbHVkZXMoKVxuICAgICAgICBmdW5jdGlvbiBpbmNsdWRlcyhpdGVtLCBhcnJheSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChhcnJheVtpXSA9PT0gaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5fcmZiX3ZlcnNpb24gPj0gMy43KSB7XG4gICAgICAgICAgICAvLyBTZXJ2ZXIgc2VuZHMgc3VwcG9ydGVkIGxpc3QsIGNsaWVudCBkZWNpZGVzXG4gICAgICAgICAgICBjb25zdCBudW1fdHlwZXMgPSB0aGlzLl9zb2NrLnJRc2hpZnQ4KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5fc29jay5yUXdhaXQoXCJzZWN1cml0eSB0eXBlXCIsIG51bV90eXBlcywgMSkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgICAgICAgIGlmIChudW1fdHlwZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZmJfaW5pdF9zdGF0ZSA9IFwiU2VjdXJpdHlSZWFzb25cIjtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZWN1cml0eV9jb250ZXh0ID0gXCJubyBzZWN1cml0eSB0eXBlc1wiO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlY3VyaXR5X3N0YXR1cyA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luaXRfbXNnKCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnN0IHR5cGVzID0gdGhpcy5fc29jay5yUXNoaWZ0Qnl0ZXMobnVtX3R5cGVzKTtcbiAgICAgICAgICAgIExvZy5EZWJ1ZyhcIlNlcnZlciBzZWN1cml0eSB0eXBlczogXCIgKyB0eXBlcyk7XG5cbiAgICAgICAgICAgIC8vIExvb2sgZm9yIGVhY2ggYXV0aCBpbiBwcmVmZXJyZWQgb3JkZXJcbiAgICAgICAgICAgIGlmIChpbmNsdWRlcygxLCB0eXBlcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZmJfYXV0aF9zY2hlbWUgPSAxOyAvLyBOb25lXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluY2x1ZGVzKDIyLCB0eXBlcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZmJfYXV0aF9zY2hlbWUgPSAyMjsgLy8gWFZQXG4gICAgICAgICAgICB9IGVsc2UgaWYgKGluY2x1ZGVzKDE2LCB0eXBlcykpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZmJfYXV0aF9zY2hlbWUgPSAxNjsgLy8gVGlnaHRcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoaW5jbHVkZXMoMiwgdHlwZXMpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmZiX2F1dGhfc2NoZW1lID0gMjsgLy8gVk5DIEF1dGhcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoXCJVbnN1cHBvcnRlZCBzZWN1cml0eSB0eXBlcyAodHlwZXM6IFwiICsgdHlwZXMgKyBcIilcIik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX3NvY2suc2VuZChbdGhpcy5fcmZiX2F1dGhfc2NoZW1lXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBTZXJ2ZXIgZGVjaWRlc1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NvY2suclF3YWl0KFwic2VjdXJpdHkgc2NoZW1lXCIsIDQpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgICAgdGhpcy5fcmZiX2F1dGhfc2NoZW1lID0gdGhpcy5fc29jay5yUXNoaWZ0MzIoKTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuX3JmYl9hdXRoX3NjaGVtZSA9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcmZiX2luaXRfc3RhdGUgPSBcIlNlY3VyaXR5UmVhc29uXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VjdXJpdHlfY29udGV4dCA9IFwiYXV0aGVudGljYXRpb24gc2NoZW1lXCI7XG4gICAgICAgICAgICAgICAgdGhpcy5fc2VjdXJpdHlfc3RhdHVzID0gMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5pdF9tc2coKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3JmYl9pbml0X3N0YXRlID0gJ0F1dGhlbnRpY2F0aW9uJztcbiAgICAgICAgTG9nLkRlYnVnKCdBdXRoZW50aWNhdGluZyB1c2luZyBzY2hlbWU6ICcgKyB0aGlzLl9yZmJfYXV0aF9zY2hlbWUpO1xuXG4gICAgICAgIHJldHVybiB0aGlzLl9pbml0X21zZygpOyAvLyBqdW1wIHRvIGF1dGhlbnRpY2F0aW9uXG4gICAgfVxuXG4gICAgX2hhbmRsZV9zZWN1cml0eV9yZWFzb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9zb2NrLnJRd2FpdChcInJlYXNvbiBsZW5ndGhcIiwgNCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzdHJsZW4gPSB0aGlzLl9zb2NrLnJRc2hpZnQzMigpO1xuICAgICAgICBsZXQgcmVhc29uID0gXCJcIjtcblxuICAgICAgICBpZiAoc3RybGVuID4gMCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3NvY2suclF3YWl0KFwicmVhc29uXCIsIHN0cmxlbiwgNCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgICByZWFzb24gPSB0aGlzLl9zb2NrLnJRc2hpZnRTdHIoc3RybGVuKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChyZWFzb24gIT09IFwiXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXG4gICAgICAgICAgICAgICAgXCJzZWN1cml0eWZhaWx1cmVcIixcbiAgICAgICAgICAgICAgICB7IGRldGFpbDogeyBzdGF0dXM6IHRoaXMuX3NlY3VyaXR5X3N0YXR1cyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IHJlYXNvbiB9IH0pKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoXCJTZWN1cml0eSBuZWdvdGlhdGlvbiBmYWlsZWQgb24gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VjdXJpdHlfY29udGV4dCArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIiAocmVhc29uOiBcIiArIHJlYXNvbiArIFwiKVwiKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXG4gICAgICAgICAgICAgICAgXCJzZWN1cml0eWZhaWx1cmVcIixcbiAgICAgICAgICAgICAgICB7IGRldGFpbDogeyBzdGF0dXM6IHRoaXMuX3NlY3VyaXR5X3N0YXR1cyB9IH0pKTtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoXCJTZWN1cml0eSBuZWdvdGlhdGlvbiBmYWlsZWQgb24gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc2VjdXJpdHlfY29udGV4dCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBhdXRoZW50aWNhdGlvblxuICAgIF9uZWdvdGlhdGVfeHZwX2F1dGgoKSB7XG4gICAgICAgIGlmICghdGhpcy5fcmZiX2NyZWRlbnRpYWxzLnVzZXJuYW1lIHx8XG4gICAgICAgICAgICAhdGhpcy5fcmZiX2NyZWRlbnRpYWxzLnBhc3N3b3JkIHx8XG4gICAgICAgICAgICAhdGhpcy5fcmZiX2NyZWRlbnRpYWxzLnRhcmdldCkge1xuICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcbiAgICAgICAgICAgICAgICBcImNyZWRlbnRpYWxzcmVxdWlyZWRcIixcbiAgICAgICAgICAgICAgICB7IGRldGFpbDogeyB0eXBlczogW1widXNlcm5hbWVcIiwgXCJwYXNzd29yZFwiLCBcInRhcmdldFwiXSB9IH0pKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IHh2cF9hdXRoX3N0ciA9IFN0cmluZy5mcm9tQ2hhckNvZGUodGhpcy5fcmZiX2NyZWRlbnRpYWxzLnVzZXJuYW1lLmxlbmd0aCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgU3RyaW5nLmZyb21DaGFyQ29kZSh0aGlzLl9yZmJfY3JlZGVudGlhbHMudGFyZ2V0Lmxlbmd0aCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fcmZiX2NyZWRlbnRpYWxzLnVzZXJuYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JmYl9jcmVkZW50aWFscy50YXJnZXQ7XG4gICAgICAgIHRoaXMuX3NvY2suc2VuZF9zdHJpbmcoeHZwX2F1dGhfc3RyKTtcbiAgICAgICAgdGhpcy5fcmZiX2F1dGhfc2NoZW1lID0gMjtcbiAgICAgICAgcmV0dXJuIHRoaXMuX25lZ290aWF0ZV9hdXRoZW50aWNhdGlvbigpO1xuICAgIH1cblxuICAgIF9uZWdvdGlhdGVfc3RkX3ZuY19hdXRoKCkge1xuICAgICAgICBpZiAodGhpcy5fc29jay5yUXdhaXQoXCJhdXRoIGNoYWxsZW5nZVwiLCAxNikpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgICAgaWYgKCF0aGlzLl9yZmJfY3JlZGVudGlhbHMucGFzc3dvcmQpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXG4gICAgICAgICAgICAgICAgXCJjcmVkZW50aWFsc3JlcXVpcmVkXCIsXG4gICAgICAgICAgICAgICAgeyBkZXRhaWw6IHsgdHlwZXM6IFtcInBhc3N3b3JkXCJdIH0gfSkpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVE9ETyhkaXJlY3R4bWFuMTIpOiBtYWtlIGdlbkRFUyBub3QgcmVxdWlyZSBhbiBBcnJheVxuICAgICAgICBjb25zdCBjaGFsbGVuZ2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9zb2NrLnJRc2hpZnRCeXRlcygxNikpO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IFJGQi5nZW5ERVModGhpcy5fcmZiX2NyZWRlbnRpYWxzLnBhc3N3b3JkLCBjaGFsbGVuZ2UpO1xuICAgICAgICB0aGlzLl9zb2NrLnNlbmQocmVzcG9uc2UpO1xuICAgICAgICB0aGlzLl9yZmJfaW5pdF9zdGF0ZSA9IFwiU2VjdXJpdHlSZXN1bHRcIjtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgX25lZ290aWF0ZV90aWdodF90dW5uZWxzKG51bVR1bm5lbHMpIHtcbiAgICAgICAgY29uc3QgY2xpZW50U3VwcG9ydGVkVHVubmVsVHlwZXMgPSB7XG4gICAgICAgICAgICAwOiB7IHZlbmRvcjogJ1RHSFQnLCBzaWduYXR1cmU6ICdOT1RVTk5FTCcgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBzZXJ2ZXJTdXBwb3J0ZWRUdW5uZWxUeXBlcyA9IHt9O1xuICAgICAgICAvLyByZWNlaXZlIHR1bm5lbCBjYXBhYmlsaXRpZXNcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1UdW5uZWxzOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNhcF9jb2RlID0gdGhpcy5fc29jay5yUXNoaWZ0MzIoKTtcbiAgICAgICAgICAgIGNvbnN0IGNhcF92ZW5kb3IgPSB0aGlzLl9zb2NrLnJRc2hpZnRTdHIoNCk7XG4gICAgICAgICAgICBjb25zdCBjYXBfc2lnbmF0dXJlID0gdGhpcy5fc29jay5yUXNoaWZ0U3RyKDgpO1xuICAgICAgICAgICAgc2VydmVyU3VwcG9ydGVkVHVubmVsVHlwZXNbY2FwX2NvZGVdID0geyB2ZW5kb3I6IGNhcF92ZW5kb3IsIHNpZ25hdHVyZTogY2FwX3NpZ25hdHVyZSB9O1xuICAgICAgICB9XG5cbiAgICAgICAgTG9nLkRlYnVnKFwiU2VydmVyIFRpZ2h0IHR1bm5lbCB0eXBlczogXCIgKyBzZXJ2ZXJTdXBwb3J0ZWRUdW5uZWxUeXBlcyk7XG5cbiAgICAgICAgLy8gU2llbWVucyB0b3VjaCBwYW5lbHMgaGF2ZSBhIFZOQyBzZXJ2ZXIgdGhhdCBzdXBwb3J0cyBOT1RVTk5FTCxcbiAgICAgICAgLy8gYnV0IGZvcmdldHMgdG8gYWR2ZXJ0aXNlIGl0LiBUcnkgdG8gZGV0ZWN0IHN1Y2ggc2VydmVycyBieVxuICAgICAgICAvLyBsb29raW5nIGZvciB0aGVpciBjdXN0b20gdHVubmVsIHR5cGUuXG4gICAgICAgIGlmIChzZXJ2ZXJTdXBwb3J0ZWRUdW5uZWxUeXBlc1sxXSAmJlxuICAgICAgICAgICAgKHNlcnZlclN1cHBvcnRlZFR1bm5lbFR5cGVzWzFdLnZlbmRvciA9PT0gXCJTSUNSXCIpICYmXG4gICAgICAgICAgICAoc2VydmVyU3VwcG9ydGVkVHVubmVsVHlwZXNbMV0uc2lnbmF0dXJlID09PSBcIlNDSEFOTkVMXCIpKSB7XG4gICAgICAgICAgICBMb2cuRGVidWcoXCJEZXRlY3RlZCBTaWVtZW5zIHNlcnZlci4gQXNzdW1pbmcgTk9UVU5ORUwgc3VwcG9ydC5cIik7XG4gICAgICAgICAgICBzZXJ2ZXJTdXBwb3J0ZWRUdW5uZWxUeXBlc1swXSA9IHsgdmVuZG9yOiAnVEdIVCcsIHNpZ25hdHVyZTogJ05PVFVOTkVMJyB9O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gY2hvb3NlIHRoZSBub3R1bm5lbCB0eXBlXG4gICAgICAgIGlmIChzZXJ2ZXJTdXBwb3J0ZWRUdW5uZWxUeXBlc1swXSkge1xuICAgICAgICAgICAgaWYgKHNlcnZlclN1cHBvcnRlZFR1bm5lbFR5cGVzWzBdLnZlbmRvciAhPSBjbGllbnRTdXBwb3J0ZWRUdW5uZWxUeXBlc1swXS52ZW5kb3IgfHxcbiAgICAgICAgICAgICAgICBzZXJ2ZXJTdXBwb3J0ZWRUdW5uZWxUeXBlc1swXS5zaWduYXR1cmUgIT0gY2xpZW50U3VwcG9ydGVkVHVubmVsVHlwZXNbMF0uc2lnbmF0dXJlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoXCJDbGllbnQncyB0dW5uZWwgdHlwZSBoYWQgdGhlIGluY29ycmVjdCBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ2ZW5kb3Igb3Igc2lnbmF0dXJlXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgTG9nLkRlYnVnKFwiU2VsZWN0ZWQgdHVubmVsIHR5cGU6IFwiICsgY2xpZW50U3VwcG9ydGVkVHVubmVsVHlwZXNbMF0pO1xuICAgICAgICAgICAgdGhpcy5fc29jay5zZW5kKFswLCAwLCAwLCAwXSk7ICAvLyB1c2UgTk9UVU5ORUxcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gd2FpdCB1bnRpbCB3ZSByZWNlaXZlIHRoZSBzdWIgYXV0aCBjb3VudCB0byBjb250aW51ZVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoXCJTZXJ2ZXIgd2FudGVkIHR1bm5lbHMsIGJ1dCBkb2Vzbid0IHN1cHBvcnQgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0aGUgbm90dW5uZWwgdHlwZVwiKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9uZWdvdGlhdGVfdGlnaHRfYXV0aCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9yZmJfdGlnaHR2bmMpIHsgIC8vIGZpcnN0IHBhc3MsIGRvIHRoZSB0dW5uZWwgbmVnb3RpYXRpb25cbiAgICAgICAgICAgIGlmICh0aGlzLl9zb2NrLnJRd2FpdChcIm51bSB0dW5uZWxzXCIsIDQpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgICAgY29uc3QgbnVtVHVubmVscyA9IHRoaXMuX3NvY2suclFzaGlmdDMyKCk7XG4gICAgICAgICAgICBpZiAobnVtVHVubmVscyA+IDAgJiYgdGhpcy5fc29jay5yUXdhaXQoXCJ0dW5uZWwgY2FwYWJpbGl0aWVzXCIsIDE2ICogbnVtVHVubmVscywgNCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgICAgICAgIHRoaXMuX3JmYl90aWdodHZuYyA9IHRydWU7XG5cbiAgICAgICAgICAgIGlmIChudW1UdW5uZWxzID4gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX25lZ290aWF0ZV90aWdodF90dW5uZWxzKG51bVR1bm5lbHMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTsgIC8vIHdhaXQgdW50aWwgd2UgcmVjZWl2ZSB0aGUgc3ViIGF1dGggdG8gY29udGludWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHNlY29uZCBwYXNzLCBkbyB0aGUgc3ViLWF1dGggbmVnb3RpYXRpb25cbiAgICAgICAgaWYgKHRoaXMuX3NvY2suclF3YWl0KFwic3ViIGF1dGggY291bnRcIiwgNCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIGNvbnN0IHN1YkF1dGhDb3VudCA9IHRoaXMuX3NvY2suclFzaGlmdDMyKCk7XG4gICAgICAgIGlmIChzdWJBdXRoQ291bnQgPT09IDApIHsgIC8vIGVtcHR5IHN1Yi1hdXRoIGxpc3QgcmVjZWl2ZWQgbWVhbnMgJ25vIGF1dGgnIHN1YnR5cGUgc2VsZWN0ZWRcbiAgICAgICAgICAgIHRoaXMuX3JmYl9pbml0X3N0YXRlID0gJ1NlY3VyaXR5UmVzdWx0JztcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuX3NvY2suclF3YWl0KFwic3ViIGF1dGggY2FwYWJpbGl0aWVzXCIsIDE2ICogc3ViQXV0aENvdW50LCA0KSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgICBjb25zdCBjbGllbnRTdXBwb3J0ZWRUeXBlcyA9IHtcbiAgICAgICAgICAgICdTVERWTk9BVVRIX18nOiAxLFxuICAgICAgICAgICAgJ1NURFZWTkNBVVRIXyc6IDJcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBzZXJ2ZXJTdXBwb3J0ZWRUeXBlcyA9IFtdO1xuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3ViQXV0aENvdW50OyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX3NvY2suclFzaGlmdDMyKCk7IC8vIGNhcE51bVxuICAgICAgICAgICAgY29uc3QgY2FwYWJpbGl0aWVzID0gdGhpcy5fc29jay5yUXNoaWZ0U3RyKDEyKTtcbiAgICAgICAgICAgIHNlcnZlclN1cHBvcnRlZFR5cGVzLnB1c2goY2FwYWJpbGl0aWVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIExvZy5EZWJ1ZyhcIlNlcnZlciBUaWdodCBhdXRoZW50aWNhdGlvbiB0eXBlczogXCIgKyBzZXJ2ZXJTdXBwb3J0ZWRUeXBlcyk7XG5cbiAgICAgICAgZm9yIChsZXQgYXV0aFR5cGUgaW4gY2xpZW50U3VwcG9ydGVkVHlwZXMpIHtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXJTdXBwb3J0ZWRUeXBlcy5pbmRleE9mKGF1dGhUeXBlKSAhPSAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3NvY2suc2VuZChbMCwgMCwgMCwgY2xpZW50U3VwcG9ydGVkVHlwZXNbYXV0aFR5cGVdXSk7XG4gICAgICAgICAgICAgICAgTG9nLkRlYnVnKFwiU2VsZWN0ZWQgYXV0aGVudGljYXRpb24gdHlwZTogXCIgKyBhdXRoVHlwZSk7XG5cbiAgICAgICAgICAgICAgICBzd2l0Y2ggKGF1dGhUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ1NURFZOT0FVVEhfXyc6ICAvLyBubyBhdXRoXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZmJfaW5pdF9zdGF0ZSA9ICdTZWN1cml0eVJlc3VsdCc7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAnU1REVlZOQ0FVVEhfJzogLy8gVk5DIGF1dGhcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JmYl9hdXRoX3NjaGVtZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5pdF9tc2coKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mYWlsKFwiVW5zdXBwb3J0ZWQgdGlueSBhdXRoIHNjaGVtZSBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIihzY2hlbWU6IFwiICsgYXV0aFR5cGUgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoXCJObyBzdXBwb3J0ZWQgc3ViLWF1dGggdHlwZXMhXCIpO1xuICAgIH1cblxuICAgIF9uZWdvdGlhdGVfYXV0aGVudGljYXRpb24oKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fcmZiX2F1dGhfc2NoZW1lKSB7XG4gICAgICAgICAgICBjYXNlIDE6ICAvLyBubyBhdXRoXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JmYl92ZXJzaW9uID49IDMuOCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZmJfaW5pdF9zdGF0ZSA9ICdTZWN1cml0eVJlc3VsdCc7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9yZmJfaW5pdF9zdGF0ZSA9ICdDbGllbnRJbml0aWFsaXNhdGlvbic7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2luaXRfbXNnKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMjI6ICAvLyBYVlAgYXV0aFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9uZWdvdGlhdGVfeHZwX2F1dGgoKTtcblxuICAgICAgICAgICAgY2FzZSAyOiAgLy8gVk5DIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25lZ290aWF0ZV9zdGRfdm5jX2F1dGgoKTtcblxuICAgICAgICAgICAgY2FzZSAxNjogIC8vIFRpZ2h0Vk5DIFNlY3VyaXR5IFR5cGVcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbmVnb3RpYXRlX3RpZ2h0X2F1dGgoKTtcblxuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmFpbChcIlVuc3VwcG9ydGVkIGF1dGggc2NoZW1lIChzY2hlbWU6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9yZmJfYXV0aF9zY2hlbWUgKyBcIilcIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfaGFuZGxlX3NlY3VyaXR5X3Jlc3VsdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NvY2suclF3YWl0KCdWTkMgYXV0aCByZXNwb25zZSAnLCA0KSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLl9zb2NrLnJRc2hpZnQzMigpO1xuXG4gICAgICAgIGlmIChzdGF0dXMgPT09IDApIHsgLy8gT0tcbiAgICAgICAgICAgIHRoaXMuX3JmYl9pbml0X3N0YXRlID0gJ0NsaWVudEluaXRpYWxpc2F0aW9uJztcbiAgICAgICAgICAgIExvZy5EZWJ1ZygnQXV0aGVudGljYXRpb24gT0snKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9pbml0X21zZygpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuX3JmYl92ZXJzaW9uID49IDMuOCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JmYl9pbml0X3N0YXRlID0gXCJTZWN1cml0eVJlYXNvblwiO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlY3VyaXR5X2NvbnRleHQgPSBcInNlY3VyaXR5IHJlc3VsdFwiO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NlY3VyaXR5X3N0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5faW5pdF9tc2coKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcbiAgICAgICAgICAgICAgICAgICAgXCJzZWN1cml0eWZhaWx1cmVcIixcbiAgICAgICAgICAgICAgICAgICAgeyBkZXRhaWw6IHsgc3RhdHVzOiBzdGF0dXMgfSB9KSk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fZmFpbChcIlNlY3VyaXR5IGhhbmRzaGFrZSBmYWlsZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfbmVnb3RpYXRlX3NlcnZlcl9pbml0KCkge1xuICAgICAgICBpZiAodGhpcy5fc29jay5yUXdhaXQoXCJzZXJ2ZXIgaW5pdGlhbGl6YXRpb25cIiwgMjQpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAgIC8qIFNjcmVlbiBzaXplICovXG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5fc29jay5yUXNoaWZ0MTYoKTtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gdGhpcy5fc29jay5yUXNoaWZ0MTYoKTtcblxuICAgICAgICAvKiBQSVhFTF9GT1JNQVQgKi9cbiAgICAgICAgY29uc3QgYnBwICAgICAgICAgPSB0aGlzLl9zb2NrLnJRc2hpZnQ4KCk7XG4gICAgICAgIGNvbnN0IGRlcHRoICAgICAgID0gdGhpcy5fc29jay5yUXNoaWZ0OCgpO1xuICAgICAgICBjb25zdCBiaWdfZW5kaWFuICA9IHRoaXMuX3NvY2suclFzaGlmdDgoKTtcbiAgICAgICAgY29uc3QgdHJ1ZV9jb2xvciAgPSB0aGlzLl9zb2NrLnJRc2hpZnQ4KCk7XG5cbiAgICAgICAgY29uc3QgcmVkX21heCAgICAgPSB0aGlzLl9zb2NrLnJRc2hpZnQxNigpO1xuICAgICAgICBjb25zdCBncmVlbl9tYXggICA9IHRoaXMuX3NvY2suclFzaGlmdDE2KCk7XG4gICAgICAgIGNvbnN0IGJsdWVfbWF4ICAgID0gdGhpcy5fc29jay5yUXNoaWZ0MTYoKTtcbiAgICAgICAgY29uc3QgcmVkX3NoaWZ0ICAgPSB0aGlzLl9zb2NrLnJRc2hpZnQ4KCk7XG4gICAgICAgIGNvbnN0IGdyZWVuX3NoaWZ0ID0gdGhpcy5fc29jay5yUXNoaWZ0OCgpO1xuICAgICAgICBjb25zdCBibHVlX3NoaWZ0ICA9IHRoaXMuX3NvY2suclFzaGlmdDgoKTtcbiAgICAgICAgdGhpcy5fc29jay5yUXNraXBCeXRlcygzKTsgIC8vIHBhZGRpbmdcblxuICAgICAgICAvLyBOQihkaXJlY3R4bWFuMTIpOiB3ZSBkb24ndCB3YW50IHRvIGNhbGwgYW55IGNhbGxiYWNrcyBvciBwcmludCBtZXNzYWdlcyB1bnRpbFxuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICAqYWZ0ZXIqIHdlJ3JlIHBhc3QgdGhlIHBvaW50IHdoZXJlIHdlIGNvdWxkIGJhY2t0cmFja1xuXG4gICAgICAgIC8qIENvbm5lY3Rpb24gbmFtZS90aXRsZSAqL1xuICAgICAgICBjb25zdCBuYW1lX2xlbmd0aCA9IHRoaXMuX3NvY2suclFzaGlmdDMyKCk7XG4gICAgICAgIGlmICh0aGlzLl9zb2NrLnJRd2FpdCgnc2VydmVyIGluaXQgbmFtZScsIG5hbWVfbGVuZ3RoLCAyNCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIHRoaXMuX2ZiX25hbWUgPSBkZWNvZGVVVEY4KHRoaXMuX3NvY2suclFzaGlmdFN0cihuYW1lX2xlbmd0aCkpO1xuXG4gICAgICAgIGlmICh0aGlzLl9yZmJfdGlnaHR2bmMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zb2NrLnJRd2FpdCgnVGlnaHRWTkMgZXh0ZW5kZWQgc2VydmVyIGluaXQgaGVhZGVyJywgOCwgMjQgKyBuYW1lX2xlbmd0aCkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgICAvLyBJbiBUaWdodFZOQyBtb2RlLCBTZXJ2ZXJJbml0IG1lc3NhZ2UgaXMgZXh0ZW5kZWRcbiAgICAgICAgICAgIGNvbnN0IG51bVNlcnZlck1lc3NhZ2VzID0gdGhpcy5fc29jay5yUXNoaWZ0MTYoKTtcbiAgICAgICAgICAgIGNvbnN0IG51bUNsaWVudE1lc3NhZ2VzID0gdGhpcy5fc29jay5yUXNoaWZ0MTYoKTtcbiAgICAgICAgICAgIGNvbnN0IG51bUVuY29kaW5ncyA9IHRoaXMuX3NvY2suclFzaGlmdDE2KCk7XG4gICAgICAgICAgICB0aGlzLl9zb2NrLnJRc2tpcEJ5dGVzKDIpOyAgLy8gcGFkZGluZ1xuXG4gICAgICAgICAgICBjb25zdCB0b3RhbE1lc3NhZ2VzTGVuZ3RoID0gKG51bVNlcnZlck1lc3NhZ2VzICsgbnVtQ2xpZW50TWVzc2FnZXMgKyBudW1FbmNvZGluZ3MpICogMTY7XG4gICAgICAgICAgICBpZiAodGhpcy5fc29jay5yUXdhaXQoJ1RpZ2h0Vk5DIGV4dGVuZGVkIHNlcnZlciBpbml0IGhlYWRlcicsIHRvdGFsTWVzc2FnZXNMZW5ndGgsIDMyICsgbmFtZV9sZW5ndGgpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBhY3R1YWxseSBkbyBhbnl0aGluZyB3aXRoIHRoZSBjYXBhYmlsaXR5IGluZm9ybWF0aW9uIHRoYXQgVElHSFQgc2VuZHMsXG4gICAgICAgICAgICAvLyBzbyB3ZSBqdXN0IHNraXAgdGhlIGFsbCBvZiB0aGlzLlxuXG4gICAgICAgICAgICAvLyBUSUdIVCBzZXJ2ZXIgbWVzc2FnZSBjYXBhYmlsaXRpZXNcbiAgICAgICAgICAgIHRoaXMuX3NvY2suclFza2lwQnl0ZXMoMTYgKiBudW1TZXJ2ZXJNZXNzYWdlcyk7XG5cbiAgICAgICAgICAgIC8vIFRJR0hUIGNsaWVudCBtZXNzYWdlIGNhcGFiaWxpdGllc1xuICAgICAgICAgICAgdGhpcy5fc29jay5yUXNraXBCeXRlcygxNiAqIG51bUNsaWVudE1lc3NhZ2VzKTtcblxuICAgICAgICAgICAgLy8gVElHSFQgZW5jb2RpbmcgY2FwYWJpbGl0aWVzXG4gICAgICAgICAgICB0aGlzLl9zb2NrLnJRc2tpcEJ5dGVzKDE2ICogbnVtRW5jb2RpbmdzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE5CKGRpcmVjdHhtYW4xMik6IHRoZXNlIGFyZSBkb3duIGhlcmUgc28gdGhhdCB3ZSBkb24ndCBydW4gdGhlbSBtdWx0aXBsZSB0aW1lc1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgICBpZiB3ZSBiYWNrdHJhY2tcbiAgICAgICAgTG9nLkluZm8oXCJTY3JlZW46IFwiICsgd2lkdGggKyBcInhcIiArIGhlaWdodCArXG4gICAgICAgICAgICAgICAgICBcIiwgYnBwOiBcIiArIGJwcCArIFwiLCBkZXB0aDogXCIgKyBkZXB0aCArXG4gICAgICAgICAgICAgICAgICBcIiwgYmlnX2VuZGlhbjogXCIgKyBiaWdfZW5kaWFuICtcbiAgICAgICAgICAgICAgICAgIFwiLCB0cnVlX2NvbG9yOiBcIiArIHRydWVfY29sb3IgK1xuICAgICAgICAgICAgICAgICAgXCIsIHJlZF9tYXg6IFwiICsgcmVkX21heCArXG4gICAgICAgICAgICAgICAgICBcIiwgZ3JlZW5fbWF4OiBcIiArIGdyZWVuX21heCArXG4gICAgICAgICAgICAgICAgICBcIiwgYmx1ZV9tYXg6IFwiICsgYmx1ZV9tYXggK1xuICAgICAgICAgICAgICAgICAgXCIsIHJlZF9zaGlmdDogXCIgKyByZWRfc2hpZnQgK1xuICAgICAgICAgICAgICAgICAgXCIsIGdyZWVuX3NoaWZ0OiBcIiArIGdyZWVuX3NoaWZ0ICtcbiAgICAgICAgICAgICAgICAgIFwiLCBibHVlX3NoaWZ0OiBcIiArIGJsdWVfc2hpZnQpO1xuXG4gICAgICAgIGlmIChiaWdfZW5kaWFuICE9PSAwKSB7XG4gICAgICAgICAgICBMb2cuV2FybihcIlNlcnZlciBuYXRpdmUgZW5kaWFuIGlzIG5vdCBsaXR0bGUgZW5kaWFuXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlZF9zaGlmdCAhPT0gMTYpIHtcbiAgICAgICAgICAgIExvZy5XYXJuKFwiU2VydmVyIG5hdGl2ZSByZWQtc2hpZnQgaXMgbm90IDE2XCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGJsdWVfc2hpZnQgIT09IDApIHtcbiAgICAgICAgICAgIExvZy5XYXJuKFwiU2VydmVyIG5hdGl2ZSBibHVlLXNoaWZ0IGlzIG5vdCAwXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gd2UncmUgcGFzdCB0aGUgcG9pbnQgd2hlcmUgd2UgY291bGQgYmFja3RyYWNrLCBzbyBpdCdzIHNhZmUgdG8gY2FsbCB0aGlzXG4gICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXG4gICAgICAgICAgICBcImRlc2t0b3BuYW1lXCIsXG4gICAgICAgICAgICB7IGRldGFpbDogeyBuYW1lOiB0aGlzLl9mYl9uYW1lIH0gfSkpO1xuXG4gICAgICAgIHRoaXMuX3Jlc2l6ZSh3aWR0aCwgaGVpZ2h0KTtcblxuICAgICAgICBpZiAoIXRoaXMuX3ZpZXdPbmx5KSB7IHRoaXMuX2tleWJvYXJkLmdyYWIoKTsgfVxuICAgICAgICBpZiAoIXRoaXMuX3ZpZXdPbmx5KSB7IHRoaXMuX21vdXNlLmdyYWIoKTsgfVxuXG4gICAgICAgIHRoaXMuX2ZiX2RlcHRoID0gMjQ7XG5cbiAgICAgICAgaWYgKHRoaXMuX2ZiX25hbWUgPT09IFwiSW50ZWwocikgQU1UIEtWTVwiKSB7XG4gICAgICAgICAgICBMb2cuV2FybihcIkludGVsIEFNVCBLVk0gb25seSBzdXBwb3J0cyA4LzE2IGJpdCBkZXB0aHMuIFVzaW5nIGxvdyBjb2xvciBtb2RlLlwiKTtcbiAgICAgICAgICAgIHRoaXMuX2ZiX2RlcHRoID0gODtcbiAgICAgICAgfVxuXG4gICAgICAgIFJGQi5tZXNzYWdlcy5waXhlbEZvcm1hdCh0aGlzLl9zb2NrLCB0aGlzLl9mYl9kZXB0aCwgdHJ1ZSk7XG4gICAgICAgIHRoaXMuX3NlbmRFbmNvZGluZ3MoKTtcbiAgICAgICAgUkZCLm1lc3NhZ2VzLmZiVXBkYXRlUmVxdWVzdCh0aGlzLl9zb2NrLCBmYWxzZSwgMCwgMCwgdGhpcy5fZmJfd2lkdGgsIHRoaXMuX2ZiX2hlaWdodCk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlQ29ubmVjdGlvblN0YXRlKCdjb25uZWN0ZWQnKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgX3NlbmRFbmNvZGluZ3MoKSB7XG4gICAgICAgIGNvbnN0IGVuY3MgPSBbXTtcblxuICAgICAgICAvLyBJbiBwcmVmZXJlbmNlIG9yZGVyXG4gICAgICAgIGVuY3MucHVzaChlbmNvZGluZ3MuZW5jb2RpbmdDb3B5UmVjdCk7XG4gICAgICAgIC8vIE9ubHkgc3VwcG9ydGVkIHdpdGggZnVsbCBkZXB0aCBzdXBwb3J0XG4gICAgICAgIGlmICh0aGlzLl9mYl9kZXB0aCA9PSAyNCkge1xuICAgICAgICAgICAgZW5jcy5wdXNoKGVuY29kaW5ncy5lbmNvZGluZ1RpZ2h0KTtcbiAgICAgICAgICAgIGVuY3MucHVzaChlbmNvZGluZ3MuZW5jb2RpbmdUaWdodFBORyk7XG4gICAgICAgICAgICBlbmNzLnB1c2goZW5jb2RpbmdzLmVuY29kaW5nSGV4dGlsZSk7XG4gICAgICAgICAgICBlbmNzLnB1c2goZW5jb2RpbmdzLmVuY29kaW5nUlJFKTtcbiAgICAgICAgfVxuICAgICAgICBlbmNzLnB1c2goZW5jb2RpbmdzLmVuY29kaW5nUmF3KTtcblxuICAgICAgICAvLyBQc3VlZG8tZW5jb2Rpbmcgc2V0dGluZ3NcbiAgICAgICAgZW5jcy5wdXNoKGVuY29kaW5ncy5wc2V1ZG9FbmNvZGluZ1F1YWxpdHlMZXZlbDAgKyA2KTtcbiAgICAgICAgZW5jcy5wdXNoKGVuY29kaW5ncy5wc2V1ZG9FbmNvZGluZ0NvbXByZXNzTGV2ZWwwICsgMik7XG5cbiAgICAgICAgZW5jcy5wdXNoKGVuY29kaW5ncy5wc2V1ZG9FbmNvZGluZ0Rlc2t0b3BTaXplKTtcbiAgICAgICAgZW5jcy5wdXNoKGVuY29kaW5ncy5wc2V1ZG9FbmNvZGluZ0xhc3RSZWN0KTtcbiAgICAgICAgZW5jcy5wdXNoKGVuY29kaW5ncy5wc2V1ZG9FbmNvZGluZ1FFTVVFeHRlbmRlZEtleUV2ZW50KTtcbiAgICAgICAgZW5jcy5wdXNoKGVuY29kaW5ncy5wc2V1ZG9FbmNvZGluZ0V4dGVuZGVkRGVza3RvcFNpemUpO1xuICAgICAgICBlbmNzLnB1c2goZW5jb2RpbmdzLnBzZXVkb0VuY29kaW5nWHZwKTtcbiAgICAgICAgZW5jcy5wdXNoKGVuY29kaW5ncy5wc2V1ZG9FbmNvZGluZ0ZlbmNlKTtcbiAgICAgICAgZW5jcy5wdXNoKGVuY29kaW5ncy5wc2V1ZG9FbmNvZGluZ0NvbnRpbnVvdXNVcGRhdGVzKTtcblxuICAgICAgICBpZiAodGhpcy5fZmJfZGVwdGggPT0gMjQpIHtcbiAgICAgICAgICAgIGVuY3MucHVzaChlbmNvZGluZ3MucHNldWRvRW5jb2RpbmdDdXJzb3IpO1xuICAgICAgICB9XG5cbiAgICAgICAgUkZCLm1lc3NhZ2VzLmNsaWVudEVuY29kaW5ncyh0aGlzLl9zb2NrLCBlbmNzKTtcbiAgICB9XG5cbiAgICAvKiBSRkIgcHJvdG9jb2wgaW5pdGlhbGl6YXRpb24gc3RhdGVzOlxuICAgICAqICAgUHJvdG9jb2xWZXJzaW9uXG4gICAgICogICBTZWN1cml0eVxuICAgICAqICAgQXV0aGVudGljYXRpb25cbiAgICAgKiAgIFNlY3VyaXR5UmVzdWx0XG4gICAgICogICBDbGllbnRJbml0aWFsaXphdGlvbiAtIG5vdCB0cmlnZ2VyZWQgYnkgc2VydmVyIG1lc3NhZ2VcbiAgICAgKiAgIFNlcnZlckluaXRpYWxpemF0aW9uXG4gICAgICovXG4gICAgX2luaXRfbXNnKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuX3JmYl9pbml0X3N0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdQcm90b2NvbFZlcnNpb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9uZWdvdGlhdGVfcHJvdG9jb2xfdmVyc2lvbigpO1xuXG4gICAgICAgICAgICBjYXNlICdTZWN1cml0eSc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25lZ290aWF0ZV9zZWN1cml0eSgpO1xuXG4gICAgICAgICAgICBjYXNlICdBdXRoZW50aWNhdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25lZ290aWF0ZV9hdXRoZW50aWNhdGlvbigpO1xuXG4gICAgICAgICAgICBjYXNlICdTZWN1cml0eVJlc3VsdCc6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZV9zZWN1cml0eV9yZXN1bHQoKTtcblxuICAgICAgICAgICAgY2FzZSAnU2VjdXJpdHlSZWFzb24nOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVfc2VjdXJpdHlfcmVhc29uKCk7XG5cbiAgICAgICAgICAgIGNhc2UgJ0NsaWVudEluaXRpYWxpc2F0aW9uJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9zb2NrLnNlbmQoW3RoaXMuX3NoYXJlZCA/IDEgOiAwXSk7IC8vIENsaWVudEluaXRpYWxpc2F0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5fcmZiX2luaXRfc3RhdGUgPSAnU2VydmVySW5pdGlhbGlzYXRpb24nO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBjYXNlICdTZXJ2ZXJJbml0aWFsaXNhdGlvbic6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25lZ290aWF0ZV9zZXJ2ZXJfaW5pdCgpO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mYWlsKFwiVW5rbm93biBpbml0IHN0YXRlIChzdGF0ZTogXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3JmYl9pbml0X3N0YXRlICsgXCIpXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX2hhbmRsZV9zZXRfY29sb3VyX21hcF9tc2coKSB7XG4gICAgICAgIExvZy5EZWJ1ZyhcIlNldENvbG9yTWFwRW50cmllc1wiKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5fZmFpbChcIlVuZXhwZWN0ZWQgU2V0Q29sb3JNYXBFbnRyaWVzIG1lc3NhZ2VcIik7XG4gICAgfVxuXG4gICAgX2hhbmRsZV9zZXJ2ZXJfY3V0X3RleHQoKSB7XG4gICAgICAgIExvZy5EZWJ1ZyhcIlNlcnZlckN1dFRleHRcIik7XG5cbiAgICAgICAgaWYgKHRoaXMuX3NvY2suclF3YWl0KFwiU2VydmVyQ3V0VGV4dCBoZWFkZXJcIiwgNywgMSkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgIHRoaXMuX3NvY2suclFza2lwQnl0ZXMoMyk7ICAvLyBQYWRkaW5nXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHRoaXMuX3NvY2suclFzaGlmdDMyKCk7XG4gICAgICAgIGlmICh0aGlzLl9zb2NrLnJRd2FpdChcIlNlcnZlckN1dFRleHRcIiwgbGVuZ3RoLCA4KSkgeyByZXR1cm4gZmFsc2U7IH1cblxuICAgICAgICBjb25zdCB0ZXh0ID0gdGhpcy5fc29jay5yUXNoaWZ0U3RyKGxlbmd0aCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3ZpZXdPbmx5KSB7IHJldHVybiB0cnVlOyB9XG5cbiAgICAgICAgdGhpcy5kaXNwYXRjaEV2ZW50KG5ldyBDdXN0b21FdmVudChcbiAgICAgICAgICAgIFwiY2xpcGJvYXJkXCIsXG4gICAgICAgICAgICB7IGRldGFpbDogeyB0ZXh0OiB0ZXh0IH0gfSkpO1xuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIF9oYW5kbGVfc2VydmVyX2ZlbmNlX21zZygpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NvY2suclF3YWl0KFwiU2VydmVyRmVuY2UgaGVhZGVyXCIsIDgsIDEpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICB0aGlzLl9zb2NrLnJRc2tpcEJ5dGVzKDMpOyAvLyBQYWRkaW5nXG4gICAgICAgIGxldCBmbGFncyA9IHRoaXMuX3NvY2suclFzaGlmdDMyKCk7XG4gICAgICAgIGxldCBsZW5ndGggPSB0aGlzLl9zb2NrLnJRc2hpZnQ4KCk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3NvY2suclF3YWl0KFwiU2VydmVyRmVuY2UgcGF5bG9hZFwiLCBsZW5ndGgsIDkpKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAgIGlmIChsZW5ndGggPiA2NCkge1xuICAgICAgICAgICAgTG9nLldhcm4oXCJCYWQgcGF5bG9hZCBsZW5ndGggKFwiICsgbGVuZ3RoICsgXCIpIGluIGZlbmNlIHJlc3BvbnNlXCIpO1xuICAgICAgICAgICAgbGVuZ3RoID0gNjQ7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBwYXlsb2FkID0gdGhpcy5fc29jay5yUXNoaWZ0U3RyKGxlbmd0aCk7XG5cbiAgICAgICAgdGhpcy5fc3VwcG9ydHNGZW5jZSA9IHRydWU7XG5cbiAgICAgICAgLypcbiAgICAgICAgICogRmVuY2UgZmxhZ3NcbiAgICAgICAgICpcbiAgICAgICAgICogICgxPDwwKSAgLSBCbG9ja0JlZm9yZVxuICAgICAgICAgKiAgKDE8PDEpICAtIEJsb2NrQWZ0ZXJcbiAgICAgICAgICogICgxPDwyKSAgLSBTeW5jTmV4dFxuICAgICAgICAgKiAgKDE8PDMxKSAtIFJlcXVlc3RcbiAgICAgICAgICovXG5cbiAgICAgICAgaWYgKCEoZmxhZ3MgJiAoMTw8MzEpKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoXCJVbmV4cGVjdGVkIGZlbmNlIHJlc3BvbnNlXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmlsdGVyIG91dCB1bnN1cHBvcnRlZCBmbGFnc1xuICAgICAgICAvLyBGSVhNRTogc3VwcG9ydCBzeW5jTmV4dFxuICAgICAgICBmbGFncyAmPSAoMTw8MCkgfCAoMTw8MSk7XG5cbiAgICAgICAgLy8gQmxvY2tCZWZvcmUgYW5kIEJsb2NrQWZ0ZXIgYXJlIGF1dG9tYXRpY2FsbHkgaGFuZGxlZCBieVxuICAgICAgICAvLyB0aGUgZmFjdCB0aGF0IHdlIHByb2Nlc3MgZWFjaCBpbmNvbWluZyBtZXNzYWdlXG4gICAgICAgIC8vIHN5bmNocm9udW9zbHkuXG4gICAgICAgIFJGQi5tZXNzYWdlcy5jbGllbnRGZW5jZSh0aGlzLl9zb2NrLCBmbGFncywgcGF5bG9hZCk7XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgX2hhbmRsZV94dnBfbXNnKCkge1xuICAgICAgICBpZiAodGhpcy5fc29jay5yUXdhaXQoXCJYVlAgdmVyc2lvbiBhbmQgbWVzc2FnZVwiLCAzLCAxKSkgeyByZXR1cm4gZmFsc2U7IH1cbiAgICAgICAgdGhpcy5fc29jay5yUXNraXBCeXRlcygxKTsgIC8vIFBhZGRpbmdcbiAgICAgICAgY29uc3QgeHZwX3ZlciA9IHRoaXMuX3NvY2suclFzaGlmdDgoKTtcbiAgICAgICAgY29uc3QgeHZwX21zZyA9IHRoaXMuX3NvY2suclFzaGlmdDgoKTtcblxuICAgICAgICBzd2l0Y2ggKHh2cF9tc2cpIHtcbiAgICAgICAgICAgIGNhc2UgMDogIC8vIFhWUF9GQUlMXG4gICAgICAgICAgICAgICAgTG9nLkVycm9yKFwiWFZQIE9wZXJhdGlvbiBGYWlsZWRcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDE6ICAvLyBYVlBfSU5JVFxuICAgICAgICAgICAgICAgIHRoaXMuX3JmYl94dnBfdmVyID0geHZwX3ZlcjtcbiAgICAgICAgICAgICAgICBMb2cuSW5mbyhcIlhWUCBleHRlbnNpb25zIGVuYWJsZWQgKHZlcnNpb24gXCIgKyB0aGlzLl9yZmJfeHZwX3ZlciArIFwiKVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRDYXBhYmlsaXR5KFwicG93ZXJcIiwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuX2ZhaWwoXCJJbGxlZ2FsIHNlcnZlciBYVlAgbWVzc2FnZSAobXNnOiBcIiArIHh2cF9tc2cgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBfbm9ybWFsX21zZygpIHtcbiAgICAgICAgbGV0IG1zZ190eXBlO1xuICAgICAgICBpZiAodGhpcy5fRkJVLnJlY3RzID4gMCkge1xuICAgICAgICAgICAgbXNnX3R5cGUgPSAwO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbXNnX3R5cGUgPSB0aGlzLl9zb2NrLnJRc2hpZnQ4KCk7XG4gICAgICAgIH1cblxuICAgICAgICBsZXQgZmlyc3QsIHJldDtcbiAgICAgICAgc3dpdGNoIChtc2dfdHlwZSkge1xuICAgICAgICAgICAgY2FzZSAwOiAgLy8gRnJhbWVidWZmZXJVcGRhdGVcbiAgICAgICAgICAgICAgICByZXQgPSB0aGlzLl9mcmFtZWJ1ZmZlclVwZGF0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChyZXQgJiYgIXRoaXMuX2VuYWJsZWRDb250aW51b3VzVXBkYXRlcykge1xuICAgICAgICAgICAgICAgICAgICBSRkIubWVzc2FnZXMuZmJVcGRhdGVSZXF1ZXN0KHRoaXMuX3NvY2ssIHRydWUsIDAsIDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmJfd2lkdGgsIHRoaXMuX2ZiX2hlaWdodCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXQ7XG5cbiAgICAgICAgICAgIGNhc2UgMTogIC8vIFNldENvbG9yTWFwRW50cmllc1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVfc2V0X2NvbG91cl9tYXBfbXNnKCk7XG5cbiAgICAgICAgICAgIGNhc2UgMjogIC8vIEJlbGxcbiAgICAgICAgICAgICAgICBMb2cuRGVidWcoXCJCZWxsXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChuZXcgQ3VzdG9tRXZlbnQoXG4gICAgICAgICAgICAgICAgICAgIFwiYmVsbFwiLFxuICAgICAgICAgICAgICAgICAgICB7IGRldGFpbDoge30gfSkpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXG4gICAgICAgICAgICBjYXNlIDM6ICAvLyBTZXJ2ZXJDdXRUZXh0XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZV9zZXJ2ZXJfY3V0X3RleHQoKTtcblxuICAgICAgICAgICAgY2FzZSAxNTA6IC8vIEVuZE9mQ29udGludW91c1VwZGF0ZXNcbiAgICAgICAgICAgICAgICBmaXJzdCA9ICF0aGlzLl9zdXBwb3J0c0NvbnRpbnVvdXNVcGRhdGVzO1xuICAgICAgICAgICAgICAgIHRoaXMuX3N1cHBvcnRzQ29udGludW91c1VwZGF0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuX2VuYWJsZWRDb250aW51b3VzVXBkYXRlcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGlmIChmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9lbmFibGVkQ29udGludW91c1VwZGF0ZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl91cGRhdGVDb250aW51b3VzVXBkYXRlcygpO1xuICAgICAgICAgICAgICAgICAgICBMb2cuSW5mbyhcIkVuYWJsaW5nIGNvbnRpbnVvdXMgdXBkYXRlcy5cIik7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUU6IFdlIG5lZWQgdG8gc2VuZCBhIGZyYW1lYnVmZmVydXBkYXRlcmVxdWVzdCBoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIHdlIGFkZCBzdXBwb3J0IGZvciB0dXJuaW5nIG9mZiBjb250aW51b3VzIHVwZGF0ZXNcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIGNhc2UgMjQ4OiAvLyBTZXJ2ZXJGZW5jZVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVfc2VydmVyX2ZlbmNlX21zZygpO1xuXG4gICAgICAgICAgICBjYXNlIDI1MDogIC8vIFhWUFxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVfeHZwX21zZygpO1xuXG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuX2ZhaWwoXCJVbmV4cGVjdGVkIHNlcnZlciBtZXNzYWdlICh0eXBlIFwiICsgbXNnX3R5cGUgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgTG9nLkRlYnVnKFwic29jay5yUXNsaWNlKDAsIDMwKTogXCIgKyB0aGlzLl9zb2NrLnJRc2xpY2UoMCwgMzApKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIF9vbkZsdXNoKCkge1xuICAgICAgICB0aGlzLl9mbHVzaGluZyA9IGZhbHNlO1xuICAgICAgICAvLyBSZXN1bWUgcHJvY2Vzc2luZ1xuICAgICAgICBpZiAodGhpcy5fc29jay5yUWxlbiA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZV9tZXNzYWdlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfZnJhbWVidWZmZXJVcGRhdGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9GQlUucmVjdHMgPT09IDApIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9zb2NrLnJRd2FpdChcIkZCVSBoZWFkZXJcIiwgMywgMSkpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgICAgICB0aGlzLl9zb2NrLnJRc2tpcEJ5dGVzKDEpOyAgLy8gUGFkZGluZ1xuICAgICAgICAgICAgdGhpcy5fRkJVLnJlY3RzID0gdGhpcy5fc29jay5yUXNoaWZ0MTYoKTtcblxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwcmV2aW91cyBmcmFtZSBpcyBmdWxseSByZW5kZXJlZCBmaXJzdFxuICAgICAgICAgICAgLy8gdG8gYXZvaWQgYnVpbGRpbmcgdXAgYW4gZXhjZXNzaXZlIHF1ZXVlXG4gICAgICAgICAgICBpZiAodGhpcy5fZGlzcGxheS5wZW5kaW5nKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9mbHVzaGluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5fZGlzcGxheS5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICh0aGlzLl9GQlUucmVjdHMgPiAwKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fRkJVLmVuY29kaW5nID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3NvY2suclF3YWl0KFwicmVjdCBoZWFkZXJcIiwgMTIpKSB7IHJldHVybiBmYWxzZTsgfVxuICAgICAgICAgICAgICAgIC8qIE5ldyBGcmFtZWJ1ZmZlclVwZGF0ZSAqL1xuXG4gICAgICAgICAgICAgICAgY29uc3QgaGRyID0gdGhpcy5fc29jay5yUXNoaWZ0Qnl0ZXMoMTIpO1xuICAgICAgICAgICAgICAgIHRoaXMuX0ZCVS54ICAgICAgICA9IChoZHJbMF0gPDwgOCkgKyBoZHJbMV07XG4gICAgICAgICAgICAgICAgdGhpcy5fRkJVLnkgICAgICAgID0gKGhkclsyXSA8PCA4KSArIGhkclszXTtcbiAgICAgICAgICAgICAgICB0aGlzLl9GQlUud2lkdGggICAgPSAoaGRyWzRdIDw8IDgpICsgaGRyWzVdO1xuICAgICAgICAgICAgICAgIHRoaXMuX0ZCVS5oZWlnaHQgICA9IChoZHJbNl0gPDwgOCkgKyBoZHJbN107XG4gICAgICAgICAgICAgICAgdGhpcy5fRkJVLmVuY29kaW5nID0gcGFyc2VJbnQoKGhkcls4XSA8PCAyNCkgKyAoaGRyWzldIDw8IDE2KSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGhkclsxMF0gPDwgOCkgKyBoZHJbMTFdLCAxMCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy5faGFuZGxlUmVjdCgpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLl9GQlUucmVjdHMtLTtcbiAgICAgICAgICAgIHRoaXMuX0ZCVS5lbmNvZGluZyA9IG51bGw7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9kaXNwbGF5LmZsaXAoKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTsgIC8vIFdlIGZpbmlzaGVkIHRoaXMgRkJVXG4gICAgfVxuXG4gICAgX2hhbmRsZVJlY3QoKSB7XG4gICAgICAgIHN3aXRjaCAodGhpcy5fRkJVLmVuY29kaW5nKSB7XG4gICAgICAgICAgICBjYXNlIGVuY29kaW5ncy5wc2V1ZG9FbmNvZGluZ0xhc3RSZWN0OlxuICAgICAgICAgICAgICAgIHRoaXMuX0ZCVS5yZWN0cyA9IDE7IC8vIFdpbGwgYmUgZGVjcmVhc2VkIHdoZW4gd2UgcmV0dXJuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgICAgIGNhc2UgZW5jb2RpbmdzLnBzZXVkb0VuY29kaW5nQ3Vyc29yOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVDdXJzb3IoKTtcblxuICAgICAgICAgICAgY2FzZSBlbmNvZGluZ3MucHNldWRvRW5jb2RpbmdRRU1VRXh0ZW5kZWRLZXlFdmVudDpcbiAgICAgICAgICAgICAgICAvLyBPbGQgU2FmYXJpIGRvZXNuJ3Qgc3VwcG9ydCBjcmVhdGluZyBrZXlib2FyZCBldmVudHNcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBrZXlib2FyZEV2ZW50ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoXCJrZXlib2FyZEV2ZW50XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5Ym9hcmRFdmVudC5jb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3FlbXVFeHRLZXlFdmVudFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRG8gbm90aGluZ1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgY2FzZSBlbmNvZGluZ3MucHNldWRvRW5jb2RpbmdEZXNrdG9wU2l6ZTpcbiAgICAgICAgICAgICAgICB0aGlzLl9yZXNpemUodGhpcy5fRkJVLndpZHRoLCB0aGlzLl9GQlUuaGVpZ2h0KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcblxuICAgICAgICAgICAgY2FzZSBlbmNvZGluZ3MucHNldWRvRW5jb2RpbmdFeHRlbmRlZERlc2t0b3BTaXplOlxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVFeHRlbmRlZERlc2t0b3BTaXplKCk7XG5cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZURhdGFSZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfaGFuZGxlQ3Vyc29yKCkge1xuICAgICAgICBjb25zdCBob3R4ID0gdGhpcy5fRkJVLng7ICAvLyBob3RzcG90LXhcbiAgICAgICAgY29uc3QgaG90eSA9IHRoaXMuX0ZCVS55OyAgLy8gaG90c3BvdC15XG4gICAgICAgIGNvbnN0IHcgPSB0aGlzLl9GQlUud2lkdGg7XG4gICAgICAgIGNvbnN0IGggPSB0aGlzLl9GQlUuaGVpZ2h0O1xuXG4gICAgICAgIGNvbnN0IHBpeGVsc2xlbmd0aCA9IHcgKiBoICogNDtcbiAgICAgICAgY29uc3QgbWFza2xlbmd0aCA9IE1hdGguY2VpbCh3IC8gOCkgKiBoO1xuXG4gICAgICAgIGxldCBieXRlcyA9IHBpeGVsc2xlbmd0aCArIG1hc2tsZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLl9zb2NrLnJRd2FpdChcImN1cnNvciBlbmNvZGluZ1wiLCBieXRlcykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERlY29kZSBmcm9tIEJHUlggcGl4ZWxzICsgYml0IG1hc2sgdG8gUkdCQVxuICAgICAgICBjb25zdCBwaXhlbHMgPSB0aGlzLl9zb2NrLnJRc2hpZnRCeXRlcyhwaXhlbHNsZW5ndGgpO1xuICAgICAgICBjb25zdCBtYXNrID0gdGhpcy5fc29jay5yUXNoaWZ0Qnl0ZXMobWFza2xlbmd0aCk7XG4gICAgICAgIGxldCByZ2JhID0gbmV3IFVpbnQ4QXJyYXkodyAqIGggKiA0KTtcblxuICAgICAgICBsZXQgcGl4X2lkeCA9IDA7XG4gICAgICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaDsgeSsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCB4ID0gMDsgeCA8IHc7IHgrKykge1xuICAgICAgICAgICAgICAgIGxldCBtYXNrX2lkeCA9IHkgKiBNYXRoLmNlaWwodyAvIDgpICsgTWF0aC5mbG9vcih4IC8gOCk7XG4gICAgICAgICAgICAgICAgbGV0IGFscGhhID0gKG1hc2tbbWFza19pZHhdIDw8ICh4ICUgOCkpICYgMHg4MCA/IDI1NSA6IDA7XG4gICAgICAgICAgICAgICAgcmdiYVtwaXhfaWR4ICAgIF0gPSBwaXhlbHNbcGl4X2lkeCArIDJdO1xuICAgICAgICAgICAgICAgIHJnYmFbcGl4X2lkeCArIDFdID0gcGl4ZWxzW3BpeF9pZHggKyAxXTtcbiAgICAgICAgICAgICAgICByZ2JhW3BpeF9pZHggKyAyXSA9IHBpeGVsc1twaXhfaWR4XTtcbiAgICAgICAgICAgICAgICByZ2JhW3BpeF9pZHggKyAzXSA9IGFscGhhO1xuICAgICAgICAgICAgICAgIHBpeF9pZHggKz0gNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3VwZGF0ZUN1cnNvcihyZ2JhLCBob3R4LCBob3R5LCB3LCBoKTtcblxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBfaGFuZGxlRXh0ZW5kZWREZXNrdG9wU2l6ZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX3NvY2suclF3YWl0KFwiRXh0ZW5kZWREZXNrdG9wU2l6ZVwiLCA0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgbnVtYmVyX29mX3NjcmVlbnMgPSB0aGlzLl9zb2NrLnJRcGVlazgoKTtcblxuICAgICAgICBsZXQgYnl0ZXMgPSA0ICsgKG51bWJlcl9vZl9zY3JlZW5zICogMTYpO1xuICAgICAgICBpZiAodGhpcy5fc29jay5yUXdhaXQoXCJFeHRlbmRlZERlc2t0b3BTaXplXCIsIGJ5dGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgZmlyc3RVcGRhdGUgPSAhdGhpcy5fc3VwcG9ydHNTZXREZXNrdG9wU2l6ZTtcbiAgICAgICAgdGhpcy5fc3VwcG9ydHNTZXREZXNrdG9wU2l6ZSA9IHRydWU7XG5cbiAgICAgICAgLy8gTm9ybWFsbHkgd2Ugb25seSBhcHBseSB0aGUgY3VycmVudCByZXNpemUgbW9kZSBhZnRlciBhXG4gICAgICAgIC8vIHdpbmRvdyByZXNpemUgZXZlbnQuIEhvd2V2ZXIgdGhlcmUgaXMgbm8gc3VjaCB0cmlnZ2VyIG9uIHRoZVxuICAgICAgICAvLyBpbml0aWFsIGNvbm5lY3QuIEFuZCB3ZSBkb24ndCBrbm93IGlmIHRoZSBzZXJ2ZXIgc3VwcG9ydHNcbiAgICAgICAgLy8gcmVzaXppbmcgdW50aWwgd2UndmUgZ290dGVuIGhlcmUuXG4gICAgICAgIGlmIChmaXJzdFVwZGF0ZSkge1xuICAgICAgICAgICAgdGhpcy5fcmVxdWVzdFJlbW90ZVJlc2l6ZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fc29jay5yUXNraXBCeXRlcygxKTsgIC8vIG51bWJlci1vZi1zY3JlZW5zXG4gICAgICAgIHRoaXMuX3NvY2suclFza2lwQnl0ZXMoMyk7ICAvLyBwYWRkaW5nXG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1iZXJfb2Zfc2NyZWVuczsgaSArPSAxKSB7XG4gICAgICAgICAgICAvLyBTYXZlIHRoZSBpZCBhbmQgZmxhZ3Mgb2YgdGhlIGZpcnN0IHNjcmVlblxuICAgICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zY3JlZW5faWQgPSB0aGlzLl9zb2NrLnJRc2hpZnRCeXRlcyg0KTsgICAgLy8gaWRcbiAgICAgICAgICAgICAgICB0aGlzLl9zb2NrLnJRc2tpcEJ5dGVzKDIpOyAgICAgICAgICAgICAgICAgICAgICAgLy8geC1wb3NpdGlvblxuICAgICAgICAgICAgICAgIHRoaXMuX3NvY2suclFza2lwQnl0ZXMoMik7ICAgICAgICAgICAgICAgICAgICAgICAvLyB5LXBvc2l0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5fc29jay5yUXNraXBCeXRlcygyKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpZHRoXG4gICAgICAgICAgICAgICAgdGhpcy5fc29jay5yUXNraXBCeXRlcygyKTsgICAgICAgICAgICAgICAgICAgICAgIC8vIGhlaWdodFxuICAgICAgICAgICAgICAgIHRoaXMuX3NjcmVlbl9mbGFncyA9IHRoaXMuX3NvY2suclFzaGlmdEJ5dGVzKDQpOyAvLyBmbGFnc1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zb2NrLnJRc2tpcEJ5dGVzKDE2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8qXG4gICAgICAgICAqIFRoZSB4LXBvc2l0aW9uIGluZGljYXRlcyB0aGUgcmVhc29uIGZvciB0aGUgY2hhbmdlOlxuICAgICAgICAgKlxuICAgICAgICAgKiAgMCAtIHNlcnZlciByZXNpemVkIG9uIGl0cyBvd25cbiAgICAgICAgICogIDEgLSB0aGlzIGNsaWVudCByZXF1ZXN0ZWQgdGhlIHJlc2l6ZVxuICAgICAgICAgKiAgMiAtIGFub3RoZXIgY2xpZW50IHJlcXVlc3RlZCB0aGUgcmVzaXplXG4gICAgICAgICAqL1xuXG4gICAgICAgIC8vIFdlIG5lZWQgdG8gaGFuZGxlIGVycm9ycyB3aGVuIHdlIHJlcXVlc3RlZCB0aGUgcmVzaXplLlxuICAgICAgICBpZiAodGhpcy5fRkJVLnggPT09IDEgJiYgdGhpcy5fRkJVLnkgIT09IDApIHtcbiAgICAgICAgICAgIGxldCBtc2cgPSBcIlwiO1xuICAgICAgICAgICAgLy8gVGhlIHktcG9zaXRpb24gaW5kaWNhdGVzIHRoZSBzdGF0dXMgY29kZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fRkJVLnkpIHtcbiAgICAgICAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IFwiUmVzaXplIGlzIGFkbWluaXN0cmF0aXZlbHkgcHJvaGliaXRlZFwiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IFwiT3V0IG9mIHJlc291cmNlc1wiO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IFwiSW52YWxpZCBzY3JlZW4gbGF5b3V0XCI7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIG1zZyA9IFwiVW5rbm93biByZWFzb25cIjtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBMb2cuV2FybihcIlNlcnZlciBkaWQgbm90IGFjY2VwdCB0aGUgcmVzaXplIHJlcXVlc3Q6IFwiXG4gICAgICAgICAgICAgICAgICAgICArIG1zZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9yZXNpemUodGhpcy5fRkJVLndpZHRoLCB0aGlzLl9GQlUuaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIF9oYW5kbGVEYXRhUmVjdCgpIHtcbiAgICAgICAgbGV0IGRlY29kZXIgPSB0aGlzLl9kZWNvZGVyc1t0aGlzLl9GQlUuZW5jb2RpbmddO1xuICAgICAgICBpZiAoIWRlY29kZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2ZhaWwoXCJVbnN1cHBvcnRlZCBlbmNvZGluZyAoZW5jb2Rpbmc6IFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fRkJVLmVuY29kaW5nICsgXCIpXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZVJlY3QodGhpcy5fRkJVLngsIHRoaXMuX0ZCVS55LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9GQlUud2lkdGgsIHRoaXMuX0ZCVS5oZWlnaHQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX3NvY2ssIHRoaXMuX2Rpc3BsYXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZiX2RlcHRoKTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICB0aGlzLl9mYWlsKFwiRXJyb3IgZGVjb2RpbmcgcmVjdDogXCIgKyBlcnIpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3VwZGF0ZUNvbnRpbnVvdXNVcGRhdGVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2VuYWJsZWRDb250aW51b3VzVXBkYXRlcykgeyByZXR1cm47IH1cblxuICAgICAgICBSRkIubWVzc2FnZXMuZW5hYmxlQ29udGludW91c1VwZGF0ZXModGhpcy5fc29jaywgdHJ1ZSwgMCwgMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ZiX3dpZHRoLCB0aGlzLl9mYl9oZWlnaHQpO1xuICAgIH1cblxuICAgIF9yZXNpemUod2lkdGgsIGhlaWdodCkge1xuICAgICAgICB0aGlzLl9mYl93aWR0aCA9IHdpZHRoO1xuICAgICAgICB0aGlzLl9mYl9oZWlnaHQgPSBoZWlnaHQ7XG5cbiAgICAgICAgdGhpcy5fZGlzcGxheS5yZXNpemUodGhpcy5fZmJfd2lkdGgsIHRoaXMuX2ZiX2hlaWdodCk7XG5cbiAgICAgICAgLy8gQWRqdXN0IHRoZSB2aXNpYmxlIHZpZXdwb3J0IGJhc2VkIG9uIHRoZSBuZXcgZGltZW5zaW9uc1xuICAgICAgICB0aGlzLl91cGRhdGVDbGlwKCk7XG4gICAgICAgIHRoaXMuX3VwZGF0ZVNjYWxlKCk7XG5cbiAgICAgICAgdGhpcy5fdXBkYXRlQ29udGludW91c1VwZGF0ZXMoKTtcbiAgICB9XG5cbiAgICBfeHZwT3AodmVyLCBvcCkge1xuICAgICAgICBpZiAodGhpcy5fcmZiX3h2cF92ZXIgPCB2ZXIpIHsgcmV0dXJuOyB9XG4gICAgICAgIExvZy5JbmZvKFwiU2VuZGluZyBYVlAgb3BlcmF0aW9uIFwiICsgb3AgKyBcIiAodmVyc2lvbiBcIiArIHZlciArIFwiKVwiKTtcbiAgICAgICAgUkZCLm1lc3NhZ2VzLnh2cE9wKHRoaXMuX3NvY2ssIHZlciwgb3ApO1xuICAgIH1cblxuICAgIF91cGRhdGVDdXJzb3IocmdiYSwgaG90eCwgaG90eSwgdywgaCkge1xuICAgICAgICB0aGlzLl9jdXJzb3JJbWFnZSA9IHtcbiAgICAgICAgICAgIHJnYmFQaXhlbHM6IHJnYmEsXG4gICAgICAgICAgICBob3R4OiBob3R4LCBob3R5OiBob3R5LCB3OiB3LCBoOiBoLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9yZWZyZXNoQ3Vyc29yKCk7XG4gICAgfVxuXG4gICAgX3Nob3VsZFNob3dEb3RDdXJzb3IoKSB7XG4gICAgICAgIC8vIENhbGxlZCB3aGVuIHRoaXMuX2N1cnNvckltYWdlIGlzIHVwZGF0ZWRcbiAgICAgICAgaWYgKCF0aGlzLl9zaG93RG90Q3Vyc29yKSB7XG4gICAgICAgICAgICAvLyBVc2VyIGRvZXMgbm90IHdhbnQgdG8gc2VlIHRoZSBkb3QsIHNvLi4uXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUaGUgZG90IHNob3VsZCBub3QgYmUgc2hvd24gaWYgdGhlIGN1cnNvciBpcyBhbHJlYWR5IHZpc2libGUsXG4gICAgICAgIC8vIGkuZS4gY29udGFpbnMgYXQgbGVhc3Qgb25lIG5vdC1mdWxseS10cmFuc3BhcmVudCBwaXhlbC5cbiAgICAgICAgLy8gU28gaXRlcmF0ZSB0aHJvdWdoIGFsbCBhbHBoYSBieXRlcyBpbiByZ2JhIGFuZCBzdG9wIGF0IHRoZVxuICAgICAgICAvLyBmaXJzdCBub24temVyby5cbiAgICAgICAgZm9yIChsZXQgaSA9IDM7IGkgPCB0aGlzLl9jdXJzb3JJbWFnZS5yZ2JhUGl4ZWxzLmxlbmd0aDsgaSArPSA0KSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY3Vyc29ySW1hZ2UucmdiYVBpeGVsc1tpXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEF0IHRoaXMgcG9pbnQsIHdlIGtub3cgdGhhdCB0aGUgY3Vyc29yIGlzIGZ1bGx5IHRyYW5zcGFyZW50LCBhbmRcbiAgICAgICAgLy8gdGhlIHVzZXIgd2FudHMgdG8gc2VlIHRoZSBkb3QgaW5zdGVhZCBvZiB0aGlzLlxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBfcmVmcmVzaEN1cnNvcigpIHtcbiAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLl9zaG91bGRTaG93RG90Q3Vyc29yKCkgPyBSRkIuY3Vyc29ycy5kb3QgOiB0aGlzLl9jdXJzb3JJbWFnZTtcbiAgICAgICAgdGhpcy5fY3Vyc29yLmNoYW5nZShpbWFnZS5yZ2JhUGl4ZWxzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGltYWdlLmhvdHgsIGltYWdlLmhvdHksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW1hZ2UudywgaW1hZ2UuaFxuICAgICAgICApO1xuICAgIH1cblxuICAgIHN0YXRpYyBnZW5ERVMocGFzc3dvcmQsIGNoYWxsZW5nZSkge1xuICAgICAgICBjb25zdCBwYXNzd29yZENoYXJzID0gcGFzc3dvcmQuc3BsaXQoJycpLm1hcChjID0+IGMuY2hhckNvZGVBdCgwKSk7XG4gICAgICAgIHJldHVybiAobmV3IERFUyhwYXNzd29yZENoYXJzKSkuZW5jcnlwdChjaGFsbGVuZ2UpO1xuICAgIH1cbn1cblxuLy8gQ2xhc3MgTWV0aG9kc1xuUkZCLm1lc3NhZ2VzID0ge1xuICAgIGtleUV2ZW50KHNvY2ssIGtleXN5bSwgZG93bikge1xuICAgICAgICBjb25zdCBidWZmID0gc29jay5fc1E7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHNvY2suX3NRbGVuO1xuXG4gICAgICAgIGJ1ZmZbb2Zmc2V0XSA9IDQ7ICAvLyBtc2ctdHlwZVxuICAgICAgICBidWZmW29mZnNldCArIDFdID0gZG93bjtcblxuICAgICAgICBidWZmW29mZnNldCArIDJdID0gMDtcbiAgICAgICAgYnVmZltvZmZzZXQgKyAzXSA9IDA7XG5cbiAgICAgICAgYnVmZltvZmZzZXQgKyA0XSA9IChrZXlzeW0gPj4gMjQpO1xuICAgICAgICBidWZmW29mZnNldCArIDVdID0gKGtleXN5bSA+PiAxNik7XG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgNl0gPSAoa2V5c3ltID4+IDgpO1xuICAgICAgICBidWZmW29mZnNldCArIDddID0ga2V5c3ltO1xuXG4gICAgICAgIHNvY2suX3NRbGVuICs9IDg7XG4gICAgICAgIHNvY2suZmx1c2goKTtcbiAgICB9LFxuXG4gICAgUUVNVUV4dGVuZGVkS2V5RXZlbnQoc29jaywga2V5c3ltLCBkb3duLCBrZXljb2RlKSB7XG4gICAgICAgIGZ1bmN0aW9uIGdldFJGQmtleWNvZGUoeHRfc2NhbmNvZGUpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwcGVyQnl0ZSA9IChrZXljb2RlID4+IDgpO1xuICAgICAgICAgICAgY29uc3QgbG93ZXJCeXRlID0gKGtleWNvZGUgJiAweDAwZmYpO1xuICAgICAgICAgICAgaWYgKHVwcGVyQnl0ZSA9PT0gMHhlMCAmJiBsb3dlckJ5dGUgPCAweDdmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxvd2VyQnl0ZSB8IDB4ODA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geHRfc2NhbmNvZGU7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBidWZmID0gc29jay5fc1E7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHNvY2suX3NRbGVuO1xuXG4gICAgICAgIGJ1ZmZbb2Zmc2V0XSA9IDI1NTsgLy8gbXNnLXR5cGVcbiAgICAgICAgYnVmZltvZmZzZXQgKyAxXSA9IDA7IC8vIHN1YiBtc2ctdHlwZVxuXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgMl0gPSAoZG93biA+PiA4KTtcbiAgICAgICAgYnVmZltvZmZzZXQgKyAzXSA9IGRvd247XG5cbiAgICAgICAgYnVmZltvZmZzZXQgKyA0XSA9IChrZXlzeW0gPj4gMjQpO1xuICAgICAgICBidWZmW29mZnNldCArIDVdID0gKGtleXN5bSA+PiAxNik7XG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgNl0gPSAoa2V5c3ltID4+IDgpO1xuICAgICAgICBidWZmW29mZnNldCArIDddID0ga2V5c3ltO1xuXG4gICAgICAgIGNvbnN0IFJGQmtleWNvZGUgPSBnZXRSRkJrZXljb2RlKGtleWNvZGUpO1xuXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgOF0gPSAoUkZCa2V5Y29kZSA+PiAyNCk7XG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgOV0gPSAoUkZCa2V5Y29kZSA+PiAxNik7XG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgMTBdID0gKFJGQmtleWNvZGUgPj4gOCk7XG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgMTFdID0gUkZCa2V5Y29kZTtcblxuICAgICAgICBzb2NrLl9zUWxlbiArPSAxMjtcbiAgICAgICAgc29jay5mbHVzaCgpO1xuICAgIH0sXG5cbiAgICBwb2ludGVyRXZlbnQoc29jaywgeCwgeSwgbWFzaykge1xuICAgICAgICBjb25zdCBidWZmID0gc29jay5fc1E7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHNvY2suX3NRbGVuO1xuXG4gICAgICAgIGJ1ZmZbb2Zmc2V0XSA9IDU7IC8vIG1zZy10eXBlXG5cbiAgICAgICAgYnVmZltvZmZzZXQgKyAxXSA9IG1hc2s7XG5cbiAgICAgICAgYnVmZltvZmZzZXQgKyAyXSA9IHggPj4gODtcbiAgICAgICAgYnVmZltvZmZzZXQgKyAzXSA9IHg7XG5cbiAgICAgICAgYnVmZltvZmZzZXQgKyA0XSA9IHkgPj4gODtcbiAgICAgICAgYnVmZltvZmZzZXQgKyA1XSA9IHk7XG5cbiAgICAgICAgc29jay5fc1FsZW4gKz0gNjtcbiAgICAgICAgc29jay5mbHVzaCgpO1xuICAgIH0sXG5cbiAgICAvLyBUT0RPKGRpcmVjdHhtYW4xMik6IG1ha2UgdGhpcyB1bmljb2RlIGNvbXBhdGlibGU/XG4gICAgY2xpZW50Q3V0VGV4dChzb2NrLCB0ZXh0KSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBzb2NrLl9zUTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc29jay5fc1FsZW47XG5cbiAgICAgICAgYnVmZltvZmZzZXRdID0gNjsgLy8gbXNnLXR5cGVcblxuICAgICAgICBidWZmW29mZnNldCArIDFdID0gMDsgLy8gcGFkZGluZ1xuICAgICAgICBidWZmW29mZnNldCArIDJdID0gMDsgLy8gcGFkZGluZ1xuICAgICAgICBidWZmW29mZnNldCArIDNdID0gMDsgLy8gcGFkZGluZ1xuXG4gICAgICAgIGxldCBsZW5ndGggPSB0ZXh0Lmxlbmd0aDtcblxuICAgICAgICBidWZmW29mZnNldCArIDRdID0gbGVuZ3RoID4+IDI0O1xuICAgICAgICBidWZmW29mZnNldCArIDVdID0gbGVuZ3RoID4+IDE2O1xuICAgICAgICBidWZmW29mZnNldCArIDZdID0gbGVuZ3RoID4+IDg7XG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgN10gPSBsZW5ndGg7XG5cbiAgICAgICAgc29jay5fc1FsZW4gKz0gODtcblxuICAgICAgICAvLyBXZSBoYXZlIHRvIGtlZXAgdHJhY2sgb2YgZnJvbSB3aGVyZSBpbiB0aGUgdGV4dCB3ZSBiZWdpbiBjcmVhdGluZyB0aGVcbiAgICAgICAgLy8gYnVmZmVyIGZvciB0aGUgZmx1c2ggaW4gdGhlIG5leHQgaXRlcmF0aW9uLlxuICAgICAgICBsZXQgdGV4dE9mZnNldCA9IDA7XG5cbiAgICAgICAgbGV0IHJlbWFpbmluZyA9IGxlbmd0aDtcbiAgICAgICAgd2hpbGUgKHJlbWFpbmluZyA+IDApIHtcblxuICAgICAgICAgICAgbGV0IGZsdXNoU2l6ZSA9IE1hdGgubWluKHJlbWFpbmluZywgKHNvY2suX3NRYnVmZmVyU2l6ZSAtIHNvY2suX3NRbGVuKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGZsdXNoU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYnVmZltzb2NrLl9zUWxlbiArIGldID0gIHRleHQuY2hhckNvZGVBdCh0ZXh0T2Zmc2V0ICsgaSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHNvY2suX3NRbGVuICs9IGZsdXNoU2l6ZTtcbiAgICAgICAgICAgIHNvY2suZmx1c2goKTtcblxuICAgICAgICAgICAgcmVtYWluaW5nIC09IGZsdXNoU2l6ZTtcbiAgICAgICAgICAgIHRleHRPZmZzZXQgKz0gZmx1c2hTaXplO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIHNldERlc2t0b3BTaXplKHNvY2ssIHdpZHRoLCBoZWlnaHQsIGlkLCBmbGFncykge1xuICAgICAgICBjb25zdCBidWZmID0gc29jay5fc1E7XG4gICAgICAgIGNvbnN0IG9mZnNldCA9IHNvY2suX3NRbGVuO1xuXG4gICAgICAgIGJ1ZmZbb2Zmc2V0XSA9IDI1MTsgICAgICAgICAgICAgIC8vIG1zZy10eXBlXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgMV0gPSAwOyAgICAgICAgICAgIC8vIHBhZGRpbmdcbiAgICAgICAgYnVmZltvZmZzZXQgKyAyXSA9IHdpZHRoID4+IDg7ICAgLy8gd2lkdGhcbiAgICAgICAgYnVmZltvZmZzZXQgKyAzXSA9IHdpZHRoO1xuICAgICAgICBidWZmW29mZnNldCArIDRdID0gaGVpZ2h0ID4+IDg7ICAvLyBoZWlnaHRcbiAgICAgICAgYnVmZltvZmZzZXQgKyA1XSA9IGhlaWdodDtcblxuICAgICAgICBidWZmW29mZnNldCArIDZdID0gMTsgICAgICAgICAgICAvLyBudW1iZXItb2Ytc2NyZWVuc1xuICAgICAgICBidWZmW29mZnNldCArIDddID0gMDsgICAgICAgICAgICAvLyBwYWRkaW5nXG5cbiAgICAgICAgLy8gc2NyZWVuIGFycmF5XG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgOF0gPSBpZCA+PiAyNDsgICAgIC8vIGlkXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgOV0gPSBpZCA+PiAxNjtcbiAgICAgICAgYnVmZltvZmZzZXQgKyAxMF0gPSBpZCA+PiA4O1xuICAgICAgICBidWZmW29mZnNldCArIDExXSA9IGlkO1xuICAgICAgICBidWZmW29mZnNldCArIDEyXSA9IDA7ICAgICAgICAgICAvLyB4LXBvc2l0aW9uXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgMTNdID0gMDtcbiAgICAgICAgYnVmZltvZmZzZXQgKyAxNF0gPSAwOyAgICAgICAgICAgLy8geS1wb3NpdGlvblxuICAgICAgICBidWZmW29mZnNldCArIDE1XSA9IDA7XG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgMTZdID0gd2lkdGggPj4gODsgIC8vIHdpZHRoXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgMTddID0gd2lkdGg7XG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgMThdID0gaGVpZ2h0ID4+IDg7IC8vIGhlaWdodFxuICAgICAgICBidWZmW29mZnNldCArIDE5XSA9IGhlaWdodDtcbiAgICAgICAgYnVmZltvZmZzZXQgKyAyMF0gPSBmbGFncyA+PiAyNDsgLy8gZmxhZ3NcbiAgICAgICAgYnVmZltvZmZzZXQgKyAyMV0gPSBmbGFncyA+PiAxNjtcbiAgICAgICAgYnVmZltvZmZzZXQgKyAyMl0gPSBmbGFncyA+PiA4O1xuICAgICAgICBidWZmW29mZnNldCArIDIzXSA9IGZsYWdzO1xuXG4gICAgICAgIHNvY2suX3NRbGVuICs9IDI0O1xuICAgICAgICBzb2NrLmZsdXNoKCk7XG4gICAgfSxcblxuICAgIGNsaWVudEZlbmNlKHNvY2ssIGZsYWdzLCBwYXlsb2FkKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBzb2NrLl9zUTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc29jay5fc1FsZW47XG5cbiAgICAgICAgYnVmZltvZmZzZXRdID0gMjQ4OyAvLyBtc2ctdHlwZVxuXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgMV0gPSAwOyAvLyBwYWRkaW5nXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgMl0gPSAwOyAvLyBwYWRkaW5nXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgM10gPSAwOyAvLyBwYWRkaW5nXG5cbiAgICAgICAgYnVmZltvZmZzZXQgKyA0XSA9IGZsYWdzID4+IDI0OyAvLyBmbGFnc1xuICAgICAgICBidWZmW29mZnNldCArIDVdID0gZmxhZ3MgPj4gMTY7XG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgNl0gPSBmbGFncyA+PiA4O1xuICAgICAgICBidWZmW29mZnNldCArIDddID0gZmxhZ3M7XG5cbiAgICAgICAgY29uc3QgbiA9IHBheWxvYWQubGVuZ3RoO1xuXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgOF0gPSBuOyAvLyBsZW5ndGhcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG47IGkrKykge1xuICAgICAgICAgICAgYnVmZltvZmZzZXQgKyA5ICsgaV0gPSBwYXlsb2FkLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIH1cblxuICAgICAgICBzb2NrLl9zUWxlbiArPSA5ICsgbjtcbiAgICAgICAgc29jay5mbHVzaCgpO1xuICAgIH0sXG5cbiAgICBlbmFibGVDb250aW51b3VzVXBkYXRlcyhzb2NrLCBlbmFibGUsIHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IHNvY2suX3NRO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBzb2NrLl9zUWxlbjtcblxuICAgICAgICBidWZmW29mZnNldF0gPSAxNTA7ICAgICAgICAgICAgIC8vIG1zZy10eXBlXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgMV0gPSBlbmFibGU7ICAgICAgLy8gZW5hYmxlLWZsYWdcblxuICAgICAgICBidWZmW29mZnNldCArIDJdID0geCA+PiA4OyAgICAgIC8vIHhcbiAgICAgICAgYnVmZltvZmZzZXQgKyAzXSA9IHg7XG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgNF0gPSB5ID4+IDg7ICAgICAgLy8geVxuICAgICAgICBidWZmW29mZnNldCArIDVdID0geTtcbiAgICAgICAgYnVmZltvZmZzZXQgKyA2XSA9IHdpZHRoID4+IDg7ICAvLyB3aWR0aFxuICAgICAgICBidWZmW29mZnNldCArIDddID0gd2lkdGg7XG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgOF0gPSBoZWlnaHQgPj4gODsgLy8gaGVpZ2h0XG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgOV0gPSBoZWlnaHQ7XG5cbiAgICAgICAgc29jay5fc1FsZW4gKz0gMTA7XG4gICAgICAgIHNvY2suZmx1c2goKTtcbiAgICB9LFxuXG4gICAgcGl4ZWxGb3JtYXQoc29jaywgZGVwdGgsIHRydWVfY29sb3IpIHtcbiAgICAgICAgY29uc3QgYnVmZiA9IHNvY2suX3NRO1xuICAgICAgICBjb25zdCBvZmZzZXQgPSBzb2NrLl9zUWxlbjtcblxuICAgICAgICBsZXQgYnBwO1xuXG4gICAgICAgIGlmIChkZXB0aCA+IDE2KSB7XG4gICAgICAgICAgICBicHAgPSAzMjtcbiAgICAgICAgfSBlbHNlIGlmIChkZXB0aCA+IDgpIHtcbiAgICAgICAgICAgIGJwcCA9IDE2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnBwID0gODtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJpdHMgPSBNYXRoLmZsb29yKGRlcHRoLzMpO1xuXG4gICAgICAgIGJ1ZmZbb2Zmc2V0XSA9IDA7ICAvLyBtc2ctdHlwZVxuXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgMV0gPSAwOyAvLyBwYWRkaW5nXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgMl0gPSAwOyAvLyBwYWRkaW5nXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgM10gPSAwOyAvLyBwYWRkaW5nXG5cbiAgICAgICAgYnVmZltvZmZzZXQgKyA0XSA9IGJwcDsgICAgICAgICAgICAgICAgIC8vIGJpdHMtcGVyLXBpeGVsXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgNV0gPSBkZXB0aDsgICAgICAgICAgICAgICAvLyBkZXB0aFxuICAgICAgICBidWZmW29mZnNldCArIDZdID0gMDsgICAgICAgICAgICAgICAgICAgLy8gbGl0dGxlLWVuZGlhblxuICAgICAgICBidWZmW29mZnNldCArIDddID0gdHJ1ZV9jb2xvciA/IDEgOiAwOyAgLy8gdHJ1ZS1jb2xvclxuXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgOF0gPSAwOyAgICAvLyByZWQtbWF4XG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgOV0gPSAoMSA8PCBiaXRzKSAtIDE7ICAvLyByZWQtbWF4XG5cbiAgICAgICAgYnVmZltvZmZzZXQgKyAxMF0gPSAwOyAgIC8vIGdyZWVuLW1heFxuICAgICAgICBidWZmW29mZnNldCArIDExXSA9ICgxIDw8IGJpdHMpIC0gMTsgLy8gZ3JlZW4tbWF4XG5cbiAgICAgICAgYnVmZltvZmZzZXQgKyAxMl0gPSAwOyAgIC8vIGJsdWUtbWF4XG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgMTNdID0gKDEgPDwgYml0cykgLSAxOyAvLyBibHVlLW1heFxuXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgMTRdID0gYml0cyAqIDI7IC8vIHJlZC1zaGlmdFxuICAgICAgICBidWZmW29mZnNldCArIDE1XSA9IGJpdHMgKiAxOyAvLyBncmVlbi1zaGlmdFxuICAgICAgICBidWZmW29mZnNldCArIDE2XSA9IGJpdHMgKiAwOyAvLyBibHVlLXNoaWZ0XG5cbiAgICAgICAgYnVmZltvZmZzZXQgKyAxN10gPSAwOyAgIC8vIHBhZGRpbmdcbiAgICAgICAgYnVmZltvZmZzZXQgKyAxOF0gPSAwOyAgIC8vIHBhZGRpbmdcbiAgICAgICAgYnVmZltvZmZzZXQgKyAxOV0gPSAwOyAgIC8vIHBhZGRpbmdcblxuICAgICAgICBzb2NrLl9zUWxlbiArPSAyMDtcbiAgICAgICAgc29jay5mbHVzaCgpO1xuICAgIH0sXG5cbiAgICBjbGllbnRFbmNvZGluZ3Moc29jaywgZW5jb2RpbmdzKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBzb2NrLl9zUTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc29jay5fc1FsZW47XG5cbiAgICAgICAgYnVmZltvZmZzZXRdID0gMjsgLy8gbXNnLXR5cGVcbiAgICAgICAgYnVmZltvZmZzZXQgKyAxXSA9IDA7IC8vIHBhZGRpbmdcblxuICAgICAgICBidWZmW29mZnNldCArIDJdID0gZW5jb2RpbmdzLmxlbmd0aCA+PiA4O1xuICAgICAgICBidWZmW29mZnNldCArIDNdID0gZW5jb2RpbmdzLmxlbmd0aDtcblxuICAgICAgICBsZXQgaiA9IG9mZnNldCArIDQ7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2RpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBlbmMgPSBlbmNvZGluZ3NbaV07XG4gICAgICAgICAgICBidWZmW2pdID0gZW5jID4+IDI0O1xuICAgICAgICAgICAgYnVmZltqICsgMV0gPSBlbmMgPj4gMTY7XG4gICAgICAgICAgICBidWZmW2ogKyAyXSA9IGVuYyA+PiA4O1xuICAgICAgICAgICAgYnVmZltqICsgM10gPSBlbmM7XG5cbiAgICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgfVxuXG4gICAgICAgIHNvY2suX3NRbGVuICs9IGogLSBvZmZzZXQ7XG4gICAgICAgIHNvY2suZmx1c2goKTtcbiAgICB9LFxuXG4gICAgZmJVcGRhdGVSZXF1ZXN0KHNvY2ssIGluY3JlbWVudGFsLCB4LCB5LCB3LCBoKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBzb2NrLl9zUTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc29jay5fc1FsZW47XG5cbiAgICAgICAgaWYgKHR5cGVvZih4KSA9PT0gXCJ1bmRlZmluZWRcIikgeyB4ID0gMDsgfVxuICAgICAgICBpZiAodHlwZW9mKHkpID09PSBcInVuZGVmaW5lZFwiKSB7IHkgPSAwOyB9XG5cbiAgICAgICAgYnVmZltvZmZzZXRdID0gMzsgIC8vIG1zZy10eXBlXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgMV0gPSBpbmNyZW1lbnRhbCA/IDEgOiAwO1xuXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgMl0gPSAoeCA+PiA4KSAmIDB4RkY7XG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgM10gPSB4ICYgMHhGRjtcblxuICAgICAgICBidWZmW29mZnNldCArIDRdID0gKHkgPj4gOCkgJiAweEZGO1xuICAgICAgICBidWZmW29mZnNldCArIDVdID0geSAmIDB4RkY7XG5cbiAgICAgICAgYnVmZltvZmZzZXQgKyA2XSA9ICh3ID4+IDgpICYgMHhGRjtcbiAgICAgICAgYnVmZltvZmZzZXQgKyA3XSA9IHcgJiAweEZGO1xuXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgOF0gPSAoaCA+PiA4KSAmIDB4RkY7XG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgOV0gPSBoICYgMHhGRjtcblxuICAgICAgICBzb2NrLl9zUWxlbiArPSAxMDtcbiAgICAgICAgc29jay5mbHVzaCgpO1xuICAgIH0sXG5cbiAgICB4dnBPcChzb2NrLCB2ZXIsIG9wKSB7XG4gICAgICAgIGNvbnN0IGJ1ZmYgPSBzb2NrLl9zUTtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gc29jay5fc1FsZW47XG5cbiAgICAgICAgYnVmZltvZmZzZXRdID0gMjUwOyAvLyBtc2ctdHlwZVxuICAgICAgICBidWZmW29mZnNldCArIDFdID0gMDsgLy8gcGFkZGluZ1xuXG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgMl0gPSB2ZXI7XG4gICAgICAgIGJ1ZmZbb2Zmc2V0ICsgM10gPSBvcDtcblxuICAgICAgICBzb2NrLl9zUWxlbiArPSA0O1xuICAgICAgICBzb2NrLmZsdXNoKCk7XG4gICAgfVxufTtcblxuUkZCLmN1cnNvcnMgPSB7XG4gICAgbm9uZToge1xuICAgICAgICByZ2JhUGl4ZWxzOiBuZXcgVWludDhBcnJheSgpLFxuICAgICAgICB3OiAwLCBoOiAwLFxuICAgICAgICBob3R4OiAwLCBob3R5OiAwLFxuICAgIH0sXG5cbiAgICBkb3Q6IHtcbiAgICAgICAgLyogZXNsaW50LWRpc2FibGUgaW5kZW50ICovXG4gICAgICAgIHJnYmFQaXhlbHM6IG5ldyBVaW50OEFycmF5KFtcbiAgICAgICAgICAgIDI1NSwgMjU1LCAyNTUsIDI1NSwgICAwLCAgIDAsICAgMCwgMjU1LCAyNTUsIDI1NSwgMjU1LCAyNTUsXG4gICAgICAgICAgICAgIDAsICAgMCwgICAwLCAyNTUsICAgMCwgICAwLCAgIDAsICAgMCwgICAwLCAgIDAsICAwLCAgMjU1LFxuICAgICAgICAgICAgMjU1LCAyNTUsIDI1NSwgMjU1LCAgIDAsICAgMCwgICAwLCAyNTUsIDI1NSwgMjU1LCAyNTUsIDI1NSxcbiAgICAgICAgXSksXG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgaW5kZW50ICovXG4gICAgICAgIHc6IDMsIGg6IDMsXG4gICAgICAgIGhvdHg6IDEsIGhvdHk6IDEsXG4gICAgfVxufTtcbiIsIi8qXG4gKiBub1ZOQzogSFRNTDUgVk5DIGNsaWVudFxuICogQ29weXJpZ2h0IChDKSAyMDE4IFRoZSBub1ZOQyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciBNUEwgMi4wIChzZWUgTElDRU5TRS50eHQpXG4gKlxuICogU2VlIFJFQURNRS5tZCBmb3IgdXNhZ2UgYW5kIGludGVncmF0aW9uIGluc3RydWN0aW9ucy5cbiAqL1xuXG5pbXBvcnQgKiBhcyBMb2cgZnJvbSAnLi9sb2dnaW5nLmpzJztcblxuLy8gVG91Y2ggZGV0ZWN0aW9uXG5leHBvcnQgbGV0IGlzVG91Y2hEZXZpY2UgPSAoJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVxdXJpZWQgZm9yIENocm9tZSBkZWJ1Z2dlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGRvY3VtZW50Lm9udG91Y2hzdGFydCAhPT0gdW5kZWZpbmVkKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVxdWlyZWQgZm9yIE1TIFN1cmZhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChuYXZpZ2F0b3IubWF4VG91Y2hQb2ludHMgPiAwKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKG5hdmlnYXRvci5tc01heFRvdWNoUG9pbnRzID4gMCk7XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIGZ1bmN0aW9uIG9uRmlyc3RUb3VjaCgpIHtcbiAgICBpc1RvdWNoRGV2aWNlID0gdHJ1ZTtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIG9uRmlyc3RUb3VjaCwgZmFsc2UpO1xufSwgZmFsc2UpO1xuXG5cbi8vIFRoZSBnb2FsIGlzIHRvIGZpbmQgYSBjZXJ0YWluIHBoeXNpY2FsIHdpZHRoLCB0aGUgZGV2aWNlUGl4ZWxSYXRpb1xuLy8gYnJpbmdzIHVzIGEgYml0IGNsb3NlciBidXQgaXMgbm90IG9wdGltYWwuXG5leHBvcnQgbGV0IGRyYWdUaHJlc2hvbGQgPSAxMCAqICh3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKTtcblxubGV0IF9zdXBwb3J0c0N1cnNvclVSSXMgPSBmYWxzZTtcblxudHJ5IHtcbiAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICB0YXJnZXQuc3R5bGUuY3Vyc29yID0gJ3VybChcImRhdGE6aW1hZ2UveC1pY29uO2Jhc2U2NCxBQUFDQUFFQUNBZ0FBQUlBQWdBNEFRQUFGZ0FBQUNnQUFBQUlBQUFBRUFBQUFBRUFJQUFBQUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBRC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vQUFBQUFBQUFBQUFBQUFBQUFBQUFBQT09XCIpIDIgMiwgZGVmYXVsdCc7XG5cbiAgICBpZiAodGFyZ2V0LnN0eWxlLmN1cnNvcikge1xuICAgICAgICBMb2cuSW5mbyhcIkRhdGEgVVJJIHNjaGVtZSBjdXJzb3Igc3VwcG9ydGVkXCIpO1xuICAgICAgICBfc3VwcG9ydHNDdXJzb3JVUklzID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBMb2cuV2FybihcIkRhdGEgVVJJIHNjaGVtZSBjdXJzb3Igbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9XG59IGNhdGNoIChleGMpIHtcbiAgICBMb2cuRXJyb3IoXCJEYXRhIFVSSSBzY2hlbWUgY3Vyc29yIHRlc3QgZXhjZXB0aW9uOiBcIiArIGV4Yyk7XG59XG5cbmV4cG9ydCBjb25zdCBzdXBwb3J0c0N1cnNvclVSSXMgPSBfc3VwcG9ydHNDdXJzb3JVUklzO1xuXG5sZXQgX3N1cHBvcnRzSW1hZ2VNZXRhZGF0YSA9IGZhbHNlO1xudHJ5IHtcbiAgICBuZXcgSW1hZ2VEYXRhKG5ldyBVaW50OENsYW1wZWRBcnJheSg0KSwgMSwgMSk7XG4gICAgX3N1cHBvcnRzSW1hZ2VNZXRhZGF0YSA9IHRydWU7XG59IGNhdGNoIChleCkge1xuICAgIC8vIGlnbm9yZSBmYWlsdXJlXG59XG5leHBvcnQgY29uc3Qgc3VwcG9ydHNJbWFnZU1ldGFkYXRhID0gX3N1cHBvcnRzSW1hZ2VNZXRhZGF0YTtcblxuZXhwb3J0IGZ1bmN0aW9uIGlzTWFjKCkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IgJiYgISEoL21hYy9pKS5leGVjKG5hdmlnYXRvci5wbGF0Zm9ybSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1dpbmRvd3MoKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvciAmJiAhISgvd2luL2kpLmV4ZWMobmF2aWdhdG9yLnBsYXRmb3JtKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzSU9TKCkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IgJiZcbiAgICAgICAgICAgKCEhKC9pcGFkL2kpLmV4ZWMobmF2aWdhdG9yLnBsYXRmb3JtKSB8fFxuICAgICAgICAgICAgISEoL2lwaG9uZS9pKS5leGVjKG5hdmlnYXRvci5wbGF0Zm9ybSkgfHxcbiAgICAgICAgICAgICEhKC9pcG9kL2kpLmV4ZWMobmF2aWdhdG9yLnBsYXRmb3JtKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0FuZHJvaWQoKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvciAmJiAhISgvYW5kcm9pZC9pKS5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNTYWZhcmkoKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvciAmJiAobmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdTYWZhcmknKSAhPT0gLTEgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICBuYXZpZ2F0b3IudXNlckFnZW50LmluZGV4T2YoJ0Nocm9tZScpID09PSAtMSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0lFKCkge1xuICAgIHJldHVybiBuYXZpZ2F0b3IgJiYgISEoL3RyaWRlbnQvaSkuZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRWRnZSgpIHtcbiAgICByZXR1cm4gbmF2aWdhdG9yICYmICEhKC9lZGdlL2kpLmV4ZWMobmF2aWdhdG9yLnVzZXJBZ2VudCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpc0ZpcmVmb3goKSB7XG4gICAgcmV0dXJuIG5hdmlnYXRvciAmJiAhISgvZmlyZWZveC9pKS5leGVjKG5hdmlnYXRvci51c2VyQWdlbnQpO1xufVxuXG4iLCIvKlxuICogbm9WTkM6IEhUTUw1IFZOQyBjbGllbnRcbiAqIENvcHlyaWdodCAoQykgMjAxOCBUaGUgbm9WTkMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgTVBMIDIuMCBvciBhbnkgbGF0ZXIgdmVyc2lvbiAoc2VlIExJQ0VOU0UudHh0KVxuICovXG5cbmltcG9ydCB7IHN1cHBvcnRzQ3Vyc29yVVJJcywgaXNUb3VjaERldmljZSB9IGZyb20gJy4vYnJvd3Nlci5qcyc7XG5cbmNvbnN0IHVzZUZhbGxiYWNrID0gIXN1cHBvcnRzQ3Vyc29yVVJJcyB8fCBpc1RvdWNoRGV2aWNlO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDdXJzb3Ige1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl90YXJnZXQgPSBudWxsO1xuXG4gICAgICAgIHRoaXMuX2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2NhbnZhcycpO1xuXG4gICAgICAgIGlmICh1c2VGYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLnBvc2l0aW9uID0gJ2ZpeGVkJztcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS56SW5kZXggPSAnNjU1MzUnO1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLnBvaW50ZXJFdmVudHMgPSAnbm9uZSc7XG4gICAgICAgICAgICAvLyBDYW4ndCB1c2UgXCJkaXNwbGF5XCIgYmVjYXVzZSBvZiBGaXJlZm94IGJ1ZyAjMTQ0NTk5N1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodGhpcy5fY2FudmFzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uID0geyB4OiAwLCB5OiAwIH07XG4gICAgICAgIHRoaXMuX2hvdFNwb3QgPSB7IHg6IDAsIHk6IDAgfTtcblxuICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXJzID0ge1xuICAgICAgICAgICAgJ21vdXNlb3Zlcic6IHRoaXMuX2hhbmRsZU1vdXNlT3Zlci5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgJ21vdXNlbGVhdmUnOiB0aGlzLl9oYW5kbGVNb3VzZUxlYXZlLmJpbmQodGhpcyksXG4gICAgICAgICAgICAnbW91c2Vtb3ZlJzogdGhpcy5faGFuZGxlTW91c2VNb3ZlLmJpbmQodGhpcyksXG4gICAgICAgICAgICAnbW91c2V1cCc6IHRoaXMuX2hhbmRsZU1vdXNlVXAuYmluZCh0aGlzKSxcbiAgICAgICAgICAgICd0b3VjaHN0YXJ0JzogdGhpcy5faGFuZGxlVG91Y2hTdGFydC5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgJ3RvdWNobW92ZSc6IHRoaXMuX2hhbmRsZVRvdWNoTW92ZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgJ3RvdWNoZW5kJzogdGhpcy5faGFuZGxlVG91Y2hFbmQuYmluZCh0aGlzKSxcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBhdHRhY2godGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl90YXJnZXQpIHtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XG5cbiAgICAgICAgaWYgKHVzZUZhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBGSVhNRTogVGhlc2UgZG9uJ3QgZmlyZSBwcm9wZXJseSBleGNlcHQgZm9yIG1vdXNlXG4gICAgICAgICAgICAvLy8gICAgICAgbW92ZW1lbnQgaW4gSUUuIFdlIHdhbnQgdG8gYWxzbyBjYXB0dXJlIGVsZW1lbnRcbiAgICAgICAgICAgIC8vICAgICAgICBtb3ZlbWVudCwgc2l6ZSBjaGFuZ2VzLCB2aXNpYmlsaXR5LCBldGMuXG4gICAgICAgICAgICBjb25zdCBvcHRpb25zID0geyBjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiB0cnVlIH07XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VvdmVyJywgdGhpcy5fZXZlbnRIYW5kbGVycy5tb3VzZW92ZXIsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCB0aGlzLl9ldmVudEhhbmRsZXJzLm1vdXNlbGVhdmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIHRoaXMuX2V2ZW50SGFuZGxlcnMubW91c2Vtb3ZlLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgdGhpcy5fZXZlbnRIYW5kbGVycy5tb3VzZXVwLCBvcHRpb25zKTtcblxuICAgICAgICAgICAgLy8gVGhlcmUgaXMgbm8gXCJ0b3VjaGxlYXZlXCIgc28gd2UgbW9uaXRvciB0b3VjaHN0YXJ0IGdsb2JhbGx5XG4gICAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2V2ZW50SGFuZGxlcnMudG91Y2hzdGFydCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fZXZlbnRIYW5kbGVycy50b3VjaG1vdmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fZXZlbnRIYW5kbGVycy50b3VjaGVuZCwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgfVxuXG4gICAgZGV0YWNoKCkge1xuICAgICAgICBpZiAodXNlRmFsbGJhY2spIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IGNhcHR1cmU6IHRydWUsIHBhc3NpdmU6IHRydWUgfTtcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCB0aGlzLl9ldmVudEhhbmRsZXJzLm1vdXNlb3Zlciwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIHRoaXMuX2V2ZW50SGFuZGxlcnMubW91c2VsZWF2ZSwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgdGhpcy5fZXZlbnRIYW5kbGVycy5tb3VzZW1vdmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCB0aGlzLl9ldmVudEhhbmRsZXJzLm1vdXNldXAsIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hzdGFydCcsIHRoaXMuX2V2ZW50SGFuZGxlcnMudG91Y2hzdGFydCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2htb3ZlJywgdGhpcy5fZXZlbnRIYW5kbGVycy50b3VjaG1vdmUsIG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RvdWNoZW5kJywgdGhpcy5fZXZlbnRIYW5kbGVycy50b3VjaGVuZCwgb3B0aW9ucyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl90YXJnZXQgPSBudWxsO1xuICAgIH1cblxuICAgIGNoYW5nZShyZ2JhLCBob3R4LCBob3R5LCB3LCBoKSB7XG4gICAgICAgIGlmICgodyA9PT0gMCkgfHwgKGggPT09IDApKSB7XG4gICAgICAgICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9wb3NpdGlvbi54ID0gdGhpcy5fcG9zaXRpb24ueCArIHRoaXMuX2hvdFNwb3QueCAtIGhvdHg7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uLnkgPSB0aGlzLl9wb3NpdGlvbi55ICsgdGhpcy5faG90U3BvdC55IC0gaG90eTtcbiAgICAgICAgdGhpcy5faG90U3BvdC54ID0gaG90eDtcbiAgICAgICAgdGhpcy5faG90U3BvdC55ID0gaG90eTtcblxuICAgICAgICBsZXQgY3R4ID0gdGhpcy5fY2FudmFzLmdldENvbnRleHQoJzJkJyk7XG5cbiAgICAgICAgdGhpcy5fY2FudmFzLndpZHRoID0gdztcbiAgICAgICAgdGhpcy5fY2FudmFzLmhlaWdodCA9IGg7XG5cbiAgICAgICAgbGV0IGltZztcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIElFIGRvZXNuJ3Qgc3VwcG9ydCB0aGlzXG4gICAgICAgICAgICBpbWcgPSBuZXcgSW1hZ2VEYXRhKG5ldyBVaW50OENsYW1wZWRBcnJheShyZ2JhKSwgdywgaCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICBpbWcgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKHcsIGgpO1xuICAgICAgICAgICAgaW1nLmRhdGEuc2V0KG5ldyBVaW50OENsYW1wZWRBcnJheShyZ2JhKSk7XG4gICAgICAgIH1cbiAgICAgICAgY3R4LmNsZWFyUmVjdCgwLCAwLCB3LCBoKTtcbiAgICAgICAgY3R4LnB1dEltYWdlRGF0YShpbWcsIDAsIDApO1xuXG4gICAgICAgIGlmICh1c2VGYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fdXBkYXRlUG9zaXRpb24oKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxldCB1cmwgPSB0aGlzLl9jYW52YXMudG9EYXRhVVJMKCk7XG4gICAgICAgICAgICB0aGlzLl90YXJnZXQuc3R5bGUuY3Vyc29yID0gJ3VybCgnICsgdXJsICsgJyknICsgaG90eCArICcgJyArIGhvdHkgKyAnLCBkZWZhdWx0JztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLl90YXJnZXQuc3R5bGUuY3Vyc29yID0gJ25vbmUnO1xuICAgICAgICB0aGlzLl9jYW52YXMud2lkdGggPSAwO1xuICAgICAgICB0aGlzLl9jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgdGhpcy5fcG9zaXRpb24ueCA9IHRoaXMuX3Bvc2l0aW9uLnggKyB0aGlzLl9ob3RTcG90Lng7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uLnkgPSB0aGlzLl9wb3NpdGlvbi55ICsgdGhpcy5faG90U3BvdC55O1xuICAgICAgICB0aGlzLl9ob3RTcG90LnggPSAwO1xuICAgICAgICB0aGlzLl9ob3RTcG90LnkgPSAwO1xuICAgIH1cblxuICAgIF9oYW5kbGVNb3VzZU92ZXIoZXZlbnQpIHtcbiAgICAgICAgLy8gVGhpcyBldmVudCBjb3VsZCBiZSBiZWNhdXNlIHdlJ3JlIGVudGVyaW5nIHRoZSB0YXJnZXQsIG9yXG4gICAgICAgIC8vIG1vdmluZyBhcm91bmQgYW1vbmdzdCBpdHMgc3ViIGVsZW1lbnRzLiBMZXQgdGhlIG1vdmUgaGFuZGxlclxuICAgICAgICAvLyBzb3J0IHRoaW5ncyBvdXQuXG4gICAgICAgIHRoaXMuX2hhbmRsZU1vdXNlTW92ZShldmVudCk7XG4gICAgfVxuXG4gICAgX2hhbmRsZU1vdXNlTGVhdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5faGlkZUN1cnNvcigpO1xuICAgIH1cblxuICAgIF9oYW5kbGVNb3VzZU1vdmUoZXZlbnQpIHtcbiAgICAgICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eShldmVudC50YXJnZXQpO1xuXG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uLnggPSBldmVudC5jbGllbnRYIC0gdGhpcy5faG90U3BvdC54O1xuICAgICAgICB0aGlzLl9wb3NpdGlvbi55ID0gZXZlbnQuY2xpZW50WSAtIHRoaXMuX2hvdFNwb3QueTtcblxuICAgICAgICB0aGlzLl91cGRhdGVQb3NpdGlvbigpO1xuICAgIH1cblxuICAgIF9oYW5kbGVNb3VzZVVwKGV2ZW50KSB7XG4gICAgICAgIC8vIFdlIG1pZ2h0IGdldCB0aGlzIGV2ZW50IGJlY2F1c2Ugb2YgYSBkcmFnIG9wZXJhdGlvbiB0aGF0XG4gICAgICAgIC8vIG1vdmVkIG91dHNpZGUgb2YgdGhlIHRhcmdldC4gQ2hlY2sgd2hhdCdzIHVuZGVyIHRoZSBjdXJzb3JcbiAgICAgICAgLy8gbm93IGFuZCBhZGp1c3QgdmlzaWJpbGl0eSBiYXNlZCBvbiB0aGF0LlxuICAgICAgICBsZXQgdGFyZ2V0ID0gZG9jdW1lbnQuZWxlbWVudEZyb21Qb2ludChldmVudC5jbGllbnRYLCBldmVudC5jbGllbnRZKTtcbiAgICAgICAgdGhpcy5fdXBkYXRlVmlzaWJpbGl0eSh0YXJnZXQpO1xuICAgIH1cblxuICAgIF9oYW5kbGVUb3VjaFN0YXJ0KGV2ZW50KSB7XG4gICAgICAgIC8vIEp1c3QgYXMgZm9yIG1vdXNlb3Zlciwgd2UgbGV0IHRoZSBtb3ZlIGhhbmRsZXIgZGVhbCB3aXRoIGl0XG4gICAgICAgIHRoaXMuX2hhbmRsZVRvdWNoTW92ZShldmVudCk7XG4gICAgfVxuXG4gICAgX2hhbmRsZVRvdWNoTW92ZShldmVudCkge1xuICAgICAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KGV2ZW50LnRhcmdldCk7XG5cbiAgICAgICAgdGhpcy5fcG9zaXRpb24ueCA9IGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFggLSB0aGlzLl9ob3RTcG90Lng7XG4gICAgICAgIHRoaXMuX3Bvc2l0aW9uLnkgPSBldmVudC5jaGFuZ2VkVG91Y2hlc1swXS5jbGllbnRZIC0gdGhpcy5faG90U3BvdC55O1xuXG4gICAgICAgIHRoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7XG4gICAgfVxuXG4gICAgX2hhbmRsZVRvdWNoRW5kKGV2ZW50KSB7XG4gICAgICAgIC8vIFNhbWUgcHJpbmNpcGxlIGFzIGZvciBtb3VzZXVwXG4gICAgICAgIGxldCB0YXJnZXQgPSBkb2N1bWVudC5lbGVtZW50RnJvbVBvaW50KGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmNoYW5nZWRUb3VjaGVzWzBdLmNsaWVudFkpO1xuICAgICAgICB0aGlzLl91cGRhdGVWaXNpYmlsaXR5KHRhcmdldCk7XG4gICAgfVxuXG4gICAgX3Nob3dDdXJzb3IoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jYW52YXMuc3R5bGUudmlzaWJpbGl0eSA9PT0gJ2hpZGRlbicpIHtcbiAgICAgICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS52aXNpYmlsaXR5ID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBfaGlkZUN1cnNvcigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NhbnZhcy5zdHlsZS52aXNpYmlsaXR5ICE9PSAnaGlkZGVuJykge1xuICAgICAgICAgICAgdGhpcy5fY2FudmFzLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNob3VsZCB3ZSBjdXJyZW50bHkgZGlzcGxheSB0aGUgY3Vyc29yP1xuICAgIC8vIChpLmUuIGFyZSB3ZSBvdmVyIHRoZSB0YXJnZXQsIG9yIGEgY2hpbGQgb2YgdGhlIHRhcmdldCB3aXRob3V0IGFcbiAgICAvLyBkaWZmZXJlbnQgY3Vyc29yIHNldClcbiAgICBfc2hvdWxkU2hvd0N1cnNvcih0YXJnZXQpIHtcbiAgICAgICAgLy8gRWFzeSBjYXNlXG4gICAgICAgIGlmICh0YXJnZXQgPT09IHRoaXMuX3RhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gT3RoZXIgcGFydCBvZiB0aGUgRE9NP1xuICAgICAgICBpZiAoIXRoaXMuX3RhcmdldC5jb250YWlucyh0YXJnZXQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSGFzIHRoZSBjaGlsZCBpdHMgb3duIGN1cnNvcj9cbiAgICAgICAgLy8gRklYTUU6IEhvdyBjYW4gd2UgdGVsbCB0aGF0IGEgc3ViIGVsZW1lbnQgaGFzIGFuXG4gICAgICAgIC8vICAgICAgICBleHBsaWNpdCBcImN1cnNvcjogbm9uZTtcIj9cbiAgICAgICAgaWYgKHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKHRhcmdldCkuY3Vyc29yICE9PSAnbm9uZScpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBfdXBkYXRlVmlzaWJpbGl0eSh0YXJnZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZFNob3dDdXJzb3IodGFyZ2V0KSkge1xuICAgICAgICAgICAgdGhpcy5fc2hvd0N1cnNvcigpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5faGlkZUN1cnNvcigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgX3VwZGF0ZVBvc2l0aW9uKCkge1xuICAgICAgICB0aGlzLl9jYW52YXMuc3R5bGUubGVmdCA9IHRoaXMuX3Bvc2l0aW9uLnggKyBcInB4XCI7XG4gICAgICAgIHRoaXMuX2NhbnZhcy5zdHlsZS50b3AgPSB0aGlzLl9wb3NpdGlvbi55ICsgXCJweFwiO1xuICAgIH1cbn1cbiIsIi8qXG4gKiBub1ZOQzogSFRNTDUgVk5DIGNsaWVudFxuICogQ29weXJpZ2h0IChDKSAyMDE4IFRoZSBub1ZOQyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciBNUEwgMi4wIChzZWUgTElDRU5TRS50eHQpXG4gKlxuICogU2VlIFJFQURNRS5tZCBmb3IgdXNhZ2UgYW5kIGludGVncmF0aW9uIGluc3RydWN0aW9ucy5cbiAqL1xuXG4vKlxuICogQ3Jvc3MtYnJvd3NlciBldmVudCBhbmQgcG9zaXRpb24gcm91dGluZXNcbiAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UG9pbnRlckV2ZW50KGUpIHtcbiAgICByZXR1cm4gZS5jaGFuZ2VkVG91Y2hlcyA/IGUuY2hhbmdlZFRvdWNoZXNbMF0gOiBlLnRvdWNoZXMgPyBlLnRvdWNoZXNbMF0gOiBlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc3RvcEV2ZW50KGUpIHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGUucHJldmVudERlZmF1bHQoKTtcbn1cblxuLy8gRW11bGF0ZSBFbGVtZW50LnNldENhcHR1cmUoKSB3aGVuIG5vdCBzdXBwb3J0ZWRcbmxldCBfY2FwdHVyZVJlY3Vyc2lvbiA9IGZhbHNlO1xubGV0IF9jYXB0dXJlRWxlbSA9IG51bGw7XG5mdW5jdGlvbiBfY2FwdHVyZVByb3h5KGUpIHtcbiAgICAvLyBSZWN1cnNpb24gcHJvdGVjdGlvbiBhcyB3ZSdsbCBzZWUgb3VyIG93biBldmVudFxuICAgIGlmIChfY2FwdHVyZVJlY3Vyc2lvbikgcmV0dXJuO1xuXG4gICAgLy8gQ2xvbmUgdGhlIGV2ZW50IGFzIHdlIGNhbm5vdCBkaXNwYXRjaCBhbiBhbHJlYWR5IGRpc3BhdGNoZWQgZXZlbnRcbiAgICBjb25zdCBuZXdFdiA9IG5ldyBlLmNvbnN0cnVjdG9yKGUudHlwZSwgZSk7XG5cbiAgICBfY2FwdHVyZVJlY3Vyc2lvbiA9IHRydWU7XG4gICAgX2NhcHR1cmVFbGVtLmRpc3BhdGNoRXZlbnQobmV3RXYpO1xuICAgIF9jYXB0dXJlUmVjdXJzaW9uID0gZmFsc2U7XG5cbiAgICAvLyBBdm9pZCBkb3VibGUgZXZlbnRzXG4gICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblxuICAgIC8vIFJlc3BlY3QgdGhlIHdpc2hlcyBvZiB0aGUgcmVkaXJlY3RlZCBldmVudCBoYW5kbGVyc1xuICAgIGlmIChuZXdFdi5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG5cbiAgICAvLyBJbXBsaWNpdGx5IHJlbGVhc2UgdGhlIGNhcHR1cmUgb24gYnV0dG9uIHJlbGVhc2VcbiAgICBpZiAoZS50eXBlID09PSBcIm1vdXNldXBcIikge1xuICAgICAgICByZWxlYXNlQ2FwdHVyZSgpO1xuICAgIH1cbn1cblxuLy8gRm9sbG93IGN1cnNvciBzdHlsZSBvZiB0YXJnZXQgZWxlbWVudFxuZnVuY3Rpb24gX2NhcHR1cmVFbGVtQ2hhbmdlZCgpIHtcbiAgICBjb25zdCBjYXB0dXJlRWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwibm9WTkNfbW91c2VfY2FwdHVyZV9lbGVtXCIpO1xuICAgIGNhcHR1cmVFbGVtLnN0eWxlLmN1cnNvciA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKF9jYXB0dXJlRWxlbSkuY3Vyc29yO1xufVxuXG5jb25zdCBfY2FwdHVyZU9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoX2NhcHR1cmVFbGVtQ2hhbmdlZCk7XG5cbmxldCBfY2FwdHVyZUluZGV4ID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIHNldENhcHR1cmUoZWxlbSkge1xuICAgIGlmIChlbGVtLnNldENhcHR1cmUpIHtcblxuICAgICAgICBlbGVtLnNldENhcHR1cmUoKTtcblxuICAgICAgICAvLyBJRSByZWxlYXNlcyBjYXB0dXJlIG9uICdjbGljaycgZXZlbnRzIHdoaWNoIG1pZ2h0IG5vdCB0cmlnZ2VyXG4gICAgICAgIGVsZW0uYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHJlbGVhc2VDYXB0dXJlKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlbGVhc2UgYW55IGV4aXN0aW5nIGNhcHR1cmUgaW4gY2FzZSB0aGlzIG1ldGhvZCBpc1xuICAgICAgICAvLyBjYWxsZWQgbXVsdGlwbGUgdGltZXMgd2l0aG91dCBjb29yZGluYXRpb25cbiAgICAgICAgcmVsZWFzZUNhcHR1cmUoKTtcblxuICAgICAgICBsZXQgY2FwdHVyZUVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm5vVk5DX21vdXNlX2NhcHR1cmVfZWxlbVwiKTtcblxuICAgICAgICBpZiAoY2FwdHVyZUVsZW0gPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNhcHR1cmVFbGVtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgICAgICAgIGNhcHR1cmVFbGVtLmlkID0gXCJub1ZOQ19tb3VzZV9jYXB0dXJlX2VsZW1cIjtcbiAgICAgICAgICAgIGNhcHR1cmVFbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJmaXhlZFwiO1xuICAgICAgICAgICAgY2FwdHVyZUVsZW0uc3R5bGUudG9wID0gXCIwcHhcIjtcbiAgICAgICAgICAgIGNhcHR1cmVFbGVtLnN0eWxlLmxlZnQgPSBcIjBweFwiO1xuICAgICAgICAgICAgY2FwdHVyZUVsZW0uc3R5bGUud2lkdGggPSBcIjEwMCVcIjtcbiAgICAgICAgICAgIGNhcHR1cmVFbGVtLnN0eWxlLmhlaWdodCA9IFwiMTAwJVwiO1xuICAgICAgICAgICAgY2FwdHVyZUVsZW0uc3R5bGUuekluZGV4ID0gMTAwMDA7XG4gICAgICAgICAgICBjYXB0dXJlRWxlbS5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNhcHR1cmVFbGVtKTtcblxuICAgICAgICAgICAgLy8gVGhpcyBpcyB0byBtYWtlIHN1cmUgY2FsbGVycyBkb24ndCBnZXQgY29uZnVzZWQgYnkgaGF2aW5nXG4gICAgICAgICAgICAvLyBvdXIgYmxvY2tpbmcgZWxlbWVudCBhcyB0aGUgdGFyZ2V0XG4gICAgICAgICAgICBjYXB0dXJlRWxlbS5hZGRFdmVudExpc3RlbmVyKCdjb250ZXh0bWVudScsIF9jYXB0dXJlUHJveHkpO1xuXG4gICAgICAgICAgICBjYXB0dXJlRWxlbS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBfY2FwdHVyZVByb3h5KTtcbiAgICAgICAgICAgIGNhcHR1cmVFbGVtLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNldXAnLCBfY2FwdHVyZVByb3h5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIF9jYXB0dXJlRWxlbSA9IGVsZW07XG4gICAgICAgIF9jYXB0dXJlSW5kZXgrKztcblxuICAgICAgICAvLyBUcmFjayBjdXJzb3IgYW5kIGdldCBpbml0aWFsIGN1cnNvclxuICAgICAgICBfY2FwdHVyZU9ic2VydmVyLm9ic2VydmUoZWxlbSwge2F0dHJpYnV0ZXM6IHRydWV9KTtcbiAgICAgICAgX2NhcHR1cmVFbGVtQ2hhbmdlZCgpO1xuXG4gICAgICAgIGNhcHR1cmVFbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXG4gICAgICAgIC8vIFdlIGxpc3RlbiB0byBldmVudHMgb24gd2luZG93IGluIG9yZGVyIHRvIGtlZXAgdHJhY2tpbmcgaWYgaXRcbiAgICAgICAgLy8gaGFwcGVucyB0byBsZWF2ZSB0aGUgdmlld3BvcnRcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIF9jYXB0dXJlUHJveHkpO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIF9jYXB0dXJlUHJveHkpO1xuICAgIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlbGVhc2VDYXB0dXJlKCkge1xuICAgIGlmIChkb2N1bWVudC5yZWxlYXNlQ2FwdHVyZSkge1xuXG4gICAgICAgIGRvY3VtZW50LnJlbGVhc2VDYXB0dXJlKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIV9jYXB0dXJlRWxlbSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlcmUgbWlnaHQgYmUgZXZlbnRzIGFscmVhZHkgcXVldWVkLCBzbyB3ZSBuZWVkIHRvIHdhaXQgZm9yXG4gICAgICAgIC8vIHRoZW0gdG8gZmx1c2guIEUuZy4gY29udGV4dG1lbnUgaW4gTWljcm9zb2Z0IEVkZ2VcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQoKGV4cGVjdGVkKSA9PiB7XG4gICAgICAgICAgICAvLyBPbmx5IGNsZWFyIGl0IGlmIGl0J3MgdGhlIGV4cGVjdGVkIGdyYWIgKGkuZS4gbm8gb25lXG4gICAgICAgICAgICAvLyBlbHNlIGhhcyBpbml0aWF0ZWQgYSBuZXcgZ3JhYilcbiAgICAgICAgICAgIGlmIChfY2FwdHVyZUluZGV4ID09PSBleHBlY3RlZCkge1xuICAgICAgICAgICAgICAgIF9jYXB0dXJlRWxlbSA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIDAsIF9jYXB0dXJlSW5kZXgpO1xuXG4gICAgICAgIF9jYXB0dXJlT2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuXG4gICAgICAgIGNvbnN0IGNhcHR1cmVFbGVtID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJub1ZOQ19tb3VzZV9jYXB0dXJlX2VsZW1cIik7XG4gICAgICAgIGNhcHR1cmVFbGVtLnN0eWxlLmRpc3BsYXkgPSBcIm5vbmVcIjtcblxuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgX2NhcHR1cmVQcm94eSk7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgX2NhcHR1cmVQcm94eSk7XG4gICAgfVxufVxuIiwiLypcbiAqIG5vVk5DOiBIVE1MNSBWTkMgY2xpZW50XG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggVGhlIG5vVk5DIEF1dGhvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIE1QTCAyLjAgKHNlZSBMSUNFTlNFLnR4dClcbiAqXG4gKiBTZWUgUkVBRE1FLm1kIGZvciB1c2FnZSBhbmQgaW50ZWdyYXRpb24gaW5zdHJ1Y3Rpb25zLlxuICovXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEV2ZW50VGFyZ2V0TWl4aW4ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBuZXcgTWFwKCk7XG4gICAgfVxuXG4gICAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIXRoaXMuX2xpc3RlbmVycy5oYXModHlwZSkpIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVycy5zZXQodHlwZSwgbmV3IFNldCgpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9saXN0ZW5lcnMuZ2V0KHR5cGUpLmFkZChjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAodGhpcy5fbGlzdGVuZXJzLmhhcyh0eXBlKSkge1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzLmdldCh0eXBlKS5kZWxldGUoY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZGlzcGF0Y2hFdmVudChldmVudCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xpc3RlbmVycy5oYXMoZXZlbnQudHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycy5nZXQoZXZlbnQudHlwZSlcbiAgICAgICAgICAgIC5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrLmNhbGwodGhpcywgZXZlbnQpKTtcbiAgICAgICAgcmV0dXJuICFldmVudC5kZWZhdWx0UHJldmVudGVkO1xuICAgIH1cbn1cbiIsIi8qXG4gKiBub1ZOQzogSFRNTDUgVk5DIGNsaWVudFxuICogQ29weXJpZ2h0IChDKSAyMDE4IFRoZSBub1ZOQyBBdXRob3JzXG4gKiBMaWNlbnNlZCB1bmRlciBNUEwgMi4wIChzZWUgTElDRU5TRS50eHQpXG4gKlxuICogU2VlIFJFQURNRS5tZCBmb3IgdXNhZ2UgYW5kIGludGVncmF0aW9uIGluc3RydWN0aW9ucy5cbiAqL1xuXG4vKlxuICogTG9nZ2luZy9kZWJ1ZyByb3V0aW5lc1xuICovXG5cbmxldCBfbG9nX2xldmVsID0gJ3dhcm4nO1xuXG5sZXQgRGVidWcgPSAoKSA9PiB7fTtcbmxldCBJbmZvID0gKCkgPT4ge307XG5sZXQgV2FybiA9ICgpID0+IHt9O1xubGV0IEVycm9yID0gKCkgPT4ge307XG5cbmV4cG9ydCBmdW5jdGlvbiBpbml0X2xvZ2dpbmcobGV2ZWwpIHtcbiAgICBpZiAodHlwZW9mIGxldmVsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsZXZlbCA9IF9sb2dfbGV2ZWw7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2xvZ19sZXZlbCA9IGxldmVsO1xuICAgIH1cblxuICAgIERlYnVnID0gSW5mbyA9IFdhcm4gPSBFcnJvciA9ICgpID0+IHt9O1xuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuY29uc29sZSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlLCBuby1mYWxsdGhyb3VnaCAqL1xuICAgICAgICBzd2l0Y2ggKGxldmVsKSB7XG4gICAgICAgICAgICBjYXNlICdkZWJ1Zyc6XG4gICAgICAgICAgICAgICAgRGVidWcgPSBjb25zb2xlLmRlYnVnLmJpbmQod2luZG93LmNvbnNvbGUpO1xuICAgICAgICAgICAgY2FzZSAnaW5mbyc6XG4gICAgICAgICAgICAgICAgSW5mbyAgPSBjb25zb2xlLmluZm8uYmluZCh3aW5kb3cuY29uc29sZSk7XG4gICAgICAgICAgICBjYXNlICd3YXJuJzpcbiAgICAgICAgICAgICAgICBXYXJuICA9IGNvbnNvbGUud2Fybi5iaW5kKHdpbmRvdy5jb25zb2xlKTtcbiAgICAgICAgICAgIGNhc2UgJ2Vycm9yJzpcbiAgICAgICAgICAgICAgICBFcnJvciA9IGNvbnNvbGUuZXJyb3IuYmluZCh3aW5kb3cuY29uc29sZSk7XG4gICAgICAgICAgICBjYXNlICdub25lJzpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHdpbmRvdy5FcnJvcihcImludmFsaWQgbG9nZ2luZyB0eXBlICdcIiArIGxldmVsICsgXCInXCIpO1xuICAgICAgICB9XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSwgbm8tZmFsbHRocm91Z2ggKi9cbiAgICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRfbG9nZ2luZygpIHtcbiAgICByZXR1cm4gX2xvZ19sZXZlbDtcbn1cblxuZXhwb3J0IHsgRGVidWcsIEluZm8sIFdhcm4sIEVycm9yIH07XG5cbi8vIEluaXRpYWxpemUgbG9nZ2luZyBsZXZlbFxuaW5pdF9sb2dnaW5nKCk7XG4iLCIvKlxuICogbm9WTkM6IEhUTUw1IFZOQyBjbGllbnRcbiAqIENvcHlyaWdodCAoQykgMjAxOCBUaGUgbm9WTkMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgTVBMIDIuMCBvciBhbnkgbGF0ZXIgdmVyc2lvbiAoc2VlIExJQ0VOU0UudHh0KVxuICovXG5cbi8qIFBvbHlmaWxscyB0byBwcm92aWRlIG5ldyBBUElzIGluIG9sZCBicm93c2VycyAqL1xuXG4vKiBPYmplY3QuYXNzaWduKCkgKHRha2VuIGZyb20gTUROKSAqL1xuaWYgKHR5cGVvZiBPYmplY3QuYXNzaWduICE9ICdmdW5jdGlvbicpIHtcbiAgICAvLyBNdXN0IGJlIHdyaXRhYmxlOiB0cnVlLCBlbnVtZXJhYmxlOiBmYWxzZSwgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdCwgXCJhc3NpZ25cIiwge1xuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gYXNzaWduKHRhcmdldCwgdmFyQXJncykgeyAvLyAubGVuZ3RoIG9mIGZ1bmN0aW9uIGlzIDJcbiAgICAgICAgICAgICd1c2Ugc3RyaWN0JztcbiAgICAgICAgICAgIGlmICh0YXJnZXQgPT0gbnVsbCkgeyAvLyBUeXBlRXJyb3IgaWYgdW5kZWZpbmVkIG9yIG51bGxcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdDYW5ub3QgY29udmVydCB1bmRlZmluZWQgb3IgbnVsbCB0byBvYmplY3QnKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc3QgdG8gPSBPYmplY3QodGFyZ2V0KTtcblxuICAgICAgICAgICAgZm9yIChsZXQgaW5kZXggPSAxOyBpbmRleCA8IGFyZ3VtZW50cy5sZW5ndGg7IGluZGV4KyspIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXh0U291cmNlID0gYXJndW1lbnRzW2luZGV4XTtcblxuICAgICAgICAgICAgICAgIGlmIChuZXh0U291cmNlICE9IG51bGwpIHsgLy8gU2tpcCBvdmVyIGlmIHVuZGVmaW5lZCBvciBudWxsXG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IG5leHRLZXkgaW4gbmV4dFNvdXJjZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQXZvaWQgYnVncyB3aGVuIGhhc093blByb3BlcnR5IGlzIHNoYWRvd2VkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG5leHRTb3VyY2UsIG5leHRLZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9bbmV4dEtleV0gPSBuZXh0U291cmNlW25leHRLZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRvO1xuICAgICAgICB9LFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG59XG5cbi8qIEN1c3RvbUV2ZW50IGNvbnN0cnVjdG9yICh0YWtlbiBmcm9tIE1ETikgKi9cbigoKSA9PiB7XG4gICAgZnVuY3Rpb24gQ3VzdG9tRXZlbnQoZXZlbnQsIHBhcmFtcykge1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwgeyBidWJibGVzOiBmYWxzZSwgY2FuY2VsYWJsZTogZmFsc2UsIGRldGFpbDogdW5kZWZpbmVkIH07XG4gICAgICAgIGNvbnN0IGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCAnQ3VzdG9tRXZlbnQnICk7XG4gICAgICAgIGV2dC5pbml0Q3VzdG9tRXZlbnQoIGV2ZW50LCBwYXJhbXMuYnViYmxlcywgcGFyYW1zLmNhbmNlbGFibGUsIHBhcmFtcy5kZXRhaWwgKTtcbiAgICAgICAgcmV0dXJuIGV2dDtcbiAgICB9XG5cbiAgICBDdXN0b21FdmVudC5wcm90b3R5cGUgPSB3aW5kb3cuRXZlbnQucHJvdG90eXBlO1xuXG4gICAgaWYgKHR5cGVvZiB3aW5kb3cuQ3VzdG9tRXZlbnQgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICB3aW5kb3cuQ3VzdG9tRXZlbnQgPSBDdXN0b21FdmVudDtcbiAgICB9XG59KSgpO1xuIiwiLypcbiAqIG5vVk5DOiBIVE1MNSBWTkMgY2xpZW50XG4gKiBDb3B5cmlnaHQgKEMpIDIwMTggVGhlIG5vVk5DIEF1dGhvcnNcbiAqIExpY2Vuc2VkIHVuZGVyIE1QTCAyLjAgKHNlZSBMSUNFTlNFLnR4dClcbiAqXG4gKiBTZWUgUkVBRE1FLm1kIGZvciB1c2FnZSBhbmQgaW50ZWdyYXRpb24gaW5zdHJ1Y3Rpb25zLlxuICovXG5cbi8qXG4gKiBEZWNvZGUgZnJvbSBVVEYtOFxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVjb2RlVVRGOCh1dGY4c3RyaW5nKSB7XG4gICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUodXRmOHN0cmluZykpO1xufVxuIiwiLypcbiAqIFdlYnNvY2s6IGhpZ2gtcGVyZm9ybWFuY2UgYmluYXJ5IFdlYlNvY2tldHNcbiAqIENvcHlyaWdodCAoQykgMjAxOCBUaGUgbm9WTkMgQXV0aG9yc1xuICogTGljZW5zZWQgdW5kZXIgTVBMIDIuMCAoc2VlIExJQ0VOU0UudHh0KVxuICpcbiAqIFdlYnNvY2sgaXMgc2ltaWxhciB0byB0aGUgc3RhbmRhcmQgV2ViU29ja2V0IG9iamVjdCBidXQgd2l0aCBleHRyYVxuICogYnVmZmVyIGhhbmRsaW5nLlxuICpcbiAqIFdlYnNvY2sgaGFzIGJ1aWx0LWluIHJlY2VpdmUgcXVldWUgYnVmZmVyaW5nOyB0aGUgbWVzc2FnZSBldmVudFxuICogZG9lcyBub3QgY29udGFpbiBhY3R1YWwgZGF0YSBidXQgaXMgc2ltcGx5IGEgbm90aWZpY2F0aW9uIHRoYXRcbiAqIHRoZXJlIGlzIG5ldyBkYXRhIGF2YWlsYWJsZS4gU2V2ZXJhbCByUSogbWV0aG9kcyBhcmUgYXZhaWxhYmxlIHRvXG4gKiByZWFkIGJpbmFyeSBkYXRhIG9mZiBvZiB0aGUgcmVjZWl2ZSBxdWV1ZS5cbiAqL1xuXG5pbXBvcnQgKiBhcyBMb2cgZnJvbSAnLi91dGlsL2xvZ2dpbmcuanMnO1xuXG4vLyB0aGlzIGhhcyBwZXJmb3JtYW5jZSBpc3N1ZXMgaW4gc29tZSB2ZXJzaW9ucyBDaHJvbWl1bSwgYW5kXG4vLyBkb2Vzbid0IGdhaW4gYSB0cmVtZW5kb3VzIGFtb3VudCBvZiBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbiBGaXJlZm94XG4vLyBhdCB0aGUgbW9tZW50LiAgSXQgbWF5IGJlIHZhbHVhYmxlIHRvIHR1cm4gaXQgb24gaW4gdGhlIGZ1dHVyZS5cbmNvbnN0IEVOQUJMRV9DT1BZV0lUSElOID0gZmFsc2U7XG5jb25zdCBNQVhfUlFfR1JPV19TSVpFID0gNDAgKiAxMDI0ICogMTAyNDsgIC8vIDQwIE1pQlxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXZWJzb2NrIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0ID0gbnVsbDsgIC8vIFdlYlNvY2tldCBvYmplY3RcblxuICAgICAgICB0aGlzLl9yUWkgPSAwOyAgICAgICAgICAgLy8gUmVjZWl2ZSBxdWV1ZSBpbmRleFxuICAgICAgICB0aGlzLl9yUWxlbiA9IDA7ICAgICAgICAgLy8gTmV4dCB3cml0ZSBwb3NpdGlvbiBpbiB0aGUgcmVjZWl2ZSBxdWV1ZVxuICAgICAgICB0aGlzLl9yUWJ1ZmZlclNpemUgPSAxMDI0ICogMTAyNCAqIDQ7IC8vIFJlY2VpdmUgcXVldWUgYnVmZmVyIHNpemUgKDQgTWlCKVxuICAgICAgICB0aGlzLl9yUW1heCA9IHRoaXMuX3JRYnVmZmVyU2l6ZSAvIDg7XG4gICAgICAgIC8vIGNhbGxlZCBpbiBpbml0OiB0aGlzLl9yUSA9IG5ldyBVaW50OEFycmF5KHRoaXMuX3JRYnVmZmVyU2l6ZSk7XG4gICAgICAgIHRoaXMuX3JRID0gbnVsbDsgLy8gUmVjZWl2ZSBxdWV1ZVxuXG4gICAgICAgIHRoaXMuX3NRYnVmZmVyU2l6ZSA9IDEwMjQgKiAxMDsgIC8vIDEwIEtpQlxuICAgICAgICAvLyBjYWxsZWQgaW4gaW5pdDogdGhpcy5fc1EgPSBuZXcgVWludDhBcnJheSh0aGlzLl9zUWJ1ZmZlclNpemUpO1xuICAgICAgICB0aGlzLl9zUWxlbiA9IDA7XG4gICAgICAgIHRoaXMuX3NRID0gbnVsbDsgIC8vIFNlbmQgcXVldWVcblxuICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXJzID0ge1xuICAgICAgICAgICAgbWVzc2FnZTogKCkgPT4ge30sXG4gICAgICAgICAgICBvcGVuOiAoKSA9PiB7fSxcbiAgICAgICAgICAgIGNsb3NlOiAoKSA9PiB7fSxcbiAgICAgICAgICAgIGVycm9yOiAoKSA9PiB7fVxuICAgICAgICB9O1xuICAgIH1cblxuICAgIC8vIEdldHRlcnMgYW5kIFNldHRlcnNcbiAgICBnZXQgc1EoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zUTtcbiAgICB9XG5cbiAgICBnZXQgclEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yUTtcbiAgICB9XG5cbiAgICBnZXQgclFpKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fclFpO1xuICAgIH1cblxuICAgIHNldCByUWkodmFsKSB7XG4gICAgICAgIHRoaXMuX3JRaSA9IHZhbDtcbiAgICB9XG5cbiAgICAvLyBSZWNlaXZlIFF1ZXVlXG4gICAgZ2V0IHJRbGVuKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fclFsZW4gLSB0aGlzLl9yUWk7XG4gICAgfVxuXG4gICAgclFwZWVrOCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JRW3RoaXMuX3JRaV07XG4gICAgfVxuXG4gICAgclFza2lwQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgdGhpcy5fclFpICs9IGJ5dGVzO1xuICAgIH1cblxuICAgIHJRc2hpZnQ4KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fclFzaGlmdCgxKTtcbiAgICB9XG5cbiAgICByUXNoaWZ0MTYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yUXNoaWZ0KDIpO1xuICAgIH1cblxuICAgIHJRc2hpZnQzMigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JRc2hpZnQoNCk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyhkaXJlY3R4bWFuMTIpOiB0ZXN0IHBlcmZvcm1hbmNlIHdpdGggdGhlc2UgdnMgYSBEYXRhVmlld1xuICAgIF9yUXNoaWZ0KGJ5dGVzKSB7XG4gICAgICAgIGxldCByZXMgPSAwO1xuICAgICAgICBmb3IgKGxldCBieXRlID0gYnl0ZXMgLSAxOyBieXRlID49IDA7IGJ5dGUtLSkge1xuICAgICAgICAgICAgcmVzICs9IHRoaXMuX3JRW3RoaXMuX3JRaSsrXSA8PCAoYnl0ZSAqIDgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuXG4gICAgclFzaGlmdFN0cihsZW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZihsZW4pID09PSAndW5kZWZpbmVkJykgeyBsZW4gPSB0aGlzLnJRbGVuOyB9XG4gICAgICAgIGxldCBzdHIgPSBcIlwiO1xuICAgICAgICAvLyBIYW5kbGUgbGFyZ2UgYXJyYXlzIGluIHN0ZXBzIHRvIGF2b2lkIGxvbmcgc3RyaW5ncyBvbiB0aGUgc3RhY2tcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gNDA5Nikge1xuICAgICAgICAgICAgbGV0IHBhcnQgPSB0aGlzLnJRc2hpZnRCeXRlcyhNYXRoLm1pbig0MDk2LCBsZW4gLSBpKSk7XG4gICAgICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgIH1cblxuICAgIHJRc2hpZnRCeXRlcyhsZW4pIHtcbiAgICAgICAgaWYgKHR5cGVvZihsZW4pID09PSAndW5kZWZpbmVkJykgeyBsZW4gPSB0aGlzLnJRbGVuOyB9XG4gICAgICAgIHRoaXMuX3JRaSArPSBsZW47XG4gICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheSh0aGlzLl9yUS5idWZmZXIsIHRoaXMuX3JRaSAtIGxlbiwgbGVuKTtcbiAgICB9XG5cbiAgICByUXNoaWZ0VG8odGFyZ2V0LCBsZW4pIHtcbiAgICAgICAgaWYgKGxlbiA9PT0gdW5kZWZpbmVkKSB7IGxlbiA9IHRoaXMuclFsZW47IH1cbiAgICAgICAgLy8gVE9ETzogbWFrZSB0aGlzIGp1c3QgdXNlIHNldCB3aXRoIHZpZXdzIHdoZW4gdXNpbmcgYSBBcnJheUJ1ZmZlciB0byBzdG9yZSB0aGUgclFcbiAgICAgICAgdGFyZ2V0LnNldChuZXcgVWludDhBcnJheSh0aGlzLl9yUS5idWZmZXIsIHRoaXMuX3JRaSwgbGVuKSk7XG4gICAgICAgIHRoaXMuX3JRaSArPSBsZW47XG4gICAgfVxuXG4gICAgclFzbGljZShzdGFydCwgZW5kID0gdGhpcy5yUWxlbikge1xuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy5fclEuYnVmZmVyLCB0aGlzLl9yUWkgKyBzdGFydCwgZW5kIC0gc3RhcnQpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBtdXN0IHdhaXQgZm9yICdudW0nIGJ5dGVzIChkZWZhdWx0IHRvIEZCVS5ieXRlcylcbiAgICAvLyB0byBiZSBhdmFpbGFibGUgaW4gdGhlIHJlY2VpdmUgcXVldWUuIFJldHVybiB0cnVlIGlmIHdlIG5lZWQgdG9cbiAgICAvLyB3YWl0IChhbmQgcG9zc2libHkgcHJpbnQgYSBkZWJ1ZyBtZXNzYWdlKSwgb3RoZXJ3aXNlIGZhbHNlLlxuICAgIHJRd2FpdChtc2csIG51bSwgZ29iYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLnJRbGVuIDwgbnVtKSB7XG4gICAgICAgICAgICBpZiAoZ29iYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3JRaSA8IGdvYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJyUXdhaXQgY2Fubm90IGJhY2t1cCBcIiArIGdvYmFjayArIFwiIGJ5dGVzXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLl9yUWkgLT0gZ29iYWNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7IC8vIHRydWUgbWVhbnMgbmVlZCBtb3JlIGRhdGFcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gU2VuZCBRdWV1ZVxuXG4gICAgZmx1c2goKSB7XG4gICAgICAgIGlmICh0aGlzLl9zUWxlbiA+IDAgJiYgdGhpcy5fd2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICAgICAgICB0aGlzLl93ZWJzb2NrZXQuc2VuZCh0aGlzLl9lbmNvZGVfbWVzc2FnZSgpKTtcbiAgICAgICAgICAgIHRoaXMuX3NRbGVuID0gMDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNlbmQoYXJyKSB7XG4gICAgICAgIHRoaXMuX3NRLnNldChhcnIsIHRoaXMuX3NRbGVuKTtcbiAgICAgICAgdGhpcy5fc1FsZW4gKz0gYXJyLmxlbmd0aDtcbiAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgIH1cblxuICAgIHNlbmRfc3RyaW5nKHN0cikge1xuICAgICAgICB0aGlzLnNlbmQoc3RyLnNwbGl0KCcnKS5tYXAoY2hyID0+IGNoci5jaGFyQ29kZUF0KDApKSk7XG4gICAgfVxuXG4gICAgLy8gRXZlbnQgSGFuZGxlcnNcbiAgICBvZmYoZXZ0KSB7XG4gICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcnNbZXZ0XSA9ICgpID0+IHt9O1xuICAgIH1cblxuICAgIG9uKGV2dCwgaGFuZGxlcikge1xuICAgICAgICB0aGlzLl9ldmVudEhhbmRsZXJzW2V2dF0gPSBoYW5kbGVyO1xuICAgIH1cblxuICAgIF9hbGxvY2F0ZV9idWZmZXJzKCkge1xuICAgICAgICB0aGlzLl9yUSA9IG5ldyBVaW50OEFycmF5KHRoaXMuX3JRYnVmZmVyU2l6ZSk7XG4gICAgICAgIHRoaXMuX3NRID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5fc1FidWZmZXJTaXplKTtcbiAgICB9XG5cbiAgICBpbml0KCkge1xuICAgICAgICB0aGlzLl9hbGxvY2F0ZV9idWZmZXJzKCk7XG4gICAgICAgIHRoaXMuX3JRaSA9IDA7XG4gICAgICAgIHRoaXMuX3dlYnNvY2tldCA9IG51bGw7XG4gICAgfVxuXG4gICAgb3Blbih1cmksIHByb3RvY29scykge1xuICAgICAgICB0aGlzLmluaXQoKTtcblxuICAgICAgICB0aGlzLl93ZWJzb2NrZXQgPSBuZXcgV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzKTtcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0LmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXG4gICAgICAgIHRoaXMuX3dlYnNvY2tldC5vbm1lc3NhZ2UgPSB0aGlzLl9yZWN2X21lc3NhZ2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5fd2Vic29ja2V0Lm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIExvZy5EZWJ1ZygnPj4gV2ViU29jay5vbm9wZW4nKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl93ZWJzb2NrZXQucHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICBMb2cuSW5mbyhcIlNlcnZlciBjaG9vc2Ugc3ViLXByb3RvY29sOiBcIiArIHRoaXMuX3dlYnNvY2tldC5wcm90b2NvbCk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcnMub3BlbigpO1xuICAgICAgICAgICAgTG9nLkRlYnVnKFwiPDwgV2ViU29jay5vbm9wZW5cIik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3dlYnNvY2tldC5vbmNsb3NlID0gKGUpID0+IHtcbiAgICAgICAgICAgIExvZy5EZWJ1ZyhcIj4+IFdlYlNvY2sub25jbG9zZVwiKTtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcnMuY2xvc2UoZSk7XG4gICAgICAgICAgICBMb2cuRGVidWcoXCI8PCBXZWJTb2NrLm9uY2xvc2VcIik7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3dlYnNvY2tldC5vbmVycm9yID0gKGUpID0+IHtcbiAgICAgICAgICAgIExvZy5EZWJ1ZyhcIj4+IFdlYlNvY2sub25lcnJvcjogXCIgKyBlKTtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50SGFuZGxlcnMuZXJyb3IoZSk7XG4gICAgICAgICAgICBMb2cuRGVidWcoXCI8PCBXZWJTb2NrLm9uZXJyb3I6IFwiICsgZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl93ZWJzb2NrZXQpIHtcbiAgICAgICAgICAgIGlmICgodGhpcy5fd2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5PUEVOKSB8fFxuICAgICAgICAgICAgICAgICAgICAodGhpcy5fd2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSkge1xuICAgICAgICAgICAgICAgIExvZy5JbmZvKFwiQ2xvc2luZyBXZWJTb2NrZXQgY29ubmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLl93ZWJzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdGhpcy5fd2Vic29ja2V0Lm9ubWVzc2FnZSA9ICgpID0+IHt9O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gcHJpdmF0ZSBtZXRob2RzXG4gICAgX2VuY29kZV9tZXNzYWdlKCkge1xuICAgICAgICAvLyBQdXQgaW4gYSBiaW5hcnkgYXJyYXlidWZmZXJcbiAgICAgICAgLy8gYWNjb3JkaW5nIHRvIHRoZSBzcGVjLCB5b3UgY2FuIHNlbmQgQXJyYXlCdWZmZXJWaWV3cyB3aXRoIHRoZSBzZW5kIG1ldGhvZFxuICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodGhpcy5fc1EuYnVmZmVyLCAwLCB0aGlzLl9zUWxlbik7XG4gICAgfVxuXG4gICAgX2V4cGFuZF9jb21wYWN0X3JRKG1pbl9maXQpIHtcbiAgICAgICAgY29uc3QgcmVzaXplTmVlZGVkID0gbWluX2ZpdCB8fCB0aGlzLnJRbGVuID4gdGhpcy5fclFidWZmZXJTaXplIC8gMjtcbiAgICAgICAgaWYgKHJlc2l6ZU5lZWRlZCkge1xuICAgICAgICAgICAgaWYgKCFtaW5fZml0KSB7XG4gICAgICAgICAgICAgICAgLy8ganVzdCBkb3VibGUgdGhlIHNpemUgaWYgd2UgbmVlZCB0byBkbyBjb21wYWN0aW9uXG4gICAgICAgICAgICAgICAgdGhpcy5fclFidWZmZXJTaXplICo9IDI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSwgbWFrZSBzdXJlIHdlIHNhdGlzeSByUWxlbiAtIHJRaSArIG1pbl9maXQgPCByUWJ1ZmZlclNpemUgLyA4XG4gICAgICAgICAgICAgICAgdGhpcy5fclFidWZmZXJTaXplID0gKHRoaXMuclFsZW4gKyBtaW5fZml0KSAqIDg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyB3ZSBkb24ndCB3YW50IHRvIGdyb3cgdW5ib3VuZGVkbHlcbiAgICAgICAgaWYgKHRoaXMuX3JRYnVmZmVyU2l6ZSA+IE1BWF9SUV9HUk9XX1NJWkUpIHtcbiAgICAgICAgICAgIHRoaXMuX3JRYnVmZmVyU2l6ZSA9IE1BWF9SUV9HUk9XX1NJWkU7XG4gICAgICAgICAgICBpZiAodGhpcy5fclFidWZmZXJTaXplIC0gdGhpcy5yUWxlbiA8IG1pbl9maXQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZWNlaXZlIFF1ZXVlIGJ1ZmZlciBleGNlZWRlZCBcIiArIE1BWF9SUV9HUk9XX1NJWkUgKyBcIiBieXRlcywgYW5kIHRoZSBuZXcgbWVzc2FnZSBjb3VsZCBub3QgZml0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHJlc2l6ZU5lZWRlZCkge1xuICAgICAgICAgICAgY29uc3Qgb2xkX3JRYnVmZmVyID0gdGhpcy5fclEuYnVmZmVyO1xuICAgICAgICAgICAgdGhpcy5fclFtYXggPSB0aGlzLl9yUWJ1ZmZlclNpemUgLyA4O1xuICAgICAgICAgICAgdGhpcy5fclEgPSBuZXcgVWludDhBcnJheSh0aGlzLl9yUWJ1ZmZlclNpemUpO1xuICAgICAgICAgICAgdGhpcy5fclEuc2V0KG5ldyBVaW50OEFycmF5KG9sZF9yUWJ1ZmZlciwgdGhpcy5fclFpKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAoRU5BQkxFX0NPUFlXSVRISU4pIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yUS5jb3B5V2l0aGluKDAsIHRoaXMuX3JRaSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JRLnNldChuZXcgVWludDhBcnJheSh0aGlzLl9yUS5idWZmZXIsIHRoaXMuX3JRaSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fclFsZW4gPSB0aGlzLl9yUWxlbiAtIHRoaXMuX3JRaTtcbiAgICAgICAgdGhpcy5fclFpID0gMDtcbiAgICB9XG5cbiAgICBfZGVjb2RlX21lc3NhZ2UoZGF0YSkge1xuICAgICAgICAvLyBwdXNoIGFycmF5YnVmZmVyIHZhbHVlcyBvbnRvIHRoZSBlbmRcbiAgICAgICAgY29uc3QgdTggPSBuZXcgVWludDhBcnJheShkYXRhKTtcbiAgICAgICAgaWYgKHU4Lmxlbmd0aCA+IHRoaXMuX3JRYnVmZmVyU2l6ZSAtIHRoaXMuX3JRbGVuKSB7XG4gICAgICAgICAgICB0aGlzLl9leHBhbmRfY29tcGFjdF9yUSh1OC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JRLnNldCh1OCwgdGhpcy5fclFsZW4pO1xuICAgICAgICB0aGlzLl9yUWxlbiArPSB1OC5sZW5ndGg7XG4gICAgfVxuXG4gICAgX3JlY3ZfbWVzc2FnZShlKSB7XG4gICAgICAgIHRoaXMuX2RlY29kZV9tZXNzYWdlKGUuZGF0YSk7XG4gICAgICAgIGlmICh0aGlzLnJRbGVuID4gMCkge1xuICAgICAgICAgICAgdGhpcy5fZXZlbnRIYW5kbGVycy5tZXNzYWdlKCk7XG4gICAgICAgICAgICAvLyBDb21wYWN0IHRoZSByZWNlaXZlIHF1ZXVlXG4gICAgICAgICAgICBpZiAodGhpcy5fclFsZW4gPT0gdGhpcy5fclFpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fclFsZW4gPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX3JRaSA9IDA7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX3JRbGVuID4gdGhpcy5fclFtYXgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9leHBhbmRfY29tcGFjdF9yUSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgTG9nLkRlYnVnKFwiSWdub3JpbmcgZW1wdHkgbWVzc2FnZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbiIsIi8vIHJlZHVjZSBidWZmZXIgc2l6ZSwgYXZvaWRpbmcgbWVtIGNvcHlcbmV4cG9ydCBmdW5jdGlvbiBzaHJpbmtCdWYgKGJ1Ziwgc2l6ZSkge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gc2l6ZSkgeyByZXR1cm4gYnVmOyB9XG4gIGlmIChidWYuc3ViYXJyYXkpIHsgcmV0dXJuIGJ1Zi5zdWJhcnJheSgwLCBzaXplKTsgfVxuICBidWYubGVuZ3RoID0gc2l6ZTtcbiAgcmV0dXJuIGJ1Zjtcbn07XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGFycmF5U2V0IChkZXN0LCBzcmMsIHNyY19vZmZzLCBsZW4sIGRlc3Rfb2Zmcykge1xuICBpZiAoc3JjLnN1YmFycmF5ICYmIGRlc3Quc3ViYXJyYXkpIHtcbiAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjX29mZnMsIHNyY19vZmZzICsgbGVuKSwgZGVzdF9vZmZzKTtcbiAgICByZXR1cm47XG4gIH1cbiAgLy8gRmFsbGJhY2sgdG8gb3JkaW5hcnkgYXJyYXlcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIGRlc3RbZGVzdF9vZmZzICsgaV0gPSBzcmNbc3JjX29mZnMgKyBpXTtcbiAgfVxufVxuXG4vLyBKb2luIGFycmF5IG9mIGNodW5rcyB0byBzaW5nbGUgYXJyYXkuXG5leHBvcnQgZnVuY3Rpb24gZmxhdHRlbkNodW5rcyAoY2h1bmtzKSB7XG4gIHZhciBpLCBsLCBsZW4sIHBvcywgY2h1bmssIHJlc3VsdDtcblxuICAvLyBjYWxjdWxhdGUgZGF0YSBsZW5ndGhcbiAgbGVuID0gMDtcbiAgZm9yIChpID0gMCwgbCA9IGNodW5rcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBsZW4gKz0gY2h1bmtzW2ldLmxlbmd0aDtcbiAgfVxuXG4gIC8vIGpvaW4gY2h1bmtzXG4gIHJlc3VsdCA9IG5ldyBVaW50OEFycmF5KGxlbik7XG4gIHBvcyA9IDA7XG4gIGZvciAoaSA9IDAsIGwgPSBjaHVua3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgY2h1bmsgPSBjaHVua3NbaV07XG4gICAgcmVzdWx0LnNldChjaHVuaywgcG9zKTtcbiAgICBwb3MgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZXhwb3J0IHZhciBCdWY4ICA9IFVpbnQ4QXJyYXk7XG5leHBvcnQgdmFyIEJ1ZjE2ID0gVWludDE2QXJyYXk7XG5leHBvcnQgdmFyIEJ1ZjMyID0gSW50MzJBcnJheTtcbiIsIi8vIE5vdGU6IGFkbGVyMzIgdGFrZXMgMTIlIGZvciBsZXZlbCAwIGFuZCAyJSBmb3IgbGV2ZWwgNi5cbi8vIEl0IGRvZXNuJ3Qgd29ydGggdG8gbWFrZSBhZGRpdGlvbmFsIG9wdGltaXphdGlvbmEgYXMgaW4gb3JpZ2luYWwuXG4vLyBTbWFsbCBzaXplIGlzIHByZWZlcmFibGUuXG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGFkbGVyMzIoYWRsZXIsIGJ1ZiwgbGVuLCBwb3MpIHtcbiAgdmFyIHMxID0gKGFkbGVyICYgMHhmZmZmKSB8MCxcbiAgICAgIHMyID0gKChhZGxlciA+Pj4gMTYpICYgMHhmZmZmKSB8MCxcbiAgICAgIG4gPSAwO1xuXG4gIHdoaWxlIChsZW4gIT09IDApIHtcbiAgICAvLyBTZXQgbGltaXQgfiB0d2ljZSBsZXNzIHRoYW4gNTU1MiwgdG8ga2VlcFxuICAgIC8vIHMyIGluIDMxLWJpdHMsIGJlY2F1c2Ugd2UgZm9yY2Ugc2lnbmVkIGludHMuXG4gICAgLy8gaW4gb3RoZXIgY2FzZSAlPSB3aWxsIGZhaWwuXG4gICAgbiA9IGxlbiA+IDIwMDAgPyAyMDAwIDogbGVuO1xuICAgIGxlbiAtPSBuO1xuXG4gICAgZG8ge1xuICAgICAgczEgPSAoczEgKyBidWZbcG9zKytdKSB8MDtcbiAgICAgIHMyID0gKHMyICsgczEpIHwwO1xuICAgIH0gd2hpbGUgKC0tbik7XG5cbiAgICBzMSAlPSA2NTUyMTtcbiAgICBzMiAlPSA2NTUyMTtcbiAgfVxuXG4gIHJldHVybiAoczEgfCAoczIgPDwgMTYpKSB8MDtcbn1cbiIsIi8vIE5vdGU6IHdlIGNhbid0IGdldCBzaWduaWZpY2FudCBzcGVlZCBib29zdCBoZXJlLlxuLy8gU28gd3JpdGUgY29kZSB0byBtaW5pbWl6ZSBzaXplIC0gbm8gcHJlZ2VuZXJhdGVkIHRhYmxlc1xuLy8gYW5kIGFycmF5IHRvb2xzIGRlcGVuZGVuY2llcy5cblxuXG4vLyBVc2Ugb3JkaW5hcnkgYXJyYXksIHNpbmNlIHVudHlwZWQgbWFrZXMgbm8gYm9vc3QgaGVyZVxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gbWFrZVRhYmxlKCkge1xuICB2YXIgYywgdGFibGUgPSBbXTtcblxuICBmb3IgKHZhciBuID0gMDsgbiA8IDI1NjsgbisrKSB7XG4gICAgYyA9IG47XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCA4OyBrKyspIHtcbiAgICAgIGMgPSAoKGMgJiAxKSA/ICgweEVEQjg4MzIwIF4gKGMgPj4+IDEpKSA6IChjID4+PiAxKSk7XG4gICAgfVxuICAgIHRhYmxlW25dID0gYztcbiAgfVxuXG4gIHJldHVybiB0YWJsZTtcbn1cblxuLy8gQ3JlYXRlIHRhYmxlIG9uIGxvYWQuIEp1c3QgMjU1IHNpZ25lZCBsb25ncy4gTm90IGEgcHJvYmxlbS5cbnZhciBjcmNUYWJsZSA9IG1ha2VUYWJsZSgpO1xuXG5cbmZ1bmN0aW9uIGNyYzMyKGNyYywgYnVmLCBsZW4sIHBvcykge1xuICB2YXIgdCA9IGNyY1RhYmxlLFxuICAgICAgZW5kID0gcG9zICsgbGVuO1xuXG4gIGNyYyBePSAtMTtcblxuICBmb3IgKHZhciBpID0gcG9zOyBpIDwgZW5kOyBpKyspIHtcbiAgICBjcmMgPSAoY3JjID4+PiA4KSBeIHRbKGNyYyBeIGJ1ZltpXSkgJiAweEZGXTtcbiAgfVxuXG4gIHJldHVybiAoY3JjIF4gKC0xKSk7IC8vID4+PiAwO1xufVxuIiwiLy8gU2VlIHN0YXRlIGRlZnMgZnJvbSBpbmZsYXRlLmpzXG52YXIgQkFEID0gMzA7ICAgICAgIC8qIGdvdCBhIGRhdGEgZXJyb3IgLS0gcmVtYWluIGhlcmUgdW50aWwgcmVzZXQgKi9cbnZhciBUWVBFID0gMTI7ICAgICAgLyogaTogd2FpdGluZyBmb3IgdHlwZSBiaXRzLCBpbmNsdWRpbmcgbGFzdC1mbGFnIGJpdCAqL1xuXG4vKlxuICAgRGVjb2RlIGxpdGVyYWwsIGxlbmd0aCwgYW5kIGRpc3RhbmNlIGNvZGVzIGFuZCB3cml0ZSBvdXQgdGhlIHJlc3VsdGluZ1xuICAgbGl0ZXJhbCBhbmQgbWF0Y2ggYnl0ZXMgdW50aWwgZWl0aGVyIG5vdCBlbm91Z2ggaW5wdXQgb3Igb3V0cHV0IGlzXG4gICBhdmFpbGFibGUsIGFuIGVuZC1vZi1ibG9jayBpcyBlbmNvdW50ZXJlZCwgb3IgYSBkYXRhIGVycm9yIGlzIGVuY291bnRlcmVkLlxuICAgV2hlbiBsYXJnZSBlbm91Z2ggaW5wdXQgYW5kIG91dHB1dCBidWZmZXJzIGFyZSBzdXBwbGllZCB0byBpbmZsYXRlKCksIGZvclxuICAgZXhhbXBsZSwgYSAxNksgaW5wdXQgYnVmZmVyIGFuZCBhIDY0SyBvdXRwdXQgYnVmZmVyLCBtb3JlIHRoYW4gOTUlIG9mIHRoZVxuICAgaW5mbGF0ZSBleGVjdXRpb24gdGltZSBpcyBzcGVudCBpbiB0aGlzIHJvdXRpbmUuXG5cbiAgIEVudHJ5IGFzc3VtcHRpb25zOlxuXG4gICAgICAgIHN0YXRlLm1vZGUgPT09IExFTlxuICAgICAgICBzdHJtLmF2YWlsX2luID49IDZcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPj0gMjU4XG4gICAgICAgIHN0YXJ0ID49IHN0cm0uYXZhaWxfb3V0XG4gICAgICAgIHN0YXRlLmJpdHMgPCA4XG5cbiAgIE9uIHJldHVybiwgc3RhdGUubW9kZSBpcyBvbmUgb2Y6XG5cbiAgICAgICAgTEVOIC0tIHJhbiBvdXQgb2YgZW5vdWdoIG91dHB1dCBzcGFjZSBvciBlbm91Z2ggYXZhaWxhYmxlIGlucHV0XG4gICAgICAgIFRZUEUgLS0gcmVhY2hlZCBlbmQgb2YgYmxvY2sgY29kZSwgaW5mbGF0ZSgpIHRvIGludGVycHJldCBuZXh0IGJsb2NrXG4gICAgICAgIEJBRCAtLSBlcnJvciBpbiBibG9jayBkYXRhXG5cbiAgIE5vdGVzOlxuXG4gICAgLSBUaGUgbWF4aW11bSBpbnB1dCBiaXRzIHVzZWQgYnkgYSBsZW5ndGgvZGlzdGFuY2UgcGFpciBpcyAxNSBiaXRzIGZvciB0aGVcbiAgICAgIGxlbmd0aCBjb2RlLCA1IGJpdHMgZm9yIHRoZSBsZW5ndGggZXh0cmEsIDE1IGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBjb2RlLFxuICAgICAgYW5kIDEzIGJpdHMgZm9yIHRoZSBkaXN0YW5jZSBleHRyYS4gIFRoaXMgdG90YWxzIDQ4IGJpdHMsIG9yIHNpeCBieXRlcy5cbiAgICAgIFRoZXJlZm9yZSBpZiBzdHJtLmF2YWlsX2luID49IDYsIHRoZW4gdGhlcmUgaXMgZW5vdWdoIGlucHV0IHRvIGF2b2lkXG4gICAgICBjaGVja2luZyBmb3IgYXZhaWxhYmxlIGlucHV0IHdoaWxlIGRlY29kaW5nLlxuXG4gICAgLSBUaGUgbWF4aW11bSBieXRlcyB0aGF0IGEgc2luZ2xlIGxlbmd0aC9kaXN0YW5jZSBwYWlyIGNhbiBvdXRwdXQgaXMgMjU4XG4gICAgICBieXRlcywgd2hpY2ggaXMgdGhlIG1heGltdW0gbGVuZ3RoIHRoYXQgY2FuIGJlIGNvZGVkLiAgaW5mbGF0ZV9mYXN0KClcbiAgICAgIHJlcXVpcmVzIHN0cm0uYXZhaWxfb3V0ID49IDI1OCBmb3IgZWFjaCBsb29wIHRvIGF2b2lkIGNoZWNraW5nIGZvclxuICAgICAgb3V0cHV0IHNwYWNlLlxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpbmZsYXRlX2Zhc3Qoc3RybSwgc3RhcnQpIHtcbiAgdmFyIHN0YXRlO1xuICB2YXIgX2luOyAgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5pbnB1dCAqL1xuICB2YXIgbGFzdDsgICAgICAgICAgICAgICAgICAgLyogaGF2ZSBlbm91Z2ggaW5wdXQgd2hpbGUgaW4gPCBsYXN0ICovXG4gIHZhciBfb3V0OyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLm91dHB1dCAqL1xuICB2YXIgYmVnOyAgICAgICAgICAgICAgICAgICAgLyogaW5mbGF0ZSgpJ3MgaW5pdGlhbCBzdHJtLm91dHB1dCAqL1xuICB2YXIgZW5kOyAgICAgICAgICAgICAgICAgICAgLyogd2hpbGUgb3V0IDwgZW5kLCBlbm91Z2ggc3BhY2UgYXZhaWxhYmxlICovXG4vLyNpZmRlZiBJTkZMQVRFX1NUUklDVFxuICB2YXIgZG1heDsgICAgICAgICAgICAgICAgICAgLyogbWF4aW11bSBkaXN0YW5jZSBmcm9tIHpsaWIgaGVhZGVyICovXG4vLyNlbmRpZlxuICB2YXIgd3NpemU7ICAgICAgICAgICAgICAgICAgLyogd2luZG93IHNpemUgb3IgemVybyBpZiBub3QgdXNpbmcgd2luZG93ICovXG4gIHZhciB3aGF2ZTsgICAgICAgICAgICAgICAgICAvKiB2YWxpZCBieXRlcyBpbiB0aGUgd2luZG93ICovXG4gIHZhciB3bmV4dDsgICAgICAgICAgICAgICAgICAvKiB3aW5kb3cgd3JpdGUgaW5kZXggKi9cbiAgLy8gVXNlIGBzX3dpbmRvd2AgaW5zdGVhZCBgd2luZG93YCwgYXZvaWQgY29uZmxpY3Qgd2l0aCBpbnN0cnVtZW50YXRpb24gdG9vbHNcbiAgdmFyIHNfd2luZG93OyAgICAgICAgICAgICAgIC8qIGFsbG9jYXRlZCBzbGlkaW5nIHdpbmRvdywgaWYgd3NpemUgIT0gMCAqL1xuICB2YXIgaG9sZDsgICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5ob2xkICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBsb2NhbCBzdHJtLmJpdHMgKi9cbiAgdmFyIGxjb2RlOyAgICAgICAgICAgICAgICAgIC8qIGxvY2FsIHN0cm0ubGVuY29kZSAqL1xuICB2YXIgZGNvZGU7ICAgICAgICAgICAgICAgICAgLyogbG9jYWwgc3RybS5kaXN0Y29kZSAqL1xuICB2YXIgbG1hc2s7ICAgICAgICAgICAgICAgICAgLyogbWFzayBmb3IgZmlyc3QgbGV2ZWwgb2YgbGVuZ3RoIGNvZGVzICovXG4gIHZhciBkbWFzazsgICAgICAgICAgICAgICAgICAvKiBtYXNrIGZvciBmaXJzdCBsZXZlbCBvZiBkaXN0YW5jZSBjb2RlcyAqL1xuICB2YXIgaGVyZTsgICAgICAgICAgICAgICAgICAgLyogcmV0cmlldmVkIHRhYmxlIGVudHJ5ICovXG4gIHZhciBvcDsgICAgICAgICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMsIG9wZXJhdGlvbiwgZXh0cmEgYml0cywgb3IgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qICB3aW5kb3cgcG9zaXRpb24sIHdpbmRvdyBieXRlcyB0byBjb3B5ICovXG4gIHZhciBsZW47ICAgICAgICAgICAgICAgICAgICAvKiBtYXRjaCBsZW5ndGgsIHVudXNlZCBieXRlcyAqL1xuICB2YXIgZGlzdDsgICAgICAgICAgICAgICAgICAgLyogbWF0Y2ggZGlzdGFuY2UgKi9cbiAgdmFyIGZyb207ICAgICAgICAgICAgICAgICAgIC8qIHdoZXJlIHRvIGNvcHkgbWF0Y2ggZnJvbSAqL1xuICB2YXIgZnJvbV9zb3VyY2U7XG5cblxuICB2YXIgaW5wdXQsIG91dHB1dDsgLy8gSlMgc3BlY2lmaWMsIGJlY2F1c2Ugd2UgaGF2ZSBubyBwb2ludGVyc1xuXG4gIC8qIGNvcHkgc3RhdGUgdG8gbG9jYWwgdmFyaWFibGVzICovXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgLy9oZXJlID0gc3RhdGUuaGVyZTtcbiAgX2luID0gc3RybS5uZXh0X2luO1xuICBpbnB1dCA9IHN0cm0uaW5wdXQ7XG4gIGxhc3QgPSBfaW4gKyAoc3RybS5hdmFpbF9pbiAtIDUpO1xuICBfb3V0ID0gc3RybS5uZXh0X291dDtcbiAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gIGJlZyA9IF9vdXQgLSAoc3RhcnQgLSBzdHJtLmF2YWlsX291dCk7XG4gIGVuZCA9IF9vdXQgKyAoc3RybS5hdmFpbF9vdXQgLSAyNTcpO1xuLy8jaWZkZWYgSU5GTEFURV9TVFJJQ1RcbiAgZG1heCA9IHN0YXRlLmRtYXg7XG4vLyNlbmRpZlxuICB3c2l6ZSA9IHN0YXRlLndzaXplO1xuICB3aGF2ZSA9IHN0YXRlLndoYXZlO1xuICB3bmV4dCA9IHN0YXRlLnduZXh0O1xuICBzX3dpbmRvdyA9IHN0YXRlLndpbmRvdztcbiAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICBsY29kZSA9IHN0YXRlLmxlbmNvZGU7XG4gIGRjb2RlID0gc3RhdGUuZGlzdGNvZGU7XG4gIGxtYXNrID0gKDEgPDwgc3RhdGUubGVuYml0cykgLSAxO1xuICBkbWFzayA9ICgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDE7XG5cblxuICAvKiBkZWNvZGUgbGl0ZXJhbHMgYW5kIGxlbmd0aC9kaXN0YW5jZXMgdW50aWwgZW5kLW9mLWJsb2NrIG9yIG5vdCBlbm91Z2hcbiAgICAgaW5wdXQgZGF0YSBvciBvdXRwdXQgc3BhY2UgKi9cblxuICB0b3A6XG4gIGRvIHtcbiAgICBpZiAoYml0cyA8IDE1KSB7XG4gICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgYml0cyArPSA4O1xuICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgIGJpdHMgKz0gODtcbiAgICB9XG5cbiAgICBoZXJlID0gbGNvZGVbaG9sZCAmIGxtYXNrXTtcblxuICAgIGRvbGVuOlxuICAgIGZvciAoOzspIHsgLy8gR290byBlbXVsYXRpb25cbiAgICAgIG9wID0gaGVyZSA+Pj4gMjQvKmhlcmUuYml0cyovO1xuICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgYml0cyAtPSBvcDtcbiAgICAgIG9wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmYvKmhlcmUub3AqLztcbiAgICAgIGlmIChvcCA9PT0gMCkgeyAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbGl0ZXJhbCAqL1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICBvdXRwdXRbX291dCsrXSA9IGhlcmUgJiAweGZmZmYvKmhlcmUudmFsKi87XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChvcCAmIDE2KSB7ICAgICAgICAgICAgICAgICAgICAgLyogbGVuZ3RoIGJhc2UgKi9cbiAgICAgICAgbGVuID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgb3AgJj0gMTU7ICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgaWYgKG9wKSB7XG4gICAgICAgICAgaWYgKGJpdHMgPCBvcCkge1xuICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGVuICs9IGhvbGQgJiAoKDEgPDwgb3ApIC0gMSk7XG4gICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgIGJpdHMgLT0gb3A7XG4gICAgICAgIH1cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgbGVuKSk7XG4gICAgICAgIGlmIChiaXRzIDwgMTUpIHtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICBob2xkICs9IGlucHV0W19pbisrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICBoZXJlID0gZGNvZGVbaG9sZCAmIGRtYXNrXTtcblxuICAgICAgICBkb2Rpc3Q6XG4gICAgICAgIGZvciAoOzspIHsgLy8gZ290byBlbXVsYXRpb25cbiAgICAgICAgICBvcCA9IGhlcmUgPj4+IDI0LypoZXJlLmJpdHMqLztcbiAgICAgICAgICBob2xkID4+Pj0gb3A7XG4gICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICBvcCA9IChoZXJlID4+PiAxNikgJiAweGZmLypoZXJlLm9wKi87XG5cbiAgICAgICAgICBpZiAob3AgJiAxNikgeyAgICAgICAgICAgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYXNlICovXG4gICAgICAgICAgICBkaXN0ID0gaGVyZSAmIDB4ZmZmZi8qaGVyZS52YWwqLztcbiAgICAgICAgICAgIG9wICY9IDE1OyAgICAgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGV4dHJhIGJpdHMgKi9cbiAgICAgICAgICAgIGlmIChiaXRzIDwgb3ApIHtcbiAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgICBpZiAoYml0cyA8IG9wKSB7XG4gICAgICAgICAgICAgICAgaG9sZCArPSBpbnB1dFtfaW4rK10gPDwgYml0cztcbiAgICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRpc3QgKz0gaG9sZCAmICgoMSA8PCBvcCkgLSAxKTtcbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICAgICAgICBpZiAoZGlzdCA+IGRtYXgpIHtcbiAgICAgICAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBkaXN0YW5jZSB0b28gZmFyIGJhY2snO1xuICAgICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICB9XG4vLyNlbmRpZlxuICAgICAgICAgICAgaG9sZCA+Pj49IG9wO1xuICAgICAgICAgICAgYml0cyAtPSBvcDtcbiAgICAgICAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgZGlzdCkpO1xuICAgICAgICAgICAgb3AgPSBfb3V0IC0gYmVnOyAgICAgICAgICAgICAgICAvKiBtYXggZGlzdGFuY2UgaW4gb3V0cHV0ICovXG4gICAgICAgICAgICBpZiAoZGlzdCA+IG9wKSB7ICAgICAgICAgICAgICAgIC8qIHNlZSBpZiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgICAgICAgIG9wID0gZGlzdCAtIG9wOyAgICAgICAgICAgICAgIC8qIGRpc3RhbmNlIGJhY2sgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgIGlmIChvcCA+IHdoYXZlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICAgICAgICBicmVhayB0b3A7XG4gICAgICAgICAgICAgICAgfVxuXG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmFpbHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICAgICAgICBpZiAobGVuIDw9IG9wIC0gd2hhdmUpIHtcbi8vICAgICAgICAgICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gMDtcbi8vICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1sZW4pO1xuLy8gICAgICAgICAgICAgICAgICBjb250aW51ZSB0b3A7XG4vLyAgICAgICAgICAgICAgICB9XG4vLyAgICAgICAgICAgICAgICBsZW4gLT0gb3AgLSB3aGF2ZTtcbi8vICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSAwO1xuLy8gICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCA+IHdoYXZlKTtcbi8vICAgICAgICAgICAgICAgIGlmIChvcCA9PT0gMCkge1xuLy8gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7XG4vLyAgICAgICAgICAgICAgICAgIGRvIHtcbi8vICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuLy8gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLWxlbik7XG4vLyAgICAgICAgICAgICAgICAgIGNvbnRpbnVlIHRvcDtcbi8vICAgICAgICAgICAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZnJvbSA9IDA7IC8vIHdpbmRvdyBpbmRleFxuICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IHNfd2luZG93O1xuICAgICAgICAgICAgICBpZiAod25leHQgPT09IDApIHsgICAgICAgICAgIC8qIHZlcnkgY29tbW9uIGNhc2UgKi9cbiAgICAgICAgICAgICAgICBmcm9tICs9IHdzaXplIC0gb3A7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgbGVuIC09IG9wO1xuICAgICAgICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICB9IHdoaWxlICgtLW9wKTtcbiAgICAgICAgICAgICAgICAgIGZyb20gPSBfb3V0IC0gZGlzdDsgIC8qIHJlc3QgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgICAgICAgICAgIGZyb21fc291cmNlID0gb3V0cHV0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBlbHNlIGlmICh3bmV4dCA8IG9wKSB7ICAgICAgLyogd3JhcCBhcm91bmQgd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3c2l6ZSArIHduZXh0IC0gb3A7XG4gICAgICAgICAgICAgICAgb3AgLT0gd25leHQ7XG4gICAgICAgICAgICAgICAgaWYgKG9wIDwgbGVuKSB7ICAgICAgICAgLyogc29tZSBmcm9tIGVuZCBvZiB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gMDtcbiAgICAgICAgICAgICAgICAgIGlmICh3bmV4dCA8IGxlbikgeyAgLyogc29tZSBmcm9tIHN0YXJ0IG9mIHdpbmRvdyAqL1xuICAgICAgICAgICAgICAgICAgICBvcCA9IHduZXh0O1xuICAgICAgICAgICAgICAgICAgICBsZW4gLT0gb3A7XG4gICAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IHNfd2luZG93W2Zyb20rK107XG4gICAgICAgICAgICAgICAgICAgIH0gd2hpbGUgKC0tb3ApO1xuICAgICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAgICAgLyogcmVzdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZWxzZSB7ICAgICAgICAgICAgICAgICAgICAgIC8qIGNvbnRpZ3VvdXMgaW4gd2luZG93ICovXG4gICAgICAgICAgICAgICAgZnJvbSArPSB3bmV4dCAtIG9wO1xuICAgICAgICAgICAgICAgIGlmIChvcCA8IGxlbikgeyAgICAgICAgIC8qIHNvbWUgZnJvbSB3aW5kb3cgKi9cbiAgICAgICAgICAgICAgICAgIGxlbiAtPSBvcDtcbiAgICAgICAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBzX3dpbmRvd1tmcm9tKytdO1xuICAgICAgICAgICAgICAgICAgfSB3aGlsZSAoLS1vcCk7XG4gICAgICAgICAgICAgICAgICBmcm9tID0gX291dCAtIGRpc3Q7ICAvKiByZXN0IGZyb20gb3V0cHV0ICovXG4gICAgICAgICAgICAgICAgICBmcm9tX3NvdXJjZSA9IG91dHB1dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgd2hpbGUgKGxlbiA+IDIpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBmcm9tX3NvdXJjZVtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IGZyb21fc291cmNlW2Zyb20rK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgZnJvbSA9IF9vdXQgLSBkaXN0OyAgICAgICAgICAvKiBjb3B5IGRpcmVjdCBmcm9tIG91dHB1dCAqL1xuICAgICAgICAgICAgICBkbyB7ICAgICAgICAgICAgICAgICAgICAgICAgLyogbWluaW11bSBsZW5ndGggaXMgdGhyZWUgKi9cbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIG91dHB1dFtfb3V0KytdID0gb3V0cHV0W2Zyb20rK107XG4gICAgICAgICAgICAgICAgb3V0cHV0W19vdXQrK10gPSBvdXRwdXRbZnJvbSsrXTtcbiAgICAgICAgICAgICAgICBsZW4gLT0gMztcbiAgICAgICAgICAgICAgfSB3aGlsZSAobGVuID4gMik7XG4gICAgICAgICAgICAgIGlmIChsZW4pIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIGlmIChsZW4gPiAxKSB7XG4gICAgICAgICAgICAgICAgICBvdXRwdXRbX291dCsrXSA9IG91dHB1dFtmcm9tKytdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmICgob3AgJiA2NCkgPT09IDApIHsgICAgICAgICAgLyogMm5kIGxldmVsIGRpc3RhbmNlIGNvZGUgKi9cbiAgICAgICAgICAgIGhlcmUgPSBkY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICAgICAgY29udGludWUgZG9kaXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrOyAvLyBuZWVkIHRvIGVtdWxhdGUgZ290byB2aWEgXCJjb250aW51ZVwiXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKChvcCAmIDY0KSA9PT0gMCkgeyAgICAgICAgICAgICAgLyogMm5kIGxldmVsIGxlbmd0aCBjb2RlICovXG4gICAgICAgIGhlcmUgPSBsY29kZVsoaGVyZSAmIDB4ZmZmZikvKmhlcmUudmFsKi8gKyAoaG9sZCAmICgoMSA8PCBvcCkgLSAxKSldO1xuICAgICAgICBjb250aW51ZSBkb2xlbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKG9wICYgMzIpIHsgICAgICAgICAgICAgICAgICAgICAvKiBlbmQtb2YtYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgICAgYnJlYWsgdG9wO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgbGl0ZXJhbC9sZW5ndGggY29kZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrIHRvcDtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7IC8vIG5lZWQgdG8gZW11bGF0ZSBnb3RvIHZpYSBcImNvbnRpbnVlXCJcbiAgICB9XG4gIH0gd2hpbGUgKF9pbiA8IGxhc3QgJiYgX291dCA8IGVuZCk7XG5cbiAgLyogcmV0dXJuIHVudXNlZCBieXRlcyAob24gZW50cnksIGJpdHMgPCA4LCBzbyBpbiB3b24ndCBnbyB0b28gZmFyIGJhY2spICovXG4gIGxlbiA9IGJpdHMgPj4gMztcbiAgX2luIC09IGxlbjtcbiAgYml0cyAtPSBsZW4gPDwgMztcbiAgaG9sZCAmPSAoMSA8PCBiaXRzKSAtIDE7XG5cbiAgLyogdXBkYXRlIHN0YXRlIGFuZCByZXR1cm4gKi9cbiAgc3RybS5uZXh0X2luID0gX2luO1xuICBzdHJtLm5leHRfb3V0ID0gX291dDtcbiAgc3RybS5hdmFpbF9pbiA9IChfaW4gPCBsYXN0ID8gNSArIChsYXN0IC0gX2luKSA6IDUgLSAoX2luIC0gbGFzdCkpO1xuICBzdHJtLmF2YWlsX291dCA9IChfb3V0IDwgZW5kID8gMjU3ICsgKGVuZCAtIF9vdXQpIDogMjU3IC0gKF9vdXQgLSBlbmQpKTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICByZXR1cm47XG59O1xuIiwiaW1wb3J0ICogYXMgdXRpbHMgZnJvbSBcIi4uL3V0aWxzL2NvbW1vbi5qc1wiO1xuaW1wb3J0IGFkbGVyMzIgZnJvbSBcIi4vYWRsZXIzMi5qc1wiO1xuaW1wb3J0IGNyYzMyIGZyb20gXCIuL2NyYzMyLmpzXCI7XG5pbXBvcnQgaW5mbGF0ZV9mYXN0IGZyb20gXCIuL2luZmZhc3QuanNcIjtcbmltcG9ydCBpbmZsYXRlX3RhYmxlIGZyb20gXCIuL2luZnRyZWVzLmpzXCI7XG5cbnZhciBDT0RFUyA9IDA7XG52YXIgTEVOUyA9IDE7XG52YXIgRElTVFMgPSAyO1xuXG4vKiBQdWJsaWMgY29uc3RhbnRzID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuLyogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09Ki9cblxuXG4vKiBBbGxvd2VkIGZsdXNoIHZhbHVlczsgc2VlIGRlZmxhdGUoKSBhbmQgaW5mbGF0ZSgpIGJlbG93IGZvciBkZXRhaWxzICovXG4vL3ZhciBaX05PX0ZMVVNIICAgICAgPSAwO1xuLy92YXIgWl9QQVJUSUFMX0ZMVVNIID0gMTtcbi8vdmFyIFpfU1lOQ19GTFVTSCAgICA9IDI7XG4vL3ZhciBaX0ZVTExfRkxVU0ggICAgPSAzO1xudmFyIFpfRklOSVNIICAgICAgICA9IDQ7XG52YXIgWl9CTE9DSyAgICAgICAgID0gNTtcbnZhciBaX1RSRUVTICAgICAgICAgPSA2O1xuXG5cbi8qIFJldHVybiBjb2RlcyBmb3IgdGhlIGNvbXByZXNzaW9uL2RlY29tcHJlc3Npb24gZnVuY3Rpb25zLiBOZWdhdGl2ZSB2YWx1ZXNcbiAqIGFyZSBlcnJvcnMsIHBvc2l0aXZlIHZhbHVlcyBhcmUgdXNlZCBmb3Igc3BlY2lhbCBidXQgbm9ybWFsIGV2ZW50cy5cbiAqL1xudmFyIFpfT0sgICAgICAgICAgICA9IDA7XG52YXIgWl9TVFJFQU1fRU5EICAgID0gMTtcbnZhciBaX05FRURfRElDVCAgICAgPSAyO1xuLy92YXIgWl9FUlJOTyAgICAgICAgID0gLTE7XG52YXIgWl9TVFJFQU1fRVJST1IgID0gLTI7XG52YXIgWl9EQVRBX0VSUk9SICAgID0gLTM7XG52YXIgWl9NRU1fRVJST1IgICAgID0gLTQ7XG52YXIgWl9CVUZfRVJST1IgICAgID0gLTU7XG4vL3ZhciBaX1ZFUlNJT05fRVJST1IgPSAtNjtcblxuLyogVGhlIGRlZmxhdGUgY29tcHJlc3Npb24gbWV0aG9kICovXG52YXIgWl9ERUZMQVRFRCAgPSA4O1xuXG5cbi8qIFNUQVRFUyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PSovXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cbnZhciAgICBIRUFEID0gMTsgICAgICAgLyogaTogd2FpdGluZyBmb3IgbWFnaWMgaGVhZGVyICovXG52YXIgICAgRkxBR1MgPSAyOyAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1ldGhvZCBhbmQgZmxhZ3MgKGd6aXApICovXG52YXIgICAgVElNRSA9IDM7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIG1vZGlmaWNhdGlvbiB0aW1lIChnemlwKSAqL1xudmFyICAgIE9TID0gNDsgICAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBmbGFncyBhbmQgb3BlcmF0aW5nIHN5c3RlbSAoZ3ppcCkgKi9cbnZhciAgICBFWExFTiA9IDU7ICAgICAgLyogaTogd2FpdGluZyBmb3IgZXh0cmEgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIEVYVFJBID0gNjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBleHRyYSBieXRlcyAoZ3ppcCkgKi9cbnZhciAgICBOQU1FID0gNzsgICAgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGZpbGUgbmFtZSAoZ3ppcCkgKi9cbnZhciAgICBDT01NRU5UID0gODsgICAgLyogaTogd2FpdGluZyBmb3IgZW5kIG9mIGNvbW1lbnQgKGd6aXApICovXG52YXIgICAgSENSQyA9IDk7ICAgICAgIC8qIGk6IHdhaXRpbmcgZm9yIGhlYWRlciBjcmMgKGd6aXApICovXG52YXIgICAgRElDVElEID0gMTA7ICAgIC8qIGk6IHdhaXRpbmcgZm9yIGRpY3Rpb25hcnkgY2hlY2sgdmFsdWUgKi9cbnZhciAgICBESUNUID0gMTE7ICAgICAgLyogd2FpdGluZyBmb3IgaW5mbGF0ZVNldERpY3Rpb25hcnkoKSBjYWxsICovXG52YXIgICAgICAgIFRZUEUgPSAxMjsgICAgICAvKiBpOiB3YWl0aW5nIGZvciB0eXBlIGJpdHMsIGluY2x1ZGluZyBsYXN0LWZsYWcgYml0ICovXG52YXIgICAgICAgIFRZUEVETyA9IDEzOyAgICAvKiBpOiBzYW1lLCBidXQgc2tpcCBjaGVjayB0byBleGl0IGluZmxhdGUgb24gbmV3IGJsb2NrICovXG52YXIgICAgICAgIFNUT1JFRCA9IDE0OyAgICAvKiBpOiB3YWl0aW5nIGZvciBzdG9yZWQgc2l6ZSAobGVuZ3RoIGFuZCBjb21wbGVtZW50KSAqL1xudmFyICAgICAgICBDT1BZXyA9IDE1OyAgICAgLyogaS9vOiBzYW1lIGFzIENPUFkgYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgQ09QWSA9IDE2OyAgICAgIC8qIGkvbzogd2FpdGluZyBmb3IgaW5wdXQgb3Igb3V0cHV0IHRvIGNvcHkgc3RvcmVkIGJsb2NrICovXG52YXIgICAgICAgIFRBQkxFID0gMTc7ICAgICAvKiBpOiB3YWl0aW5nIGZvciBkeW5hbWljIGJsb2NrIHRhYmxlIGxlbmd0aHMgKi9cbnZhciAgICAgICAgTEVOTEVOUyA9IDE4OyAgIC8qIGk6IHdhaXRpbmcgZm9yIGNvZGUgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xudmFyICAgICAgICBDT0RFTEVOUyA9IDE5OyAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoL2xpdCBhbmQgZGlzdGFuY2UgY29kZSBsZW5ndGhzICovXG52YXIgICAgICAgICAgICBMRU5fID0gMjA7ICAgICAgLyogaTogc2FtZSBhcyBMRU4gYmVsb3csIGJ1dCBvbmx5IGZpcnN0IHRpbWUgaW4gKi9cbnZhciAgICAgICAgICAgIExFTiA9IDIxOyAgICAgICAvKiBpOiB3YWl0aW5nIGZvciBsZW5ndGgvbGl0L2VvYiBjb2RlICovXG52YXIgICAgICAgICAgICBMRU5FWFQgPSAyMjsgICAgLyogaTogd2FpdGluZyBmb3IgbGVuZ3RoIGV4dHJhIGJpdHMgKi9cbnZhciAgICAgICAgICAgIERJU1QgPSAyMzsgICAgICAvKiBpOiB3YWl0aW5nIGZvciBkaXN0YW5jZSBjb2RlICovXG52YXIgICAgICAgICAgICBESVNURVhUID0gMjQ7ICAgLyogaTogd2FpdGluZyBmb3IgZGlzdGFuY2UgZXh0cmEgYml0cyAqL1xudmFyICAgICAgICAgICAgTUFUQ0ggPSAyNTsgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byBjb3B5IHN0cmluZyAqL1xudmFyICAgICAgICAgICAgTElUID0gMjY7ICAgICAgIC8qIG86IHdhaXRpbmcgZm9yIG91dHB1dCBzcGFjZSB0byB3cml0ZSBsaXRlcmFsICovXG52YXIgICAgQ0hFQ0sgPSAyNzsgICAgIC8qIGk6IHdhaXRpbmcgZm9yIDMyLWJpdCBjaGVjayB2YWx1ZSAqL1xudmFyICAgIExFTkdUSCA9IDI4OyAgICAvKiBpOiB3YWl0aW5nIGZvciAzMi1iaXQgbGVuZ3RoIChnemlwKSAqL1xudmFyICAgIERPTkUgPSAyOTsgICAgICAvKiBmaW5pc2hlZCBjaGVjaywgZG9uZSAtLSByZW1haW4gaGVyZSB1bnRpbCByZXNldCAqL1xudmFyICAgIEJBRCA9IDMwOyAgICAgICAvKiBnb3QgYSBkYXRhIGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgTUVNID0gMzE7ICAgICAgIC8qIGdvdCBhbiBpbmZsYXRlKCkgbWVtb3J5IGVycm9yIC0tIHJlbWFpbiBoZXJlIHVudGlsIHJlc2V0ICovXG52YXIgICAgU1lOQyA9IDMyOyAgICAgIC8qIGxvb2tpbmcgZm9yIHN5bmNocm9uaXphdGlvbiBieXRlcyB0byByZXN0YXJ0IGluZmxhdGUoKSAqL1xuXG4vKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0qL1xuXG5cblxudmFyIEVOT1VHSF9MRU5TID0gODUyO1xudmFyIEVOT1VHSF9ESVNUUyA9IDU5Mjtcbi8vdmFyIEVOT1VHSCA9ICAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIE1BWF9XQklUUyA9IDE1O1xuLyogMzJLIExaNzcgd2luZG93ICovXG52YXIgREVGX1dCSVRTID0gTUFYX1dCSVRTO1xuXG5cbmZ1bmN0aW9uIHpzd2FwMzIocSkge1xuICByZXR1cm4gICgoKHEgPj4+IDI0KSAmIDB4ZmYpICtcbiAgICAgICAgICAoKHEgPj4+IDgpICYgMHhmZjAwKSArXG4gICAgICAgICAgKChxICYgMHhmZjAwKSA8PCA4KSArXG4gICAgICAgICAgKChxICYgMHhmZikgPDwgMjQpKTtcbn1cblxuXG5mdW5jdGlvbiBJbmZsYXRlU3RhdGUoKSB7XG4gIHRoaXMubW9kZSA9IDA7ICAgICAgICAgICAgIC8qIGN1cnJlbnQgaW5mbGF0ZSBtb2RlICovXG4gIHRoaXMubGFzdCA9IGZhbHNlOyAgICAgICAgICAvKiB0cnVlIGlmIHByb2Nlc3NpbmcgbGFzdCBibG9jayAqL1xuICB0aGlzLndyYXAgPSAwOyAgICAgICAgICAgICAgLyogYml0IDAgdHJ1ZSBmb3IgemxpYiwgYml0IDEgdHJ1ZSBmb3IgZ3ppcCAqL1xuICB0aGlzLmhhdmVkaWN0ID0gZmFsc2U7ICAgICAgLyogdHJ1ZSBpZiBkaWN0aW9uYXJ5IHByb3ZpZGVkICovXG4gIHRoaXMuZmxhZ3MgPSAwOyAgICAgICAgICAgICAvKiBnemlwIGhlYWRlciBtZXRob2QgYW5kIGZsYWdzICgwIGlmIHpsaWIpICovXG4gIHRoaXMuZG1heCA9IDA7ICAgICAgICAgICAgICAvKiB6bGliIGhlYWRlciBtYXggZGlzdGFuY2UgKElORkxBVEVfU1RSSUNUKSAqL1xuICB0aGlzLmNoZWNrID0gMDsgICAgICAgICAgICAgLyogcHJvdGVjdGVkIGNvcHkgb2YgY2hlY2sgdmFsdWUgKi9cbiAgdGhpcy50b3RhbCA9IDA7ICAgICAgICAgICAgIC8qIHByb3RlY3RlZCBjb3B5IG9mIG91dHB1dCBjb3VudCAqL1xuICAvLyBUT0RPOiBtYXkgYmUge31cbiAgdGhpcy5oZWFkID0gbnVsbDsgICAgICAgICAgIC8qIHdoZXJlIHRvIHNhdmUgZ3ppcCBoZWFkZXIgaW5mb3JtYXRpb24gKi9cblxuICAvKiBzbGlkaW5nIHdpbmRvdyAqL1xuICB0aGlzLndiaXRzID0gMDsgICAgICAgICAgICAgLyogbG9nIGJhc2UgMiBvZiByZXF1ZXN0ZWQgd2luZG93IHNpemUgKi9cbiAgdGhpcy53c2l6ZSA9IDA7ICAgICAgICAgICAgIC8qIHdpbmRvdyBzaXplIG9yIHplcm8gaWYgbm90IHVzaW5nIHdpbmRvdyAqL1xuICB0aGlzLndoYXZlID0gMDsgICAgICAgICAgICAgLyogdmFsaWQgYnl0ZXMgaW4gdGhlIHdpbmRvdyAqL1xuICB0aGlzLnduZXh0ID0gMDsgICAgICAgICAgICAgLyogd2luZG93IHdyaXRlIGluZGV4ICovXG4gIHRoaXMud2luZG93ID0gbnVsbDsgICAgICAgICAvKiBhbGxvY2F0ZWQgc2xpZGluZyB3aW5kb3csIGlmIG5lZWRlZCAqL1xuXG4gIC8qIGJpdCBhY2N1bXVsYXRvciAqL1xuICB0aGlzLmhvbGQgPSAwOyAgICAgICAgICAgICAgLyogaW5wdXQgYml0IGFjY3VtdWxhdG9yICovXG4gIHRoaXMuYml0cyA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgYml0cyBpbiBcImluXCIgKi9cblxuICAvKiBmb3Igc3RyaW5nIGFuZCBzdG9yZWQgYmxvY2sgY29weWluZyAqL1xuICB0aGlzLmxlbmd0aCA9IDA7ICAgICAgICAgICAgLyogbGl0ZXJhbCBvciBsZW5ndGggb2YgZGF0YSB0byBjb3B5ICovXG4gIHRoaXMub2Zmc2V0ID0gMDsgICAgICAgICAgICAvKiBkaXN0YW5jZSBiYWNrIHRvIGNvcHkgc3RyaW5nIGZyb20gKi9cblxuICAvKiBmb3IgdGFibGUgYW5kIGNvZGUgZGVjb2RpbmcgKi9cbiAgdGhpcy5leHRyYSA9IDA7ICAgICAgICAgICAgIC8qIGV4dHJhIGJpdHMgbmVlZGVkICovXG5cbiAgLyogZml4ZWQgYW5kIGR5bmFtaWMgY29kZSB0YWJsZXMgKi9cbiAgdGhpcy5sZW5jb2RlID0gbnVsbDsgICAgICAgICAgLyogc3RhcnRpbmcgdGFibGUgZm9yIGxlbmd0aC9saXRlcmFsIGNvZGVzICovXG4gIHRoaXMuZGlzdGNvZGUgPSBudWxsOyAgICAgICAgIC8qIHN0YXJ0aW5nIHRhYmxlIGZvciBkaXN0YW5jZSBjb2RlcyAqL1xuICB0aGlzLmxlbmJpdHMgPSAwOyAgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgbGVuY29kZSAqL1xuICB0aGlzLmRpc3RiaXRzID0gMDsgICAgICAgICAgLyogaW5kZXggYml0cyBmb3IgZGlzdGNvZGUgKi9cblxuICAvKiBkeW5hbWljIHRhYmxlIGJ1aWxkaW5nICovXG4gIHRoaXMubmNvZGUgPSAwOyAgICAgICAgICAgICAvKiBudW1iZXIgb2YgY29kZSBsZW5ndGggY29kZSBsZW5ndGhzICovXG4gIHRoaXMubmxlbiA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgbGVuZ3RoIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLm5kaXN0ID0gMDsgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGRpc3RhbmNlIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLmhhdmUgPSAwOyAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIGNvZGUgbGVuZ3RocyBpbiBsZW5zW10gKi9cbiAgdGhpcy5uZXh0ID0gbnVsbDsgICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIGNvZGVzW10gKi9cblxuICB0aGlzLmxlbnMgPSBuZXcgdXRpbHMuQnVmMTYoMzIwKTsgLyogdGVtcG9yYXJ5IHN0b3JhZ2UgZm9yIGNvZGUgbGVuZ3RocyAqL1xuICB0aGlzLndvcmsgPSBuZXcgdXRpbHMuQnVmMTYoMjg4KTsgLyogd29yayBhcmVhIGZvciBjb2RlIHRhYmxlIGJ1aWxkaW5nICovXG5cbiAgLypcbiAgIGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSBwb2ludGVycyBpbiBqcywgd2UgdXNlIGxlbmNvZGUgYW5kIGRpc3Rjb2RlIGRpcmVjdGx5XG4gICBhcyBidWZmZXJzIHNvIHdlIGRvbid0IG5lZWQgY29kZXNcbiAgKi9cbiAgLy90aGlzLmNvZGVzID0gbmV3IHV0aWxzLkJ1ZjMyKEVOT1VHSCk7ICAgICAgIC8qIHNwYWNlIGZvciBjb2RlIHRhYmxlcyAqL1xuICB0aGlzLmxlbmR5biA9IG51bGw7ICAgICAgICAgICAgICAvKiBkeW5hbWljIHRhYmxlIGZvciBsZW5ndGgvbGl0ZXJhbCBjb2RlcyAoSlMgc3BlY2lmaWMpICovXG4gIHRoaXMuZGlzdGR5biA9IG51bGw7ICAgICAgICAgICAgIC8qIGR5bmFtaWMgdGFibGUgZm9yIGRpc3RhbmNlIGNvZGVzIChKUyBzcGVjaWZpYykgKi9cbiAgdGhpcy5zYW5lID0gMDsgICAgICAgICAgICAgICAgICAgLyogaWYgZmFsc2UsIGFsbG93IGludmFsaWQgZGlzdGFuY2UgdG9vIGZhciAqL1xuICB0aGlzLmJhY2sgPSAwOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGJhY2sgb2YgbGFzdCB1bnByb2Nlc3NlZCBsZW5ndGgvbGl0ICovXG4gIHRoaXMud2FzID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIGluaXRpYWwgbGVuZ3RoIG9mIG1hdGNoICovXG59XG5cbmZ1bmN0aW9uIGluZmxhdGVSZXNldEtlZXAoc3RybSkge1xuICB2YXIgc3RhdGU7XG5cbiAgaWYgKCFzdHJtIHx8ICFzdHJtLnN0YXRlKSB7IHJldHVybiBaX1NUUkVBTV9FUlJPUjsgfVxuICBzdGF0ZSA9IHN0cm0uc3RhdGU7XG4gIHN0cm0udG90YWxfaW4gPSBzdHJtLnRvdGFsX291dCA9IHN0YXRlLnRvdGFsID0gMDtcbiAgc3RybS5tc2cgPSAnJzsgLypaX05VTEwqL1xuICBpZiAoc3RhdGUud3JhcCkgeyAgICAgICAvKiB0byBzdXBwb3J0IGlsbC1jb25jZWl2ZWQgSmF2YSB0ZXN0IHN1aXRlICovXG4gICAgc3RybS5hZGxlciA9IHN0YXRlLndyYXAgJiAxO1xuICB9XG4gIHN0YXRlLm1vZGUgPSBIRUFEO1xuICBzdGF0ZS5sYXN0ID0gMDtcbiAgc3RhdGUuaGF2ZWRpY3QgPSAwO1xuICBzdGF0ZS5kbWF4ID0gMzI3Njg7XG4gIHN0YXRlLmhlYWQgPSBudWxsLypaX05VTEwqLztcbiAgc3RhdGUuaG9sZCA9IDA7XG4gIHN0YXRlLmJpdHMgPSAwO1xuICAvL3N0YXRlLmxlbmNvZGUgPSBzdGF0ZS5kaXN0Y29kZSA9IHN0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgc3RhdGUubGVuY29kZSA9IHN0YXRlLmxlbmR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfTEVOUyk7XG4gIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUuZGlzdGR5biA9IG5ldyB1dGlscy5CdWYzMihFTk9VR0hfRElTVFMpO1xuXG4gIHN0YXRlLnNhbmUgPSAxO1xuICBzdGF0ZS5iYWNrID0gLTE7XG4gIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogcmVzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVJlc2V0KHN0cm0pIHtcbiAgdmFyIHN0YXRlO1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBzdGF0ZS53c2l6ZSA9IDA7XG4gIHN0YXRlLndoYXZlID0gMDtcbiAgc3RhdGUud25leHQgPSAwO1xuICByZXR1cm4gaW5mbGF0ZVJlc2V0S2VlcChzdHJtKTtcblxufVxuXG5mdW5jdGlvbiBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpIHtcbiAgdmFyIHdyYXA7XG4gIHZhciBzdGF0ZTtcblxuICAvKiBnZXQgdGhlIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGV4dHJhY3Qgd3JhcCByZXF1ZXN0IGZyb20gd2luZG93Qml0cyBwYXJhbWV0ZXIgKi9cbiAgaWYgKHdpbmRvd0JpdHMgPCAwKSB7XG4gICAgd3JhcCA9IDA7XG4gICAgd2luZG93Qml0cyA9IC13aW5kb3dCaXRzO1xuICB9XG4gIGVsc2Uge1xuICAgIHdyYXAgPSAod2luZG93Qml0cyA+PiA0KSArIDE7XG4gICAgaWYgKHdpbmRvd0JpdHMgPCA0OCkge1xuICAgICAgd2luZG93Qml0cyAmPSAxNTtcbiAgICB9XG4gIH1cblxuICAvKiBzZXQgbnVtYmVyIG9mIHdpbmRvdyBiaXRzLCBmcmVlIHdpbmRvdyBpZiBkaWZmZXJlbnQgKi9cbiAgaWYgKHdpbmRvd0JpdHMgJiYgKHdpbmRvd0JpdHMgPCA4IHx8IHdpbmRvd0JpdHMgPiAxNSkpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cbiAgaWYgKHN0YXRlLndpbmRvdyAhPT0gbnVsbCAmJiBzdGF0ZS53Yml0cyAhPT0gd2luZG93Qml0cykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cblxuICAvKiB1cGRhdGUgc3RhdGUgYW5kIHJlc2V0IHRoZSByZXN0IG9mIGl0ICovXG4gIHN0YXRlLndyYXAgPSB3cmFwO1xuICBzdGF0ZS53Yml0cyA9IHdpbmRvd0JpdHM7XG4gIHJldHVybiBpbmZsYXRlUmVzZXQoc3RybSk7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0MihzdHJtLCB3aW5kb3dCaXRzKSB7XG4gIHZhciByZXQ7XG4gIHZhciBzdGF0ZTtcblxuICBpZiAoIXN0cm0pIHsgcmV0dXJuIFpfU1RSRUFNX0VSUk9SOyB9XG4gIC8vc3RybS5tc2cgPSBaX05VTEw7ICAgICAgICAgICAgICAgICAvKiBpbiBjYXNlIHdlIHJldHVybiBhbiBlcnJvciAqL1xuXG4gIHN0YXRlID0gbmV3IEluZmxhdGVTdGF0ZSgpO1xuXG4gIC8vaWYgKHN0YXRlID09PSBaX05VTEwpIHJldHVybiBaX01FTV9FUlJPUjtcbiAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiBhbGxvY2F0ZWRcXG5cIikpO1xuICBzdHJtLnN0YXRlID0gc3RhdGU7XG4gIHN0YXRlLndpbmRvdyA9IG51bGwvKlpfTlVMTCovO1xuICByZXQgPSBpbmZsYXRlUmVzZXQyKHN0cm0sIHdpbmRvd0JpdHMpO1xuICBpZiAocmV0ICE9PSBaX09LKSB7XG4gICAgc3RybS5zdGF0ZSA9IG51bGwvKlpfTlVMTCovO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVJbml0KHN0cm0pIHtcbiAgcmV0dXJuIGluZmxhdGVJbml0MihzdHJtLCBERUZfV0JJVFMpO1xufVxuXG5cbi8qXG4gUmV0dXJuIHN0YXRlIHdpdGggbGVuZ3RoIGFuZCBkaXN0YW5jZSBkZWNvZGluZyB0YWJsZXMgYW5kIGluZGV4IHNpemVzIHNldCB0b1xuIGZpeGVkIGNvZGUgZGVjb2RpbmcuICBOb3JtYWxseSB0aGlzIHJldHVybnMgZml4ZWQgdGFibGVzIGZyb20gaW5mZml4ZWQuaC5cbiBJZiBCVUlMREZJWEVEIGlzIGRlZmluZWQsIHRoZW4gaW5zdGVhZCB0aGlzIHJvdXRpbmUgYnVpbGRzIHRoZSB0YWJsZXMgdGhlXG4gZmlyc3QgdGltZSBpdCdzIGNhbGxlZCwgYW5kIHJldHVybnMgdGhvc2UgdGFibGVzIHRoZSBmaXJzdCB0aW1lIGFuZFxuIHRoZXJlYWZ0ZXIuICBUaGlzIHJlZHVjZXMgdGhlIHNpemUgb2YgdGhlIGNvZGUgYnkgYWJvdXQgMksgYnl0ZXMsIGluXG4gZXhjaGFuZ2UgZm9yIGEgbGl0dGxlIGV4ZWN1dGlvbiB0aW1lLiAgSG93ZXZlciwgQlVJTERGSVhFRCBzaG91bGQgbm90IGJlXG4gdXNlZCBmb3IgdGhyZWFkZWQgYXBwbGljYXRpb25zLCBzaW5jZSB0aGUgcmV3cml0aW5nIG9mIHRoZSB0YWJsZXMgYW5kIHZpcmdpblxuIG1heSBub3QgYmUgdGhyZWFkLXNhZmUuXG4gKi9cbnZhciB2aXJnaW4gPSB0cnVlO1xuXG52YXIgbGVuZml4LCBkaXN0Zml4OyAvLyBXZSBoYXZlIG5vIHBvaW50ZXJzIGluIEpTLCBzbyBrZWVwIHRhYmxlcyBzZXBhcmF0ZVxuXG5mdW5jdGlvbiBmaXhlZHRhYmxlcyhzdGF0ZSkge1xuICAvKiBidWlsZCBmaXhlZCBodWZmbWFuIHRhYmxlcyBpZiBmaXJzdCBjYWxsIChtYXkgbm90IGJlIHRocmVhZCBzYWZlKSAqL1xuICBpZiAodmlyZ2luKSB7XG4gICAgdmFyIHN5bTtcblxuICAgIGxlbmZpeCA9IG5ldyB1dGlscy5CdWYzMig1MTIpO1xuICAgIGRpc3RmaXggPSBuZXcgdXRpbHMuQnVmMzIoMzIpO1xuXG4gICAgLyogbGl0ZXJhbC9sZW5ndGggdGFibGUgKi9cbiAgICBzeW0gPSAwO1xuICAgIHdoaWxlIChzeW0gPCAxNDQpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG4gICAgd2hpbGUgKHN5bSA8IDI1NikgeyBzdGF0ZS5sZW5zW3N5bSsrXSA9IDk7IH1cbiAgICB3aGlsZSAoc3ltIDwgMjgwKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNzsgfVxuICAgIHdoaWxlIChzeW0gPCAyODgpIHsgc3RhdGUubGVuc1tzeW0rK10gPSA4OyB9XG5cbiAgICBpbmZsYXRlX3RhYmxlKExFTlMsICBzdGF0ZS5sZW5zLCAwLCAyODgsIGxlbmZpeCwgICAwLCBzdGF0ZS53b3JrLCB7IGJpdHM6IDkgfSk7XG5cbiAgICAvKiBkaXN0YW5jZSB0YWJsZSAqL1xuICAgIHN5bSA9IDA7XG4gICAgd2hpbGUgKHN5bSA8IDMyKSB7IHN0YXRlLmxlbnNbc3ltKytdID0gNTsgfVxuXG4gICAgaW5mbGF0ZV90YWJsZShESVNUUywgc3RhdGUubGVucywgMCwgMzIsICAgZGlzdGZpeCwgMCwgc3RhdGUud29yaywgeyBiaXRzOiA1IH0pO1xuXG4gICAgLyogZG8gdGhpcyBqdXN0IG9uY2UgKi9cbiAgICB2aXJnaW4gPSBmYWxzZTtcbiAgfVxuXG4gIHN0YXRlLmxlbmNvZGUgPSBsZW5maXg7XG4gIHN0YXRlLmxlbmJpdHMgPSA5O1xuICBzdGF0ZS5kaXN0Y29kZSA9IGRpc3RmaXg7XG4gIHN0YXRlLmRpc3RiaXRzID0gNTtcbn1cblxuXG4vKlxuIFVwZGF0ZSB0aGUgd2luZG93IHdpdGggdGhlIGxhc3Qgd3NpemUgKG5vcm1hbGx5IDMySykgYnl0ZXMgd3JpdHRlbiBiZWZvcmVcbiByZXR1cm5pbmcuICBJZiB3aW5kb3cgZG9lcyBub3QgZXhpc3QgeWV0LCBjcmVhdGUgaXQuICBUaGlzIGlzIG9ubHkgY2FsbGVkXG4gd2hlbiBhIHdpbmRvdyBpcyBhbHJlYWR5IGluIHVzZSwgb3Igd2hlbiBvdXRwdXQgaGFzIGJlZW4gd3JpdHRlbiBkdXJpbmcgdGhpc1xuIGluZmxhdGUgY2FsbCwgYnV0IHRoZSBlbmQgb2YgdGhlIGRlZmxhdGUgc3RyZWFtIGhhcyBub3QgYmVlbiByZWFjaGVkIHlldC5cbiBJdCBpcyBhbHNvIGNhbGxlZCB0byBjcmVhdGUgYSB3aW5kb3cgZm9yIGRpY3Rpb25hcnkgZGF0YSB3aGVuIGEgZGljdGlvbmFyeVxuIGlzIGxvYWRlZC5cblxuIFByb3ZpZGluZyBvdXRwdXQgYnVmZmVycyBsYXJnZXIgdGhhbiAzMksgdG8gaW5mbGF0ZSgpIHNob3VsZCBwcm92aWRlIGEgc3BlZWRcbiBhZHZhbnRhZ2UsIHNpbmNlIG9ubHkgdGhlIGxhc3QgMzJLIG9mIG91dHB1dCBpcyBjb3BpZWQgdG8gdGhlIHNsaWRpbmcgd2luZG93XG4gdXBvbiByZXR1cm4gZnJvbSBpbmZsYXRlKCksIGFuZCBzaW5jZSBhbGwgZGlzdGFuY2VzIGFmdGVyIHRoZSBmaXJzdCAzMksgb2ZcbiBvdXRwdXQgd2lsbCBmYWxsIGluIHRoZSBvdXRwdXQgZGF0YSwgbWFraW5nIG1hdGNoIGNvcGllcyBzaW1wbGVyIGFuZCBmYXN0ZXIuXG4gVGhlIGFkdmFudGFnZSBtYXkgYmUgZGVwZW5kZW50IG9uIHRoZSBzaXplIG9mIHRoZSBwcm9jZXNzb3IncyBkYXRhIGNhY2hlcy5cbiAqL1xuZnVuY3Rpb24gdXBkYXRld2luZG93KHN0cm0sIHNyYywgZW5kLCBjb3B5KSB7XG4gIHZhciBkaXN0O1xuICB2YXIgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIC8qIGlmIGl0IGhhc24ndCBiZWVuIGRvbmUgYWxyZWFkeSwgYWxsb2NhdGUgc3BhY2UgZm9yIHRoZSB3aW5kb3cgKi9cbiAgaWYgKHN0YXRlLndpbmRvdyA9PT0gbnVsbCkge1xuICAgIHN0YXRlLndzaXplID0gMSA8PCBzdGF0ZS53Yml0cztcbiAgICBzdGF0ZS53bmV4dCA9IDA7XG4gICAgc3RhdGUud2hhdmUgPSAwO1xuXG4gICAgc3RhdGUud2luZG93ID0gbmV3IHV0aWxzLkJ1Zjgoc3RhdGUud3NpemUpO1xuICB9XG5cbiAgLyogY29weSBzdGF0ZS0+d3NpemUgb3IgbGVzcyBvdXRwdXQgYnl0ZXMgaW50byB0aGUgY2lyY3VsYXIgd2luZG93ICovXG4gIGlmIChjb3B5ID49IHN0YXRlLndzaXplKSB7XG4gICAgdXRpbHMuYXJyYXlTZXQoc3RhdGUud2luZG93LCBzcmMsIGVuZCAtIHN0YXRlLndzaXplLCBzdGF0ZS53c2l6ZSwgMCk7XG4gICAgc3RhdGUud25leHQgPSAwO1xuICAgIHN0YXRlLndoYXZlID0gc3RhdGUud3NpemU7XG4gIH1cbiAgZWxzZSB7XG4gICAgZGlzdCA9IHN0YXRlLndzaXplIC0gc3RhdGUud25leHQ7XG4gICAgaWYgKGRpc3QgPiBjb3B5KSB7XG4gICAgICBkaXN0ID0gY29weTtcbiAgICB9XG4gICAgLy96bWVtY3B5KHN0YXRlLT53aW5kb3cgKyBzdGF0ZS0+d25leHQsIGVuZCAtIGNvcHksIGRpc3QpO1xuICAgIHV0aWxzLmFycmF5U2V0KHN0YXRlLndpbmRvdywgc3JjLCBlbmQgLSBjb3B5LCBkaXN0LCBzdGF0ZS53bmV4dCk7XG4gICAgY29weSAtPSBkaXN0O1xuICAgIGlmIChjb3B5KSB7XG4gICAgICAvL3ptZW1jcHkoc3RhdGUtPndpbmRvdywgZW5kIC0gY29weSwgY29weSk7XG4gICAgICB1dGlscy5hcnJheVNldChzdGF0ZS53aW5kb3csIHNyYywgZW5kIC0gY29weSwgY29weSwgMCk7XG4gICAgICBzdGF0ZS53bmV4dCA9IGNvcHk7XG4gICAgICBzdGF0ZS53aGF2ZSA9IHN0YXRlLndzaXplO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN0YXRlLnduZXh0ICs9IGRpc3Q7XG4gICAgICBpZiAoc3RhdGUud25leHQgPT09IHN0YXRlLndzaXplKSB7IHN0YXRlLnduZXh0ID0gMDsgfVxuICAgICAgaWYgKHN0YXRlLndoYXZlIDwgc3RhdGUud3NpemUpIHsgc3RhdGUud2hhdmUgKz0gZGlzdDsgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZShzdHJtLCBmbHVzaCkge1xuICB2YXIgc3RhdGU7XG4gIHZhciBpbnB1dCwgb3V0cHV0OyAgICAgICAgICAvLyBpbnB1dC9vdXRwdXQgYnVmZmVyc1xuICB2YXIgbmV4dDsgICAgICAgICAgICAgICAgICAgLyogbmV4dCBpbnB1dCBJTkRFWCAqL1xuICB2YXIgcHV0OyAgICAgICAgICAgICAgICAgICAgLyogbmV4dCBvdXRwdXQgSU5ERVggKi9cbiAgdmFyIGhhdmUsIGxlZnQ7ICAgICAgICAgICAgIC8qIGF2YWlsYWJsZSBpbnB1dCBhbmQgb3V0cHV0ICovXG4gIHZhciBob2xkOyAgICAgICAgICAgICAgICAgICAvKiBiaXQgYnVmZmVyICovXG4gIHZhciBiaXRzOyAgICAgICAgICAgICAgICAgICAvKiBiaXRzIGluIGJpdCBidWZmZXIgKi9cbiAgdmFyIF9pbiwgX291dDsgICAgICAgICAgICAgIC8qIHNhdmUgc3RhcnRpbmcgYXZhaWxhYmxlIGlucHV0IGFuZCBvdXRwdXQgKi9cbiAgdmFyIGNvcHk7ICAgICAgICAgICAgICAgICAgIC8qIG51bWJlciBvZiBzdG9yZWQgb3IgbWF0Y2ggYnl0ZXMgdG8gY29weSAqL1xuICB2YXIgZnJvbTsgICAgICAgICAgICAgICAgICAgLyogd2hlcmUgdG8gY29weSBtYXRjaCBieXRlcyBmcm9tICovXG4gIHZhciBmcm9tX3NvdXJjZTtcbiAgdmFyIGhlcmUgPSAwOyAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgZGVjb2RpbmcgdGFibGUgZW50cnkgKi9cbiAgdmFyIGhlcmVfYml0cywgaGVyZV9vcCwgaGVyZV92YWw7IC8vIHBha2VkIFwiaGVyZVwiIGRlbm9ybWFsaXplZCAoSlMgc3BlY2lmaWMpXG4gIC8vdmFyIGxhc3Q7ICAgICAgICAgICAgICAgICAgIC8qIHBhcmVudCB0YWJsZSBlbnRyeSAqL1xuICB2YXIgbGFzdF9iaXRzLCBsYXN0X29wLCBsYXN0X3ZhbDsgLy8gcGFrZWQgXCJsYXN0XCIgZGVub3JtYWxpemVkIChKUyBzcGVjaWZpYylcbiAgdmFyIGxlbjsgICAgICAgICAgICAgICAgICAgIC8qIGxlbmd0aCB0byBjb3B5IGZvciByZXBlYXRzLCBiaXRzIHRvIGRyb3AgKi9cbiAgdmFyIHJldDsgICAgICAgICAgICAgICAgICAgIC8qIHJldHVybiBjb2RlICovXG4gIHZhciBoYnVmID0gbmV3IHV0aWxzLkJ1ZjgoNCk7ICAgIC8qIGJ1ZmZlciBmb3IgZ3ppcCBoZWFkZXIgY3JjIGNhbGN1bGF0aW9uICovXG4gIHZhciBvcHRzO1xuXG4gIHZhciBuOyAvLyB0ZW1wb3JhcnkgdmFyIGZvciBORUVEX0JJVFNcblxuICB2YXIgb3JkZXIgPSAvKiBwZXJtdXRhdGlvbiBvZiBjb2RlIGxlbmd0aHMgKi9cbiAgICBbIDE2LCAxNywgMTgsIDAsIDgsIDcsIDksIDYsIDEwLCA1LCAxMSwgNCwgMTIsIDMsIDEzLCAyLCAxNCwgMSwgMTUgXTtcblxuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSB8fCAhc3RybS5vdXRwdXQgfHxcbiAgICAgICghc3RybS5pbnB1dCAmJiBzdHJtLmF2YWlsX2luICE9PSAwKSkge1xuICAgIHJldHVybiBaX1NUUkVBTV9FUlJPUjtcbiAgfVxuXG4gIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLm1vZGUgPT09IFRZUEUpIHsgc3RhdGUubW9kZSA9IFRZUEVETzsgfSAgICAvKiBza2lwIGNoZWNrICovXG5cblxuICAvLy0tLSBMT0FEKCkgLS0tXG4gIHB1dCA9IHN0cm0ubmV4dF9vdXQ7XG4gIG91dHB1dCA9IHN0cm0ub3V0cHV0O1xuICBsZWZ0ID0gc3RybS5hdmFpbF9vdXQ7XG4gIG5leHQgPSBzdHJtLm5leHRfaW47XG4gIGlucHV0ID0gc3RybS5pbnB1dDtcbiAgaGF2ZSA9IHN0cm0uYXZhaWxfaW47XG4gIGhvbGQgPSBzdGF0ZS5ob2xkO1xuICBiaXRzID0gc3RhdGUuYml0cztcbiAgLy8tLS1cblxuICBfaW4gPSBoYXZlO1xuICBfb3V0ID0gbGVmdDtcbiAgcmV0ID0gWl9PSztcblxuICBpbmZfbGVhdmU6IC8vIGdvdG8gZW11bGF0aW9uXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKHN0YXRlLm1vZGUpIHtcbiAgICBjYXNlIEhFQUQ6XG4gICAgICBpZiAoc3RhdGUud3JhcCA9PT0gMCkge1xuICAgICAgICBzdGF0ZS5tb2RlID0gVFlQRURPO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vPT09IE5FRURCSVRTKDE2KTtcbiAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIGlmICgoc3RhdGUud3JhcCAmIDIpICYmIGhvbGQgPT09IDB4OGIxZikgeyAgLyogZ3ppcCBoZWFkZXIgKi9cbiAgICAgICAgc3RhdGUuY2hlY2sgPSAwLypjcmMzMigwTCwgWl9OVUxMLCAwKSovO1xuICAgICAgICAvLz09PSBDUkMyKHN0YXRlLmNoZWNrLCBob2xkKTtcbiAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaGJ1ZiwgMiwgMCk7XG4gICAgICAgIC8vPT09Ly9cblxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubW9kZSA9IEZMQUdTO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmZsYWdzID0gMDsgICAgICAgICAgIC8qIGV4cGVjdCB6bGliIGhlYWRlciAqL1xuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIShzdGF0ZS53cmFwICYgMSkgfHwgICAvKiBjaGVjayBpZiB6bGliIGhlYWRlciBhbGxvd2VkICovXG4gICAgICAgICgoKGhvbGQgJiAweGZmKS8qQklUUyg4KSovIDw8IDgpICsgKGhvbGQgPj4gOCkpICUgMzEpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGhlYWRlciBjaGVjayc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKChob2xkICYgMHgwZikvKkJJVFMoNCkqLyAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy8tLS0gRFJPUEJJVFMoNCkgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSA0O1xuICAgICAgYml0cyAtPSA0O1xuICAgICAgLy8tLS0vL1xuICAgICAgbGVuID0gKGhvbGQgJiAweDBmKS8qQklUUyg0KSovICsgODtcbiAgICAgIGlmIChzdGF0ZS53Yml0cyA9PT0gMCkge1xuICAgICAgICBzdGF0ZS53Yml0cyA9IGxlbjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxlbiA+IHN0YXRlLndiaXRzKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgd2luZG93IHNpemUnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmRtYXggPSAxIDw8IGxlbjtcbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICB6bGliIGhlYWRlciBva1xcblwiKSk7XG4gICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICBzdGF0ZS5tb2RlID0gaG9sZCAmIDB4MjAwID8gRElDVElEIDogVFlQRTtcbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBGTEFHUzpcbiAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLmZsYWdzID0gaG9sZDtcbiAgICAgIGlmICgoc3RhdGUuZmxhZ3MgJiAweGZmKSAhPT0gWl9ERUZMQVRFRCkge1xuICAgICAgICBzdHJtLm1zZyA9ICd1bmtub3duIGNvbXByZXNzaW9uIG1ldGhvZCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHhlMDAwKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ3Vua25vd24gaGVhZGVyIGZsYWdzIHNldCc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC50ZXh0ID0gKChob2xkID4+IDgpICYgMSk7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgIGhidWZbMF0gPSBob2xkICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsxXSA9IChob2xkID4+PiA4KSAmIDB4ZmY7XG4gICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAvLz09PS8vXG4gICAgICB9XG4gICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgaG9sZCA9IDA7XG4gICAgICBiaXRzID0gMDtcbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm1vZGUgPSBUSU1FO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgVElNRTpcbiAgICAgIC8vPT09IE5FRURCSVRTKDMyKTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQudGltZSA9IGhvbGQ7XG4gICAgICB9XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgLy89PT0gQ1JDNChzdGF0ZS5jaGVjaywgaG9sZClcbiAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICBoYnVmWzFdID0gKGhvbGQgPj4+IDgpICYgMHhmZjtcbiAgICAgICAgaGJ1ZlsyXSA9IChob2xkID4+PiAxNikgJiAweGZmO1xuICAgICAgICBoYnVmWzNdID0gKGhvbGQgPj4+IDI0KSAmIDB4ZmY7XG4gICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDQsIDApO1xuICAgICAgICAvLz09PVxuICAgICAgfVxuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gT1M7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBPUzpcbiAgICAgIC8vPT09IE5FRURCSVRTKDE2KTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQueGZsYWdzID0gKGhvbGQgJiAweGZmKTtcbiAgICAgICAgc3RhdGUuaGVhZC5vcyA9IChob2xkID4+IDgpO1xuICAgICAgfVxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgIC8vPT09IENSQzIoc3RhdGUuY2hlY2ssIGhvbGQpO1xuICAgICAgICBoYnVmWzBdID0gaG9sZCAmIDB4ZmY7XG4gICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBoYnVmLCAyLCAwKTtcbiAgICAgICAgLy89PT0vL1xuICAgICAgfVxuICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgIGhvbGQgPSAwO1xuICAgICAgYml0cyA9IDA7XG4gICAgICAvLz09PS8vXG4gICAgICBzdGF0ZS5tb2RlID0gRVhMRU47XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBFWExFTjpcbiAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDQwMCkge1xuICAgICAgICAvLz09PSBORUVEQklUUygxNik7ICovXG4gICAgICAgIHdoaWxlIChiaXRzIDwgMTYpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUubGVuZ3RoID0gaG9sZDtcbiAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhX2xlbiA9IGhvbGQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwMjAwKSB7XG4gICAgICAgICAgLy89PT0gQ1JDMihzdGF0ZS5jaGVjaywgaG9sZCk7XG4gICAgICAgICAgaGJ1ZlswXSA9IGhvbGQgJiAweGZmO1xuICAgICAgICAgIGhidWZbMV0gPSAoaG9sZCA+Pj4gOCkgJiAweGZmO1xuICAgICAgICAgIHN0YXRlLmNoZWNrID0gY3JjMzIoc3RhdGUuY2hlY2ssIGhidWYsIDIsIDApO1xuICAgICAgICAgIC8vPT09Ly9cbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgc3RhdGUuaGVhZC5leHRyYSA9IG51bGwvKlpfTlVMTCovO1xuICAgICAgfVxuICAgICAgc3RhdGUubW9kZSA9IEVYVFJBO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgRVhUUkE6XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDA0MDApIHtcbiAgICAgICAgY29weSA9IHN0YXRlLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQpIHtcbiAgICAgICAgICAgIGxlbiA9IHN0YXRlLmhlYWQuZXh0cmFfbGVuIC0gc3RhdGUubGVuZ3RoO1xuICAgICAgICAgICAgaWYgKCFzdGF0ZS5oZWFkLmV4dHJhKSB7XG4gICAgICAgICAgICAgIC8vIFVzZSB1bnR5cGVkIGFycmF5IGZvciBtb3JlIGNvbnZlbmllbmQgcHJvY2Vzc2luZyBsYXRlclxuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhID0gbmV3IEFycmF5KHN0YXRlLmhlYWQuZXh0cmFfbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHV0aWxzLmFycmF5U2V0KFxuICAgICAgICAgICAgICBzdGF0ZS5oZWFkLmV4dHJhLFxuICAgICAgICAgICAgICBpbnB1dCxcbiAgICAgICAgICAgICAgbmV4dCxcbiAgICAgICAgICAgICAgLy8gZXh0cmEgZmllbGQgaXMgbGltaXRlZCB0byA2NTUzNiBieXRlc1xuICAgICAgICAgICAgICAvLyAtIG5vIG5lZWQgZm9yIGFkZGl0aW9uYWwgc2l6ZSBjaGVja1xuICAgICAgICAgICAgICBjb3B5LFxuICAgICAgICAgICAgICAvKmxlbiArIGNvcHkgPiBzdGF0ZS5oZWFkLmV4dHJhX21heCAtIGxlbiA/IHN0YXRlLmhlYWQuZXh0cmFfbWF4IDogY29weSwqL1xuICAgICAgICAgICAgICBsZW5cbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICAvL3ptZW1jcHkoc3RhdGUuaGVhZC5leHRyYSArIGxlbiwgbmV4dCxcbiAgICAgICAgICAgIC8vICAgICAgICBsZW4gKyBjb3B5ID4gc3RhdGUuaGVhZC5leHRyYV9tYXggP1xuICAgICAgICAgICAgLy8gICAgICAgIHN0YXRlLmhlYWQuZXh0cmFfbWF4IC0gbGVuIDogY29weSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChzdGF0ZS5mbGFncyAmIDB4MDIwMCkge1xuICAgICAgICAgICAgc3RhdGUuY2hlY2sgPSBjcmMzMihzdGF0ZS5jaGVjaywgaW5wdXQsIGNvcHksIG5leHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgICAgbmV4dCArPSBjb3B5O1xuICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5sZW5ndGgpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICB9XG4gICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgc3RhdGUubW9kZSA9IE5BTUU7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBOQU1FOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgwODAwKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIC8vIFRPRE86IDIgb3IgMSBieXRlcz9cbiAgICAgICAgICBsZW4gPSBpbnB1dFtuZXh0ICsgY29weSsrXTtcbiAgICAgICAgICAvKiB1c2UgY29uc3RhbnQgbGltaXQgYmVjYXVzZSBpbiBqcyB3ZSBzaG91bGQgbm90IHByZWFsbG9jYXRlIG1lbW9yeSAqL1xuICAgICAgICAgIGlmIChzdGF0ZS5oZWFkICYmIGxlbiAmJlxuICAgICAgICAgICAgICAoc3RhdGUubGVuZ3RoIDwgNjU1MzYgLypzdGF0ZS5oZWFkLm5hbWVfbWF4Ki8pKSB7XG4gICAgICAgICAgICBzdGF0ZS5oZWFkLm5hbWUgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShsZW4pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSB3aGlsZSAobGVuICYmIGNvcHkgPCBoYXZlKTtcblxuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQubmFtZSA9IG51bGw7XG4gICAgICB9XG4gICAgICBzdGF0ZS5sZW5ndGggPSAwO1xuICAgICAgc3RhdGUubW9kZSA9IENPTU1FTlQ7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBDT01NRU5UOlxuICAgICAgaWYgKHN0YXRlLmZsYWdzICYgMHgxMDAwKSB7XG4gICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICBjb3B5ID0gMDtcbiAgICAgICAgZG8ge1xuICAgICAgICAgIGxlbiA9IGlucHV0W25leHQgKyBjb3B5KytdO1xuICAgICAgICAgIC8qIHVzZSBjb25zdGFudCBsaW1pdCBiZWNhdXNlIGluIGpzIHdlIHNob3VsZCBub3QgcHJlYWxsb2NhdGUgbWVtb3J5ICovXG4gICAgICAgICAgaWYgKHN0YXRlLmhlYWQgJiYgbGVuICYmXG4gICAgICAgICAgICAgIChzdGF0ZS5sZW5ndGggPCA2NTUzNiAvKnN0YXRlLmhlYWQuY29tbV9tYXgqLykpIHtcbiAgICAgICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGxlbik7XG4gICAgICAgICAgfVxuICAgICAgICB9IHdoaWxlIChsZW4gJiYgY29weSA8IGhhdmUpO1xuICAgICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgICBzdGF0ZS5jaGVjayA9IGNyYzMyKHN0YXRlLmNoZWNrLCBpbnB1dCwgY29weSwgbmV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgaGF2ZSAtPSBjb3B5O1xuICAgICAgICBuZXh0ICs9IGNvcHk7XG4gICAgICAgIGlmIChsZW4pIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQuY29tbWVudCA9IG51bGw7XG4gICAgICB9XG4gICAgICBzdGF0ZS5tb2RlID0gSENSQztcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIEhDUkM6XG4gICAgICBpZiAoc3RhdGUuZmxhZ3MgJiAweDAyMDApIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoMTYpOyAqL1xuICAgICAgICB3aGlsZSAoYml0cyA8IDE2KSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIGlmIChob2xkICE9PSAoc3RhdGUuY2hlY2sgJiAweGZmZmYpKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaGVhZGVyIGNyYyBtaXNtYXRjaCc7XG4gICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLz09PSBJTklUQklUUygpO1xuICAgICAgICBob2xkID0gMDtcbiAgICAgICAgYml0cyA9IDA7XG4gICAgICAgIC8vPT09Ly9cbiAgICAgIH1cbiAgICAgIGlmIChzdGF0ZS5oZWFkKSB7XG4gICAgICAgIHN0YXRlLmhlYWQuaGNyYyA9ICgoc3RhdGUuZmxhZ3MgPj4gOSkgJiAxKTtcbiAgICAgICAgc3RhdGUuaGVhZC5kb25lID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9IDA7XG4gICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgRElDVElEOlxuICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgc3RybS5hZGxlciA9IHN0YXRlLmNoZWNrID0genN3YXAzMihob2xkKTtcbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubW9kZSA9IERJQ1Q7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBESUNUOlxuICAgICAgaWYgKHN0YXRlLmhhdmVkaWN0ID09PSAwKSB7XG4gICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAvLy0tLVxuICAgICAgICByZXR1cm4gWl9ORUVEX0RJQ1Q7XG4gICAgICB9XG4gICAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAxLyphZGxlcjMyKDBMLCBaX05VTEwsIDApKi87XG4gICAgICBzdGF0ZS5tb2RlID0gVFlQRTtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIFRZUEU6XG4gICAgICBpZiAoZmx1c2ggPT09IFpfQkxPQ0sgfHwgZmx1c2ggPT09IFpfVFJFRVMpIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBUWVBFRE86XG4gICAgICBpZiAoc3RhdGUubGFzdCkge1xuICAgICAgICAvLy0tLSBCWVRFQklUUygpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBiaXRzICYgNztcbiAgICAgICAgYml0cyAtPSBiaXRzICYgNztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5tb2RlID0gQ0hFQ0s7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy89PT0gTkVFREJJVFMoMyk7ICovXG4gICAgICB3aGlsZSAoYml0cyA8IDMpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLmxhc3QgPSAoaG9sZCAmIDB4MDEpLypCSVRTKDEpKi87XG4gICAgICAvLy0tLSBEUk9QQklUUygxKSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IDE7XG4gICAgICBiaXRzIC09IDE7XG4gICAgICAvLy0tLS8vXG5cbiAgICAgIHN3aXRjaCAoKGhvbGQgJiAweDAzKS8qQklUUygyKSovKSB7XG4gICAgICBjYXNlIDA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBzdG9yZWQgYmxvY2sgKi9cbiAgICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgc3RvcmVkIGJsb2NrJXNcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFNUT1JFRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE6ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBmaXhlZCBibG9jayAqL1xuICAgICAgICBmaXhlZHRhYmxlcyhzdGF0ZSk7XG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgIGZpeGVkIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IExFTl87ICAgICAgICAgICAgIC8qIGRlY29kZSBjb2RlcyAqL1xuICAgICAgICBpZiAoZmx1c2ggPT09IFpfVFJFRVMpIHtcbiAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgIGhvbGQgPj4+PSAyO1xuICAgICAgICAgIGJpdHMgLT0gMjtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgYnJlYWsgaW5mX2xlYXZlO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZHluYW1pYyBibG9jayAqL1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICBkeW5hbWljIGNvZGVzIGJsb2NrJXNcXG5cIixcbiAgICAgICAgLy8gICAgICAgIHN0YXRlLmxhc3QgPyBcIiAobGFzdClcIiA6IFwiXCIpKTtcbiAgICAgICAgc3RhdGUubW9kZSA9IFRBQkxFO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBibG9jayB0eXBlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgIH1cbiAgICAgIC8vLS0tIERST1BCSVRTKDIpIC0tLS8vXG4gICAgICBob2xkID4+Pj0gMjtcbiAgICAgIGJpdHMgLT0gMjtcbiAgICAgIC8vLS0tLy9cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU1RPUkVEOlxuICAgICAgLy8tLS0gQllURUJJVFMoKSAtLS0vLyAvKiBnbyB0byBieXRlIGJvdW5kYXJ5ICovXG4gICAgICBob2xkID4+Pj0gYml0cyAmIDc7XG4gICAgICBiaXRzIC09IGJpdHMgJiA3O1xuICAgICAgLy8tLS0vL1xuICAgICAgLy89PT0gTkVFREJJVFMoMzIpOyAqL1xuICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgaGF2ZS0tO1xuICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgYml0cyArPSA4O1xuICAgICAgfVxuICAgICAgLy89PT0vL1xuICAgICAgaWYgKChob2xkICYgMHhmZmZmKSAhPT0gKChob2xkID4+PiAxNikgXiAweGZmZmYpKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgc3RvcmVkIGJsb2NrIGxlbmd0aHMnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHN0YXRlLmxlbmd0aCA9IGhvbGQgJiAweGZmZmY7XG4gICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHN0b3JlZCBsZW5ndGggJXVcXG5cIixcbiAgICAgIC8vICAgICAgICBzdGF0ZS5sZW5ndGgpKTtcbiAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICBob2xkID0gMDtcbiAgICAgIGJpdHMgPSAwO1xuICAgICAgLy89PT0vL1xuICAgICAgc3RhdGUubW9kZSA9IENPUFlfO1xuICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgQ09QWV86XG4gICAgICBzdGF0ZS5tb2RlID0gQ09QWTtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIENPUFk6XG4gICAgICBjb3B5ID0gc3RhdGUubGVuZ3RoO1xuICAgICAgaWYgKGNvcHkpIHtcbiAgICAgICAgaWYgKGNvcHkgPiBoYXZlKSB7IGNvcHkgPSBoYXZlOyB9XG4gICAgICAgIGlmIChjb3B5ID4gbGVmdCkgeyBjb3B5ID0gbGVmdDsgfVxuICAgICAgICBpZiAoY29weSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgLy8tLS0gem1lbWNweShwdXQsIG5leHQsIGNvcHkpOyAtLS1cbiAgICAgICAgdXRpbHMuYXJyYXlTZXQob3V0cHV0LCBpbnB1dCwgbmV4dCwgY29weSwgcHV0KTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBoYXZlIC09IGNvcHk7XG4gICAgICAgIG5leHQgKz0gY29weTtcbiAgICAgICAgbGVmdCAtPSBjb3B5O1xuICAgICAgICBwdXQgKz0gY29weTtcbiAgICAgICAgc3RhdGUubGVuZ3RoIC09IGNvcHk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgLy9UcmFjZXYoKHN0ZGVyciwgXCJpbmZsYXRlOiAgICAgICBzdG9yZWQgZW5kXFxuXCIpKTtcbiAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBUQUJMRTpcbiAgICAgIC8vPT09IE5FRURCSVRTKDE0KTsgKi9cbiAgICAgIHdoaWxlIChiaXRzIDwgMTQpIHtcbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgIH1cbiAgICAgIC8vPT09Ly9cbiAgICAgIHN0YXRlLm5sZW4gPSAoaG9sZCAmIDB4MWYpLypCSVRTKDUpKi8gKyAyNTc7XG4gICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICBiaXRzIC09IDU7XG4gICAgICAvLy0tLS8vXG4gICAgICBzdGF0ZS5uZGlzdCA9IChob2xkICYgMHgxZikvKkJJVFMoNSkqLyArIDE7XG4gICAgICAvLy0tLSBEUk9QQklUUyg1KSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IDU7XG4gICAgICBiaXRzIC09IDU7XG4gICAgICAvLy0tLS8vXG4gICAgICBzdGF0ZS5uY29kZSA9IChob2xkICYgMHgwZikvKkJJVFMoNCkqLyArIDQ7XG4gICAgICAvLy0tLSBEUk9QQklUUyg0KSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IDQ7XG4gICAgICBiaXRzIC09IDQ7XG4gICAgICAvLy0tLS8vXG4vLyNpZm5kZWYgUEtaSVBfQlVHX1dPUktBUk9VTkRcbiAgICAgIGlmIChzdGF0ZS5ubGVuID4gMjg2IHx8IHN0YXRlLm5kaXN0ID4gMzApIHtcbiAgICAgICAgc3RybS5tc2cgPSAndG9vIG1hbnkgbGVuZ3RoIG9yIGRpc3RhbmNlIHN5bWJvbHMnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbi8vI2VuZGlmXG4gICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgIHRhYmxlIHNpemVzIG9rXFxuXCIpKTtcbiAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgc3RhdGUubW9kZSA9IExFTkxFTlM7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBMRU5MRU5TOlxuICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCBzdGF0ZS5uY29kZSkge1xuICAgICAgICAvLz09PSBORUVEQklUUygzKTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzKSB7XG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgfVxuICAgICAgICAvLz09PS8vXG4gICAgICAgIHN0YXRlLmxlbnNbb3JkZXJbc3RhdGUuaGF2ZSsrXV0gPSAoaG9sZCAmIDB4MDcpOy8vQklUUygzKTtcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoMykgLS0tLy9cbiAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgIGJpdHMgLT0gMztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgfVxuICAgICAgd2hpbGUgKHN0YXRlLmhhdmUgPCAxOSkge1xuICAgICAgICBzdGF0ZS5sZW5zW29yZGVyW3N0YXRlLmhhdmUrK11dID0gMDtcbiAgICAgIH1cbiAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAvL3N0YXRlLm5leHQgPSBzdGF0ZS5jb2RlcztcbiAgICAgIC8vc3RhdGUubGVuY29kZSA9IHN0YXRlLm5leHQ7XG4gICAgICAvLyBTd2l0Y2ggdG8gdXNlIGR5bmFtaWMgdGFibGVcbiAgICAgIHN0YXRlLmxlbmNvZGUgPSBzdGF0ZS5sZW5keW47XG4gICAgICBzdGF0ZS5sZW5iaXRzID0gNztcblxuICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShDT0RFUywgc3RhdGUubGVucywgMCwgMTksIHN0YXRlLmxlbmNvZGUsIDAsIHN0YXRlLndvcmssIG9wdHMpO1xuICAgICAgc3RhdGUubGVuYml0cyA9IG9wdHMuYml0cztcblxuICAgICAgaWYgKHJldCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGNvZGUgbGVuZ3RocyBzZXQnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgY29kZSBsZW5ndGhzIG9rXFxuXCIpKTtcbiAgICAgIHN0YXRlLmhhdmUgPSAwO1xuICAgICAgc3RhdGUubW9kZSA9IENPREVMRU5TO1xuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgQ09ERUxFTlM6XG4gICAgICB3aGlsZSAoc3RhdGUuaGF2ZSA8IHN0YXRlLm5sZW4gKyBzdGF0ZS5uZGlzdCkge1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbaG9sZCAmICgoMSA8PCBzdGF0ZS5sZW5iaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVyZV92YWwgPCAxNikge1xuICAgICAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBoZXJlX3ZhbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBpZiAoaGVyZV92YWwgPT09IDE2KSB7XG4gICAgICAgICAgICAvLz09PSBORUVEQklUUyhoZXJlLmJpdHMgKyAyKTtcbiAgICAgICAgICAgIG4gPSBoZXJlX2JpdHMgKyAyO1xuICAgICAgICAgICAgd2hpbGUgKGJpdHMgPCBuKSB7XG4gICAgICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLz09PS8vXG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUyhoZXJlLmJpdHMpIC0tLS8vXG4gICAgICAgICAgICBob2xkID4+Pj0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgYml0cyAtPSBoZXJlX2JpdHM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSA9PT0gMCkge1xuICAgICAgICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGJpdCBsZW5ndGggcmVwZWF0JztcbiAgICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZW4gPSBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUgLSAxXTtcbiAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDAzKTsvL0JJVFMoMik7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUygyKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IDI7XG4gICAgICAgICAgICBiaXRzIC09IDI7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGhlcmVfdmFsID09PSAxNykge1xuICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgMyk7XG4gICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgMztcbiAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgIGNvcHkgPSAzICsgKGhvbGQgJiAweDA3KTsvL0JJVFMoMyk7XG4gICAgICAgICAgICAvLy0tLSBEUk9QQklUUygzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IDM7XG4gICAgICAgICAgICBiaXRzIC09IDM7XG4gICAgICAgICAgICAvLy0tLS8vXG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy89PT0gTkVFREJJVFMoaGVyZS5iaXRzICsgNyk7XG4gICAgICAgICAgICBuID0gaGVyZV9iaXRzICsgNztcbiAgICAgICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy89PT0vL1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgICAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgICAgbGVuID0gMDtcbiAgICAgICAgICAgIGNvcHkgPSAxMSArIChob2xkICYgMHg3Zik7Ly9CSVRTKDcpO1xuICAgICAgICAgICAgLy8tLS0gRFJPUEJJVFMoNykgLS0tLy9cbiAgICAgICAgICAgIGhvbGQgPj4+PSA3O1xuICAgICAgICAgICAgYml0cyAtPSA3O1xuICAgICAgICAgICAgLy8tLS0vL1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc3RhdGUuaGF2ZSArIGNvcHkgPiBzdGF0ZS5ubGVuICsgc3RhdGUubmRpc3QpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgYml0IGxlbmd0aCByZXBlYXQnO1xuICAgICAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB3aGlsZSAoY29weS0tKSB7XG4gICAgICAgICAgICBzdGF0ZS5sZW5zW3N0YXRlLmhhdmUrK10gPSBsZW47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8qIGhhbmRsZSBlcnJvciBicmVha3MgaW4gd2hpbGUgKi9cbiAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBCQUQpIHsgYnJlYWs7IH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVuZC1vZi1ibG9jayBjb2RlIChiZXR0ZXIgaGF2ZSBvbmUpICovXG4gICAgICBpZiAoc3RhdGUubGVuc1syNTZdID09PSAwKSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgY29kZSAtLSBtaXNzaW5nIGVuZC1vZi1ibG9jayc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvKiBidWlsZCBjb2RlIHRhYmxlcyAtLSBub3RlOiBkbyBub3QgY2hhbmdlIHRoZSBsZW5iaXRzIG9yIGRpc3RiaXRzXG4gICAgICAgICB2YWx1ZXMgaGVyZSAoOSBhbmQgNikgd2l0aG91dCByZWFkaW5nIHRoZSBjb21tZW50cyBpbiBpbmZ0cmVlcy5oXG4gICAgICAgICBjb25jZXJuaW5nIHRoZSBFTk9VR0ggY29uc3RhbnRzLCB3aGljaCBkZXBlbmQgb24gdGhvc2UgdmFsdWVzICovXG4gICAgICBzdGF0ZS5sZW5iaXRzID0gOTtcblxuICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUubGVuYml0cyB9O1xuICAgICAgcmV0ID0gaW5mbGF0ZV90YWJsZShMRU5TLCBzdGF0ZS5sZW5zLCAwLCBzdGF0ZS5ubGVuLCBzdGF0ZS5sZW5jb2RlLCAwLCBzdGF0ZS53b3JrLCBvcHRzKTtcbiAgICAgIC8vIFdlIGhhdmUgc2VwYXJhdGUgdGFibGVzICYgbm8gcG9pbnRlcnMuIDIgY29tbWVudGVkIGxpbmVzIGJlbG93IG5vdCBuZWVkZWQuXG4gICAgICAvLyBzdGF0ZS5uZXh0X2luZGV4ID0gb3B0cy50YWJsZV9pbmRleDtcbiAgICAgIHN0YXRlLmxlbmJpdHMgPSBvcHRzLmJpdHM7XG4gICAgICAvLyBzdGF0ZS5sZW5jb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgaWYgKHJldCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGxpdGVyYWwvbGVuZ3RocyBzZXQnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgc3RhdGUuZGlzdGJpdHMgPSA2O1xuICAgICAgLy9zdGF0ZS5kaXN0Y29kZS5jb3B5KHN0YXRlLmNvZGVzKTtcbiAgICAgIC8vIFN3aXRjaCB0byB1c2UgZHluYW1pYyB0YWJsZVxuICAgICAgc3RhdGUuZGlzdGNvZGUgPSBzdGF0ZS5kaXN0ZHluO1xuICAgICAgb3B0cyA9IHsgYml0czogc3RhdGUuZGlzdGJpdHMgfTtcbiAgICAgIHJldCA9IGluZmxhdGVfdGFibGUoRElTVFMsIHN0YXRlLmxlbnMsIHN0YXRlLm5sZW4sIHN0YXRlLm5kaXN0LCBzdGF0ZS5kaXN0Y29kZSwgMCwgc3RhdGUud29yaywgb3B0cyk7XG4gICAgICAvLyBXZSBoYXZlIHNlcGFyYXRlIHRhYmxlcyAmIG5vIHBvaW50ZXJzLiAyIGNvbW1lbnRlZCBsaW5lcyBiZWxvdyBub3QgbmVlZGVkLlxuICAgICAgLy8gc3RhdGUubmV4dF9pbmRleCA9IG9wdHMudGFibGVfaW5kZXg7XG4gICAgICBzdGF0ZS5kaXN0Yml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vIHN0YXRlLmRpc3Rjb2RlID0gc3RhdGUubmV4dDtcblxuICAgICAgaWYgKHJldCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlcyBzZXQnO1xuICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIC8vVHJhY2V2KChzdGRlcnIsICdpbmZsYXRlOiAgICAgICBjb2RlcyBva1xcbicpKTtcbiAgICAgIHN0YXRlLm1vZGUgPSBMRU5fO1xuICAgICAgaWYgKGZsdXNoID09PSBaX1RSRUVTKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGNhc2UgTEVOXzpcbiAgICAgIHN0YXRlLm1vZGUgPSBMRU47XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBMRU46XG4gICAgICBpZiAoaGF2ZSA+PSA2ICYmIGxlZnQgPj0gMjU4KSB7XG4gICAgICAgIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgICAgICAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgICAgICAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICAgICAgICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICAgICAgICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgICAgICAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gICAgICAgIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAgICAgICAvLy0tLVxuICAgICAgICBpbmZsYXRlX2Zhc3Qoc3RybSwgX291dCk7XG4gICAgICAgIC8vLS0tIExPQUQoKSAtLS1cbiAgICAgICAgcHV0ID0gc3RybS5uZXh0X291dDtcbiAgICAgICAgb3V0cHV0ID0gc3RybS5vdXRwdXQ7XG4gICAgICAgIGxlZnQgPSBzdHJtLmF2YWlsX291dDtcbiAgICAgICAgbmV4dCA9IHN0cm0ubmV4dF9pbjtcbiAgICAgICAgaW5wdXQgPSBzdHJtLmlucHV0O1xuICAgICAgICBoYXZlID0gc3RybS5hdmFpbF9pbjtcbiAgICAgICAgaG9sZCA9IHN0YXRlLmhvbGQ7XG4gICAgICAgIGJpdHMgPSBzdGF0ZS5iaXRzO1xuICAgICAgICAvLy0tLVxuXG4gICAgICAgIGlmIChzdGF0ZS5tb2RlID09PSBUWVBFKSB7XG4gICAgICAgICAgc3RhdGUuYmFjayA9IC0xO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUuYmFjayA9IDA7XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGhlcmUgPSBzdGF0ZS5sZW5jb2RlW2hvbGQgJiAoKDEgPDwgc3RhdGUubGVuYml0cykgLSAxKV07ICAvKkJJVFMoc3RhdGUubGVuYml0cykqL1xuICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgaGVyZV9vcCA9IChoZXJlID4+PiAxNikgJiAweGZmO1xuICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgaWYgKGhlcmVfYml0cyA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgfVxuICAgICAgaWYgKGhlcmVfb3AgJiYgKGhlcmVfb3AgJiAweGYwKSA9PT0gMCkge1xuICAgICAgICBsYXN0X2JpdHMgPSBoZXJlX2JpdHM7XG4gICAgICAgIGxhc3Rfb3AgPSBoZXJlX29wO1xuICAgICAgICBsYXN0X3ZhbCA9IGhlcmVfdmFsO1xuICAgICAgICBmb3IgKDs7KSB7XG4gICAgICAgICAgaGVyZSA9IHN0YXRlLmxlbmNvZGVbbGFzdF92YWwgK1xuICAgICAgICAgICAgICAgICAgKChob2xkICYgKCgxIDw8IChsYXN0X2JpdHMgKyBsYXN0X29wKSkgLSAxKSkvKkJJVFMobGFzdC5iaXRzICsgbGFzdC5vcCkqLyA+PiBsYXN0X2JpdHMpXTtcbiAgICAgICAgICBoZXJlX2JpdHMgPSBoZXJlID4+PiAyNDtcbiAgICAgICAgICBoZXJlX29wID0gKGhlcmUgPj4+IDE2KSAmIDB4ZmY7XG4gICAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgICAgaWYgKChsYXN0X2JpdHMgKyBoZXJlX2JpdHMpIDw9IGJpdHMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAvLy0tLSBQVUxMQllURSgpIC0tLS8vXG4gICAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgICAgaGF2ZS0tO1xuICAgICAgICAgIGhvbGQgKz0gaW5wdXRbbmV4dCsrXSA8PCBiaXRzO1xuICAgICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgICAvLy0tLS8vXG4gICAgICAgIH1cbiAgICAgICAgLy8tLS0gRFJPUEJJVFMobGFzdC5iaXRzKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gbGFzdF9iaXRzO1xuICAgICAgICBiaXRzIC09IGxhc3RfYml0cztcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IGxhc3RfYml0cztcbiAgICAgIH1cbiAgICAgIC8vLS0tIERST1BCSVRTKGhlcmUuYml0cykgLS0tLy9cbiAgICAgIGhvbGQgPj4+PSBoZXJlX2JpdHM7XG4gICAgICBiaXRzIC09IGhlcmVfYml0cztcbiAgICAgIC8vLS0tLy9cbiAgICAgIHN0YXRlLmJhY2sgKz0gaGVyZV9iaXRzO1xuICAgICAgc3RhdGUubGVuZ3RoID0gaGVyZV92YWw7XG4gICAgICBpZiAoaGVyZV9vcCA9PT0gMCkge1xuICAgICAgICAvL1RyYWNldnYoKHN0ZGVyciwgaGVyZS52YWwgPj0gMHgyMCAmJiBoZXJlLnZhbCA8IDB4N2YgP1xuICAgICAgICAvLyAgICAgICAgXCJpbmZsYXRlOiAgICAgICAgIGxpdGVyYWwgJyVjJ1xcblwiIDpcbiAgICAgICAgLy8gICAgICAgIFwiaW5mbGF0ZTogICAgICAgICBsaXRlcmFsIDB4JTAyeFxcblwiLCBoZXJlLnZhbCkpO1xuICAgICAgICBzdGF0ZS5tb2RlID0gTElUO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChoZXJlX29wICYgMzIpIHtcbiAgICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBlbmQgb2YgYmxvY2tcXG5cIikpO1xuICAgICAgICBzdGF0ZS5iYWNrID0gLTE7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBUWVBFO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChoZXJlX29wICYgNjQpIHtcbiAgICAgICAgc3RybS5tc2cgPSAnaW52YWxpZCBsaXRlcmFsL2xlbmd0aCBjb2RlJztcbiAgICAgICAgc3RhdGUubW9kZSA9IEJBRDtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBzdGF0ZS5leHRyYSA9IGhlcmVfb3AgJiAxNTtcbiAgICAgIHN0YXRlLm1vZGUgPSBMRU5FWFQ7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBMRU5FWFQ6XG4gICAgICBpZiAoc3RhdGUuZXh0cmEpIHtcbiAgICAgICAgLy89PT0gTkVFREJJVFMoc3RhdGUuZXh0cmEpO1xuICAgICAgICBuID0gc3RhdGUuZXh0cmE7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgbikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBzdGF0ZS5sZW5ndGggKz0gaG9sZCAmICgoMSA8PCBzdGF0ZS5leHRyYSkgLSAxKS8qQklUUyhzdGF0ZS5leHRyYSkqLztcbiAgICAgICAgLy8tLS0gRFJPUEJJVFMoc3RhdGUuZXh0cmEpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBzdGF0ZS5leHRyYTtcbiAgICAgICAgYml0cyAtPSBzdGF0ZS5leHRyYTtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgICBzdGF0ZS5iYWNrICs9IHN0YXRlLmV4dHJhO1xuICAgICAgfVxuICAgICAgLy9UcmFjZXZ2KChzdGRlcnIsIFwiaW5mbGF0ZTogICAgICAgICBsZW5ndGggJXVcXG5cIiwgc3RhdGUubGVuZ3RoKSk7XG4gICAgICBzdGF0ZS53YXMgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICBzdGF0ZS5tb2RlID0gRElTVDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIERJU1Q6XG4gICAgICBmb3IgKDs7KSB7XG4gICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtob2xkICYgKCgxIDw8IHN0YXRlLmRpc3RiaXRzKSAtIDEpXTsvKkJJVFMoc3RhdGUuZGlzdGJpdHMpKi9cbiAgICAgICAgaGVyZV9iaXRzID0gaGVyZSA+Pj4gMjQ7XG4gICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgaGVyZV92YWwgPSBoZXJlICYgMHhmZmZmO1xuXG4gICAgICAgIGlmICgoaGVyZV9iaXRzKSA8PSBiaXRzKSB7IGJyZWFrOyB9XG4gICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgaWYgKGhhdmUgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICAgIGhhdmUtLTtcbiAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgIGJpdHMgKz0gODtcbiAgICAgICAgLy8tLS0vL1xuICAgICAgfVxuICAgICAgaWYgKChoZXJlX29wICYgMHhmMCkgPT09IDApIHtcbiAgICAgICAgbGFzdF9iaXRzID0gaGVyZV9iaXRzO1xuICAgICAgICBsYXN0X29wID0gaGVyZV9vcDtcbiAgICAgICAgbGFzdF92YWwgPSBoZXJlX3ZhbDtcbiAgICAgICAgZm9yICg7Oykge1xuICAgICAgICAgIGhlcmUgPSBzdGF0ZS5kaXN0Y29kZVtsYXN0X3ZhbCArXG4gICAgICAgICAgICAgICAgICAoKGhvbGQgJiAoKDEgPDwgKGxhc3RfYml0cyArIGxhc3Rfb3ApKSAtIDEpKS8qQklUUyhsYXN0LmJpdHMgKyBsYXN0Lm9wKSovID4+IGxhc3RfYml0cyldO1xuICAgICAgICAgIGhlcmVfYml0cyA9IGhlcmUgPj4+IDI0O1xuICAgICAgICAgIGhlcmVfb3AgPSAoaGVyZSA+Pj4gMTYpICYgMHhmZjtcbiAgICAgICAgICBoZXJlX3ZhbCA9IGhlcmUgJiAweGZmZmY7XG5cbiAgICAgICAgICBpZiAoKGxhc3RfYml0cyArIGhlcmVfYml0cykgPD0gYml0cykgeyBicmVhazsgfVxuICAgICAgICAgIC8vLS0tIFBVTExCWVRFKCkgLS0tLy9cbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICAgIC8vLS0tLy9cbiAgICAgICAgfVxuICAgICAgICAvLy0tLSBEUk9QQklUUyhsYXN0LmJpdHMpIC0tLS8vXG4gICAgICAgIGhvbGQgPj4+PSBsYXN0X2JpdHM7XG4gICAgICAgIGJpdHMgLT0gbGFzdF9iaXRzO1xuICAgICAgICAvLy0tLS8vXG4gICAgICAgIHN0YXRlLmJhY2sgKz0gbGFzdF9iaXRzO1xuICAgICAgfVxuICAgICAgLy8tLS0gRFJPUEJJVFMoaGVyZS5iaXRzKSAtLS0vL1xuICAgICAgaG9sZCA+Pj49IGhlcmVfYml0cztcbiAgICAgIGJpdHMgLT0gaGVyZV9iaXRzO1xuICAgICAgLy8tLS0vL1xuICAgICAgc3RhdGUuYmFjayArPSBoZXJlX2JpdHM7XG4gICAgICBpZiAoaGVyZV9vcCAmIDY0KSB7XG4gICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgY29kZSc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgc3RhdGUub2Zmc2V0ID0gaGVyZV92YWw7XG4gICAgICBzdGF0ZS5leHRyYSA9IChoZXJlX29wKSAmIDE1O1xuICAgICAgc3RhdGUubW9kZSA9IERJU1RFWFQ7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBESVNURVhUOlxuICAgICAgaWYgKHN0YXRlLmV4dHJhKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKHN0YXRlLmV4dHJhKTtcbiAgICAgICAgbiA9IHN0YXRlLmV4dHJhO1xuICAgICAgICB3aGlsZSAoYml0cyA8IG4pIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgaG9sZCArPSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgc3RhdGUub2Zmc2V0ICs9IGhvbGQgJiAoKDEgPDwgc3RhdGUuZXh0cmEpIC0gMSkvKkJJVFMoc3RhdGUuZXh0cmEpKi87XG4gICAgICAgIC8vLS0tIERST1BCSVRTKHN0YXRlLmV4dHJhKSAtLS0vL1xuICAgICAgICBob2xkID4+Pj0gc3RhdGUuZXh0cmE7XG4gICAgICAgIGJpdHMgLT0gc3RhdGUuZXh0cmE7XG4gICAgICAgIC8vLS0tLy9cbiAgICAgICAgc3RhdGUuYmFjayArPSBzdGF0ZS5leHRyYTtcbiAgICAgIH1cbi8vI2lmZGVmIElORkxBVEVfU1RSSUNUXG4gICAgICBpZiAoc3RhdGUub2Zmc2V0ID4gc3RhdGUuZG1heCkge1xuICAgICAgICBzdHJtLm1zZyA9ICdpbnZhbGlkIGRpc3RhbmNlIHRvbyBmYXIgYmFjayc7XG4gICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuLy8jZW5kaWZcbiAgICAgIC8vVHJhY2V2digoc3RkZXJyLCBcImluZmxhdGU6ICAgICAgICAgZGlzdGFuY2UgJXVcXG5cIiwgc3RhdGUub2Zmc2V0KSk7XG4gICAgICBzdGF0ZS5tb2RlID0gTUFUQ0g7XG4gICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgY2FzZSBNQVRDSDpcbiAgICAgIGlmIChsZWZ0ID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgY29weSA9IF9vdXQgLSBsZWZ0O1xuICAgICAgaWYgKHN0YXRlLm9mZnNldCA+IGNvcHkpIHsgICAgICAgICAvKiBjb3B5IGZyb20gd2luZG93ICovXG4gICAgICAgIGNvcHkgPSBzdGF0ZS5vZmZzZXQgLSBjb3B5O1xuICAgICAgICBpZiAoY29weSA+IHN0YXRlLndoYXZlKSB7XG4gICAgICAgICAgaWYgKHN0YXRlLnNhbmUpIHtcbiAgICAgICAgICAgIHN0cm0ubXNnID0gJ2ludmFsaWQgZGlzdGFuY2UgdG9vIGZhciBiYWNrJztcbiAgICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4vLyAoISkgVGhpcyBibG9jayBpcyBkaXNhYmxlZCBpbiB6bGliIGRlZmFpbHRzLFxuLy8gZG9uJ3QgZW5hYmxlIGl0IGZvciBiaW5hcnkgY29tcGF0aWJpbGl0eVxuLy8jaWZkZWYgSU5GTEFURV9BTExPV19JTlZBTElEX0RJU1RBTkNFX1RPT0ZBUl9BUlJSXG4vLyAgICAgICAgICBUcmFjZSgoc3RkZXJyLCBcImluZmxhdGUuYyB0b28gZmFyXFxuXCIpKTtcbi8vICAgICAgICAgIGNvcHkgLT0gc3RhdGUud2hhdmU7XG4vLyAgICAgICAgICBpZiAoY29weSA+IHN0YXRlLmxlbmd0aCkgeyBjb3B5ID0gc3RhdGUubGVuZ3RoOyB9XG4vLyAgICAgICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbi8vICAgICAgICAgIGxlZnQgLT0gY29weTtcbi8vICAgICAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuLy8gICAgICAgICAgZG8ge1xuLy8gICAgICAgICAgICBvdXRwdXRbcHV0KytdID0gMDtcbi8vICAgICAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4vLyAgICAgICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbi8vICAgICAgICAgIGJyZWFrO1xuLy8jZW5kaWZcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29weSA+IHN0YXRlLnduZXh0KSB7XG4gICAgICAgICAgY29weSAtPSBzdGF0ZS53bmV4dDtcbiAgICAgICAgICBmcm9tID0gc3RhdGUud3NpemUgLSBjb3B5O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGZyb20gPSBzdGF0ZS53bmV4dCAtIGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvcHkgPiBzdGF0ZS5sZW5ndGgpIHsgY29weSA9IHN0YXRlLmxlbmd0aDsgfVxuICAgICAgICBmcm9tX3NvdXJjZSA9IHN0YXRlLndpbmRvdztcbiAgICAgIH1cbiAgICAgIGVsc2UgeyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIGNvcHkgZnJvbSBvdXRwdXQgKi9cbiAgICAgICAgZnJvbV9zb3VyY2UgPSBvdXRwdXQ7XG4gICAgICAgIGZyb20gPSBwdXQgLSBzdGF0ZS5vZmZzZXQ7XG4gICAgICAgIGNvcHkgPSBzdGF0ZS5sZW5ndGg7XG4gICAgICB9XG4gICAgICBpZiAoY29weSA+IGxlZnQpIHsgY29weSA9IGxlZnQ7IH1cbiAgICAgIGxlZnQgLT0gY29weTtcbiAgICAgIHN0YXRlLmxlbmd0aCAtPSBjb3B5O1xuICAgICAgZG8ge1xuICAgICAgICBvdXRwdXRbcHV0KytdID0gZnJvbV9zb3VyY2VbZnJvbSsrXTtcbiAgICAgIH0gd2hpbGUgKC0tY29weSk7XG4gICAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7IHN0YXRlLm1vZGUgPSBMRU47IH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgTElUOlxuICAgICAgaWYgKGxlZnQgPT09IDApIHsgYnJlYWsgaW5mX2xlYXZlOyB9XG4gICAgICBvdXRwdXRbcHV0KytdID0gc3RhdGUubGVuZ3RoO1xuICAgICAgbGVmdC0tO1xuICAgICAgc3RhdGUubW9kZSA9IExFTjtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ0hFQ0s6XG4gICAgICBpZiAoc3RhdGUud3JhcCkge1xuICAgICAgICAvLz09PSBORUVEQklUUygzMik7XG4gICAgICAgIHdoaWxlIChiaXRzIDwgMzIpIHtcbiAgICAgICAgICBpZiAoaGF2ZSA9PT0gMCkgeyBicmVhayBpbmZfbGVhdmU7IH1cbiAgICAgICAgICBoYXZlLS07XG4gICAgICAgICAgLy8gVXNlICd8JyBpbnNkZWFkIG9mICcrJyB0byBtYWtlIHN1cmUgdGhhdCByZXN1bHQgaXMgc2lnbmVkXG4gICAgICAgICAgaG9sZCB8PSBpbnB1dFtuZXh0KytdIDw8IGJpdHM7XG4gICAgICAgICAgYml0cyArPSA4O1xuICAgICAgICB9XG4gICAgICAgIC8vPT09Ly9cbiAgICAgICAgX291dCAtPSBsZWZ0O1xuICAgICAgICBzdHJtLnRvdGFsX291dCArPSBfb3V0O1xuICAgICAgICBzdGF0ZS50b3RhbCArPSBfb3V0O1xuICAgICAgICBpZiAoX291dCkge1xuICAgICAgICAgIHN0cm0uYWRsZXIgPSBzdGF0ZS5jaGVjayA9XG4gICAgICAgICAgICAgIC8qVVBEQVRFKHN0YXRlLmNoZWNrLCBwdXQgLSBfb3V0LCBfb3V0KTsqL1xuICAgICAgICAgICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBwdXQgLSBfb3V0KSA6IGFkbGVyMzIoc3RhdGUuY2hlY2ssIG91dHB1dCwgX291dCwgcHV0IC0gX291dCkpO1xuXG4gICAgICAgIH1cbiAgICAgICAgX291dCA9IGxlZnQ7XG4gICAgICAgIC8vIE5COiBjcmMzMiBzdG9yZWQgYXMgc2lnbmVkIDMyLWJpdCBpbnQsIHpzd2FwMzIgcmV0dXJucyBzaWduZWQgdG9vXG4gICAgICAgIGlmICgoc3RhdGUuZmxhZ3MgPyBob2xkIDogenN3YXAzMihob2xkKSkgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICAgICAgc3RybS5tc2cgPSAnaW5jb3JyZWN0IGRhdGEgY2hlY2snO1xuICAgICAgICAgIHN0YXRlLm1vZGUgPSBCQUQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0gSU5JVEJJVFMoKTtcbiAgICAgICAgaG9sZCA9IDA7XG4gICAgICAgIGJpdHMgPSAwO1xuICAgICAgICAvLz09PS8vXG4gICAgICAgIC8vVHJhY2V2KChzdGRlcnIsIFwiaW5mbGF0ZTogICBjaGVjayBtYXRjaGVzIHRyYWlsZXJcXG5cIikpO1xuICAgICAgfVxuICAgICAgc3RhdGUubW9kZSA9IExFTkdUSDtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIExFTkdUSDpcbiAgICAgIGlmIChzdGF0ZS53cmFwICYmIHN0YXRlLmZsYWdzKSB7XG4gICAgICAgIC8vPT09IE5FRURCSVRTKDMyKTtcbiAgICAgICAgd2hpbGUgKGJpdHMgPCAzMikge1xuICAgICAgICAgIGlmIChoYXZlID09PSAwKSB7IGJyZWFrIGluZl9sZWF2ZTsgfVxuICAgICAgICAgIGhhdmUtLTtcbiAgICAgICAgICBob2xkICs9IGlucHV0W25leHQrK10gPDwgYml0cztcbiAgICAgICAgICBiaXRzICs9IDg7XG4gICAgICAgIH1cbiAgICAgICAgLy89PT0vL1xuICAgICAgICBpZiAoaG9sZCAhPT0gKHN0YXRlLnRvdGFsICYgMHhmZmZmZmZmZikpIHtcbiAgICAgICAgICBzdHJtLm1zZyA9ICdpbmNvcnJlY3QgbGVuZ3RoIGNoZWNrJztcbiAgICAgICAgICBzdGF0ZS5tb2RlID0gQkFEO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vPT09IElOSVRCSVRTKCk7XG4gICAgICAgIGhvbGQgPSAwO1xuICAgICAgICBiaXRzID0gMDtcbiAgICAgICAgLy89PT0vL1xuICAgICAgICAvL1RyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgbGVuZ3RoIG1hdGNoZXMgdHJhaWxlclxcblwiKSk7XG4gICAgICB9XG4gICAgICBzdGF0ZS5tb2RlID0gRE9ORTtcbiAgICAgIC8qIGZhbGxzIHRocm91Z2ggKi9cbiAgICBjYXNlIERPTkU6XG4gICAgICByZXQgPSBaX1NUUkVBTV9FTkQ7XG4gICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgY2FzZSBCQUQ6XG4gICAgICByZXQgPSBaX0RBVEFfRVJST1I7XG4gICAgICBicmVhayBpbmZfbGVhdmU7XG4gICAgY2FzZSBNRU06XG4gICAgICByZXR1cm4gWl9NRU1fRVJST1I7XG4gICAgY2FzZSBTWU5DOlxuICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gICAgfVxuICB9XG5cbiAgLy8gaW5mX2xlYXZlIDwtIGhlcmUgaXMgcmVhbCBwbGFjZSBmb3IgXCJnb3RvIGluZl9sZWF2ZVwiLCBlbXVsYXRlZCB2aWEgXCJicmVhayBpbmZfbGVhdmVcIlxuXG4gIC8qXG4gICAgIFJldHVybiBmcm9tIGluZmxhdGUoKSwgdXBkYXRpbmcgdGhlIHRvdGFsIGNvdW50cyBhbmQgdGhlIGNoZWNrIHZhbHVlLlxuICAgICBJZiB0aGVyZSB3YXMgbm8gcHJvZ3Jlc3MgZHVyaW5nIHRoZSBpbmZsYXRlKCkgY2FsbCwgcmV0dXJuIGEgYnVmZmVyXG4gICAgIGVycm9yLiAgQ2FsbCB1cGRhdGV3aW5kb3coKSB0byBjcmVhdGUgYW5kL29yIHVwZGF0ZSB0aGUgd2luZG93IHN0YXRlLlxuICAgICBOb3RlOiBhIG1lbW9yeSBlcnJvciBmcm9tIGluZmxhdGUoKSBpcyBub24tcmVjb3ZlcmFibGUuXG4gICAqL1xuXG4gIC8vLS0tIFJFU1RPUkUoKSAtLS1cbiAgc3RybS5uZXh0X291dCA9IHB1dDtcbiAgc3RybS5hdmFpbF9vdXQgPSBsZWZ0O1xuICBzdHJtLm5leHRfaW4gPSBuZXh0O1xuICBzdHJtLmF2YWlsX2luID0gaGF2ZTtcbiAgc3RhdGUuaG9sZCA9IGhvbGQ7XG4gIHN0YXRlLmJpdHMgPSBiaXRzO1xuICAvLy0tLVxuXG4gIGlmIChzdGF0ZS53c2l6ZSB8fCAoX291dCAhPT0gc3RybS5hdmFpbF9vdXQgJiYgc3RhdGUubW9kZSA8IEJBRCAmJlxuICAgICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlIDwgQ0hFQ0sgfHwgZmx1c2ggIT09IFpfRklOSVNIKSkpIHtcbiAgICBpZiAodXBkYXRld2luZG93KHN0cm0sIHN0cm0ub3V0cHV0LCBzdHJtLm5leHRfb3V0LCBfb3V0IC0gc3RybS5hdmFpbF9vdXQpKSB7XG4gICAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgICAgcmV0dXJuIFpfTUVNX0VSUk9SO1xuICAgIH1cbiAgfVxuICBfaW4gLT0gc3RybS5hdmFpbF9pbjtcbiAgX291dCAtPSBzdHJtLmF2YWlsX291dDtcbiAgc3RybS50b3RhbF9pbiArPSBfaW47XG4gIHN0cm0udG90YWxfb3V0ICs9IF9vdXQ7XG4gIHN0YXRlLnRvdGFsICs9IF9vdXQ7XG4gIGlmIChzdGF0ZS53cmFwICYmIF9vdXQpIHtcbiAgICBzdHJtLmFkbGVyID0gc3RhdGUuY2hlY2sgPSAvKlVQREFURShzdGF0ZS5jaGVjaywgc3RybS5uZXh0X291dCAtIF9vdXQsIF9vdXQpOyovXG4gICAgICAoc3RhdGUuZmxhZ3MgPyBjcmMzMihzdGF0ZS5jaGVjaywgb3V0cHV0LCBfb3V0LCBzdHJtLm5leHRfb3V0IC0gX291dCkgOiBhZGxlcjMyKHN0YXRlLmNoZWNrLCBvdXRwdXQsIF9vdXQsIHN0cm0ubmV4dF9vdXQgLSBfb3V0KSk7XG4gIH1cbiAgc3RybS5kYXRhX3R5cGUgPSBzdGF0ZS5iaXRzICsgKHN0YXRlLmxhc3QgPyA2NCA6IDApICtcbiAgICAgICAgICAgICAgICAgICAgKHN0YXRlLm1vZGUgPT09IFRZUEUgPyAxMjggOiAwKSArXG4gICAgICAgICAgICAgICAgICAgIChzdGF0ZS5tb2RlID09PSBMRU5fIHx8IHN0YXRlLm1vZGUgPT09IENPUFlfID8gMjU2IDogMCk7XG4gIGlmICgoKF9pbiA9PT0gMCAmJiBfb3V0ID09PSAwKSB8fCBmbHVzaCA9PT0gWl9GSU5JU0gpICYmIHJldCA9PT0gWl9PSykge1xuICAgIHJldCA9IFpfQlVGX0VSUk9SO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGluZmxhdGVFbmQoc3RybSkge1xuXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSAvKnx8IHN0cm0tPnpmcmVlID09IChmcmVlX2Z1bmMpMCovKSB7XG4gICAgcmV0dXJuIFpfU1RSRUFNX0VSUk9SO1xuICB9XG5cbiAgdmFyIHN0YXRlID0gc3RybS5zdGF0ZTtcbiAgaWYgKHN0YXRlLndpbmRvdykge1xuICAgIHN0YXRlLndpbmRvdyA9IG51bGw7XG4gIH1cbiAgc3RybS5zdGF0ZSA9IG51bGw7XG4gIHJldHVybiBaX09LO1xufVxuXG5mdW5jdGlvbiBpbmZsYXRlR2V0SGVhZGVyKHN0cm0sIGhlYWQpIHtcbiAgdmFyIHN0YXRlO1xuXG4gIC8qIGNoZWNrIHN0YXRlICovXG4gIGlmICghc3RybSB8fCAhc3RybS5zdGF0ZSkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuICBpZiAoKHN0YXRlLndyYXAgJiAyKSA9PT0gMCkgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cblxuICAvKiBzYXZlIGhlYWRlciBzdHJ1Y3R1cmUgKi9cbiAgc3RhdGUuaGVhZCA9IGhlYWQ7XG4gIGhlYWQuZG9uZSA9IGZhbHNlO1xuICByZXR1cm4gWl9PSztcbn1cblxuZnVuY3Rpb24gaW5mbGF0ZVNldERpY3Rpb25hcnkoc3RybSwgZGljdGlvbmFyeSkge1xuICB2YXIgZGljdExlbmd0aCA9IGRpY3Rpb25hcnkubGVuZ3RoO1xuXG4gIHZhciBzdGF0ZTtcbiAgdmFyIGRpY3RpZDtcbiAgdmFyIHJldDtcblxuICAvKiBjaGVjayBzdGF0ZSAqL1xuICBpZiAoIXN0cm0gLyogPT0gWl9OVUxMICovIHx8ICFzdHJtLnN0YXRlIC8qID09IFpfTlVMTCAqLykgeyByZXR1cm4gWl9TVFJFQU1fRVJST1I7IH1cbiAgc3RhdGUgPSBzdHJtLnN0YXRlO1xuXG4gIGlmIChzdGF0ZS53cmFwICE9PSAwICYmIHN0YXRlLm1vZGUgIT09IERJQ1QpIHtcbiAgICByZXR1cm4gWl9TVFJFQU1fRVJST1I7XG4gIH1cblxuICAvKiBjaGVjayBmb3IgY29ycmVjdCBkaWN0aW9uYXJ5IGlkZW50aWZpZXIgKi9cbiAgaWYgKHN0YXRlLm1vZGUgPT09IERJQ1QpIHtcbiAgICBkaWN0aWQgPSAxOyAvKiBhZGxlcjMyKDAsIG51bGwsIDApKi9cbiAgICAvKiBkaWN0aWQgPSBhZGxlcjMyKGRpY3RpZCwgZGljdGlvbmFyeSwgZGljdExlbmd0aCk7ICovXG4gICAgZGljdGlkID0gYWRsZXIzMihkaWN0aWQsIGRpY3Rpb25hcnksIGRpY3RMZW5ndGgsIDApO1xuICAgIGlmIChkaWN0aWQgIT09IHN0YXRlLmNoZWNrKSB7XG4gICAgICByZXR1cm4gWl9EQVRBX0VSUk9SO1xuICAgIH1cbiAgfVxuICAvKiBjb3B5IGRpY3Rpb25hcnkgdG8gd2luZG93IHVzaW5nIHVwZGF0ZXdpbmRvdygpLCB3aGljaCB3aWxsIGFtZW5kIHRoZVxuICAgZXhpc3RpbmcgZGljdGlvbmFyeSBpZiBhcHByb3ByaWF0ZSAqL1xuICByZXQgPSB1cGRhdGV3aW5kb3coc3RybSwgZGljdGlvbmFyeSwgZGljdExlbmd0aCwgZGljdExlbmd0aCk7XG4gIGlmIChyZXQpIHtcbiAgICBzdGF0ZS5tb2RlID0gTUVNO1xuICAgIHJldHVybiBaX01FTV9FUlJPUjtcbiAgfVxuICBzdGF0ZS5oYXZlZGljdCA9IDE7XG4gIC8vIFRyYWNldigoc3RkZXJyLCBcImluZmxhdGU6ICAgZGljdGlvbmFyeSBzZXRcXG5cIikpO1xuICByZXR1cm4gWl9PSztcbn1cblxuZXhwb3J0IHsgaW5mbGF0ZVJlc2V0LCBpbmZsYXRlUmVzZXQyLCBpbmZsYXRlUmVzZXRLZWVwLCBpbmZsYXRlSW5pdCwgaW5mbGF0ZUluaXQyLCBpbmZsYXRlLCBpbmZsYXRlRW5kLCBpbmZsYXRlR2V0SGVhZGVyLCBpbmZsYXRlU2V0RGljdGlvbmFyeSB9O1xuZXhwb3J0IHZhciBpbmZsYXRlSW5mbyA9ICdwYWtvIGluZmxhdGUgKGZyb20gTm9kZWNhIHByb2plY3QpJztcblxuLyogTm90IGltcGxlbWVudGVkXG5leHBvcnRzLmluZmxhdGVDb3B5ID0gaW5mbGF0ZUNvcHk7XG5leHBvcnRzLmluZmxhdGVHZXREaWN0aW9uYXJ5ID0gaW5mbGF0ZUdldERpY3Rpb25hcnk7XG5leHBvcnRzLmluZmxhdGVNYXJrID0gaW5mbGF0ZU1hcms7XG5leHBvcnRzLmluZmxhdGVQcmltZSA9IGluZmxhdGVQcmltZTtcbmV4cG9ydHMuaW5mbGF0ZVN5bmMgPSBpbmZsYXRlU3luYztcbmV4cG9ydHMuaW5mbGF0ZVN5bmNQb2ludCA9IGluZmxhdGVTeW5jUG9pbnQ7XG5leHBvcnRzLmluZmxhdGVVbmRlcm1pbmUgPSBpbmZsYXRlVW5kZXJtaW5lO1xuKi9cbiIsImltcG9ydCAqIGFzIHV0aWxzIGZyb20gXCIuLi91dGlscy9jb21tb24uanNcIjtcblxudmFyIE1BWEJJVFMgPSAxNTtcbnZhciBFTk9VR0hfTEVOUyA9IDg1MjtcbnZhciBFTk9VR0hfRElTVFMgPSA1OTI7XG4vL3ZhciBFTk9VR0ggPSAoRU5PVUdIX0xFTlMrRU5PVUdIX0RJU1RTKTtcblxudmFyIENPREVTID0gMDtcbnZhciBMRU5TID0gMTtcbnZhciBESVNUUyA9IDI7XG5cbnZhciBsYmFzZSA9IFsgLyogTGVuZ3RoIGNvZGVzIDI1Ny4uMjg1IGJhc2UgKi9cbiAgMywgNCwgNSwgNiwgNywgOCwgOSwgMTAsIDExLCAxMywgMTUsIDE3LCAxOSwgMjMsIDI3LCAzMSxcbiAgMzUsIDQzLCA1MSwgNTksIDY3LCA4MywgOTksIDExNSwgMTMxLCAxNjMsIDE5NSwgMjI3LCAyNTgsIDAsIDBcbl07XG5cbnZhciBsZXh0ID0gWyAvKiBMZW5ndGggY29kZXMgMjU3Li4yODUgZXh0cmEgKi9cbiAgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE3LCAxNywgMTgsIDE4LCAxOCwgMTgsXG4gIDE5LCAxOSwgMTksIDE5LCAyMCwgMjAsIDIwLCAyMCwgMjEsIDIxLCAyMSwgMjEsIDE2LCA3MiwgNzhcbl07XG5cbnZhciBkYmFzZSA9IFsgLyogRGlzdGFuY2UgY29kZXMgMC4uMjkgYmFzZSAqL1xuICAxLCAyLCAzLCA0LCA1LCA3LCA5LCAxMywgMTcsIDI1LCAzMywgNDksIDY1LCA5NywgMTI5LCAxOTMsXG4gIDI1NywgMzg1LCA1MTMsIDc2OSwgMTAyNSwgMTUzNywgMjA0OSwgMzA3MywgNDA5NywgNjE0NSxcbiAgODE5MywgMTIyODksIDE2Mzg1LCAyNDU3NywgMCwgMFxuXTtcblxudmFyIGRleHQgPSBbIC8qIERpc3RhbmNlIGNvZGVzIDAuLjI5IGV4dHJhICovXG4gIDE2LCAxNiwgMTYsIDE2LCAxNywgMTcsIDE4LCAxOCwgMTksIDE5LCAyMCwgMjAsIDIxLCAyMSwgMjIsIDIyLFxuICAyMywgMjMsIDI0LCAyNCwgMjUsIDI1LCAyNiwgMjYsIDI3LCAyNyxcbiAgMjgsIDI4LCAyOSwgMjksIDY0LCA2NFxuXTtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gaW5mbGF0ZV90YWJsZSh0eXBlLCBsZW5zLCBsZW5zX2luZGV4LCBjb2RlcywgdGFibGUsIHRhYmxlX2luZGV4LCB3b3JrLCBvcHRzKVxue1xuICB2YXIgYml0cyA9IG9wdHMuYml0cztcbiAgICAgIC8vaGVyZSA9IG9wdHMuaGVyZTsgLyogdGFibGUgZW50cnkgZm9yIGR1cGxpY2F0aW9uICovXG5cbiAgdmFyIGxlbiA9IDA7ICAgICAgICAgICAgICAgLyogYSBjb2RlJ3MgbGVuZ3RoIGluIGJpdHMgKi9cbiAgdmFyIHN5bSA9IDA7ICAgICAgICAgICAgICAgLyogaW5kZXggb2YgY29kZSBzeW1ib2xzICovXG4gIHZhciBtaW4gPSAwLCBtYXggPSAwOyAgICAgICAgICAvKiBtaW5pbXVtIGFuZCBtYXhpbXVtIGNvZGUgbGVuZ3RocyAqL1xuICB2YXIgcm9vdCA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3Igcm9vdCB0YWJsZSAqL1xuICB2YXIgY3VyciA9IDA7ICAgICAgICAgICAgICAvKiBudW1iZXIgb2YgaW5kZXggYml0cyBmb3IgY3VycmVudCB0YWJsZSAqL1xuICB2YXIgZHJvcCA9IDA7ICAgICAgICAgICAgICAvKiBjb2RlIGJpdHMgdG8gZHJvcCBmb3Igc3ViLXRhYmxlICovXG4gIHZhciBsZWZ0ID0gMDsgICAgICAgICAgICAgICAgICAgLyogbnVtYmVyIG9mIHByZWZpeCBjb2RlcyBhdmFpbGFibGUgKi9cbiAgdmFyIHVzZWQgPSAwOyAgICAgICAgICAgICAgLyogY29kZSBlbnRyaWVzIGluIHRhYmxlIHVzZWQgKi9cbiAgdmFyIGh1ZmYgPSAwOyAgICAgICAgICAgICAgLyogSHVmZm1hbiBjb2RlICovXG4gIHZhciBpbmNyOyAgICAgICAgICAgICAgLyogZm9yIGluY3JlbWVudGluZyBjb2RlLCBpbmRleCAqL1xuICB2YXIgZmlsbDsgICAgICAgICAgICAgIC8qIGluZGV4IGZvciByZXBsaWNhdGluZyBlbnRyaWVzICovXG4gIHZhciBsb3c7ICAgICAgICAgICAgICAgLyogbG93IGJpdHMgZm9yIGN1cnJlbnQgcm9vdCBlbnRyeSAqL1xuICB2YXIgbWFzazsgICAgICAgICAgICAgIC8qIG1hc2sgZm9yIGxvdyByb290IGJpdHMgKi9cbiAgdmFyIG5leHQ7ICAgICAgICAgICAgIC8qIG5leHQgYXZhaWxhYmxlIHNwYWNlIGluIHRhYmxlICovXG4gIHZhciBiYXNlID0gbnVsbDsgICAgIC8qIGJhc2UgdmFsdWUgdGFibGUgdG8gdXNlICovXG4gIHZhciBiYXNlX2luZGV4ID0gMDtcbi8vICB2YXIgc2hvZXh0cmE7ICAgIC8qIGV4dHJhIGJpdHMgdGFibGUgdG8gdXNlICovXG4gIHZhciBlbmQ7ICAgICAgICAgICAgICAgICAgICAvKiB1c2UgYmFzZSBhbmQgZXh0cmEgZm9yIHN5bWJvbCA+IGVuZCAqL1xuICB2YXIgY291bnQgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAvKiBudW1iZXIgb2YgY29kZXMgb2YgZWFjaCBsZW5ndGggKi9cbiAgdmFyIG9mZnMgPSBuZXcgdXRpbHMuQnVmMTYoTUFYQklUUyArIDEpOyAvL1tNQVhCSVRTKzFdOyAgICAgLyogb2Zmc2V0cyBpbiB0YWJsZSBmb3IgZWFjaCBsZW5ndGggKi9cbiAgdmFyIGV4dHJhID0gbnVsbDtcbiAgdmFyIGV4dHJhX2luZGV4ID0gMDtcblxuICB2YXIgaGVyZV9iaXRzLCBoZXJlX29wLCBoZXJlX3ZhbDtcblxuICAvKlxuICAgUHJvY2VzcyBhIHNldCBvZiBjb2RlIGxlbmd0aHMgdG8gY3JlYXRlIGEgY2Fub25pY2FsIEh1ZmZtYW4gY29kZS4gIFRoZVxuICAgY29kZSBsZW5ndGhzIGFyZSBsZW5zWzAuLmNvZGVzLTFdLiAgRWFjaCBsZW5ndGggY29ycmVzcG9uZHMgdG8gdGhlXG4gICBzeW1ib2xzIDAuLmNvZGVzLTEuICBUaGUgSHVmZm1hbiBjb2RlIGlzIGdlbmVyYXRlZCBieSBmaXJzdCBzb3J0aW5nIHRoZVxuICAgc3ltYm9scyBieSBsZW5ndGggZnJvbSBzaG9ydCB0byBsb25nLCBhbmQgcmV0YWluaW5nIHRoZSBzeW1ib2wgb3JkZXJcbiAgIGZvciBjb2RlcyB3aXRoIGVxdWFsIGxlbmd0aHMuICBUaGVuIHRoZSBjb2RlIHN0YXJ0cyB3aXRoIGFsbCB6ZXJvIGJpdHNcbiAgIGZvciB0aGUgZmlyc3QgY29kZSBvZiB0aGUgc2hvcnRlc3QgbGVuZ3RoLCBhbmQgdGhlIGNvZGVzIGFyZSBpbnRlZ2VyXG4gICBpbmNyZW1lbnRzIGZvciB0aGUgc2FtZSBsZW5ndGgsIGFuZCB6ZXJvcyBhcmUgYXBwZW5kZWQgYXMgdGhlIGxlbmd0aFxuICAgaW5jcmVhc2VzLiAgRm9yIHRoZSBkZWZsYXRlIGZvcm1hdCwgdGhlc2UgYml0cyBhcmUgc3RvcmVkIGJhY2t3YXJkc1xuICAgZnJvbSB0aGVpciBtb3JlIG5hdHVyYWwgaW50ZWdlciBpbmNyZW1lbnQgb3JkZXJpbmcsIGFuZCBzbyB3aGVuIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzIGFyZSBidWlsdCBpbiB0aGUgbGFyZ2UgbG9vcCBiZWxvdywgdGhlIGludGVnZXIgY29kZXNcbiAgIGFyZSBpbmNyZW1lbnRlZCBiYWNrd2FyZHMuXG5cbiAgIFRoaXMgcm91dGluZSBhc3N1bWVzLCBidXQgZG9lcyBub3QgY2hlY2ssIHRoYXQgYWxsIG9mIHRoZSBlbnRyaWVzIGluXG4gICBsZW5zW10gYXJlIGluIHRoZSByYW5nZSAwLi5NQVhCSVRTLiAgVGhlIGNhbGxlciBtdXN0IGFzc3VyZSB0aGlzLlxuICAgMS4uTUFYQklUUyBpcyBpbnRlcnByZXRlZCBhcyB0aGF0IGNvZGUgbGVuZ3RoLiAgemVybyBtZWFucyB0aGF0IHRoYXRcbiAgIHN5bWJvbCBkb2VzIG5vdCBvY2N1ciBpbiB0aGlzIGNvZGUuXG5cbiAgIFRoZSBjb2RlcyBhcmUgc29ydGVkIGJ5IGNvbXB1dGluZyBhIGNvdW50IG9mIGNvZGVzIGZvciBlYWNoIGxlbmd0aCxcbiAgIGNyZWF0aW5nIGZyb20gdGhhdCBhIHRhYmxlIG9mIHN0YXJ0aW5nIGluZGljZXMgZm9yIGVhY2ggbGVuZ3RoIGluIHRoZVxuICAgc29ydGVkIHRhYmxlLCBhbmQgdGhlbiBlbnRlcmluZyB0aGUgc3ltYm9scyBpbiBvcmRlciBpbiB0aGUgc29ydGVkXG4gICB0YWJsZS4gIFRoZSBzb3J0ZWQgdGFibGUgaXMgd29ya1tdLCB3aXRoIHRoYXQgc3BhY2UgYmVpbmcgcHJvdmlkZWQgYnlcbiAgIHRoZSBjYWxsZXIuXG5cbiAgIFRoZSBsZW5ndGggY291bnRzIGFyZSB1c2VkIGZvciBvdGhlciBwdXJwb3NlcyBhcyB3ZWxsLCBpLmUuIGZpbmRpbmdcbiAgIHRoZSBtaW5pbXVtIGFuZCBtYXhpbXVtIGxlbmd0aCBjb2RlcywgZGV0ZXJtaW5pbmcgaWYgdGhlcmUgYXJlIGFueVxuICAgY29kZXMgYXQgYWxsLCBjaGVja2luZyBmb3IgYSB2YWxpZCBzZXQgb2YgbGVuZ3RocywgYW5kIGxvb2tpbmcgYWhlYWRcbiAgIGF0IGxlbmd0aCBjb3VudHMgdG8gZGV0ZXJtaW5lIHN1Yi10YWJsZSBzaXplcyB3aGVuIGJ1aWxkaW5nIHRoZVxuICAgZGVjb2RpbmcgdGFibGVzLlxuICAgKi9cblxuICAvKiBhY2N1bXVsYXRlIGxlbmd0aHMgZm9yIGNvZGVzIChhc3N1bWVzIGxlbnNbXSBhbGwgaW4gMC4uTUFYQklUUykgKi9cbiAgZm9yIChsZW4gPSAwOyBsZW4gPD0gTUFYQklUUzsgbGVuKyspIHtcbiAgICBjb3VudFtsZW5dID0gMDtcbiAgfVxuICBmb3IgKHN5bSA9IDA7IHN5bSA8IGNvZGVzOyBzeW0rKykge1xuICAgIGNvdW50W2xlbnNbbGVuc19pbmRleCArIHN5bV1dKys7XG4gIH1cblxuICAvKiBib3VuZCBjb2RlIGxlbmd0aHMsIGZvcmNlIHJvb3QgdG8gYmUgd2l0aGluIGNvZGUgbGVuZ3RocyAqL1xuICByb290ID0gYml0cztcbiAgZm9yIChtYXggPSBNQVhCSVRTOyBtYXggPj0gMTsgbWF4LS0pIHtcbiAgICBpZiAoY291bnRbbWF4XSAhPT0gMCkgeyBicmVhazsgfVxuICB9XG4gIGlmIChyb290ID4gbWF4KSB7XG4gICAgcm9vdCA9IG1heDtcbiAgfVxuICBpZiAobWF4ID09PSAwKSB7ICAgICAgICAgICAgICAgICAgICAgLyogbm8gc3ltYm9scyB0byBjb2RlIGF0IGFsbCAqL1xuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDsgIC8vaGVyZS5vcCA9ICh2YXIgY2hhcik2NDsgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tvcHRzLnRhYmxlX2luZGV4XSA9IDE7ICAgLy9oZXJlLmJpdHMgPSAodmFyIGNoYXIpMTtcbiAgICAvL3RhYmxlLnZhbFtvcHRzLnRhYmxlX2luZGV4KytdID0gMDsgICAvL2hlcmUudmFsID0gKHZhciBzaG9ydCkwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cblxuICAgIC8vdGFibGUub3Bbb3B0cy50YWJsZV9pbmRleF0gPSA2NDtcbiAgICAvL3RhYmxlLmJpdHNbb3B0cy50YWJsZV9pbmRleF0gPSAxO1xuICAgIC8vdGFibGUudmFsW29wdHMudGFibGVfaW5kZXgrK10gPSAwO1xuICAgIHRhYmxlW3RhYmxlX2luZGV4KytdID0gKDEgPDwgMjQpIHwgKDY0IDw8IDE2KSB8IDA7XG5cbiAgICBvcHRzLmJpdHMgPSAxO1xuICAgIHJldHVybiAwOyAgICAgLyogbm8gc3ltYm9scywgYnV0IHdhaXQgZm9yIGRlY29kaW5nIHRvIHJlcG9ydCBlcnJvciAqL1xuICB9XG4gIGZvciAobWluID0gMTsgbWluIDwgbWF4OyBtaW4rKykge1xuICAgIGlmIChjb3VudFttaW5dICE9PSAwKSB7IGJyZWFrOyB9XG4gIH1cbiAgaWYgKHJvb3QgPCBtaW4pIHtcbiAgICByb290ID0gbWluO1xuICB9XG5cbiAgLyogY2hlY2sgZm9yIGFuIG92ZXItc3Vic2NyaWJlZCBvciBpbmNvbXBsZXRlIHNldCBvZiBsZW5ndGhzICovXG4gIGxlZnQgPSAxO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8PSBNQVhCSVRTOyBsZW4rKykge1xuICAgIGxlZnQgPDw9IDE7XG4gICAgbGVmdCAtPSBjb3VudFtsZW5dO1xuICAgIGlmIChsZWZ0IDwgMCkge1xuICAgICAgcmV0dXJuIC0xO1xuICAgIH0gICAgICAgIC8qIG92ZXItc3Vic2NyaWJlZCAqL1xuICB9XG4gIGlmIChsZWZ0ID4gMCAmJiAodHlwZSA9PT0gQ09ERVMgfHwgbWF4ICE9PSAxKSkge1xuICAgIHJldHVybiAtMTsgICAgICAgICAgICAgICAgICAgICAgLyogaW5jb21wbGV0ZSBzZXQgKi9cbiAgfVxuXG4gIC8qIGdlbmVyYXRlIG9mZnNldHMgaW50byBzeW1ib2wgdGFibGUgZm9yIGVhY2ggbGVuZ3RoIGZvciBzb3J0aW5nICovXG4gIG9mZnNbMV0gPSAwO1xuICBmb3IgKGxlbiA9IDE7IGxlbiA8IE1BWEJJVFM7IGxlbisrKSB7XG4gICAgb2Zmc1tsZW4gKyAxXSA9IG9mZnNbbGVuXSArIGNvdW50W2xlbl07XG4gIH1cblxuICAvKiBzb3J0IHN5bWJvbHMgYnkgbGVuZ3RoLCBieSBzeW1ib2wgb3JkZXIgd2l0aGluIGVhY2ggbGVuZ3RoICovXG4gIGZvciAoc3ltID0gMDsgc3ltIDwgY29kZXM7IHN5bSsrKSB7XG4gICAgaWYgKGxlbnNbbGVuc19pbmRleCArIHN5bV0gIT09IDApIHtcbiAgICAgIHdvcmtbb2Zmc1tsZW5zW2xlbnNfaW5kZXggKyBzeW1dXSsrXSA9IHN5bTtcbiAgICB9XG4gIH1cblxuICAvKlxuICAgQ3JlYXRlIGFuZCBmaWxsIGluIGRlY29kaW5nIHRhYmxlcy4gIEluIHRoaXMgbG9vcCwgdGhlIHRhYmxlIGJlaW5nXG4gICBmaWxsZWQgaXMgYXQgbmV4dCBhbmQgaGFzIGN1cnIgaW5kZXggYml0cy4gIFRoZSBjb2RlIGJlaW5nIHVzZWQgaXMgaHVmZlxuICAgd2l0aCBsZW5ndGggbGVuLiAgVGhhdCBjb2RlIGlzIGNvbnZlcnRlZCB0byBhbiBpbmRleCBieSBkcm9wcGluZyBkcm9wXG4gICBiaXRzIG9mZiBvZiB0aGUgYm90dG9tLiAgRm9yIGNvZGVzIHdoZXJlIGxlbiBpcyBsZXNzIHRoYW4gZHJvcCArIGN1cnIsXG4gICB0aG9zZSB0b3AgZHJvcCArIGN1cnIgLSBsZW4gYml0cyBhcmUgaW5jcmVtZW50ZWQgdGhyb3VnaCBhbGwgdmFsdWVzIHRvXG4gICBmaWxsIHRoZSB0YWJsZSB3aXRoIHJlcGxpY2F0ZWQgZW50cmllcy5cblxuICAgcm9vdCBpcyB0aGUgbnVtYmVyIG9mIGluZGV4IGJpdHMgZm9yIHRoZSByb290IHRhYmxlLiAgV2hlbiBsZW4gZXhjZWVkc1xuICAgcm9vdCwgc3ViLXRhYmxlcyBhcmUgY3JlYXRlZCBwb2ludGVkIHRvIGJ5IHRoZSByb290IGVudHJ5IHdpdGggYW4gaW5kZXhcbiAgIG9mIHRoZSBsb3cgcm9vdCBiaXRzIG9mIGh1ZmYuICBUaGlzIGlzIHNhdmVkIGluIGxvdyB0byBjaGVjayBmb3Igd2hlbiBhXG4gICBuZXcgc3ViLXRhYmxlIHNob3VsZCBiZSBzdGFydGVkLiAgZHJvcCBpcyB6ZXJvIHdoZW4gdGhlIHJvb3QgdGFibGUgaXNcbiAgIGJlaW5nIGZpbGxlZCwgYW5kIGRyb3AgaXMgcm9vdCB3aGVuIHN1Yi10YWJsZXMgYXJlIGJlaW5nIGZpbGxlZC5cblxuICAgV2hlbiBhIG5ldyBzdWItdGFibGUgaXMgbmVlZGVkLCBpdCBpcyBuZWNlc3NhcnkgdG8gbG9vayBhaGVhZCBpbiB0aGVcbiAgIGNvZGUgbGVuZ3RocyB0byBkZXRlcm1pbmUgd2hhdCBzaXplIHN1Yi10YWJsZSBpcyBuZWVkZWQuICBUaGUgbGVuZ3RoXG4gICBjb3VudHMgYXJlIHVzZWQgZm9yIHRoaXMsIGFuZCBzbyBjb3VudFtdIGlzIGRlY3JlbWVudGVkIGFzIGNvZGVzIGFyZVxuICAgZW50ZXJlZCBpbiB0aGUgdGFibGVzLlxuXG4gICB1c2VkIGtlZXBzIHRyYWNrIG9mIGhvdyBtYW55IHRhYmxlIGVudHJpZXMgaGF2ZSBiZWVuIGFsbG9jYXRlZCBmcm9tIHRoZVxuICAgcHJvdmlkZWQgKnRhYmxlIHNwYWNlLiAgSXQgaXMgY2hlY2tlZCBmb3IgTEVOUyBhbmQgRElTVCB0YWJsZXMgYWdhaW5zdFxuICAgdGhlIGNvbnN0YW50cyBFTk9VR0hfTEVOUyBhbmQgRU5PVUdIX0RJU1RTIHRvIGd1YXJkIGFnYWluc3QgY2hhbmdlcyBpblxuICAgdGhlIGluaXRpYWwgcm9vdCB0YWJsZSBzaXplIGNvbnN0YW50cy4gIFNlZSB0aGUgY29tbWVudHMgaW4gaW5mdHJlZXMuaFxuICAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXG5cbiAgIHN5bSBpbmNyZW1lbnRzIHRocm91Z2ggYWxsIHN5bWJvbHMsIGFuZCB0aGUgbG9vcCB0ZXJtaW5hdGVzIHdoZW5cbiAgIGFsbCBjb2RlcyBvZiBsZW5ndGggbWF4LCBpLmUuIGFsbCBjb2RlcywgaGF2ZSBiZWVuIHByb2Nlc3NlZC4gIFRoaXNcbiAgIHJvdXRpbmUgcGVybWl0cyBpbmNvbXBsZXRlIGNvZGVzLCBzbyBhbm90aGVyIGxvb3AgYWZ0ZXIgdGhpcyBvbmUgZmlsbHNcbiAgIGluIHRoZSByZXN0IG9mIHRoZSBkZWNvZGluZyB0YWJsZXMgd2l0aCBpbnZhbGlkIGNvZGUgbWFya2Vycy5cbiAgICovXG5cbiAgLyogc2V0IHVwIGZvciBjb2RlIHR5cGUgKi9cbiAgLy8gcG9vciBtYW4gb3B0aW1pemF0aW9uIC0gdXNlIGlmLWVsc2UgaW5zdGVhZCBvZiBzd2l0Y2gsXG4gIC8vIHRvIGF2b2lkIGRlb3B0cyBpbiBvbGQgdjhcbiAgaWYgKHR5cGUgPT09IENPREVTKSB7XG4gICAgYmFzZSA9IGV4dHJhID0gd29yazsgICAgLyogZHVtbXkgdmFsdWUtLW5vdCB1c2VkICovXG4gICAgZW5kID0gMTk7XG5cbiAgfSBlbHNlIGlmICh0eXBlID09PSBMRU5TKSB7XG4gICAgYmFzZSA9IGxiYXNlO1xuICAgIGJhc2VfaW5kZXggLT0gMjU3O1xuICAgIGV4dHJhID0gbGV4dDtcbiAgICBleHRyYV9pbmRleCAtPSAyNTc7XG4gICAgZW5kID0gMjU2O1xuXG4gIH0gZWxzZSB7ICAgICAgICAgICAgICAgICAgICAvKiBESVNUUyAqL1xuICAgIGJhc2UgPSBkYmFzZTtcbiAgICBleHRyYSA9IGRleHQ7XG4gICAgZW5kID0gLTE7XG4gIH1cblxuICAvKiBpbml0aWFsaXplIG9wdHMgZm9yIGxvb3AgKi9cbiAgaHVmZiA9IDA7ICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgKi9cbiAgc3ltID0gMDsgICAgICAgICAgICAgICAgICAgIC8qIHN0YXJ0aW5nIGNvZGUgc3ltYm9sICovXG4gIGxlbiA9IG1pbjsgICAgICAgICAgICAgICAgICAvKiBzdGFydGluZyBjb2RlIGxlbmd0aCAqL1xuICBuZXh0ID0gdGFibGVfaW5kZXg7ICAgICAgICAgICAgICAvKiBjdXJyZW50IHRhYmxlIHRvIGZpbGwgaW4gKi9cbiAgY3VyciA9IHJvb3Q7ICAgICAgICAgICAgICAgIC8qIGN1cnJlbnQgdGFibGUgaW5kZXggYml0cyAqL1xuICBkcm9wID0gMDsgICAgICAgICAgICAgICAgICAgLyogY3VycmVudCBiaXRzIHRvIGRyb3AgZnJvbSBjb2RlIGZvciBpbmRleCAqL1xuICBsb3cgPSAtMTsgICAgICAgICAgICAgICAgICAgLyogdHJpZ2dlciBuZXcgc3ViLXRhYmxlIHdoZW4gbGVuID4gcm9vdCAqL1xuICB1c2VkID0gMSA8PCByb290OyAgICAgICAgICAvKiB1c2Ugcm9vdCB0YWJsZSBlbnRyaWVzICovXG4gIG1hc2sgPSB1c2VkIC0gMTsgICAgICAgICAgICAvKiBtYXNrIGZvciBjb21wYXJpbmcgbG93ICovXG5cbiAgLyogY2hlY2sgYXZhaWxhYmxlIHRhYmxlIHNwYWNlICovXG4gIGlmICgodHlwZSA9PT0gTEVOUyAmJiB1c2VkID4gRU5PVUdIX0xFTlMpIHx8XG4gICAgKHR5cGUgPT09IERJU1RTICYmIHVzZWQgPiBFTk9VR0hfRElTVFMpKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvKiBwcm9jZXNzIGFsbCBjb2RlcyBhbmQgbWFrZSB0YWJsZSBlbnRyaWVzICovXG4gIGZvciAoOzspIHtcbiAgICAvKiBjcmVhdGUgdGFibGUgZW50cnkgKi9cbiAgICBoZXJlX2JpdHMgPSBsZW4gLSBkcm9wO1xuICAgIGlmICh3b3JrW3N5bV0gPCBlbmQpIHtcbiAgICAgIGhlcmVfb3AgPSAwO1xuICAgICAgaGVyZV92YWwgPSB3b3JrW3N5bV07XG4gICAgfVxuICAgIGVsc2UgaWYgKHdvcmtbc3ltXSA+IGVuZCkge1xuICAgICAgaGVyZV9vcCA9IGV4dHJhW2V4dHJhX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICAgIGhlcmVfdmFsID0gYmFzZVtiYXNlX2luZGV4ICsgd29ya1tzeW1dXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBoZXJlX29wID0gMzIgKyA2NDsgICAgICAgICAvKiBlbmQgb2YgYmxvY2sgKi9cbiAgICAgIGhlcmVfdmFsID0gMDtcbiAgICB9XG5cbiAgICAvKiByZXBsaWNhdGUgZm9yIHRob3NlIGluZGljZXMgd2l0aCBsb3cgbGVuIGJpdHMgZXF1YWwgdG8gaHVmZiAqL1xuICAgIGluY3IgPSAxIDw8IChsZW4gLSBkcm9wKTtcbiAgICBmaWxsID0gMSA8PCBjdXJyO1xuICAgIG1pbiA9IGZpbGw7ICAgICAgICAgICAgICAgICAvKiBzYXZlIG9mZnNldCB0byBuZXh0IHRhYmxlICovXG4gICAgZG8ge1xuICAgICAgZmlsbCAtPSBpbmNyO1xuICAgICAgdGFibGVbbmV4dCArIChodWZmID4+IGRyb3ApICsgZmlsbF0gPSAoaGVyZV9iaXRzIDw8IDI0KSB8IChoZXJlX29wIDw8IDE2KSB8IGhlcmVfdmFsIHwwO1xuICAgIH0gd2hpbGUgKGZpbGwgIT09IDApO1xuXG4gICAgLyogYmFja3dhcmRzIGluY3JlbWVudCB0aGUgbGVuLWJpdCBjb2RlIGh1ZmYgKi9cbiAgICBpbmNyID0gMSA8PCAobGVuIC0gMSk7XG4gICAgd2hpbGUgKGh1ZmYgJiBpbmNyKSB7XG4gICAgICBpbmNyID4+PSAxO1xuICAgIH1cbiAgICBpZiAoaW5jciAhPT0gMCkge1xuICAgICAgaHVmZiAmPSBpbmNyIC0gMTtcbiAgICAgIGh1ZmYgKz0gaW5jcjtcbiAgICB9IGVsc2Uge1xuICAgICAgaHVmZiA9IDA7XG4gICAgfVxuXG4gICAgLyogZ28gdG8gbmV4dCBzeW1ib2wsIHVwZGF0ZSBjb3VudCwgbGVuICovXG4gICAgc3ltKys7XG4gICAgaWYgKC0tY291bnRbbGVuXSA9PT0gMCkge1xuICAgICAgaWYgKGxlbiA9PT0gbWF4KSB7IGJyZWFrOyB9XG4gICAgICBsZW4gPSBsZW5zW2xlbnNfaW5kZXggKyB3b3JrW3N5bV1dO1xuICAgIH1cblxuICAgIC8qIGNyZWF0ZSBuZXcgc3ViLXRhYmxlIGlmIG5lZWRlZCAqL1xuICAgIGlmIChsZW4gPiByb290ICYmIChodWZmICYgbWFzaykgIT09IGxvdykge1xuICAgICAgLyogaWYgZmlyc3QgdGltZSwgdHJhbnNpdGlvbiB0byBzdWItdGFibGVzICovXG4gICAgICBpZiAoZHJvcCA9PT0gMCkge1xuICAgICAgICBkcm9wID0gcm9vdDtcbiAgICAgIH1cblxuICAgICAgLyogaW5jcmVtZW50IHBhc3QgbGFzdCB0YWJsZSAqL1xuICAgICAgbmV4dCArPSBtaW47ICAgICAgICAgICAgLyogaGVyZSBtaW4gaXMgMSA8PCBjdXJyICovXG5cbiAgICAgIC8qIGRldGVybWluZSBsZW5ndGggb2YgbmV4dCB0YWJsZSAqL1xuICAgICAgY3VyciA9IGxlbiAtIGRyb3A7XG4gICAgICBsZWZ0ID0gMSA8PCBjdXJyO1xuICAgICAgd2hpbGUgKGN1cnIgKyBkcm9wIDwgbWF4KSB7XG4gICAgICAgIGxlZnQgLT0gY291bnRbY3VyciArIGRyb3BdO1xuICAgICAgICBpZiAobGVmdCA8PSAwKSB7IGJyZWFrOyB9XG4gICAgICAgIGN1cnIrKztcbiAgICAgICAgbGVmdCA8PD0gMTtcbiAgICAgIH1cblxuICAgICAgLyogY2hlY2sgZm9yIGVub3VnaCBzcGFjZSAqL1xuICAgICAgdXNlZCArPSAxIDw8IGN1cnI7XG4gICAgICBpZiAoKHR5cGUgPT09IExFTlMgJiYgdXNlZCA+IEVOT1VHSF9MRU5TKSB8fFxuICAgICAgICAodHlwZSA9PT0gRElTVFMgJiYgdXNlZCA+IEVOT1VHSF9ESVNUUykpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgICB9XG5cbiAgICAgIC8qIHBvaW50IGVudHJ5IGluIHJvb3QgdGFibGUgdG8gc3ViLXRhYmxlICovXG4gICAgICBsb3cgPSBodWZmICYgbWFzaztcbiAgICAgIC8qdGFibGUub3BbbG93XSA9IGN1cnI7XG4gICAgICB0YWJsZS5iaXRzW2xvd10gPSByb290O1xuICAgICAgdGFibGUudmFsW2xvd10gPSBuZXh0IC0gb3B0cy50YWJsZV9pbmRleDsqL1xuICAgICAgdGFibGVbbG93XSA9IChyb290IDw8IDI0KSB8IChjdXJyIDw8IDE2KSB8IChuZXh0IC0gdGFibGVfaW5kZXgpIHwwO1xuICAgIH1cbiAgfVxuXG4gIC8qIGZpbGwgaW4gcmVtYWluaW5nIHRhYmxlIGVudHJ5IGlmIGNvZGUgaXMgaW5jb21wbGV0ZSAoZ3VhcmFudGVlZCB0byBoYXZlXG4gICBhdCBtb3N0IG9uZSByZW1haW5pbmcgZW50cnksIHNpbmNlIGlmIHRoZSBjb2RlIGlzIGluY29tcGxldGUsIHRoZVxuICAgbWF4aW11bSBjb2RlIGxlbmd0aCB0aGF0IHdhcyBhbGxvd2VkIHRvIGdldCB0aGlzIGZhciBpcyBvbmUgYml0KSAqL1xuICBpZiAoaHVmZiAhPT0gMCkge1xuICAgIC8vdGFibGUub3BbbmV4dCArIGh1ZmZdID0gNjQ7ICAgICAgICAgICAgLyogaW52YWxpZCBjb2RlIG1hcmtlciAqL1xuICAgIC8vdGFibGUuYml0c1tuZXh0ICsgaHVmZl0gPSBsZW4gLSBkcm9wO1xuICAgIC8vdGFibGUudmFsW25leHQgKyBodWZmXSA9IDA7XG4gICAgdGFibGVbbmV4dCArIGh1ZmZdID0gKChsZW4gLSBkcm9wKSA8PCAyNCkgfCAoNjQgPDwgMTYpIHwwO1xuICB9XG5cbiAgLyogc2V0IHJldHVybiBwYXJhbWV0ZXJzICovXG4gIC8vb3B0cy50YWJsZV9pbmRleCArPSB1c2VkO1xuICBvcHRzLmJpdHMgPSByb290O1xuICByZXR1cm4gMDtcbn07XG4iLCJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBaU3RyZWFtKCkge1xuICAvKiBuZXh0IGlucHV0IGJ5dGUgKi9cbiAgdGhpcy5pbnB1dCA9IG51bGw7IC8vIEpTIHNwZWNpZmljLCBiZWNhdXNlIHdlIGhhdmUgbm8gcG9pbnRlcnNcbiAgdGhpcy5uZXh0X2luID0gMDtcbiAgLyogbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSBhdCBpbnB1dCAqL1xuICB0aGlzLmF2YWlsX2luID0gMDtcbiAgLyogdG90YWwgbnVtYmVyIG9mIGlucHV0IGJ5dGVzIHJlYWQgc28gZmFyICovXG4gIHRoaXMudG90YWxfaW4gPSAwO1xuICAvKiBuZXh0IG91dHB1dCBieXRlIHNob3VsZCBiZSBwdXQgdGhlcmUgKi9cbiAgdGhpcy5vdXRwdXQgPSBudWxsOyAvLyBKUyBzcGVjaWZpYywgYmVjYXVzZSB3ZSBoYXZlIG5vIHBvaW50ZXJzXG4gIHRoaXMubmV4dF9vdXQgPSAwO1xuICAvKiByZW1haW5pbmcgZnJlZSBzcGFjZSBhdCBvdXRwdXQgKi9cbiAgdGhpcy5hdmFpbF9vdXQgPSAwO1xuICAvKiB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgb3V0cHV0IHNvIGZhciAqL1xuICB0aGlzLnRvdGFsX291dCA9IDA7XG4gIC8qIGxhc3QgZXJyb3IgbWVzc2FnZSwgTlVMTCBpZiBubyBlcnJvciAqL1xuICB0aGlzLm1zZyA9ICcnLypaX05VTEwqLztcbiAgLyogbm90IHZpc2libGUgYnkgYXBwbGljYXRpb25zICovXG4gIHRoaXMuc3RhdGUgPSBudWxsO1xuICAvKiBiZXN0IGd1ZXNzIGFib3V0IHRoZSBkYXRhIHR5cGU6IGJpbmFyeSBvciB0ZXh0ICovXG4gIHRoaXMuZGF0YV90eXBlID0gMi8qWl9VTktOT1dOKi87XG4gIC8qIGFkbGVyMzIgdmFsdWUgb2YgdGhlIHVuY29tcHJlc3NlZCBkYXRhICovXG4gIHRoaXMuYWRsZXIgPSAwO1xufVxuIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcbiIsIi8qKlxuICogQHRoaXMge1Byb21pc2V9XG4gKi9cbmZ1bmN0aW9uIGZpbmFsbHlDb25zdHJ1Y3RvcihjYWxsYmFjaykge1xuICB2YXIgY29uc3RydWN0b3IgPSB0aGlzLmNvbnN0cnVjdG9yO1xuICByZXR1cm4gdGhpcy50aGVuKFxuICAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gY29uc3RydWN0b3IucmVzb2x2ZShjYWxsYmFjaygpKS50aGVuKGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGZ1bmN0aW9uKHJlYXNvbikge1xuICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlc29sdmUoY2FsbGJhY2soKSkudGhlbihmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGNvbnN0cnVjdG9yLnJlamVjdChyZWFzb24pO1xuICAgICAgfSk7XG4gICAgfVxuICApO1xufVxuXG5leHBvcnQgZGVmYXVsdCBmaW5hbGx5Q29uc3RydWN0b3I7XG4iLCJpbXBvcnQgcHJvbWlzZUZpbmFsbHkgZnJvbSAnLi9maW5hbGx5JztcblxuLy8gU3RvcmUgc2V0VGltZW91dCByZWZlcmVuY2Ugc28gcHJvbWlzZS1wb2x5ZmlsbCB3aWxsIGJlIHVuYWZmZWN0ZWQgYnlcbi8vIG90aGVyIGNvZGUgbW9kaWZ5aW5nIHNldFRpbWVvdXQgKGxpa2Ugc2lub24udXNlRmFrZVRpbWVycygpKVxudmFyIHNldFRpbWVvdXRGdW5jID0gc2V0VGltZW91dDtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbi8vIFBvbHlmaWxsIGZvciBGdW5jdGlvbi5wcm90b3R5cGUuYmluZFxuZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgZm4uYXBwbHkodGhpc0FyZywgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIFByb21pc2UoZm4pIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFByb21pc2UpKVxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb21pc2VzIG11c3QgYmUgY29uc3RydWN0ZWQgdmlhIG5ldycpO1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdub3QgYSBmdW5jdGlvbicpO1xuICAvKiogQHR5cGUgeyFudW1iZXJ9ICovXG4gIHRoaXMuX3N0YXRlID0gMDtcbiAgLyoqIEB0eXBlIHshYm9vbGVhbn0gKi9cbiAgdGhpcy5faGFuZGxlZCA9IGZhbHNlO1xuICAvKiogQHR5cGUge1Byb21pc2V8dW5kZWZpbmVkfSAqL1xuICB0aGlzLl92YWx1ZSA9IHVuZGVmaW5lZDtcbiAgLyoqIEB0eXBlIHshQXJyYXk8IUZ1bmN0aW9uPn0gKi9cbiAgdGhpcy5fZGVmZXJyZWRzID0gW107XG5cbiAgZG9SZXNvbHZlKGZuLCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlKHNlbGYsIGRlZmVycmVkKSB7XG4gIHdoaWxlIChzZWxmLl9zdGF0ZSA9PT0gMykge1xuICAgIHNlbGYgPSBzZWxmLl92YWx1ZTtcbiAgfVxuICBpZiAoc2VsZi5fc3RhdGUgPT09IDApIHtcbiAgICBzZWxmLl9kZWZlcnJlZHMucHVzaChkZWZlcnJlZCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIHNlbGYuX2hhbmRsZWQgPSB0cnVlO1xuICBQcm9taXNlLl9pbW1lZGlhdGVGbihmdW5jdGlvbigpIHtcbiAgICB2YXIgY2IgPSBzZWxmLl9zdGF0ZSA9PT0gMSA/IGRlZmVycmVkLm9uRnVsZmlsbGVkIDogZGVmZXJyZWQub25SZWplY3RlZDtcbiAgICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICAgIChzZWxmLl9zdGF0ZSA9PT0gMSA/IHJlc29sdmUgOiByZWplY3QpKGRlZmVycmVkLnByb21pc2UsIHNlbGYuX3ZhbHVlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHJldDtcbiAgICB0cnkge1xuICAgICAgcmV0ID0gY2Ioc2VsZi5fdmFsdWUpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHJlamVjdChkZWZlcnJlZC5wcm9taXNlLCBlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzb2x2ZShkZWZlcnJlZC5wcm9taXNlLCByZXQpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZShzZWxmLCBuZXdWYWx1ZSkge1xuICB0cnkge1xuICAgIC8vIFByb21pc2UgUmVzb2x1dGlvbiBQcm9jZWR1cmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9wcm9taXNlcy1hcGx1cy9wcm9taXNlcy1zcGVjI3RoZS1wcm9taXNlLXJlc29sdXRpb24tcHJvY2VkdXJlXG4gICAgaWYgKG5ld1ZhbHVlID09PSBzZWxmKVxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQSBwcm9taXNlIGNhbm5vdCBiZSByZXNvbHZlZCB3aXRoIGl0c2VsZi4nKTtcbiAgICBpZiAoXG4gICAgICBuZXdWYWx1ZSAmJlxuICAgICAgKHR5cGVvZiBuZXdWYWx1ZSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIG5ld1ZhbHVlID09PSAnZnVuY3Rpb24nKVxuICAgICkge1xuICAgICAgdmFyIHRoZW4gPSBuZXdWYWx1ZS50aGVuO1xuICAgICAgaWYgKG5ld1ZhbHVlIGluc3RhbmNlb2YgUHJvbWlzZSkge1xuICAgICAgICBzZWxmLl9zdGF0ZSA9IDM7XG4gICAgICAgIHNlbGYuX3ZhbHVlID0gbmV3VmFsdWU7XG4gICAgICAgIGZpbmFsZShzZWxmKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkb1Jlc29sdmUoYmluZCh0aGVuLCBuZXdWYWx1ZSksIHNlbGYpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIHNlbGYuX3N0YXRlID0gMTtcbiAgICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICAgIGZpbmFsZShzZWxmKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJlamVjdChzZWxmLCBlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZWplY3Qoc2VsZiwgbmV3VmFsdWUpIHtcbiAgc2VsZi5fc3RhdGUgPSAyO1xuICBzZWxmLl92YWx1ZSA9IG5ld1ZhbHVlO1xuICBmaW5hbGUoc2VsZik7XG59XG5cbmZ1bmN0aW9uIGZpbmFsZShzZWxmKSB7XG4gIGlmIChzZWxmLl9zdGF0ZSA9PT0gMiAmJiBzZWxmLl9kZWZlcnJlZHMubGVuZ3RoID09PSAwKSB7XG4gICAgUHJvbWlzZS5faW1tZWRpYXRlRm4oZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXNlbGYuX2hhbmRsZWQpIHtcbiAgICAgICAgUHJvbWlzZS5fdW5oYW5kbGVkUmVqZWN0aW9uRm4oc2VsZi5fdmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHNlbGYuX2RlZmVycmVkcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGhhbmRsZShzZWxmLCBzZWxmLl9kZWZlcnJlZHNbaV0pO1xuICB9XG4gIHNlbGYuX2RlZmVycmVkcyA9IG51bGw7XG59XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cbmZ1bmN0aW9uIEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb21pc2UpIHtcbiAgdGhpcy5vbkZ1bGZpbGxlZCA9IHR5cGVvZiBvbkZ1bGZpbGxlZCA9PT0gJ2Z1bmN0aW9uJyA/IG9uRnVsZmlsbGVkIDogbnVsbDtcbiAgdGhpcy5vblJlamVjdGVkID0gdHlwZW9mIG9uUmVqZWN0ZWQgPT09ICdmdW5jdGlvbicgPyBvblJlamVjdGVkIDogbnVsbDtcbiAgdGhpcy5wcm9taXNlID0gcHJvbWlzZTtcbn1cblxuLyoqXG4gKiBUYWtlIGEgcG90ZW50aWFsbHkgbWlzYmVoYXZpbmcgcmVzb2x2ZXIgZnVuY3Rpb24gYW5kIG1ha2Ugc3VyZVxuICogb25GdWxmaWxsZWQgYW5kIG9uUmVqZWN0ZWQgYXJlIG9ubHkgY2FsbGVkIG9uY2UuXG4gKlxuICogTWFrZXMgbm8gZ3VhcmFudGVlcyBhYm91dCBhc3luY2hyb255LlxuICovXG5mdW5jdGlvbiBkb1Jlc29sdmUoZm4sIHNlbGYpIHtcbiAgdmFyIGRvbmUgPSBmYWxzZTtcbiAgdHJ5IHtcbiAgICBmbihcbiAgICAgIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIGlmIChkb25lKSByZXR1cm47XG4gICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICByZXNvbHZlKHNlbGYsIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBmdW5jdGlvbihyZWFzb24pIHtcbiAgICAgICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgIHJlamVjdChzZWxmLCByZWFzb24pO1xuICAgICAgfVxuICAgICk7XG4gIH0gY2F0Y2ggKGV4KSB7XG4gICAgaWYgKGRvbmUpIHJldHVybjtcbiAgICBkb25lID0gdHJ1ZTtcbiAgICByZWplY3Qoc2VsZiwgZXgpO1xuICB9XG59XG5cblByb21pc2UucHJvdG90eXBlWydjYXRjaCddID0gZnVuY3Rpb24ob25SZWplY3RlZCkge1xuICByZXR1cm4gdGhpcy50aGVuKG51bGwsIG9uUmVqZWN0ZWQpO1xufTtcblxuUHJvbWlzZS5wcm90b3R5cGUudGhlbiA9IGZ1bmN0aW9uKG9uRnVsZmlsbGVkLCBvblJlamVjdGVkKSB7XG4gIC8vIEB0cy1pZ25vcmVcbiAgdmFyIHByb20gPSBuZXcgdGhpcy5jb25zdHJ1Y3Rvcihub29wKTtcblxuICBoYW5kbGUodGhpcywgbmV3IEhhbmRsZXIob25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIHByb20pKTtcbiAgcmV0dXJuIHByb207XG59O1xuXG5Qcm9taXNlLnByb3RvdHlwZVsnZmluYWxseSddID0gcHJvbWlzZUZpbmFsbHk7XG5cblByb21pc2UuYWxsID0gZnVuY3Rpb24oYXJyKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICBpZiAoIWFyciB8fCB0eXBlb2YgYXJyLmxlbmd0aCA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdQcm9taXNlLmFsbCBhY2NlcHRzIGFuIGFycmF5Jyk7XG4gICAgdmFyIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnIpO1xuICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHJlc29sdmUoW10pO1xuICAgIHZhciByZW1haW5pbmcgPSBhcmdzLmxlbmd0aDtcblxuICAgIGZ1bmN0aW9uIHJlcyhpLCB2YWwpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmICh2YWwgJiYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnIHx8IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpKSB7XG4gICAgICAgICAgdmFyIHRoZW4gPSB2YWwudGhlbjtcbiAgICAgICAgICBpZiAodHlwZW9mIHRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHRoZW4uY2FsbChcbiAgICAgICAgICAgICAgdmFsLFxuICAgICAgICAgICAgICBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgICAgICByZXMoaSwgdmFsKTtcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgcmVqZWN0XG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhcmdzW2ldID0gdmFsO1xuICAgICAgICBpZiAoLS1yZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICByZXNvbHZlKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICByZWplY3QoZXgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgcmVzKGksIGFyZ3NbaV0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG5Qcm9taXNlLnJlc29sdmUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gUHJvbWlzZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZSh2YWx1ZSk7XG4gIH0pO1xufTtcblxuUHJvbWlzZS5yZWplY3QgPSBmdW5jdGlvbih2YWx1ZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgcmVqZWN0KHZhbHVlKTtcbiAgfSk7XG59O1xuXG5Qcm9taXNlLnJhY2UgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB2YWx1ZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIHZhbHVlc1tpXS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfVxuICB9KTtcbn07XG5cbi8vIFVzZSBwb2x5ZmlsbCBmb3Igc2V0SW1tZWRpYXRlIGZvciBwZXJmb3JtYW5jZSBnYWluc1xuUHJvbWlzZS5faW1tZWRpYXRlRm4gPVxuICAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIGZ1bmN0aW9uKGZuKSB7XG4gICAgICBzZXRJbW1lZGlhdGUoZm4pO1xuICAgIH0pIHx8XG4gIGZ1bmN0aW9uKGZuKSB7XG4gICAgc2V0VGltZW91dEZ1bmMoZm4sIDApO1xuICB9O1xuXG5Qcm9taXNlLl91bmhhbmRsZWRSZWplY3Rpb25GbiA9IGZ1bmN0aW9uIF91bmhhbmRsZWRSZWplY3Rpb25GbihlcnIpIHtcbiAgaWYgKHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJiBjb25zb2xlKSB7XG4gICAgY29uc29sZS53YXJuKCdQb3NzaWJsZSBVbmhhbmRsZWQgUHJvbWlzZSBSZWplY3Rpb246JywgZXJyKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gIH1cbn07XG5cbmV4cG9ydCBkZWZhdWx0IFByb21pc2U7XG4iLCIoZnVuY3Rpb24gKGdsb2JhbCwgdW5kZWZpbmVkKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICBpZiAoZ2xvYmFsLnNldEltbWVkaWF0ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIG5leHRIYW5kbGUgPSAxOyAvLyBTcGVjIHNheXMgZ3JlYXRlciB0aGFuIHplcm9cbiAgICB2YXIgdGFza3NCeUhhbmRsZSA9IHt9O1xuICAgIHZhciBjdXJyZW50bHlSdW5uaW5nQVRhc2sgPSBmYWxzZTtcbiAgICB2YXIgZG9jID0gZ2xvYmFsLmRvY3VtZW50O1xuICAgIHZhciByZWdpc3RlckltbWVkaWF0ZTtcblxuICAgIGZ1bmN0aW9uIHNldEltbWVkaWF0ZShjYWxsYmFjaykge1xuICAgICAgLy8gQ2FsbGJhY2sgY2FuIGVpdGhlciBiZSBhIGZ1bmN0aW9uIG9yIGEgc3RyaW5nXG4gICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBuZXcgRnVuY3Rpb24oXCJcIiArIGNhbGxiYWNrKTtcbiAgICAgIH1cbiAgICAgIC8vIENvcHkgZnVuY3Rpb24gYXJndW1lbnRzXG4gICAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2kgKyAxXTtcbiAgICAgIH1cbiAgICAgIC8vIFN0b3JlIGFuZCByZWdpc3RlciB0aGUgdGFza1xuICAgICAgdmFyIHRhc2sgPSB7IGNhbGxiYWNrOiBjYWxsYmFjaywgYXJnczogYXJncyB9O1xuICAgICAgdGFza3NCeUhhbmRsZVtuZXh0SGFuZGxlXSA9IHRhc2s7XG4gICAgICByZWdpc3RlckltbWVkaWF0ZShuZXh0SGFuZGxlKTtcbiAgICAgIHJldHVybiBuZXh0SGFuZGxlKys7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYXJJbW1lZGlhdGUoaGFuZGxlKSB7XG4gICAgICAgIGRlbGV0ZSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuKHRhc2spIHtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gdGFzay5jYWxsYmFjaztcbiAgICAgICAgdmFyIGFyZ3MgPSB0YXNrLmFyZ3M7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICBjYWxsYmFjayhhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodW5kZWZpbmVkLCBhcmdzKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcnVuSWZQcmVzZW50KGhhbmRsZSkge1xuICAgICAgICAvLyBGcm9tIHRoZSBzcGVjOiBcIldhaXQgdW50aWwgYW55IGludm9jYXRpb25zIG9mIHRoaXMgYWxnb3JpdGhtIHN0YXJ0ZWQgYmVmb3JlIHRoaXMgb25lIGhhdmUgY29tcGxldGVkLlwiXG4gICAgICAgIC8vIFNvIGlmIHdlJ3JlIGN1cnJlbnRseSBydW5uaW5nIGEgdGFzaywgd2UnbGwgbmVlZCB0byBkZWxheSB0aGlzIGludm9jYXRpb24uXG4gICAgICAgIGlmIChjdXJyZW50bHlSdW5uaW5nQVRhc2spIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGJ5IGRvaW5nIGEgc2V0VGltZW91dC4gc2V0SW1tZWRpYXRlIHdhcyB0cmllZCBpbnN0ZWFkLCBidXQgaW4gRmlyZWZveCA3IGl0IGdlbmVyYXRlZCBhXG4gICAgICAgICAgICAvLyBcInRvbyBtdWNoIHJlY3Vyc2lvblwiIGVycm9yLlxuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YXIgdGFzayA9IHRhc2tzQnlIYW5kbGVbaGFuZGxlXTtcbiAgICAgICAgICAgIGlmICh0YXNrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBydW4odGFzayk7XG4gICAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJJbW1lZGlhdGUoaGFuZGxlKTtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE5leHRUaWNrSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHsgcnVuSWZQcmVzZW50KGhhbmRsZSk7IH0pO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNhblVzZVBvc3RNZXNzYWdlKCkge1xuICAgICAgICAvLyBUaGUgdGVzdCBhZ2FpbnN0IGBpbXBvcnRTY3JpcHRzYCBwcmV2ZW50cyB0aGlzIGltcGxlbWVudGF0aW9uIGZyb20gYmVpbmcgaW5zdGFsbGVkIGluc2lkZSBhIHdlYiB3b3JrZXIsXG4gICAgICAgIC8vIHdoZXJlIGBnbG9iYWwucG9zdE1lc3NhZ2VgIG1lYW5zIHNvbWV0aGluZyBjb21wbGV0ZWx5IGRpZmZlcmVudCBhbmQgY2FuJ3QgYmUgdXNlZCBmb3IgdGhpcyBwdXJwb3NlLlxuICAgICAgICBpZiAoZ2xvYmFsLnBvc3RNZXNzYWdlICYmICFnbG9iYWwuaW1wb3J0U2NyaXB0cykge1xuICAgICAgICAgICAgdmFyIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG9sZE9uTWVzc2FnZSA9IGdsb2JhbC5vbm1lc3NhZ2U7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyA9IGZhbHNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShcIlwiLCBcIipcIik7XG4gICAgICAgICAgICBnbG9iYWwub25tZXNzYWdlID0gb2xkT25NZXNzYWdlO1xuICAgICAgICAgICAgcmV0dXJuIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXM7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgLy8gSW5zdGFsbHMgYW4gZXZlbnQgaGFuZGxlciBvbiBgZ2xvYmFsYCBmb3IgdGhlIGBtZXNzYWdlYCBldmVudDogc2VlXG4gICAgICAgIC8vICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vRE9NL3dpbmRvdy5wb3N0TWVzc2FnZVxuICAgICAgICAvLyAqIGh0dHA6Ly93d3cud2hhdHdnLm9yZy9zcGVjcy93ZWItYXBwcy9jdXJyZW50LXdvcmsvbXVsdGlwYWdlL2NvbW1zLmh0bWwjY3Jvc3NEb2N1bWVudE1lc3NhZ2VzXG5cbiAgICAgICAgdmFyIG1lc3NhZ2VQcmVmaXggPSBcInNldEltbWVkaWF0ZSRcIiArIE1hdGgucmFuZG9tKCkgKyBcIiRcIjtcbiAgICAgICAgdmFyIG9uR2xvYmFsTWVzc2FnZSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBnbG9iYWwgJiZcbiAgICAgICAgICAgICAgICB0eXBlb2YgZXZlbnQuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuICAgICAgICAgICAgICAgIGV2ZW50LmRhdGEuaW5kZXhPZihtZXNzYWdlUHJlZml4KSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudCgrZXZlbnQuZGF0YS5zbGljZShtZXNzYWdlUHJlZml4Lmxlbmd0aCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGlmIChnbG9iYWwuYWRkRXZlbnRMaXN0ZW5lcikge1xuICAgICAgICAgICAgZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSwgZmFsc2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ2xvYmFsLmF0dGFjaEV2ZW50KFwib25tZXNzYWdlXCIsIG9uR2xvYmFsTWVzc2FnZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgZ2xvYmFsLnBvc3RNZXNzYWdlKG1lc3NhZ2VQcmVmaXggKyBoYW5kbGUsIFwiKlwiKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsTWVzc2FnZUNoYW5uZWxJbXBsZW1lbnRhdGlvbigpIHtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSBuZXcgTWVzc2FnZUNoYW5uZWwoKTtcbiAgICAgICAgY2hhbm5lbC5wb3J0MS5vbm1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgdmFyIGhhbmRsZSA9IGV2ZW50LmRhdGE7XG4gICAgICAgICAgICBydW5JZlByZXNlbnQoaGFuZGxlKTtcbiAgICAgICAgfTtcblxuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wb3J0Mi5wb3N0TWVzc2FnZShoYW5kbGUpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIDxzY3JpcHQ+IGVsZW1lbnQ7IGl0cyByZWFkeXN0YXRlY2hhbmdlIGV2ZW50IHdpbGwgYmUgZmlyZWQgYXN5bmNocm9ub3VzbHkgb25jZSBpdCBpcyBpbnNlcnRlZFxuICAgICAgICAgICAgLy8gaW50byB0aGUgZG9jdW1lbnQuIERvIHNvLCB0aHVzIHF1ZXVpbmcgdXAgdGhlIHRhc2suIFJlbWVtYmVyIHRvIGNsZWFuIHVwIG9uY2UgaXQncyBiZWVuIGNhbGxlZC5cbiAgICAgICAgICAgIHZhciBzY3JpcHQgPSBkb2MuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG4gICAgICAgICAgICAgICAgaHRtbC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgICAgIHNjcmlwdCA9IG51bGw7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaHRtbC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuICAgICAgICB9O1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxTZXRUaW1lb3V0SW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KHJ1bklmUHJlc2VudCwgMCwgaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICAvLyBJZiBzdXBwb3J0ZWQsIHdlIHNob3VsZCBhdHRhY2ggdG8gdGhlIHByb3RvdHlwZSBvZiBnbG9iYWwsIHNpbmNlIHRoYXQgaXMgd2hlcmUgc2V0VGltZW91dCBldCBhbC4gbGl2ZS5cbiAgICB2YXIgYXR0YWNoVG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGdsb2JhbCk7XG4gICAgYXR0YWNoVG8gPSBhdHRhY2hUbyAmJiBhdHRhY2hUby5zZXRUaW1lb3V0ID8gYXR0YWNoVG8gOiBnbG9iYWw7XG5cbiAgICAvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IGUuZy4gYnJvd3NlcmlmeSBlbnZpcm9ubWVudHMuXG4gICAgaWYgKHt9LnRvU3RyaW5nLmNhbGwoZ2xvYmFsLnByb2Nlc3MpID09PSBcIltvYmplY3QgcHJvY2Vzc11cIikge1xuICAgICAgICAvLyBGb3IgTm9kZS5qcyBiZWZvcmUgMC45XG4gICAgICAgIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGNhblVzZVBvc3RNZXNzYWdlKCkpIHtcbiAgICAgICAgLy8gRm9yIG5vbi1JRTEwIG1vZGVybiBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsUG9zdE1lc3NhZ2VJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChnbG9iYWwuTWVzc2FnZUNoYW5uZWwpIHtcbiAgICAgICAgLy8gRm9yIHdlYiB3b3JrZXJzLCB3aGVyZSBzdXBwb3J0ZWRcbiAgICAgICAgaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZG9jICYmIFwib25yZWFkeXN0YXRlY2hhbmdlXCIgaW4gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIikpIHtcbiAgICAgICAgLy8gRm9yIElFIDbigJM4XG4gICAgICAgIGluc3RhbGxSZWFkeVN0YXRlQ2hhbmdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEZvciBvbGRlciBicm93c2Vyc1xuICAgICAgICBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCk7XG4gICAgfVxuXG4gICAgYXR0YWNoVG8uc2V0SW1tZWRpYXRlID0gc2V0SW1tZWRpYXRlO1xuICAgIGF0dGFjaFRvLmNsZWFySW1tZWRpYXRlID0gY2xlYXJJbW1lZGlhdGU7XG59KHR5cGVvZiBzZWxmID09PSBcInVuZGVmaW5lZFwiID8gdHlwZW9mIGdsb2JhbCA9PT0gXCJ1bmRlZmluZWRcIiA/IHRoaXMgOiBnbG9iYWwgOiBzZWxmKSk7XG4iLCJ2YXIgc2NvcGUgPSAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwpIHx8XG4gICAgICAgICAgICAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZikgfHxcbiAgICAgICAgICAgIHdpbmRvdztcbnZhciBhcHBseSA9IEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseTtcblxuLy8gRE9NIEFQSXMsIGZvciBjb21wbGV0ZW5lc3NcblxuZXhwb3J0cy5zZXRUaW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldFRpbWVvdXQsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhclRpbWVvdXQpO1xufTtcbmV4cG9ydHMuc2V0SW50ZXJ2YWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIG5ldyBUaW1lb3V0KGFwcGx5LmNhbGwoc2V0SW50ZXJ2YWwsIHNjb3BlLCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHNjb3BlLCB0aGlzLl9pZCk7XG59O1xuXG4vLyBEb2VzIG5vdCBzdGFydCB0aGUgdGltZSwganVzdCBzZXRzIHVwIHRoZSBtZW1iZXJzIG5lZWRlZC5cbmV4cG9ydHMuZW5yb2xsID0gZnVuY3Rpb24oaXRlbSwgbXNlY3MpIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IG1zZWNzO1xufTtcblxuZXhwb3J0cy51bmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuICBpdGVtLl9pZGxlVGltZW91dCA9IC0xO1xufTtcblxuZXhwb3J0cy5fdW5yZWZBY3RpdmUgPSBleHBvcnRzLmFjdGl2ZSA9IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgY2xlYXJUaW1lb3V0KGl0ZW0uX2lkbGVUaW1lb3V0SWQpO1xuXG4gIHZhciBtc2VjcyA9IGl0ZW0uX2lkbGVUaW1lb3V0O1xuICBpZiAobXNlY3MgPj0gMCkge1xuICAgIGl0ZW0uX2lkbGVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uIG9uVGltZW91dCgpIHtcbiAgICAgIGlmIChpdGVtLl9vblRpbWVvdXQpXG4gICAgICAgIGl0ZW0uX29uVGltZW91dCgpO1xuICAgIH0sIG1zZWNzKTtcbiAgfVxufTtcblxuLy8gc2V0aW1tZWRpYXRlIGF0dGFjaGVzIGl0c2VsZiB0byB0aGUgZ2xvYmFsIG9iamVjdFxucmVxdWlyZShcInNldGltbWVkaWF0ZVwiKTtcbi8vIE9uIHNvbWUgZXhvdGljIGVudmlyb25tZW50cywgaXQncyBub3QgY2xlYXIgd2hpY2ggb2JqZWN0IGBzZXRpbW1lZGlhdGVgIHdhc1xuLy8gYWJsZSB0byBpbnN0YWxsIG9udG8uICBTZWFyY2ggZWFjaCBwb3NzaWJpbGl0eSBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGVcbi8vIGBzZXRpbW1lZGlhdGVgIGxpYnJhcnkuXG5leHBvcnRzLnNldEltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsLnNldEltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5zZXRJbW1lZGlhdGUpO1xuZXhwb3J0cy5jbGVhckltbWVkaWF0ZSA9ICh0eXBlb2Ygc2VsZiAhPT0gXCJ1bmRlZmluZWRcIiAmJiBzZWxmLmNsZWFySW1tZWRpYXRlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodGhpcyAmJiB0aGlzLmNsZWFySW1tZWRpYXRlKTtcbiIsInNlbGYuZmV0Y2h8fChzZWxmLmZldGNoPWZ1bmN0aW9uKGUsbil7cmV0dXJuIG49bnx8e30sbmV3IFByb21pc2UoZnVuY3Rpb24odCxyKXt2YXIgcz1uZXcgWE1MSHR0cFJlcXVlc3Q7Zm9yKHZhciBvIGluIHMub3BlbihuLm1ldGhvZHx8XCJnZXRcIixlLCEwKSxuLmhlYWRlcnMpcy5zZXRSZXF1ZXN0SGVhZGVyKG8sbi5oZWFkZXJzW29dKTtmdW5jdGlvbiB1KCl7dmFyIGUsbj1bXSx0PVtdLHI9e307cmV0dXJuIHMuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkucmVwbGFjZSgvXiguKj8pOlteXFxTXFxuXSooW1xcc1xcU10qPykkL2dtLGZ1bmN0aW9uKHMsbyx1KXtuLnB1c2gobz1vLnRvTG93ZXJDYXNlKCkpLHQucHVzaChbbyx1XSkscltvXT0oZT1yW29dKT9lK1wiLFwiK3U6dX0pLHtvazoyPT0ocy5zdGF0dXMvMTAwfDApLHN0YXR1czpzLnN0YXR1cyxzdGF0dXNUZXh0OnMuc3RhdHVzVGV4dCx1cmw6cy5yZXNwb25zZVVSTCxjbG9uZTp1LHRleHQ6ZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHMucmVzcG9uc2VUZXh0KX0sanNvbjpmdW5jdGlvbigpe3JldHVybiBQcm9taXNlLnJlc29sdmUocy5yZXNwb25zZVRleHQpLnRoZW4oSlNPTi5wYXJzZSl9LGJsb2I6ZnVuY3Rpb24oKXtyZXR1cm4gUHJvbWlzZS5yZXNvbHZlKG5ldyBCbG9iKFtzLnJlc3BvbnNlXSkpfSxoZWFkZXJzOntrZXlzOmZ1bmN0aW9uKCl7cmV0dXJuIG59LGVudHJpZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdH0sZ2V0OmZ1bmN0aW9uKGUpe3JldHVybiByW2UudG9Mb3dlckNhc2UoKV19LGhhczpmdW5jdGlvbihlKXtyZXR1cm4gZS50b0xvd2VyQ2FzZSgpaW4gcn19fX1zLndpdGhDcmVkZW50aWFscz1cImluY2x1ZGVcIj09bi5jcmVkZW50aWFscyxzLm9ubG9hZD1mdW5jdGlvbigpe3QodSgpKX0scy5vbmVycm9yPXIscy5zZW5kKG4uYm9keXx8bnVsbCl9KX0pO1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwiLy8gUGxheSBBdWRpbyB3aXRoIE1lZGlhU291cmNlIGV4dGVuc2lvbnMgcmVjZWl2ZWQgb3ZlciBhIHdlYnNvY2tldFxudmFyIE9QVVNfTUlNRV9UWVBFID0gJ2F1ZGlvL3dlYm07IGNvZGVjcz1cIm9wdXNcIic7XG52YXIgTVAzX01JTUVfVFlQRSA9ICdhdWRpby9tcGVnJztcblxuLy8gVGhpcyByZXByZXNlbnRzIHRoZSBvcmRlciBpbiB3aGljaCB0aGUgdHlwZXMgYXJlIHRyaWVkXG5jb25zdCBBVURJT19UWVBFUyA9IFtcbiAge1wiaWRcIjogXCJtcDNcIixcbiAgICBcInR5cGVcIjogTVAzX01JTUVfVFlQRX0sXG5cbiAge1wiaWRcIjogXCJvcHVzXCIsXG4gICAgXCJ0eXBlXCI6IE9QVVNfTUlNRV9UWVBFfSxcbl07XG5cbmV4cG9ydCB7Z2V0QmVzdEF1ZGlvVHlwZSwgTVNBdWRpb307XG5cblxuZnVuY3Rpb24gZ2V0QmVzdEF1ZGlvVHlwZSgpIHtcbiAgaWYgKHdpbmRvdy5NZWRpYVNvdXJjZSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQVVESU9fVFlQRVMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh3aW5kb3cuTWVkaWFTb3VyY2UuaXNUeXBlU3VwcG9ydGVkKEFVRElPX1RZUEVTW2ldLnR5cGUpKSB7XG4gICAgICAgIHJldHVybiBBVURJT19UWVBFU1tpXS5pZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJkbyBub3Qgc3VwcG9ydCBcIiArIEFVRElPX1RZUEVTW2ldLnR5cGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTVNBdWRpbyB7XG4gIGNvbnN0cnVjdG9yIChmb3JtYXQsIG1lZGlhX2NvbnRyb2xsZXIsIGxvY2tfYXVkaW8pIHtcbiAgICB0aGlzLmZvcm1hdCA9IGZvcm1hdDtcbiAgICB0aGlzLm1lZGlhX2NvbnRyb2xsZXIgPSBtZWRpYV9jb250cm9sbGVyO1xuICAgIHRoaXMubG9ja19hdWRpbyA9IGxvY2tfYXVkaW87XG5cbiAgICB0aGlzLk1BWF9CVUZGRVJTID0gMjUwO1xuICAgIHRoaXMuTUlOX1NUQVJUX0JVRkZFUlMgPSAxMDtcblxuICAgIHRoaXMubWluTGF0ZW5jeSA9IDAuMjsgLy8gMjAwbXNcbiAgICB0aGlzLm1heExhdGVuY3kgPSAwLjU7ICAvLyA1MDBtc1xuXG4gICAgdGhpcy5sYXRlbmN5Q2hlY2sgPSBudWxsO1xuXG4gICAgdGhpcy53cyA9IG51bGw7XG4gICAgdGhpcy53c191cmwgPSBudWxsO1xuXG4gICAgdGhpcy5lcnJDb3VudCA9IDA7XG5cbiAgICB0aGlzLmFsbG93QXBwZW5kID0gZmFsc2U7XG5cbiAgICB0aGlzLmF1ZGlvID0gbnVsbDtcbiAgICB0aGlzLmF1ZGlvX21pbWUgPSBudWxsO1xuICAgIHRoaXMubWVkaWFzb3VyY2UgPSBudWxsO1xuICAgIHRoaXMuYnVmZmVyID0gbnVsbDtcblxuICAgIHRoaXMuYnVmZlEgPSBbXTtcbiAgICB0aGlzLmJ1ZmZDb3VudCA9IDA7XG4gICAgdGhpcy5idWZmU2l6ZSA9IDA7XG5cbiAgfVxuXG4gIGdldF9hdWRpb19taW1lKCkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgQVVESU9fVFlQRVMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChBVURJT19UWVBFU1tpXS5pZCA9PSB0aGlzLmZvcm1hdCkge1xuICAgICAgICByZXR1cm4gQVVESU9fVFlQRVNbaV0udHlwZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zb2xlLmxvZyhcIkF1ZGlvIG5vdCBpbml0ZWQsIHVua25vd24gYXVkaW8gdHlwZTogXCIgKyB0aGlzLmZvcm1hdCk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB1bmxvY2tBdWRpbygpIHtcbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJVbmxvY2sgTVNBdWRpb1wiKTtcbiAgICB9XG4gICAgdGhpcy5sb2NrX2F1ZGlvID0gZmFsc2U7XG4gICAgaWYgKHRoaXMuYXVkaW8gIT0gbnVsbCkge1xuICAgICAgdGhpcy5hdWRpby5tdXRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5hdWRpby5wbGF5KCkuY2F0Y2goZnVuY3Rpb24oKSB7IH0pO1xuICAgIH1cbiAgfVxuXG4gIHN0YXJ0KCkge1xuICAgIGNvbnNvbGUubG9nKCdzdGFydCBNUyBBdWRpbyB3aXRoIGZvcm1hdCAnICsgdGhpcy5mb3JtYXQpO1xuICAgIHRoaXMuYXVkaW9fbWltZSA9IHRoaXMuZ2V0X2F1ZGlvX21pbWUoKTtcblxuICAgIGlmICghdGhpcy5hdWRpb19taW1lKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImF1ZGlvIE1pbWUgbm90IGZvdW5kXCIpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMubGF0ZW5jeUNoZWNrID0gc2V0SW50ZXJ2YWwodGhpcy5sYXRlbmN5Q29udHJvbGxlci5iaW5kKHRoaXMpLCAyNTApO1xuXG4gICAgdGhpcy5tZWRpYXNvdXJjZSA9IG5ldyBNZWRpYVNvdXJjZSgpO1xuICAgIHRoaXMubWVkaWFzb3VyY2UuYWRkRXZlbnRMaXN0ZW5lcihcInNvdXJjZW9wZW5cIiwgdGhpcy5zb3VyY2VPcGVuLmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy5tZWRpYXNvdXJjZS5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICB0aGlzLmF1ZGlvRXJyb3IoXCJNZWRpYVNvdXJjZSBFcnJvclwiLCBldmVudCk7XG4gICAgfSkuYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLmF1ZGlvID0gbmV3IEF1ZGlvKCk7XG4gICAgdGhpcy5hdWRpby5zcmMgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKHRoaXMubWVkaWFzb3VyY2UpO1xuICAgIHRoaXMuYXVkaW8uYXV0b3BsYXkgPSB0cnVlO1xuICAgIHRoaXMuYXVkaW8ubXV0ZWQgPSB0aGlzLmxvY2tfYXVkaW87XG4gICAgdGhpcy5hdWRpby5sb2FkKCk7XG4gICAgdGhpcy5hdWRpby5wbGF5KCkuY2F0Y2goZnVuY3Rpb24oZSkgeyBjb25zb2xlLmxvZyhlKTsgfSk7XG5cbiAgICBsZXQgbXNnID0ge1wibXNfYXVkaW9cIjogZ2V0QmVzdEF1ZGlvVHlwZSgpfTtcbiAgICB0aGlzLm1lZGlhX2NvbnRyb2xsZXIuc2VuZChtc2cpO1xuICAgIHRoaXMubWVkaWFfY29udHJvbGxlci53c19jb25uLmJpbmFyeVR5cGUgPSAnYXJyYXlidWZmZXInO1xuXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBzb3VyY2VPcGVuKCkge1xuICAgIGlmICh0aGlzLm1lZGlhc291cmNlLnNvdXJjZUJ1ZmZlcnMubGVuZ3RoKSB7XG4gICAgICBjb25zb2xlLmxvZyhcInNvdXJjZSBhbHJlYWR5IG9wZW5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIGJ1ZmZlciA9IG51bGw7XG5cbiAgICB0cnkge1xuICAgICAgYnVmZmVyID0gdGhpcy5tZWRpYXNvdXJjZS5hZGRTb3VyY2VCdWZmZXIodGhpcy5hdWRpb19taW1lKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIk9wZW5pbmcgU291cmNlIEVycm9yOiBcIiArIGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGJ1ZmZlci5tb2RlID0gXCJzZXF1ZW5jZVwiO1xuICAgIC8vYnVmZmVyLnRpbWVzdGFtcE9mZnNldCA9IDA7XG5cbiAgICBidWZmZXIuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIChmdW5jdGlvbihldmVudCkge1xuICAgICAgdGhpcy5hdWRpb0Vycm9yKFwiYnVmZmVyIGVycm9yOiBcIiArICh0aGlzLmJ1ZmZDb3VudCksIGV2ZW50KTtcbiAgICB9KS5iaW5kKHRoaXMpKTtcblxuICAgIGJ1ZmZlci5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZW5kXCIsIHRoaXMub25VcGRhdGVFbmQuYmluZCh0aGlzKSk7XG5cbiAgICB0aGlzLmJ1ZmZlciA9IGJ1ZmZlcjtcblxuICAgIHRoaXMuYWxsb3dBcHBlbmQgPSB0cnVlO1xuXG4gIH07XG5cbiAgY2xvc2UoKSB7XG4gICAgY29uc29sZS5sb2coXCJDbG9zaW5nIEF1ZGlvXCIpO1xuICAgIHRyeSB7XG4gICAgICBpZiAodGhpcy5sYXRlbmN5Q2hlY2spIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmxhdGVuY3lDaGVjayk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm1lZGlhc291cmNlKSB7XG4gICAgICAgIHRoaXMubWVkaWFzb3VyY2UucmVtb3ZlU291cmNlQnVmZmVyKHRoaXMuYnVmZmVyKTtcbiAgICAgICAgaWYgKHRoaXMubWVkaWFzb3VyY2UucmVhZHlTdGF0ZSA9PSBcIm9wZW5cIikge1xuICAgICAgICAgIHRoaXMubWVkaWFzb3VyY2UuZW5kT2ZTdHJlYW0oKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5idWZmZXIgPSBudWxsO1xuXG4gICAgfSBjYXRjaChlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkVycm9yIENsb3NpbmcgbWVkaWFzb3VyY2U6IFwiICsgZSk7XG4gICAgfVxuICAgIHRoaXMubWVkaWFzb3VyY2UgPSBudWxsO1xuXG4gICAgdHJ5IHtcbiAgICAgIGlmICh0aGlzLmF1ZGlvKSB7XG4gICAgICAgIHRoaXMuYXVkaW8ucGF1c2UoKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYXVkaW8gPSBudWxsO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiRXJyb3IgQ2xvc2luZyBhdWRpbyA6IFwiICsgZSk7XG4gICAgfVxuICB9XG5cbiAgbWVyZ2VCdWZmZXJzKCkge1xuICAgIHZhciBtZXJnZWQ7XG5cbiAgICBpZiAodGhpcy5idWZmUS5sZW5ndGggPT0gMSkge1xuICAgICAgbWVyZ2VkID0gdGhpcy5idWZmUVswXTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVyZ2VkID0gbmV3IFVpbnQ4QXJyYXkodGhpcy5idWZmU2l6ZSk7XG5cbiAgICAgIHZhciBsZW5ndGggPSB0aGlzLmJ1ZmZRLmxlbmd0aDtcbiAgICAgIHZhciBvZmZzZXQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBjdXJyID0gdGhpcy5idWZmUVtpXTtcbiAgICAgICAgaWYgKGN1cnIubGVuZ3RoIDw9IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBtZXJnZWQuc2V0KGN1cnIsIG9mZnNldCk7XG4gICAgICAgIG9mZnNldCArPSBjdXJyLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmJ1ZmZRID0gW107XG4gICAgdGhpcy5idWZmQ291bnQrKztcbiAgICByZXR1cm4gbWVyZ2VkO1xuICB9XG5cbiAgb25VcGRhdGVFbmQoKSB7XG4gICAgdGhpcy5hbGxvd0FwcGVuZCA9IHRydWU7XG4gICAgdGhpcy51cGRhdGVOZXh0KCk7XG4gIH1cblxuICB1cGRhdGVOZXh0KCkge1xuICAgIGlmICghdGhpcy5idWZmUS5sZW5ndGgpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgdmFyIG1lcmdlZCA9IHRoaXMubWVyZ2VCdWZmZXJzKCk7XG4gICAgICB0aGlzLmJ1ZmZlci5hcHBlbmRCdWZmZXIobWVyZ2VkKTtcbiAgICAgIHRoaXMuYWxsb3dBcHBlbmQgPSBmYWxzZTtcbiAgICAgIHRoaXMuYnVmZlNpemUgLT0gbWVyZ2VkLmxlbmd0aDtcbiAgICAgIHRoaXMuZXJyQ291bnQgPSAwO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIHRoaXMuYXVkaW9FcnJvcihcIkVycm9yIEFkZGluZyBCdWZmZXI6IFwiICsgZSk7XG4gICAgfVxuICB9XG5cbiAgbGF0ZW5jeUNvbnRyb2xsZXIoKSB7XG4gICAgLy8gY2hlY2sgZm9yIGxhdGVuY3kgYW5kIHNlZWsgZm9yd2FyZCBpZiBuZWNlc3NhcnlcbiAgICB0cnkge1xuICAgICAgdmFyIGxhdGVuY3kgPSB0aGlzLmF1ZGlvLmJ1ZmZlcmVkLmVuZCgwKSAtIHRoaXMuYXVkaW8uY3VycmVudFRpbWU7XG4gICAgICBpZiAobGF0ZW5jeSA+IHRoaXMubWF4TGF0ZW5jeSkge1xuICAgICAgICB0aGlzLmF1ZGlvLmN1cnJlbnRUaW1lID0gdGhpcy5hdWRpby5idWZmZXJlZC5lbmQoMCkgLSB0aGlzLm1pbkxhdGVuY3k7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiQXVkaW8gaGFzIGJlZW4gc2Vla2VkIGJ5IFwiLCBNYXRoLnJvdW5kKChsYXRlbmN5IC0gdGhpcy5taW5MYXRlbmN5KSAqIDEwMDApLCBcIiBtc1wiKTtcbiAgICAgIH1cblxuICAgIH0gY2F0Y2goZSkge1xuXG4gICAgfVxuICB9XG5cbiAgYXVkaW9FcnJvcihtc2csIGV2ZW50KSB7XG4gICAgaWYgKHRoaXMuYXVkaW8gJiYgdGhpcy5hdWRpby5lcnJvcikge1xuICAgICAgY29uc29sZS5sb2cobXNnKTtcbiAgICAgIGNvbnNvbGUubG9nKHRoaXMuYXVkaW8uZXJyb3IpO1xuICAgICAgdGhpcy5lcnJDb3VudCArPSAxO1xuXG4gICAgfVxuICB9XG5cbiAgcXVldWUoYnVmZmVyKSB7XG4gICAgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoYnVmZmVyKTtcbiAgICB0aGlzLmJ1ZmZRLnB1c2goYnVmZmVyKTtcbiAgICB0aGlzLmJ1ZmZTaXplICs9IGJ1ZmZlci5sZW5ndGg7XG4gICAgaWYgKHRoaXMuYWxsb3dBcHBlbmQpIHtcbiAgICAgIHRoaXMudXBkYXRlTmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZU1lc3NhZ2UoZGF0YSkge1xuICAgIGlmICh0aGlzLmVyckNvdW50IDwgMTApIHtcblxuICAgICAgdGhpcy5xdWV1ZShkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coJ3RvbyBtdWNoIGVycm9yJyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbn07XG4iLCJpbXBvcnQgJ3VuZmV0Y2gvcG9seWZpbGwvaW5kZXgnO1xuaW1wb3J0IFJGQiBmcm9tICdAbm92bmMvbm92bmMvY29yZS9yZmInO1xuaW1wb3J0IFByb21pc2UgZnJvbSAncHJvbWlzZS1wb2x5ZmlsbCc7XG5pbXBvcnQgTWVkaWFDb250cm9sbGVyIGZyb20gXCIuL21lZGlhLWNvbnRyb2xsZXJcIjtcblxuXG5mdW5jdGlvbiB0b1F1ZXJ5U3RyaW5nKG9iaikge1xuICB2YXIgcGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGkpKSB7XG4gICAgICBwYXJ0cy5wdXNoKGVuY29kZVVSSUNvbXBvbmVudChpKSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChvYmpbaV0pKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRzLmpvaW4oJyYnKTtcbn1cblxuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBDQnJvd3NlcihyZXFpZCwgdGFyZ2V0X2RpdiwgaW5pdF9wYXJhbXMpIHtcbiAgdmFyIGNvbnRyb2xsZXIgPSB0eXBlb2YgQWJvcnRDb250cm9sbGVyICE9PSAndW5kZWZpbmVkJyA/IG5ldyBBYm9ydENvbnRyb2xsZXIoKSA6IG51bGw7XG5cbiAgdmFyIGNtZF9wb3J0ID0gdW5kZWZpbmVkO1xuICB2YXIgdm5jX3BvcnQgPSB1bmRlZmluZWQ7XG4gIHZhciBwcm94eV93c191cmwgPSBudWxsO1xuXG4gIHZhciBjbGlwRXZlbnRzID0gWydwYXN0ZSddO1xuICB2YXIgY29ubmVjdGVkID0gZmFsc2U7XG4gIHZhciBjb3VudGRvd25UaW1lciA9IG51bGw7XG4gIHZhciB2aXNpYmlsaXR5SGFuZGxlID0gbnVsbDtcbiAgdmFyIGV2ZXJfY29ubmVjdGVkID0gZmFsc2U7XG4gIHZhciBmYWlsX2NvdW50ID0gMDtcbiAgdmFyIGhhc0NsaXBib2FyZCA9IGZhbHNlO1xuICB2YXIgbGFzdFRleHQgPSB1bmRlZmluZWQ7XG4gIHZhciBtYXhSZXRyeSA9IDEwO1xuICB2YXIgcmV0cnlDb3VudCA9IDA7XG4gIHZhciByZXRyeUhhbmRsZSA9IG51bGw7XG4gIHZhciBzdGFnZWRUZXh0ID0gbnVsbDtcbiAgdmFyIHRpbWVycyA9IFtdXG5cbiAgdmFyIG1pbl93aWR0aCA9IDMwMDtcbiAgdmFyIG1pbl9oZWlnaHQgPSAzMDA7XG5cbiAgdmFyIHJmYjtcbiAgdmFyIHJlc2l6ZVRpbWVvdXQ7XG4gIHZhciB2bmNfcGFzcyA9IFwic2VjcmV0XCI7XG5cbiAgdmFyIGVuZF90aW1lID0gdW5kZWZpbmVkO1xuXG4gIHZhciBlbnZpcm9uID0ge307XG4gIHZhciBhdWRpb1R5cGUgPSBudWxsO1xuXG4gIHZhciB0YXJnZXREaXZOb2RlID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXRfZGl2KTtcblxuICB2YXIgd2FpdGluZ19mb3JfY29udGFpbmVyID0gZmFsc2U7XG4gIHZhciB3YWl0aW5nX2Zvcl92bmMgPSBmYWxzZTtcblxuICBpbml0X3BhcmFtcyA9IGluaXRfcGFyYW1zIHx8IHt9O1xuXG4gIGluaXRfcGFyYW1zLmFwaV9wcmVmaXggPSBpbml0X3BhcmFtcy5hcGlfcHJlZml4IHx8IFwiXCI7XG5cbiAgdmFyIG51bV92bmNfcmV0cmllcyA9IGluaXRfcGFyYW1zLm51bV92bmNfcmV0cmllcyB8fCAzO1xuXG4gIC8vIHJmYiBldmVudCBjYWxsYmFja3NcbiAgdmFyIGNyZWRlbnRpYWxzUmVxdWlyZWQ7XG4gIHZhciBjb25uZWN0O1xuICB2YXIgZGlzY29ubmVjdDtcbiAgdmFyIHNlY3VyaXR5RmFpbHVyZTtcbiAgdmFyIGNsaXBib2FyZFxuICB2YXIgcmZiRXZlbnRzQm91bmQgPSBmYWxzZTtcblxuXG4gIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgIC8vIENvdW50ZG93biB1cGRhdGVyXG4gICAgaWYgKGluaXRfcGFyYW1zLm9uX2NvdW50ZG93bikge1xuICAgICAgY291bnRkb3duVGltZXIgPSBzZXRJbnRlcnZhbCh1cGRhdGVfY291bnRkb3duLCAxMDAwKTtcbiAgICB9XG5cbiAgICBpbml0X2h0bWwodGFyZ2V0X2Rpdik7XG5cbiAgICBzZXR1cF9icm93c2VyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBjbGlwSGFuZGxlcihlKSB7XG4gICAgaWYgKCFoYXNDbGlwYm9hcmQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgdGV4dDtcbiAgICBpZiAod2luZG93LmNsaXBib2FyZERhdGEgJiYgd2luZG93LmNsaXBib2FyZERhdGEuZ2V0RGF0YSkgeyAvLyBpZVxuICAgICAgdGV4dCA9IHdpbmRvdy5jbGlwYm9hcmREYXRhLmdldERhdGEoJ1RleHQnKTtcbiAgICB9IGVsc2UgaWYgKGUuY2xpcGJvYXJkRGF0YSAmJiBlLmNsaXBib2FyZERhdGEuZ2V0RGF0YSkge1xuICAgICAgdGV4dCA9IGUuY2xpcGJvYXJkRGF0YS5nZXREYXRhKCd0ZXh0L3BsYWluJyk7XG4gICAgfVxuXG4gICAgaWYgKGNvbm5lY3RlZCAmJiByZmIgJiYgdGV4dCkge1xuICAgICAgcmZiLmNsaXBib2FyZFBhc3RlRnJvbSh0ZXh0KTtcblxuICAgICAgLy8gYXR0ZW1wdCBzZW5kaW5nIHBhc3RlIGNvbW1hbmRcbiAgICAgIHJmYi5zZW5kS2V5KDB4ZmZlMywgbnVsbCwgdHJ1ZSk7XG4gICAgICByZmIuc2VuZEtleSgweDAwNzYsIG51bGwsIHRydWUpO1xuICAgICAgcmZiLnNlbmRLZXkoMHgwMDc2LCBudWxsLCBmYWxzZSk7XG4gICAgICByZmIuc2VuZEtleSgweGZmZTMsIG51bGwsIGZhbHNlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbml0X2NsaXBib2FyZCgpIHtcbiAgICBpZiAoIWluaXRfcGFyYW1zLmNsaXBib2FyZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGhhc0NsaXBib2FyZCA9IHRydWU7XG4gICAgbGFzdFRleHQgPSB1bmRlZmluZWQ7XG5cbiAgICAvLyBpZiByZW1vdGUgYnJvd3NlciBjdXQvY29weSBvcHBlcmF0aW9uIG9jY3VyZWQsIGluc2VydCBpbnRvIGNsaXBib2FyZCBmaWVsZFxuICAgIGlmIChzdGFnZWRUZXh0KSB7XG4gICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoaW5pdF9wYXJhbXMuY2xpcGJvYXJkKS52YWx1ZSA9IHN0YWdlZFRleHQ7XG4gICAgICAgIHN0YWdlZFRleHQgPSBudWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2xpcEV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihpbml0X3BhcmFtcy5jbGlwYm9hcmQpLmFkZEV2ZW50TGlzdGVuZXIoY2xpcEV2ZW50c1tpXSwgY2xpcEhhbmRsZXIpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRlc3Ryb3lfY2xpcGJvYXJkKCkge1xuICAgIGlmICghaW5pdF9wYXJhbXMuY2xpcGJvYXJkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaGFzQ2xpcGJvYXJkID0gZmFsc2U7XG4gIH1cblxuICBmdW5jdGlvbiBjYW52YXMoKSB7XG4gICAgcmV0dXJuIHRhcmdldERpdk5vZGUucXVlcnlTZWxlY3RvcignLmNhbnZhcycpO1xuICB9XG5cbiAgZnVuY3Rpb24gbXNnZGl2KCkge1xuICAgIHJldHVybiB0YXJnZXREaXZOb2RlLnF1ZXJ5U2VsZWN0b3IoJyNicm93c2VyTXNnJyk7XG4gIH1cblxuICBmdW5jdGlvbiBzY3JlZW4oKSB7XG4gICAgcmV0dXJuIHRhcmdldERpdk5vZGUucXVlcnlTZWxlY3RvcignI25vVk5DX3NjcmVlbicpO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5pdF9odG1sKCkge1xuICAgIC8vIGVuc3VyZSBjb250YWluZXIgaXMgZW1wdGllZCBvZiBwcmV2aW91cyBicm93c2Vyc1xuICAgIHRhcmdldERpdk5vZGUuaW5uZXJIVE1MID0gJyc7XG5cbiAgICB2YXIgbXNnRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbXNnRGl2LnNldEF0dHJpYnV0ZSgnaWQnLCAnYnJvd3Nlck1zZycpO1xuICAgIG1zZ0Rpdi5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgJ2xvYWRpbmcnKTtcbiAgICB0YXJnZXREaXZOb2RlLmFwcGVuZENoaWxkKG1zZ0Rpdik7XG5cbiAgICB2YXIgY2FudmFzRWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY2FudmFzRWxlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnY2FudmFzJyk7XG4gICAgdmFyIGNhbnZhc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgIGNhbnZhc0Rpdi5zZXRBdHRyaWJ1dGUoJ2lkJywgJ25vVk5DX3NjcmVlbicpO1xuICAgIGNhbnZhc0Rpdi5hcHBlbmRDaGlsZChjYW52YXNFbGUpO1xuICAgIHRhcmdldERpdk5vZGUuYXBwZW5kQ2hpbGQoY2FudmFzRGl2KTtcblxuICAgIGNhbnZhc0VsZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICB9XG5cbiAgZnVuY3Rpb24gc2V0dXBfYnJvd3NlcigpIHtcbiAgICBpZiAod2FpdGluZ19mb3Jfdm5jIHx8IHdhaXRpbmdfZm9yX2NvbnRhaW5lcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtc2c7XG5cbiAgICBpZiAoZXZlcl9jb25uZWN0ZWQpIHtcbiAgICAgIG1zZyA9IFwiUmVjb25uZWN0aW5nIHRvIFJlbW90ZSBCcm93c2VyLi4uXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1zZyA9IFwiSW5pdGlhbGl6aW5nIFJlbW90ZSBCcm93c2VyLi4uXCI7XG4gICAgfVxuXG4gICAgbXNnZGl2KCkuaW5uZXJIVE1MID0gbXNnO1xuICAgIG1zZ2RpdigpLnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xuXG4gICAgLy8gY2FsY3VsYXRlIGRpbWVuc2lvbnNcbiAgICBjb25zdCBiY3IgPSB0YXJnZXREaXZOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGxldCB3ID0gYmNyLndpZHRoO1xuICAgIGxldCBoID0gYmNyLmhlaWdodDtcblxuICAgIGlmICghaW5pdF9wYXJhbXMuZmlsbF93aW5kb3cpIHtcbiAgICAgIHcgKj0gMC45NjtcbiAgICAgIGggLT0gMjU7XG4gICAgfVxuXG4gICAgaWYgKHcgPCBoKSB7XG4gICAgICAvLyBmbGlwIG1pbnMgZm9yIHZlcnRpY2FsIGxheW91dFxuICAgICAgdmFyIHQgPSBtaW5fd2lkdGg7XG4gICAgICBtaW5fd2lkdGggPSBtaW5faGVpZ2h0O1xuICAgICAgbWluX2hlaWdodCA9IHQ7XG4gICAgfVxuXG4gICAgbGV0IHdpZHRoID0gTWF0aC5tYXgodywgbWluX3dpZHRoKTtcbiAgICBsZXQgaGVpZ2h0ID0gTWF0aC5tYXgoaCwgbWluX2hlaWdodCk7XG4gICAgd2lkdGggPSBwYXJzZUludCh3aWR0aCAvIDgpICogODtcbiAgICBoZWlnaHQgPSBwYXJzZUludChoZWlnaHQgLyA4KSAqIDg7XG4gICAgLy9yZXFfcGFyYW1zWydyZXFpZCddID0gcmVxaWQ7XG5cbiAgICBpZiAoaW5pdF9wYXJhbXMud2VicnRjKSB7XG4gICAgICBhdWRpb1R5cGUgPSAnd2VicnRjJztcbiAgICB9IGVsc2Uge1xuICAgICAgYXVkaW9UeXBlID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIWF1ZGlvVHlwZSkge1xuICAgICAgY29uc29sZS5sb2coXCJObyBTdXBwb3J0ZWQgQXVkaW8gVHlwZXNcIik7XG4gICAgfVxuXG4gICAgZW52aXJvbiA9IHsnU0NSRUVOX1dJRFRIJzogd2lkdGgsXG4gICAgICAgICAgICAgICAnU0NSRUVOX0hFSUdIVCc6IGhlaWdodCxcbiAgICAgICAgICAgICAgICdBVURJT19UWVBFJzogYXVkaW9UeXBlLFxuICAgICAgICAgICAgICAgJ1JFUV9JRCc6IHJlcWlkXG4gICAgICAgICAgICAgIH07XG5cbiAgICBpbml0X2Jyb3dzZXIoKVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdF9icm93c2VyKCkge1xuICAgIGlmICh3YWl0aW5nX2Zvcl9jb250YWluZXIpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3YWl0aW5nX2Zvcl9jb250YWluZXIgPSB0cnVlO1xuXG4gICAgLy92YXIgaW5pdF91cmwgPSBpbml0X3BhcmFtcy5hcGlfcHJlZml4ICsgXCIvaW5pdF9icm93c2VyP1wiICsgdG9RdWVyeVN0cmluZyhyZXFfcGFyYW1zKTtcbiAgICB2YXIgaW5pdF91cmwgPSBpbml0X3BhcmFtcy5hcGlfcHJlZml4ICsgXCIvYXBpL2Zsb2NrL3N0YXJ0L1wiICsgcmVxaWQ7XG5cbiAgICB2YXIgcmVxX3BhcmFtcyA9IHtcImVudmlyb25cIjogZW52aXJvbn07XG5cbiAgICB2YXIgaGVhZGVycyA9IGluaXRfcGFyYW1zLmhlYWRlcnMgfHwge307XG4gICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XG5cbiAgICB2YXIgb3B0aW9ucyA9IHsgaGVhZGVyczogbmV3IEhlYWRlcnMoaGVhZGVycyksXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHJlcV9wYXJhbXMpLFxuICAgICAgICAgICAgICAgICAgfTtcblxuICAgIGlmIChjb250cm9sbGVyKSB7XG4gICAgICBvcHRpb25zLnNpZ25hbCA9IGNvbnRyb2xsZXIuc2lnbmFsO1xuICAgIH1cblxuICAgIC8vIGV4cGVjdHMganNvbiByZXNwb25zZVxuICAgIGZldGNoKGluaXRfdXJsLCBvcHRpb25zKVxuICAgICAgLnRoZW4oZnVuY3Rpb24gKHJlcykge1xuICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihyZXMuc3RhdHVzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXMuanNvbigpO1xuICAgICAgfSlcbiAgICAgIC50aGVuKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHdhaXRpbmdfZm9yX2NvbnRhaW5lciA9IGZhbHNlO1xuICAgICAgICBoYW5kbGVfYnJvd3Nlcl9yZXNwb25zZShkYXRhKTtcbiAgICAgIH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICBjb25zb2xlLmxvZygnZmV0Y2ggZXJyb3InLCBlcnIpO1xuICAgICAgICB3YWl0aW5nX2Zvcl9jb250YWluZXIgPSBmYWxzZTtcblxuICAgICAgICAvLyB1c2VyIGNhbmNlbGVkXG4gICAgICAgIGlmIChlcnIubWVzc2FnZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFlcnIgfHwgZXJyLm1lc3NhZ2UgIT0gNDA0KSB7XG4gICAgICAgICAgbXNnZGl2KCkuaW5uZXJIVE1MID0gJ1JlY29ubmVjdGluZyB0byBSZW1vdGUgQnJvd3Nlci4uLic7XG4gICAgICAgICAgbXNnZGl2KCkuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgICAgICBpZiAocmV0cnlDb3VudCsrIDwgbWF4UmV0cnkpIHtcbiAgICAgICAgICAgIHRpbWVycy5wdXNoKHNldFRpbWVvdXQoaW5pdF9icm93c2VyLCAxMDAwKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluaXRfcGFyYW1zLm9uX2V2ZW50KSB7XG4gICAgICAgICAgaW5pdF9wYXJhbXMub25fZXZlbnQoJ2Vycm9yJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbXNnZGl2KCkuaW5uZXJIVE1MID0gJ1JlbW90ZSBCcm93c2VyIEV4cGlyZWQuLi4gUGxlYXNlIHRyeSBhZ2Fpbi4uLic7XG4gICAgICAgICAgbXNnZGl2KCkuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlX2Jyb3dzZXJfcmVzcG9uc2UoZGF0YSkge1xuICAgIFxuICAgIGlmIChkYXRhLmNvbnRhaW5lcnMgJiYgZGF0YS5jb250YWluZXJzLnhzZXJ2ZXIgJiYgZGF0YS5jb250YWluZXJzLnhzZXJ2ZXIucG9ydHMpIHtcbiAgICAgIGxldCBwb3J0cyA9IGRhdGEuY29udGFpbmVycy54c2VydmVyLnBvcnRzO1xuXG4gICAgICB2bmNfcG9ydCA9IHBvcnRzW1widm5jLXBvcnRcIl07XG4gICAgICBjbWRfcG9ydCA9IHBvcnRzW1wiY21kLXBvcnRcIl07XG5cbiAgICAgIGVuZF90aW1lID0gcGFyc2VJbnQoRGF0ZS5ub3coKSAvIDEwMDAsIDEwKSArIGRhdGEudHRsO1xuXG4gICAgICB2bmNfcGFzcyA9IGRhdGEuY29udGFpbmVycy54c2VydmVyLmVudmlyb24uVk5DX1BBU1M7XG5cbiAgICAgIGlmIChkYXRhLmNvbnRhaW5lcnMucHl3Yi5wb3J0c1sncHl3Yi1wb3J0J10pIHtcbiAgICAgICAgd2luZG93Lm9wZW4oXCJodHRwOi8vbG9jYWxob3N0OlwiICsgZGF0YS5jb250YWluZXJzLnB5d2IucG9ydHNbJ3B5d2ItcG9ydCddICsgXCIvY29tYmluZWQvXCIgKyBkYXRhLmNvbnRhaW5lcnMucHl3Yi5lbnZpcm9uW1wiVVJMXCJdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGluaXRfcGFyYW1zLnByb3h5X3dzKSB7XG4gICAgICAgIHZhciBpcCA9IGRhdGEuY29udGFpbmVycy54c2VydmVyLmlwO1xuICAgICAgICBwcm94eV93c191cmwgPSBgX3dlYnNvY2tpZnk/aXA9JHtpcH0mcG9ydD1gO1xuICAgICAgfVxuXG4gICAgICBsZXQgbWVkaWFfcGFyYW1zID0ge1wicG9ydHNcIjpwb3J0cyxcbiAgICAgICAgXCJwcm94eV93c1wiOnByb3h5X3dzX3VybCxcbiAgICAgICAgXCJsb2NrX2F1ZGlvXCI6IChpbml0X3BhcmFtcy5hdWRpbyA9PSBcIndhaXRfZm9yX2NsaWNrXCIpLFxuICAgICAgICBcIndlYnJ0Y1wiOiBpbml0X3BhcmFtcy53ZWJydGMsXG4gICAgICAgIFwid2VicnRjX3ZpZGVvXCI6IGluaXRfcGFyYW1zLndlYnJ0Y192aWRlb1xuICAgICAgfTtcbiAgICAgIHdpbmRvdy5tZWRpYUNvbnRyb2xsZXIgPSBuZXcgTWVkaWFDb250cm9sbGVyKHRhcmdldERpdk5vZGUsIG1lZGlhX3BhcmFtcyk7XG5cbiAgICAgIGlmIChpbml0X3BhcmFtcy5hdWRpbyA9PSBcIndhaXRfZm9yX2NsaWNrXCIpIHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB3aW5kb3cubWVkaWFDb250cm9sbGVyLnVubG9ja0F1ZGlvKCk7XG4gICAgICAgIH0sIHsgb25jZTogdHJ1ZSB9KTtcblxuICAgICAgfVxuXG4gICAgICBpZiAoaW5pdF9wYXJhbXMub25fZXZlbnQpIHtcbiAgICAgICAgaW5pdF9wYXJhbXMub25fZXZlbnQoXCJpbml0XCIsIGRhdGEpO1xuICAgICAgfVxuXG4gICAgICB0aW1lcnMucHVzaCh3aW5kb3cuc2V0VGltZW91dCh0cnlfaW5pdF92bmMsIDMwMDApKTtcblxuICAgIH0gZWxzZSBpZiAoZGF0YS5xdWV1ZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgIHZhciBtc2cgPSBcIldhaXRpbmcgZm9yIGVtcHR5IHNsb3QuLi4gXCI7XG4gICAgICBpZiAoZGF0YS5xdWV1ZSA9PSAwKSB7XG4gICAgICAgIG1zZyArPSBcIjxiPllvdSBhcmUgbmV4dCE8L2I+XCI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtc2cgKz0gXCJBdCBtb3N0IDxiPlwiICsgZGF0YS5xdWV1ZSArIFwiIHVzZXIocyk8L2I+IGFoZWFkIG9mIHlvdVwiO1xuICAgICAgfVxuICAgICAgbXNnZGl2KCkuaW5uZXJIVE1MID0gbXNnO1xuXG4gICAgICB0aW1lcnMucHVzaCh3aW5kb3cuc2V0VGltZW91dChpbml0X2Jyb3dzZXIsIDMwMDApKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB0cnlfaW5pdF92bmMoKSB7XG4gICAgZG9fdm5jKClcbiAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHsgd2FpdGluZ19mb3Jfdm5jID0gZmFsc2U7IH0pXG4gICAgICAuY2F0Y2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdmYWlsZWQnLCBlcnIpO1xuXG4gICAgICAgIHdhaXRpbmdfZm9yX3ZuYyA9IGZhbHNlO1xuICAgICAgICBmYWlsX2NvdW50Kys7XG5cbiAgICAgICAgaWYgKGZhaWxfY291bnQgPD0gbnVtX3ZuY19yZXRyaWVzKSB7XG4gICAgICAgICAgbXNnZGl2KCkuaW5uZXJIVE1MID0gXCJSZXRyeWluZyB0byBjb25uZWN0IHRvIHJlbW90ZSBicm93c2VyLi4uXCI7XG4gICAgICAgICAgdGltZXJzLnB1c2goc2V0VGltZW91dChpbml0X2Jyb3dzZXIsIDUwMCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChpbml0X3BhcmFtcy5vbl9ldmVudCkge1xuICAgICAgICAgICAgaW5pdF9wYXJhbXMub25fZXZlbnQoXCJmYWlsXCIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtc2dkaXYoKS5pbm5lckhUTUwgPSBcIkZhaWxlZCB0byBjb25uZWN0IHRvIHJlbW90ZSBicm93c2VyLi4uIFBsZWFzZSB0cnkgYWdhaW4gbGF0ZXJcIjtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gIH1cblxuICBmdW5jdGlvbiBjbGllbnRQb3NpdGlvbigpIHtcbiAgICBjb25zdCBiY3IgPSB0YXJnZXREaXZOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBjID0gY2FudmFzKCk7XG4gICAgdmFyIGNoID0gYy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQ7XG4gICAgdmFyIGN3ID0gYy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aDtcbiAgICBpZiAoIWluaXRfcGFyYW1zLmZpbGxfd2luZG93KSB7XG4gICAgICBjLnN0eWxlLm1hcmdpbkxlZnQgPSAoKGJjci53aWR0aCAtIGN3KS8yKSArICdweCc7XG4gICAgICBjLnN0eWxlLm1hcmdpblRvcCA9ICgoYmNyLmhlaWdodCAtIChjaCArIDI1KSkvMikgKyAncHgnO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNsaWVudFJlc2l6ZSgpIHtcbiAgICBjb25zdCBiY3IgPSB0YXJnZXREaXZOb2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgbGV0IHcgPSBiY3Iud2lkdGg7XG4gICAgbGV0IGggPSBiY3IuaGVpZ2h0O1xuXG4gICAgaWYgKCFpbml0X3BhcmFtcy5maWxsX3dpbmRvdykge1xuICAgICAgdyA9IE1hdGgucm91bmQodyAqIDAuOTYpO1xuICAgICAgaCA9IGggLSAyNTtcbiAgICB9XG5cbiAgICBpZiAocmZiKSB7XG4gICAgICB2YXIgcyA9IHJmYi5fZGlzcGxheS5hdXRvc2NhbGUodywgaCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25WTkNDb3B5Q3V0KHJmYiwgdGV4dCkge1xuICAgIGlmIChpbml0X3BhcmFtcy5jbGlwYm9hcmQgJiYgaGFzQ2xpcGJvYXJkKSB7XG4gICAgICAvLyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGluaXRfcGFyYW1zLmNsaXBib2FyZCkuaW5uZXJIVE1MID0gKHRleHQpO1xuICAgIH0gZWxzZSBpZihpbml0X3BhcmFtcy5jbGlwYm9hcmQpIHtcbiAgICAgIHN0YWdlZFRleHQgPSB0ZXh0O1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGRvX3ZuYygpIHtcbiAgICBpZiAod2FpdGluZ19mb3Jfdm5jKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd2FpdGluZ19mb3Jfdm5jID0gdHJ1ZTtcblxuICAgIHZhciBob3N0ID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgIHZhciBwb3J0ID0gdm5jX3BvcnQ7XG4gICAgdmFyIHBhdGggPSBcIndlYnNvY2tpZnlcIjtcbiAgICB2YXIgcHJvdG9jb2wgPSBcIndzXCI7XG5cbiAgICBpZiAod2luZG93LmxvY2F0aW9uLnByb3RvY29sID09PSBcImh0dHBzOlwiKSB7XG4gICAgICBwcm90b2NvbCA9IFwid3NzXCI7XG4gICAgfVxuXG4gICAgLy8gUHJveHkgV1MgdmlhIHRoZSBvcmlnaW4gaG9zdCwgaW5zdGVhZCBvZiBtYWtpbmcgZGlyZWN0IGNvbm5cbiAgICAvLyAncHJveHlfd3MnIHNwZWNpZmllcyB0aGUgcHJveHkgcGF0aCwgcG9ydCBpcyBhcHBlbmRlZFxuICAgIGlmIChwcm94eV93c191cmwpIHtcbiAgICAgIHBhdGggPSBwcm94eV93c191cmwgKyBwb3J0O1xuICAgICAgcG9ydCA9IHdpbmRvdy5sb2NhdGlvbi5wb3J0O1xuICAgICAgaWYgKCFwb3J0KSB7XG4gICAgICAgIHBvcnQgPSAod2luZG93LmxvY2F0aW9uLnByb3RvY29sID09IFwiaHR0cHM6XCIgPyA0NDMgOiA4MCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHRhcmdldCA9IGNhbnZhcygpO1xuICAgIHZhciB3ZWJzZXJ2aWNlX3VybCA9IHByb3RvY29sICsgJzovLycgKyBob3N0ICsgJzonICsgcG9ydCArICcvJyArIHBhdGg7XG5cbiAgICBjb25zb2xlLmxvZyhcIkNvbm5lY3RpbmcgdG8gXCIgKyB3ZWJzZXJ2aWNlX3VybCk7XG5cbiAgICB2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHJmYiA9IG5ldyBSRkIodGFyZ2V0LCB3ZWJzZXJ2aWNlX3VybCwgeydjcmVkZW50aWFscyc6IHsncGFzc3dvcmQnOiB2bmNfcGFzc319KTtcbiAgICAgIHdpbmRvdy5yZmIgPSByZmI7XG5cbiAgICAgIC8vaWYgKCFyZmJFdmVudHNCb3VuZCkge1xuICAgICAgY3JlZGVudGlhbHNSZXF1aXJlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmVqZWN0KFwiY3JlZGVudGlhbHNyZXF1aXJlZFwiKTtcbiAgICAgIH1cblxuICAgICAgY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY2FudmFzKCkuc3R5bGUuZGlzcGxheSA9ICdibG9jayc7XG5cbiAgICAgICAgaWYgKGluaXRfcGFyYW1zLmZpbGxfd2luZG93KSB7XG4gICAgICAgICAgY2FudmFzKCkuZm9jdXMoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG1zZ2RpdigpLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICAgICAgZXZlcl9jb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICBjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICBmYWlsX2NvdW50ID0gMDtcblxuICAgICAgICBpZiAoaW5pdF9wYXJhbXMub25fZXZlbnQpIHtcbiAgICAgICAgICBpbml0X3BhcmFtcy5vbl9ldmVudChcImNvbm5lY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmZiLnJlc2l6ZVNlc3Npb24gPSB0cnVlO1xuICAgICAgICByZmIuc2NhbGVWaWV3cG9ydCA9IHRydWU7XG5cbiAgICAgICAgcmVzb2x2ZShcImNvbm5lY3RlZFwiKTtcbiAgICAgIH1cblxuICAgICAgZGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29ubmVjdGVkID0gZmFsc2U7XG5cbiAgICAgICAgY2FudmFzKCkuc3R5bGUuZGlzcGxheSA9ICdub25lJztcblxuICAgICAgICB2YXIgcmVpbml0ID0gIWRvY3VtZW50LmhpZGRlbjtcblxuICAgICAgICBpZiAoaW5pdF9wYXJhbXMub25fZXZlbnQpIHtcbiAgICAgICAgICBpbml0X3BhcmFtcy5vbl9ldmVudChcImRpc2Nvbm5lY3RcIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocmVpbml0KSB7XG4gICAgICAgICAgc2V0dXBfYnJvd3NlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJlamVjdChcImRpc2Nvbm5lY3RlZFwiKTtcbiAgICAgIH1cblxuICAgICAgc2VjdXJpdHlGYWlsdXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZWplY3QoXCJzZWN1cml0eUZhaWx1cmVcIik7XG4gICAgICB9XG5cbiAgICAgIGNsaXBib2FyZCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBvblZOQ0NvcHlDdXQocmZiLCBldmVudC5kZXRhaWwudGV4dCk7XG4gICAgICB9XG5cbiAgICAgIHJmYi5hZGRFdmVudExpc3RlbmVyKFwiY3JlZGVudGlhbHNyZXF1aXJlZFwiLCBjcmVkZW50aWFsc1JlcXVpcmVkKTtcbiAgICAgIHJmYi5hZGRFdmVudExpc3RlbmVyKFwiY29ubmVjdFwiLCBjb25uZWN0KTtcbiAgICAgIHJmYi5hZGRFdmVudExpc3RlbmVyKFwiZGlzY29ubmVjdFwiLCBkaXNjb25uZWN0KTtcbiAgICAgIHJmYi5hZGRFdmVudExpc3RlbmVyKFwic2VjdXJpdHlmYWlsdXJlXCIsIHNlY3VyaXR5RmFpbHVyZSk7XG4gICAgICByZmIuYWRkRXZlbnRMaXN0ZW5lcihcImNsaXBib2FyZFwiLCBjbGlwYm9hcmQpO1xuICAgICAgLy8gICByZmJFdmVudHNCb3VuZCA9IHRydWU7XG4gICAgICAvLyB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuXG5cbiAgd2luZG93Lm9ucmVzaXplID0gZnVuY3Rpb24gKCkge1xuICAgIC8vIFdoZW4gdGhlIHdpbmRvdyBoYXMgYmVlbiByZXNpemVkLCB3YWl0IHVudGlsIHRoZSBzaXplIHJlbWFpbnNcbiAgICAvLyB0aGUgc2FtZSBmb3IgMC41IHNlY29uZHMgYmVmb3JlIHNlbmRpbmcgdGhlIHJlcXVlc3QgZm9yIGNoYW5naW5nXG4gICAgLy8gdGhlIHJlc29sdXRpb24gb2YgdGhlIHNlc3Npb25cbiAgICBjbGVhclRpbWVvdXQocmVzaXplVGltZW91dCk7XG4gICAgcmVzaXplVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIGNsaWVudFJlc2l6ZSgpO1xuICAgICAgLy9jbGllbnRQb3NpdGlvbigpO1xuICAgIH0sIDUwMCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gdmlzaWJpbGl0eUNoYW5nZUNCKCkge1xuICAgIGlmIChkb2N1bWVudC5oaWRkZW4pIHtcbiAgICAgIHZpc2liaWxpdHlIYW5kbGUgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAocmZiKSB7XG4gICAgICAgICAgcmZiLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGluaXRfcGFyYW1zLmluYWN0aXZlU2VjcyAqIDEwMDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGVhclRpbWVvdXQodmlzaWJpbGl0eUhhbmRsZSk7XG4gICAgICBpZiAoIWNvbm5lY3RlZCkge1xuICAgICAgICBpZiAoaW5pdF9wYXJhbXMub25fZXZlbnQpIHtcbiAgICAgICAgICBpbml0X3BhcmFtcy5vbl9ldmVudChcInJlY29ubmVjdFwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNldHVwX2Jyb3dzZXIoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiB1cGRhdGVfY291bnRkb3duKCkge1xuICAgIGlmICghZW5kX3RpbWUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGN1cnIgPSBNYXRoLmZsb29yKG5ldyBEYXRlKCkuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgdmFyIHNlY2RpZmYgPSBlbmRfdGltZSAtIGN1cnI7XG5cbiAgICBpZiAoc2VjZGlmZiA8IDApIHtcbiAgICAgIGluaXRfcGFyYW1zLm9uX2NvdW50ZG93bigwLCBcIjAwOjAwXCIpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBtaW4gPSBNYXRoLmZsb29yKHNlY2RpZmYgLyA2MCk7XG4gICAgdmFyIHNlYyA9IHNlY2RpZmYgJSA2MDtcbiAgICBpZiAoc2VjIDw9IDkpIHtcbiAgICAgIHNlYyA9IFwiMFwiICsgc2VjO1xuICAgIH1cbiAgICBpZiAobWluIDw9IDkpIHtcbiAgICAgIG1pbiA9IFwiMFwiICsgbWluO1xuICAgIH1cblxuICAgIGluaXRfcGFyYW1zLm9uX2NvdW50ZG93bihzZWNkaWZmLCBtaW4gKyBcIjpcIiArIHNlYyk7XG4gIH1cblxuICBpZiAoaW5pdF9wYXJhbXMuaW5hY3RpdmVTZWNzKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgdmlzaWJpbGl0eUNoYW5nZUNCKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNsZWFyVGltZXJzKCkge1xuICAgIC8vIGNsZWFyIGludGVydmFscyBhbmQgdGltZXJzXG4gICAgY2xlYXJJbnRlcnZhbChjb3VudGRvd25UaW1lcik7XG4gICAgY2xlYXJUaW1lb3V0KHZpc2liaWxpdHlIYW5kbGUpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGltZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGltZXJzW2ldKTtcbiAgICB9XG4gICAgdGltZXJzID0gW107XG4gIH1cblxuICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICBpZiAoY29udHJvbGxlcikge1xuICAgICAgLy8gY2FuY2VsIGZldGNoIHJlcXVlc3RzXG4gICAgICBjb250cm9sbGVyLmFib3J0KCk7XG4gICAgfVxuXG4gICAgaWYgKHdpbmRvdy5tZWRpYUNvbnRyb2xsZXIpIHtcbiAgICAgIHdpbmRvdy5tZWRpYUNvbnRyb2xsZXIuc3RvcCgpO1xuICAgIH1cblxuICAgIC8vIHN0b3AgYXVkaW8gcGx1Z2luXG4gICAgaWYgKHdpbmRvdy5hdWRpb1BsdWdpbikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc29sZS5sb2coXCJDbG9zZSBBdWRpb1wiKTtcbiAgICAgICAgd2luZG93LmF1ZGlvUGx1Z2luLmNsb3NlKCk7XG4gICAgICAgIHdpbmRvdy5hdWRpb1BsdWdpbiA9IHVuZGVmaW5lZDtcbiAgICAgIH0gY2F0Y2ggKGVycil7fVxuICAgIH1cblxuICAgIGlmIChyZmIpIHtcbiAgICAgIHJmYi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY3JlZGVudGlhbHNyZXF1aXJlZFwiLCBjcmVkZW50aWFsc1JlcXVpcmVkKTtcbiAgICAgIHJmYi5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29ubmVjdFwiLCBjb25uZWN0KTtcbiAgICAgIHJmYi5yZW1vdmVFdmVudExpc3RlbmVyKFwiZGlzY29ubmVjdFwiLCBkaXNjb25uZWN0KTtcbiAgICAgIHJmYi5yZW1vdmVFdmVudExpc3RlbmVyKFwic2VjdXJpdHlmYWlsdXJlXCIsIHNlY3VyaXR5RmFpbHVyZSk7XG4gICAgICByZmIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaXBib2FyZFwiLCBjbGlwYm9hcmQpO1xuICAgICAgcmZiLmRpc2Nvbm5lY3QoKTtcbiAgICB9XG5cbiAgICB2YXIgY252cyA9IGNhbnZhcygpO1xuICAgIHZhciBfc2NyZWVuID0gc2NyZWVuKCk7XG5cbiAgICBjbGVhclRpbWVycygpO1xuXG4gICAgZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInZpc2liaWxpdHljaGFuZ2VcIiwgdmlzaWJpbGl0eUNoYW5nZUNCKTtcbiAgfVxuXG4gIHN0YXJ0KCk7XG5cbiAgcmV0dXJuIHtcbiAgICBcImNsb3NlXCI6IGNsb3NlLFxuICAgIFwiZGVzdHJveV9jbGlwYm9hcmRcIjogZGVzdHJveV9jbGlwYm9hcmQsXG4gICAgXCJpbml0X2NsaXBib2FyZFwiOiBpbml0X2NsaXBib2FyZFxuICAgfVxufVxuXG5cblxuIiwiaW1wb3J0IHtkZXRlcm1pbmVWaWRlb0Zvcm1hdHMsIFdlYlJUQ30gZnJvbSBcIi4vd2VicnRjXCI7XG5pbXBvcnQge2dldEJlc3RBdWRpb1R5cGUsIE1TQXVkaW99IGZyb20gXCIuL2F1ZGlvLW1lZGlhc291cmNlXCI7XG5cbmV4cG9ydCB7TWVkaWFDb250cm9sbGVyfTtcblxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNZWRpYUNvbnRyb2xsZXIge1xuXG4gIGNvbnN0cnVjdG9yKHRhcmdldCwgZGF0YSl7XG4gICAgdGhpcy50YXJnZXQgPSB0YXJnZXQ7XG4gICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICB0aGlzLmRlYnVnID0gdHJ1ZTtcbiAgICB0aGlzLmNvbm5lY3RfYXR0ZW1wdHMgPSAwO1xuICAgIHRoaXMud3NfY29ubjtcbiAgICB0aGlzLndlYnJ0Y192aWRlb19mb3JtYXRzO1xuXG4gICAgdGhpcy53ZWJydGMgPSBkYXRhLndlYnJ0YztcbiAgICB0aGlzLndlYnJ0Y192aWRlbyA9IGRhdGEud2VicnRjX3ZpZGVvO1xuXG4gICAgdGhpcy5sb2NrX2F1ZGlvID0gZGF0YVsnbG9ja19hdWRpbyddO1xuXG4gICAgdGhpcy5jb25uZWN0VG9TZXJ2ZXIoKTtcbiAgfVxuXG4gIGdldENvbW1hbmRTZXJ2ZXIoKSB7XG4gICAgbGV0IHdzX3VybCA9ICh3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyBcIndzczovL1wiIDogXCJ3czovL1wiKTtcbiAgICB3c191cmwgKz0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuXG4gICAgdmFyIGF1ZGlvX3BvcnQgPSB0aGlzLmRhdGEucG9ydHNbXCJjbWQtcG9ydFwiXTtcblxuICAgIGlmICh0aGlzLmRhdGEucHJveHlfd3MpIHtcbiAgICAgIHdzX3VybCArPSBcIi9cIiArIHRoaXMuZGF0YS5wcm94eV93cyArIGF1ZGlvX3BvcnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdzX3VybCArPSBcIjpcIiArIGF1ZGlvX3BvcnQgKyBcIi9hdWRpb193c1wiO1xuICAgIH1cblxuICAgIHJldHVybiB3c191cmw7XG4gIH1cblxuICBjb25uZWN0VG9TZXJ2ZXIoKSB7XG4gICAgdGhpcy5jb25uZWN0X2F0dGVtcHRzKys7XG4gICAgaWYgKHRoaXMuY29ubmVjdF9hdHRlbXB0cyA+IDEwMCkge1xuICAgICAgY29uc29sZS5sb2coXCJUb28gbWFueSBjb25uZWN0aW9uIGF0dGVtcHRzLCBhYm9ydGluZy4gUmVmcmVzaCBwYWdlIHRvIHRyeSBhZ2FpblwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgd3NfdXJsID0gdGhpcy5nZXRDb21tYW5kU2VydmVyKCk7XG4gICAgdGhpcy5zZXRTdGF0dXMoXCJDb25uZWN0aW5nIHRvIHNlcnZlciBcIiArIHdzX3VybCArIFwiLCBhdHRlbXB0PSBcIiArIHRoaXMuY29ubmVjdF9hdHRlbXB0cyk7XG4gICAgdGhpcy53c19jb25uID0gbmV3IFdlYlNvY2tldCh3c191cmwpO1xuICAgIC8qIFdoZW4gY29ubmVjdGVkLCBpbW1lZGlhdGVseSByZWdpc3RlciB3aXRoIHRoZSBzZXJ2ZXIgKi9cbiAgICB0aGlzLndzX2Nvbm4uYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsICgpID0+IHtcbiAgICAgIHRoaXMud3NfY29ubi5zZW5kKCdIRUxMTyAnKTtcbiAgICAgIHRoaXMuc2V0U3RhdHVzKFwiUmVnaXN0ZXJpbmcgd2l0aCBzZXJ2ZXJcIik7XG4gICAgfSk7XG5cbiAgICB0aGlzLndzX2Nvbm4uYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCB0aGlzLm9uU2VydmVyRXJyb3IuYmluZCh0aGlzKSk7XG4gICAgdGhpcy53c19jb25uLmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLm9uU2VydmVyTWVzc2FnZS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLndzX2Nvbm4uYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCB0aGlzLm9uU2VydmVyQ2xvc2UuYmluZCh0aGlzKSk7XG5cbiAgICB3aW5kb3cub25iZWZvcmV1bmxvYWQgPSB0aGlzLmNsb3NlLmJpbmQodGhpcyk7XG4gIH1cblxuICB3ZWJydGNJbml0T3B0aW9ucyhmb3JtYXRzKSB7XG4gICAgaWYgKCF0aGlzLndlYnJ0Yykge1xuICAgICAgcmV0dXJuIHtcIndlYnJ0Y1wiOiBmYWxzZX07XG4gICAgfVxuXG4gICAgaWYgKHRoaXMud2VicnRjX3ZpZGVvICYmIGZvcm1hdHMpIHtcbiAgICAgIGlmICh0eXBlb2YodGhpcy53ZWJydGNfdmlkZW8pID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGZvcm1hdHMudW5zaGlmdCh0aGlzLndlYnJ0Y192aWRlbyk7XG4gICAgICB9XG5cbiAgICAgIGlmIChmb3JtYXRzLmluY2x1ZGVzKFwiVlA4XCIpIHx8IGZvcm1hdHMuaW5jbHVkZXMoXCJIMjY0XCIpKSB7XG4gICAgICAgIHJldHVybiB7XCJ3ZWJydGNcIjogdHJ1ZSwgXCJ3ZWJydGNfdmlkZW9cIjogZm9ybWF0c31cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1wid2VicnRjXCI6IHRydWV9O1xuICB9XG5cbiAgdW5sb2NrQXVkaW8oKSB7XG4gICAgdGhpcy5sb2NrX2F1ZGlvID0gZmFsc2U7XG4gICAgaWYgKHdpbmRvdy5tZWRpYVBsdWdpbiAhPSBudWxsKSB7XG4gICAgICB3aW5kb3cubWVkaWFQbHVnaW4udW5sb2NrQXVkaW8oKVxuICAgIH1cbiAgfVxuXG4gIGFzeW5jIGluaXRDb25uZWN0aW9uKCkge1xuICAgIGNvbnN0IGZvcm1hdHMgPSBhd2FpdCBkZXRlcm1pbmVWaWRlb0Zvcm1hdHMoKTtcbiAgICBjb25zdCBtZXNzYWdlID0gdGhpcy53ZWJydGNJbml0T3B0aW9ucyhmb3JtYXRzKTtcblxuICAgIHRoaXMud2VicnRjX3ZpZGVvX2Zvcm1hdHMgPSBmb3JtYXRzO1xuXG4gICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgdGhpcy5zZW5kKG1lc3NhZ2UpO1xuXG4gICAgLy8gaW5zdGFudGlhdGUgcmlnaHQgcGx1Z2luc1xuICAgIGlmIChtZXNzYWdlLndlYnJ0Yykge1xuICAgICAgd2luZG93Lm1lZGlhUGx1Z2luID0gbmV3IFdlYlJUQyh0aGlzLnRhcmdldCwgMSwgdGhpcywgdGhpcy5sb2NrX2F1ZGlvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGF1ZGlvX2Zvcm1hdCA9IGdldEJlc3RBdWRpb1R5cGUoKTtcbiAgICAgIHdpbmRvdy5tZWRpYVBsdWdpbiA9IG5ldyBNU0F1ZGlvKGF1ZGlvX2Zvcm1hdCwgdGhpcywgdGhpcy5sb2NrX2F1ZGlvKTtcbiAgICB9XG4gICAgd2luZG93Lm1lZGlhUGx1Z2luLnN0YXJ0KCk7XG4gIH1cblxuICBjbG9zZSAoKSB7XG4gICAgdGhpcy5kaXNjb25uZWN0V2Vic29ja2V0KCk7XG4gICAgaWYgKHdpbmRvdy5tZWRpYVBsdWdpbikge1xuICAgICAgd2luZG93Lm1lZGlhUGx1Z2luLmNsb3NlKCk7XG4gICAgICB3aW5kb3cubWVkaWFQbHVnaW4gPSBudWxsO1xuICAgIH1cbiAgfVxuXG4gIG9uU2VydmVyQ2xvc2UoZXZlbnQpIHtcbiAgICB0aGlzLnNldFN0YXR1cygnRGlzY29ubmVjdGVkIGZyb20gc2VydmVyIHdpdGggY29kZT0nICsgZXZlbnQuY29kZSArICcgcmVhc29uPScgKyBldmVudC5yZWFzb24pO1xuXG4gICAgdGhpcy5kaXNjb25uZWN0V2Vic29ja2V0KCk7XG5cbiAgICBpZiAoZXZlbnQuY29kZSAhPT0gMTAwMikge1xuICAgICAgLy8gUmVzZXQgYWZ0ZXIgYSBzZWNvbmRcbiAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMuY29ubmVjdFRvU2VydmVyLmJpbmQodGhpcyksIDIwMDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodGhpcy5jb25uZWN0X2F0dGVtcHRzIDwgNSkge1xuICAgICAgICAvLyBSZXRyaWV2ZSB0byBjb25uZWN0IHVwIHRvIDUgdGltZXMgKHBlZXItaWQgbWlnaHQgYmUgaW4gY29uZmxpY3QgaWYgaW5pdF9icm93c2VyIGlzIGNhbGxlZCBhZ2FpbilcbiAgICAgICAgd2luZG93LnNldFRpbWVvdXQodGhpcy5jb25uZWN0VG9TZXJ2ZXIuYmluZCh0aGlzKSwgMjAwMCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZGlzY29ubmVjdFdlYnNvY2tldCgpIHtcbiAgICBpZiAodGhpcy53c19jb25uKSB7XG4gICAgICB0aGlzLnNldFN0YXR1cyhcImRpc2Nvbm5lY3Qgd2Vic29ja2V0XCIpO1xuICAgICAgdGhpcy53c19jb25uLmNsb3NlKCk7XG4gICAgfVxuICB9XG5cbiAgc2VuZChtZXNzYWdlKSB7XG4gICAgdGhpcy53c19jb25uLnNlbmQoSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuICB9XG5cbiAgb25TZXJ2ZXJFcnJvcigpIHtcbiAgICB0aGlzLnNldFN0YXR1cyhcIlVuYWJsZSB0byBjb25uZWN0IHRvIHNlcnZlciwgZGlkIHlvdSBhZGQgYW4gZXhjZXB0aW9uIGZvciB0aGUgY2VydGlmaWNhdGU/XCIpO1xuICAgIC8vIFJldHJ5IGFmdGVyIDMgc2Vjb25kc1xuICAgIHdpbmRvdy5zZXRUaW1lb3V0KHRoaXMuY29ubmVjdFRvU2VydmVyLmJpbmQodGhpcyksIDMwMDApO1xuICB9XG5cbiAgc2V0U3RhdHVzKHN0YXR1cykge1xuICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIk1lZGlhIENvbnRyb2xsZXIgLSBzdGF0dXM6XCIgKyBzdGF0dXMpO1xuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUluY29taW5nRXJyb3IobWVzc2FnZSkge1xuICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcImhhbmRsZUluY29taW5nRXJyb3I6IFwiICsgbWVzc2FnZSk7XG4gICAgfVxuICB9XG5cbiAgb25TZXJ2ZXJNZXNzYWdlKGV2ZW50KSB7XG4gICAgbGV0IGRhdGEgPSBldmVudC5kYXRhO1xuICAgIGlmICh3aW5kb3cubWVkaWFQbHVnaW4gIT0gbnVsbCkge1xuICAgICAgaWYod2luZG93Lm1lZGlhUGx1Z2luLmhhbmRsZU1lc3NhZ2UoZGF0YSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbXNnO1xuXG4gICAgc3dpdGNoIChkYXRhKSB7XG4gICAgICBjYXNlIFwiSEVMTE9cIjpcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJSZWdpc3RlcmVkIHdpdGggc2VydmVyLCBkZXRlcm1pbmUgd2hpY2ggcHJvdG9jb2wgdG8gdXNlXCIpO1xuICAgICAgICB0aGlzLmluaXRDb25uZWN0aW9uKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChldmVudC5kYXRhLnN0YXJ0c1dpdGgoXCJFUlJPUlwiKSkge1xuICAgICAgICAgIHRoaXMuaGFuZGxlSW5jb21pbmdFcnJvcihldmVudC5kYXRhKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBtc2cgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBTeW50YXhFcnJvcikge1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVJbmNvbWluZ0Vycm9yKFwiRXJyb3IgcGFyc2luZyBpbmNvbWluZyBKU09OOiBcIiArIGV2ZW50LmRhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhhbmRsZUluY29taW5nRXJyb3IoXCJVbmtub3duIGVycm9yIHBhcnNpbmcgcmVzcG9uc2U6IFwiICsgZXZlbnQuZGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuIiwiZXhwb3J0IHtXZWJSVEMsIGRldGVybWluZVZpZGVvRm9ybWF0c307XG5cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgV2ViUlRDIHtcblxuICBjb25zdHJ1Y3Rvcih0YXJnZXQsIHBlZXJfaWQsIG1lZGlhX2NvbnRyb2xsZXIsIGxvY2tfYXVkaW8pIHtcblxuICAgIHRoaXMuZGVidWcgPSB0cnVlO1xuICAgIHRoaXMubG9ja19hdWRpbyA9IGxvY2tfYXVkaW87XG4gICAgdGhpcy5wZWVyX2Nvbm5lY3Rpb247XG4gICAgdGhpcy5tZWRpYV9jb250cm9sbGVyID0gbWVkaWFfY29udHJvbGxlcjtcblxuICAgIHRoaXMudmlkZW9fZWxlbWVudDtcbiAgICB0aGlzLmF1ZGlvX2VsZW1lbnQ7XG5cbiAgICB0aGlzLnRhcmdldCA9IHRhcmdldDtcbiAgICB0aGlzLnBlZXJfaWQgPSBwZWVyX2lkO1xuICAgIHRoaXMuY2FuZGlkYXRlX251bWJlciA9IDA7XG4gIH1cblxuICBzdGFydCgpIHtcbiAgICBpZiAodGhpcy52aWRlb19lbGVtZW50IHx8IHRoaXMuYXVkaW9fZWxlbWVudCkge1xuICAgICAgY29uc29sZS5sb2coXCJhbHJlYWR5IHN0YXJ0ZWRcIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9O1xuXG4gIGdldFBlZXJJZCgpIHtcbiAgICByZXR1cm4gdGhpcy5wZWVyX2lkO1xuICB9XG5cbiAgaW5pdEljZVNlcnZlcnModXNlcm5hbWUsIHBhc3N3b3JkKSB7XG4gICAgY29uc3Qgc3R1biA9IFwic3R1bjpzdHVuLmwuZ29vZ2xlLmNvbToxOTMwMlwiO1xuICAgIGNvbnN0IGhvc3RuYW1lID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgIGNvbnN0IHBvcnQgPSB3aW5kb3cubG9jYXRpb24ucHJvdG9jb2wgPT09IFwiaHR0cHM6XCIgPyA0NDMgOiAzMDQ3ODtcblxuICAgIGNvbnN0IGljZVNlcnZlcnMgPSBbXG4gICAgICB7J3VybHMnOiBzdHVufSxcbiAgICAgIHtcInVybHNcIjpbYHR1cm46JHtob3N0bmFtZX06JHtwb3J0fT90cmFuc3BvcnQ9dWRwYCxcbiAgICAgICAgICAgICAgIGB0dXJuOiR7aG9zdG5hbWV9OiR7cG9ydH0/dHJhbnNwb3J0PXRjcGBdLFxuICAgICAgIFwidXNlcm5hbWVcIjogdXNlcm5hbWUsXG4gICAgICAgXCJjcmVkZW50aWFsXCI6IHBhc3N3b3JkfVxuICAgIF07XG5cbiAgICByZXR1cm4geydpY2VUcmFuc3BvcnRQb2xpY3knOiAncmVsYXknLCAnaWNlU2VydmVycyc6IGljZVNlcnZlcnN9O1xuICB9XG5cbiAgb25JbmNvbWluZ0NvbmZpZ3VyYXRpb24obXNnKSB7XG4gICAgbXNnID0gdGhpcy5pbml0SWNlU2VydmVycyhtc2cudXNlcm5hbWUsIG1zZy5wYXNzd29yZCk7XG5cbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJDcmVhdGUgcGVlckNvbm5lY3Rpb24gd2l0aCBjb25maWd1cmF0aW9uXCIgKyBKU09OLnN0cmluZ2lmeShtc2cpKTtcbiAgICB9XG4gICAgdGhpcy5jcmVhdGVDYWxsKG1zZyk7XG4gIH1cblxuICAvLyBJQ0UgY2FuZGlkYXRlIHJlY2VpdmVkIGZyb20gcGVlciwgYWRkIGl0IHRvIHRoZSBwZWVyIGNvbm5lY3Rpb25cbiAgb25JbmNvbWluZ0lDRShpY2UpIHtcbiAgICBsZXQgY2FuZGlkYXRlID0gbmV3IFJUQ0ljZUNhbmRpZGF0ZShpY2UpO1xuICAgIHRoaXMucGVlcl9jb25uZWN0aW9uLmFkZEljZUNhbmRpZGF0ZShjYW5kaWRhdGUpLmNhdGNoKCgpID0+IHRoaXMuc2V0RXJyb3IoXCJFcnJvciBhZGRpbmcgaWNlIGNhbmRpZGF0ZVwiKSk7XG4gIH1cblxuICBzZXRTdGF0dXMoc3RhdHVzKSB7XG4gICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwiV2ViUlRDLXN0YXR1czpcIiArIHN0YXR1cyk7XG4gICAgfVxuICB9XG5cbiAgc2V0RXJyb3IoZXJyb3IpIHtcbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJXZWJSVEMtZXJyb3I6IFwiICsgZXJyb3IpO1xuICAgIH1cbiAgfVxuXG4gIG9uSW5jb21pbmdTRFAoc2RwKSB7XG4gICAgdGhpcy5wZWVyX2Nvbm5lY3Rpb24uc2V0UmVtb3RlRGVzY3JpcHRpb24oc2RwKS50aGVuKCgpID0+IHtcbiAgICAgIHRoaXMuc2V0U3RhdHVzKFwiUmVtb3RlIFNEUCBzZXRcIik7XG4gICAgICBpZiAoc2RwLnR5cGUgIT09IFwib2ZmZXJcIilcbiAgICAgICAgcmV0dXJuO1xuICAgICAgdGhpcy5zZXRTdGF0dXMoXCJHb3QgU0RQIG9mZmVyXCIpO1xuICAgICAgdGhpcy5wZWVyX2Nvbm5lY3Rpb24uY3JlYXRlQW5zd2VyKClcbiAgICAgICAgLnRoZW4odGhpcy5vbkxvY2FsRGVzY3JpcHRpb24uYmluZCh0aGlzKSkuY2F0Y2goKCkgPT4gdGhpcy5zZXRFcnJvcihcIkVycm9yIHNldHRpbmcgbG9jYWwgZGVzY3JpcHRpb25cIikpO1xuICAgIH0pLmNhdGNoKChldmVudCkgPT4gdGhpcy5zZXRFcnJvcihcIkVycm9yIHNldHRpbmcgcmVtb3RlIGRlc2NyaXB0aW9uOlwiICsgZXZlbnQpKTtcbiAgfVxuXG4gIC8vIExvY2FsIGRlc2NyaXB0aW9uIHdhcyBzZXQsIHNlbmQgaXQgdG8gcGVlclxuICBvbkxvY2FsRGVzY3JpcHRpb24oZGVzYykge1xuICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkdvdCBsb2NhbCBkZXNjcmlwdGlvbjogXCIgKyBKU09OLnN0cmluZ2lmeShkZXNjKSk7XG4gICAgfVxuICAgIHRoaXMucGVlcl9jb25uZWN0aW9uLnNldExvY2FsRGVzY3JpcHRpb24oZGVzYykudGhlbihmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuc2V0U3RhdHVzKFwiU2VuZGluZyBTRFAgYW5zd2VyXCIpO1xuICAgICAgbGV0IHNkcCA9IHsnc2RwJzogdGhpcy5wZWVyX2Nvbm5lY3Rpb24ubG9jYWxEZXNjcmlwdGlvbn07XG4gICAgICB0aGlzLm1lZGlhX2NvbnRyb2xsZXIuc2VuZChzZHApO1xuICAgIH0uYmluZCh0aGlzKSk7XG4gIH1cblxuXG4gIGhhbmRsZU1lc3NhZ2UoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICBsZXQgbXNnID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICAgIC8vIEluY29taW5nIEpTT04gc2lnbmFscyB0aGUgYmVnaW5uaW5nIG9mIGEgY2FsbFxuICAgICAgaWYgKG1zZy5zZHAgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLm9uSW5jb21pbmdTRFAobXNnLnNkcCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChtc2cuaWNlICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5vbkluY29taW5nSUNFKG1zZy5pY2UpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAobXNnLnVzZXJuYW1lICYmIG1zZy5wYXNzd29yZCkge1xuICAgICAgICB0aGlzLm9uSW5jb21pbmdDb25maWd1cmF0aW9uKG1zZyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHt9XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB1bmxvY2tBdWRpbygpIHtcbiAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgY29uc29sZS5sb2coXCJVbmxvY2sgd2VicnRjIGF1ZGlvXCIpO1xuICAgIH1cbiAgICB0aGlzLmxvY2tfYXVkaW8gPSBmYWxzZTtcbiAgICBpZiAodGhpcy5hdWRpb19lbGVtZW50ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuYXVkaW9fZWxlbWVudC5tdXRlZCA9IGZhbHNlO1xuICAgICAgY29uc29sZS5sb2coXCIgcGF1c2VkOiBcIiArIHRoaXMuYXVkaW9fZWxlbWVudC5wYXVzZWQpO1xuICAgICAgdGhpcy5hdWRpb19lbGVtZW50LnBsYXkoKS5jYXRjaCgoZXJyKSA9PiB0aGlzLnNldEVycm9yKFwidW5sb2NrIGF1ZGlvX2VsZW1lbnQucGxheSgpIGVycm9yOiBcIiArIGVycikpO1xuICAgIH1cbiAgICBpZiAodGhpcy52aWRlb19lbGVtZW50ICE9IG51bGwpIHtcbiAgICAgIHRoaXMudmlkZW9fZWxlbWVudC5tdXRlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHRoaXMuc2V0U3RhdHVzKFwiQ2xvc2luZyBXZWJSVEMgY29ubmVjdGlvblwiKTtcbiAgICB0aGlzLnBlZXJfY29ubmVjdGlvbi5jbG9zZSgpO1xuICAgIHRoaXMucGVlcl9jb25uZWN0aW9uID0gbnVsbDtcbiAgfTtcblxuICBjcmVhdGVDYWxsKGNvbmZpZ3VyYXRpb24pIHtcblxuICAgIHRoaXMucGVlcl9jb25uZWN0aW9uID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKGNvbmZpZ3VyYXRpb24pO1xuICAgIHRoaXMucGVlcl9jb25uZWN0aW9uLm9udHJhY2sgPSB0aGlzLm9uUmVtb3RlVHJhY2tBZGRlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMucGVlcl9jb25uZWN0aW9uLm9uaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlID0gdGhpcy5vbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZS5iaW5kKHRoaXMpO1xuICAgIHRoaXMucGVlcl9jb25uZWN0aW9uLm9uaWNlY2FuZGlkYXRlID0gdGhpcy5vbkljZUNhbmRpZGF0ZS5iaW5kKHRoaXMpO1xuXG4gICAgdGhpcy5zZXRTdGF0dXMoXCJDcmVhdGVkIHBlZXIgY29ubmVjdGlvbiBmb3IgY2FsbCwgd2FpdGluZyBmb3IgU0RQXCIpO1xuICB9XG5cbiAgb25JY2VDYW5kaWRhdGUoZXZlbnQpIHtcbiAgICAgIGxldCBjYW5kaWRhdGUgPSBldmVudC5jYW5kaWRhdGU7XG5cbiAgICAgIGlmIChjYW5kaWRhdGUgPT0gbnVsbCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIkljZSBDYW5kaWRhdGVzIERvbmUsIFNlbnQgXCIgKyB0aGlzLmNhbmRpZGF0ZV9udW1iZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnNvbGUubG9nKFwic2VuZCBjYW5kaWRhdGUgcmVtb3RlbHk6IFwiICsgY2FuZGlkYXRlLmNhbmRpZGF0ZSk7XG4gICAgICB0aGlzLm1lZGlhX2NvbnRyb2xsZXIuc2VuZCh7J2ljZSc6IGNhbmRpZGF0ZX0pO1xuICAgICAgdGhpcy5jYW5kaWRhdGVfbnVtYmVyKys7XG4gICAgfTtcblxuICBvbkljZUNvbm5lY3Rpb25TdGF0ZUNoYW5nZShldmVudCkge1xuICAgIGlmICh0aGlzLnBlZXJfY29ubmVjdGlvbi5pY2VDb25uZWN0aW9uU3RhdGUgPT09IFwiY29ubmVjdGVkXCIpIHtcbiAgICAgICAgaWYgKHRoaXMuZGVidWcpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIldlYlJUQyBpcyBvbiFcIik7XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzeW5jVmlkZW9FbGVtZW50KCkge1xuICAgIGxldCBjYW52YXMgPSB0aGlzLnRhcmdldC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJylbMF07XG4gICAgaWYgKHRoaXMudmlkZW9fZWxlbWVudCAhPSBudWxsICAmJiBjYW52YXMgIT0gdW5kZWZpbmVkKSB7XG4gICAgICBsZXQgY2FudmFzX3Bvc2l0aW9uID0gY2FudmFzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgbGV0IGxlZnQgPSBjYW52YXNfcG9zaXRpb24ueDtcbiAgICAgIGxldCB0b3AgPSBjYW52YXNfcG9zaXRpb24ueTtcbiAgICAgIGxldCB3aWR0aCA9IGNhbnZhc19wb3NpdGlvbi53aWR0aDtcbiAgICAgIGxldCBoZWlnaHQgPSBjYW52YXNfcG9zaXRpb24uaGVpZ2h0O1xuXG4gICAgICBpZiAodGhpcy5kZWJ1Zykge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlZpZGVvIHBvc2l0aW9uIGlzIGxlZnQgXCIgKyBsZWZ0ICsgXCIsIHRvcCBcIiArIHRvcCArIFwiLCB3aWR0aCBcIiArIHdpZHRoICsgXCIsIGhlaWdodCBcIiArIGhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudmlkZW9fZWxlbWVudC5zdHlsZS5sZWZ0ID0gbGVmdCArIFwicHhcIjtcbiAgICAgIHRoaXMudmlkZW9fZWxlbWVudC5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICBpZiAod2lkdGggPiAwKSB7XG4gICAgICAgIHRoaXMudmlkZW9fZWxlbWVudC5zdHlsZS53aWR0aCA9IHdpZHRoICsgXCJweFwiO1xuICAgICAgfVxuICAgICAgaWYgKGhlaWdodCA+IDApIHtcbiAgICAgICAgdGhpcy52aWRlb19lbGVtZW50LnN0eWxlLmhlaWdodCA9IGhlaWdodCArIFwicHhcIjtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBvblJlbW90ZVRyYWNrQWRkZWQoZXZlbnQpIHtcbiAgICBjb25zb2xlLmxvZygncmVjZWl2ZSAnICsgZXZlbnQuc3RyZWFtcy5sZW5ndGggKyAnU3RyZWFtcy4gc3RyZWFtIDEgID0gJyArIGV2ZW50LnN0cmVhbXNbMF0uZ2V0VmlkZW9UcmFja3MoKS5sZW5ndGggKyAnIHZpZGVvIHRyYWNrcyBhbmQgJyArIGV2ZW50LnN0cmVhbXNbMF0uZ2V0QXVkaW9UcmFja3MoKS5sZW5ndGggKyAnIGF1ZGlvIHRyYWNrcycgKTtcblxuICAgIGlmIChldmVudC5zdHJlYW1zWzBdLmdldEF1ZGlvVHJhY2tzKCkubGVuZ3RoID4gMCAmJiBldmVudC5zdHJlYW1zWzBdLmdldFZpZGVvVHJhY2tzKCkubGVuZ3RoID09IDApIHtcbiAgICAgIGlmICh0aGlzLmF1ZGlvX2VsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIHRoaXMuYXVkaW9fZWxlbWVudC5wYXVzZSgpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coJ2NhbiBub3QgcGF1c2UgYXVkaW8gZWxlbWVudCcpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmF1ZGlvX2VsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhdWRpbycpO1xuICAgICAgICB0aGlzLmF1ZGlvX2VsZW1lbnQuYXV0b3BsYXkgPSB0cnVlO1xuICAgICAgICB0aGlzLnRhcmdldC5hcHBlbmQodGhpcy5hdWRpb19lbGVtZW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hdWRpb19lbGVtZW50LnNyY09iamVjdCA9IGV2ZW50LnN0cmVhbXNbMF07XG5cbiAgICAgIHRoaXMuYXVkaW9fZWxlbWVudC5wbGF5KCkuY2F0Y2goKGVycikgPT4gdGhpcy5tZWRpYVBsYXlFcnJvcihlcnIsIHRoaXMuYXVkaW9fZWxlbWVudCwgXCJhdWRpb19lbGVtZW50LnBsYXkoKVwiKSk7XG5cbiAgICB9XG5cbiAgICBpZiAoZXZlbnQuc3RyZWFtc1swXS5nZXRWaWRlb1RyYWNrcygpLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0aGlzLmF1ZGlvX2VsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICB0aGlzLmF1ZGlvX2VsZW1lbnQucGF1c2UoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudmlkZW9fZWxlbWVudCA9PSBudWxsKSB7XG4gICAgICAgIC8vIEZ1bGwgV2ViUlRDXG4gICAgICAgIHRoaXMudmlkZW9fZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3ZpZGVvJyk7XG4gICAgICAgIGlmICh0aGlzLmRlYnVnKSB7XG4gICAgICAgICAgdGhpcy52aWRlb19lbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IFwiYmx1ZVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vdGhpcy52aWRlb19lbGVtZW50LnN0eWxlLm9wYWNpdHkgPSBcIjAuNVwiO1xuICAgICAgICB0aGlzLnZpZGVvX2VsZW1lbnQuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCJcbiAgICAgICAgdGhpcy52aWRlb19lbGVtZW50LnN0eWxlLnRvcCA9IFwiMHB4XCI7XG4gICAgICAgIHRoaXMudmlkZW9fZWxlbWVudC5zdHlsZS5sZWZ0ID0gXCIwcHhcIjtcbiAgICAgICAgLy90aGlzLnZpZGVvX2VsZW1lbnQuc3R5bGUud2lkdGggPSBcIjEwMCVcIlxuICAgICAgICB0aGlzLnZpZGVvX2VsZW1lbnQuc3R5bGUuekluZGV4ID0gXCItMVwiO1xuXG4gICAgICAgIHRoaXMudmlkZW9fZWxlbWVudC5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgICAgICAvLyBIaWRlIHJlYWwgVk5DXG4gICAgICAgIHRoaXMudGFyZ2V0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2NhbnZhcycpWzBdLnN0eWxlLm9wYWNpdHkgPSAwO1xuXG4gICAgICAgIGlmICh0aGlzLmxvY2tfYXVkaW8pIHtcbiAgICAgICAgICB0aGlzLnZpZGVvX2VsZW1lbnQubXV0ZWQgPSB0cnVlO1xuICAgICAgICB9XG5cblxuICAgICAgICB0aGlzLnRhcmdldC5hcHBlbmQodGhpcy52aWRlb19lbGVtZW50KTtcbiAgICAgICAgd2luZG93Lm9ucmVzaXplID0gdGhpcy5zeW5jVmlkZW9FbGVtZW50LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMuc3luY1ZpZGVvRWxlbWVudCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLnZpZGVvX2VsZW1lbnQucGF1c2UoKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGNvbnNvbGUubG9nKCdjYW4gbm90IHBhdXNlIHZpZGVvIGVsZW1lbnQnKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnZpZGVvX2VsZW1lbnQuc3JjT2JqZWN0ID0gZXZlbnQuc3RyZWFtc1swXTtcblxuICAgICAgdmFyIHZpZGVvID0gdGhpcy52aWRlb19lbGVtZW50O1xuXG4gICAgICB0aGlzLnZpZGVvX2VsZW1lbnQucGxheSgpLmNhdGNoKChlcnIpID0+IHRoaXMubWVkaWFQbGF5RXJyb3IoZXJyLCB0aGlzLnZpZGVvX2VsZW1lbnQsIFwidmlkZW9fZWxlbWVudC5wbGF5KClcIikpO1xuICAgIH1cbiAgfVxuXG4gIG1lZGlhUGxheUVycm9yKGVyciwgZWxlbSwgbXNnKSB7XG4gICAgaWYgKGVyci5uYW1lID09PSAnTm90QWxsb3dlZEVycm9yJykge1xuICAgICAgZWxlbS5tdXRlZCA9IHRydWU7XG4gICAgICBkb2N1bWVudC5ib2R5LmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCAoKSA9PiB0aGlzLnVubG9ja0F1ZGlvKCkpO1xuICAgICAgZWxlbS5wbGF5KCkuY2F0Y2goKGVycikgPT4gdGhpcy5zZXRFcnJvcihtc2cgKyBcIiBtdXRlZCBlcnJvcjogXCIgKyBlcnIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRFcnJvcihtc2cgKyBcIiBlcnJvcjogXCIgKyBlcnIpO1xuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gZGV0ZXJtaW5lVmlkZW9Gb3JtYXRzKCkge1xuXG4gIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBjb25uID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKCk7XG4gICAgICBpZiAoY29ubi5hZGRUcmFuc2NlaXZlcikge1xuICAgICAgICBjb25uLmFkZFRyYW5zY2VpdmVyKFwidmlkZW9cIiwge1wiZGlyZWN0aW9uXCI6IFwicmVjdm9ubHlcIn0pO1xuICAgICAgfVxuICAgICAgY29ubi5jcmVhdGVPZmZlcih7XCJvZmZlclRvUmVjZWl2ZVZpZGVvXCI6IHRydWV9KS50aGVuKChvZmZlcikgPT4ge1xuICAgICAgICBjb25uLmNsb3NlKCk7XG5cbiAgICAgICAgdmFyIGZvcm1hdHMgPSBbXTtcbiAgICAgICAgdmFyIGZvdW5kID0ge307XG5cbiAgICAgICAgdmFyIHJ4ID0gL2E9cnRwbWFwWzpdXFxkKyAoXFx3KylcXC8vZztcblxuICAgICAgICB2YXIgcmVzID0gbnVsbDtcblxuICAgICAgICB3aGlsZSAoKHJlcyA9IHJ4LmV4ZWMob2ZmZXIuc2RwKSkgIT0gbnVsbCkge1xuICAgICAgICAgIHZhciBmb3JtYXQgPSByZXNbMV07XG4gICAgICAgICAgaWYgKCFmb3VuZFtmb3JtYXRdKSB7XG4gICAgICAgICAgICBmb3JtYXRzLnB1c2goZm9ybWF0KTtcbiAgICAgICAgICAgIGZvdW5kW2Zvcm1hdF0gPSAxO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlc29sdmUoZm9ybWF0cyk7XG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmxvZyhcIkVycm9yIFdlYlJUQyBub3Qgc3VwcG9ydGVkXCIpXG4gICAgICByZXNvbHZlKCk7XG4gICAgfVxuXG4gIH0pO1xufVxuXG4iXSwic291cmNlUm9vdCI6IiJ9
